<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.0" rel="stylesheet"><meta name="keywords" content="Java,SpringMVC,"><link rel="alternate" href="/atom.xml" title="冰封承諾" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0"><meta name="description" content="SpringMVC 是 Spring 的一个模块，提供 web 层解决方案；和众多其他web框架一样，它基于MVC的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。SpringMVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，无需实现任何接口，同时，SpringMVC 还支持 REST 风格的 URL 请求。此外，SpringMVC 在数据绑定"><meta name="keywords" content="Java,SpringMVC"><meta property="og:type" content="article"><meta property="og:title" content="SpringMVC学习笔记"><meta property="og:url" content="http://bfchengnuo.com/2017/10/05/SpringMVC学习笔记/index.html"><meta property="og:site_name" content="冰封承諾"><meta property="og:description" content="SpringMVC 是 Spring 的一个模块，提供 web 层解决方案；和众多其他web框架一样，它基于MVC的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。SpringMVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，无需实现任何接口，同时，SpringMVC 还支持 REST 风格的 URL 请求。此外，SpringMVC 在数据绑定"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://bfchengnuo.com/image/dev/SpringMVC.jpeg"><meta property="og:image" content="http://bfchengnuo.com/image/dev/Spring-MVC-详细运行流程图（通俗易懂）.png"><meta property="og:updated_time" content="2018-08-25T09:37:28.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="SpringMVC学习笔记"><meta name="twitter:description" content="SpringMVC 是 Spring 的一个模块，提供 web 层解决方案；和众多其他web框架一样，它基于MVC的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。SpringMVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，无需实现任何接口，同时，SpringMVC 还支持 REST 风格的 URL 请求。此外，SpringMVC 在数据绑定"><meta name="twitter:image" content="http://bfchengnuo.com/image/dev/SpringMVC.jpeg"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bfchengnuo.com/2017/10/05/SpringMVC学习笔记/"><title>SpringMVC学习笔记 | 冰封承諾</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-77463916-1","auto"),ga("send","pageview")</script><div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=1259036521&web_id=1259036521" language="JavaScript"></script></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">冰封承諾</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">立于浮华之世,奏响天籁之音.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-mark"><a href="/mark" rel="section"><i class="menu-item-icon fa fa-fw fa-retweet"></i><br>笔记本</a></li><li class="menu-item menu-item-books"><a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书单</a></li><li class="menu-item menu-item-music"><a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>音乐台</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://bfchengnuo.com/2017/10/05/SpringMVC学习笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kerronex"><meta itemprop="description" content=""><meta itemprop="image" content="/image/tx.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冰封承諾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SpringMVC学习笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-05T21:12:31+08:00">2017-10-05</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span> <span id="/2017/10/05/SpringMVC学习笔记/" class="leancloud_visitors" data-flag-title="SpringMVC学习笔记"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">5,145</span></span></div></header><div class="post-body" itemprop="articleBody"><p>SpringMVC 是 Spring 的一个模块，提供 web 层解决方案；和众多其他web框架一样，它基于MVC的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。<br>SpringMVC <strong>通过一套 MVC 注解</strong>，让 POJO 成为处理请求的控制器，无需实现任何接口，同时，SpringMVC 还支持 REST 风格的 URL 请求。<br>此外，SpringMVC 在数据绑定、视图解析、本地化处理及静态资源处理上都有许多不俗的表现。<a id="more"></a><br><strong>它在框架设计、扩展性、灵活性等方面全面超越了 Struts、WebWork 等 MVC 框架，从原来的追赶者一跃成为 MVC 的领跑者。</strong><br>SpringMVC 框架围绕 Dispatcher<strong>Servlet</strong> 这个核心展开，DispatcherServlet 是 SpringMVC 框架的总导演、总策划，它负责截获请求并将其分派给相应的处理器处理。</p><h2 id="框架流程"><a href="#框架流程" class="headerlink" title="框架流程"></a>框架流程</h2><p>下面说说 SpringMVC 的执行流程，当然和传统的 MVC 模式是非常相似的：</p><p><img src="/image/dev/SpringMVC.jpeg" alt="SpringMVC.jpeg"></p><p>介绍中提到过，DispatcherServlet 是前端控制器，相当于中央调度器，各个组件都和前端控制器进行交互，降低了各个组件之间耦合度；Handler 是后端控制器，当成模型（Model）。<br>那么一个请求的完整步骤可以概况为：</p><ol><li>用户发起 request 请求，请求至 <strong>DispatcherServlet 前端控制器</strong></li><li>DispatcherServlet 前端控制器请求 <strong>HandlerMapping 处理器映射器</strong>查找 Handler</li><li>HandlerMapping 处理器映射器，根据 url 及一些配置规则（xml配置、注解配置）查找 Handler，将 Handler 返回给 DispatcherServlet 前端控制器；<br>这里其实会以 <strong>HandlerExecutionChain</strong> 对象的形式返回，我就称它为执行链了，<strong>它包含了 Handler 对象和拦截器列表</strong></li><li>DispatcherServlet 前端控制器根据返回的 Handler 调用合适的<strong>适配器</strong>执行 Handler，有了适配器通过适配器去扩展对不同 Handler 执行方式（比如：原始servlet开发，注解开发）</li><li>适配器执行 Handler（成功获得 HandlerAdapter 后，将开始执行拦截器的 preHandler(…) 方法 ），其中会经过一些消息转换器，例如进行数据绑定相关操作（数据转换、格式化、校验等）</li><li>Handler 执行完成后返回 ModelAndView 给适配器<br>ModelAndView 是 springmvc 的一个对象，对 Model （数据）和 view （仅仅是 View 的名字）进行封装。</li><li>适配器将 ModelAndView 返回给 DispatcherServlet</li><li>DispatcherServlet 通过返回的 View 的名称，调用视图解析器进行视图解析，解析后生成真正的 view<br>也就是说视图解析器根据逻辑视图名解析出真正的视图对象。<br>View：springmvc 视图封装对象，提供了很多 view，比如：jsp、freemarker、pdf、excel。。。</li><li>ViewResolver 视图解析器给前端控制器返回真正的 view 对象</li><li>DispatcherServlet 调用 view 的渲染视图的方法（根据模型对象的数据），<strong>将模型数据填充到 request 域</strong>。</li><li>View 返回渲染后的视图</li><li>DispatcherServlet 向用户响应结果(jsp页面、json数据等)</li></ol><p>以上就是 springmvc 处理一个请求的步骤了，然后再贴一张详细一点的流程图吧：</p><p><img src="/image/dev/Spring-MVC-详细运行流程图（通俗易懂）.png" alt="Spring-MVC-详细运行流程图（通俗易懂）.png"></p><h2 id="一个简单的栗子"><a href="#一个简单的栗子" class="headerlink" title="一个简单的栗子"></a>一个简单的栗子</h2><p>然后就来看看具体的开发流程，首先定义 web.xml 文件，也就是定义 SpringMVC 的总导演 DispatcherServlet 这就是一个 servlet：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- springMVC前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- load-on-startup 表示在web应用启动时，即加载该DispatcherServlet，而不是等到首次请求再中载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于配置文件也有必要说一下，首先这里使用了 init-param 标签来指定配置文件的位置，如果不配置，默认加载的是 <code>WEB-INF/{servlet-name}-servlet.xml</code> ，其中大括号中指的是变量名，还记的 servlet-name 在那设置的么？看第六行！也就是说最终默认找的配置文件是 springmvc-servlet.xml 。<br>然后就是 url-pattern 了，匹配规则，SpringMVC 支持：<code>*.xxx</code>、<code>/</code>、<code>/xxx/*</code> ；不支持 ：<code>/*</code> ；<br>是的，原来在 struts 中写的很爽的 <code>/*</code> 在这里是错误的；使用这种配置，最终要转发到一个 jsp 页面时，仍然会由 DispatcherServlet 解析 jsp 地址，不能根据 jsp 页面找到 handler，会报错。<br>不过 <code>/</code> 表示所有访问的地址都由 DispatcherServlet 解析，对于静态文件的解析需要配置不让 DispatcherServlet 解析，使用此种方法可以实现 RESTful 风格的 url。<br>按照套路接下来就应该是 <strong>springmvc 的配置文件</strong>了（先使用配置文件的方式），其实就是 spring 的配置文件，因为基本没差嘛：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"</span>&gt;</span>                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置 HandlerMapping（处理器映射器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 处理器适配器，所有的处理器适配器都实现HandlerAdapter --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置Handler(自己写的) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/hello.action"</span> <span class="attr">class</span>=<span class="string">"cn.itcast.ssm.controller.HelloController"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义视图解析器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些定义其实都没必要看文档，就看上面的那个流程图，定义的这些 bean 完全就是按照图的顺序定义的，因为图中都是接口所以定义的时候要写具体实现的 bean。<br>视图解析器的前缀后缀是什么意思呢？从图中得知，最终要根据一个 View 的名字（在 Handler 的返回值中）返回一个具体的视图对象，视图说白了就是 jsp、json 等这种，所以视图解析器会根据前缀和后缀最后拼出一个真正的视图，也就是找到具体你定义的 jsp 文件。<br>视图就不写了，就是简单的一个 JSP 文件，除了视图 Handler 也需要自己写，看下 Handler 应该怎么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Controller接口的映射器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 返回ModelAndView</span></span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">// 相当于 request 的 setAttribute 方法</span></span><br><span class="line">    <span class="comment">// 在jsp页面中就可以通过 EL 表达式获取数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">"msg"</span>,<span class="string">"HelloWorld!"</span>);</span><br><span class="line">    <span class="comment">//指定视图</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一定要实现 Controller 接口，在适配器中会检查是否有实现这个接口，一般 Handler 会放在 controller 包下。<br>视图解析器会根据 setViewName 设置的名字和前缀、后缀进行拼接，最后就转到了我们定义的 jsp 视图上；<br>这样就可以通过访问 <code>/hello.action</code> 来调用 Handler 了。<br><strong>从命名来说，一般如果是 addXXX 那么就可以添加多个，如果是 setXXX 那么就只能设置一个了。</strong><br>另外，Controller（handler）的名字和视图的名字应该是对应的。</p><h3 id="优化配置文件"><a href="#优化配置文件" class="headerlink" title="优化配置文件"></a>优化配置文件</h3><p>我们在 springmvc 的配置文件中配置了一些 bean，但是有些其实是不用配也是可以的（有默认值），比如前两个：处理器映射器和处理器适配器，后面两个肯定不能省了，因为有我们自己配的信息</p><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在最开始的介绍中也说明了，springmvc 中的注解是很重要的，大多都是用注解吧，毕竟在默认的配置文件中就已经开启了注解，所以注解我们可以直接用。<br>目标就是达到零配置！虽然默认配置已经开启了注解，但是已经过时了（AnnotationMethodHandlerAdapter 和 DefaultAnnotationHandlerMapping），推荐使用新的类（RequestMappingHandlerAdapter 和 RequestMappingHandlerMapping）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring 3.1之后由RequestMappingHandlerAdapter和RequestMappingHandlerMapping代替 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者直接使用下面的注解驱动，上面的两个就不用写了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明DispatcherServlet不要拦截下面声明的目录 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 另一种放行方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>至于注解驱动是如何将最新的映射器和适配器注入的可以去看 <code>org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</code> 这个类，我就先不研究了….<br>简单说，驱动注解内部其实包含了这些内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter "</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HadnlerExceptionResolvers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver "</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>在 SpringMVC 中，控制器 Controller 负责处理由 DispatcherServlet 分发的请求，它把用户请求的数据 经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。<br>在 SpringMVC 中提供了一个非常简便的定义 Controller 的方法，<strong>你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是 Controller</strong> 。<br>然后使用 @RequestMapping 和 @RequestParam 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。<br>Controller 不会直接依赖于 HttpServletRequest 和 HttpServletResponse 等 HttpServlet 对象，它们可以通过 Controller 的方法参数灵活的获取到。<br>也就是说，@Controller 用于标记在一个类上，使用它标记的类就是一个 SpringMVC Controller 对象，然后 Spring 怎样才能找到它呢，有两种方式，当然，推荐使用扫描啦：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.controller.MyController"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"com.host.app.web"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>首先这是一个重点！其次，它非常 NB。<br>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上；访问的时候就是 类上 value + 方法上的 value 拼起来，并且可以不加斜线，会自动处理。<br>RequestMapping 注解有六个属性，可分为五种映射（或者说三种映射两种限制）：</p><ol><li><p>标准URL映射<br>比如：<code>@RequestMapping(&quot;hello&quot;)</code> or <code>@RequestMapping(&quot;/hello&quot;)</code> or <code>@RequestMapping(value=&quot;hello&quot;)</code> ，它们都是一样的。</p></li><li><p>Ant 风格的 URL 映射<br>Ant 通配符有三种，<code>？</code>- 匹配单个字符；<code>*</code> - 匹配 0 或者任意数量的字符；<code>**</code> - 匹配 0 或者更多的目录。<br>例如：<code>@RequestMapping(&quot;/test/*/hello&quot;)</code></p></li><li><p>占位符映射<br>使用占位符用花括号括起来，可以使用多个占位符。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> pid) </span>&#123;</span><br><span class="line">	ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">	modelAndView.addObject(<span class="string">"msg"</span>,<span class="string">"HelloWorld!"</span> + pid);</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样访问 <code>xxx/user/123.action</code> 的时候，会自动把 123 传进 pid 这个参数，这样就又多了一种传值的方式。</p></li><li><p>限制请求方法映射<br>也就是限制请求方式，只要添加一个属性就可以了，使用到的是 <strong>method</strong> 属性：<br><code>@RequestMapping(value=&quot;hello&quot;,method = RequestMethod.GET)</code><br>需要多个的话用花括号括起来就行了，之间用逗号分割。</p></li><li><p>限制参数映射<br>也是通过属性指定，<strong>params</strong> 属性：指定 request 中必须包含某些参数值是，才让该方法处理。<br>过个参数还是用花括号括起来，一般有下面的几种形式：<br><code>&quot;!user&quot;</code> ：参数不能包含 user；<br><code>&quot;userID != 1&quot;</code> ：参数必须包含 userID 但是不能为 1；<br><code>{&quot;user&quot;,&quot;age&quot;}</code> ：参数必须包含 user 和 age；</p></li></ol><p>然后属性这样就已经说了三个了，value、method、params；其它是的：<br><strong>headers</strong>： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求；举个栗子：<br><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; })</code> ，这样就表示只有当请求头包含 Accept 信息，且请求的 host 为 localhost 的时候才能正确的访问到此方法。<br><strong>consumes：</strong> 指定处理请求的提交内容类型（Content-Type），例如 application/json 、 text/html;<br><strong>produces</strong>: 指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回；</p><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 uri 模板中的变量作为参数。<br>上面已经使用过了，需要注意的是 value 参数不能省略！虽然省略了可以执行，但是当正常编译（ IDE 一般为 debug 模式）时，方法的传入参数不会被记录，所以会报错。<br>许多注解都是这个机制，所以最好是写上 value ，万无一失，总之就是不要依赖变量名。<br>Eclipse 中的 Java Compiler 中的 <code>add variable attributes to generated class files</code> 默认是开启的。</p><h3 id="requestParam"><a href="#requestParam" class="headerlink" title="@requestParam"></a>@requestParam</h3><p>主要用于在 SpringMVC 后台控制层获取参数，类似一种是 <code>request.getParameter(&quot;name&quot;)</code>，它有三个常用参数：<br><strong>defaultValue = “0”、required = false、 value = “isApp”；</strong><br>defaultValue 表示设置默认值，required 通过 boolean 设置是否是必须要传入的参数（默认为 true），value 值表示接受的传入的参数类型。<br>具体用在哪里可以参考上面的 PathVariable ，差不多的，这样就直接把请求参数放进方法参数里了，在方法里使用非常方便了，对于基本数据类型，记得一定要写，不要省略。<br>它可以直接对参数进行 POJO 实体注入、转换数组、List 等集合，并且不会出现空指针异常，非常的方便！</p><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>可以把 Request header 中关于 cookie 的值绑定到方法的参数上，例如获取 cookie 中的 JSESSIONID 的值：<br><code>public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie) {}</code><br>和上面两个注解也没啥差别，都是获取数据的。</p><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>和 CookieValue 等注解类似，就是将 HttpServletRequest 头信息到 Controller 的方法参数上，比如 <code>@RequestHeader(&quot;host&quot;)</code> 就是获取 host 头信息；<br>不同的是，在 RequestHeader 中是不区分大小写的，但在 @PathVariable 、 @RequestParam 和 @CookieValue 中都是大小写敏感的。</p><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>作用：该注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区。<br>使用时机：返回的数据不是 html 标签的页面，而是其他某种格式的数据时（如 json、xml等）使用；默认为 JSON；<br>补充：为什么默认是 JSON ，在注解驱动中已经定义了，如果项目中有 Jackson 的依赖，那么会自动注册其转换器做转换输出。</p><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>和上面长的很像…..我都看错了，它们是一对。<br>该注解常用来处理<strong>请求的</strong> Content-Type 不是<code>application/x-www-form-urlencoded</code>编码的内容，例如 <code>application/json</code>, <code>application/xml</code> 等.<br>它是通过使用 HandlerAdapter 配置的 HttpMessageConverters 来解析 post data body，然后绑定到相应的 bean 上的。<br>因为配置有 FormHttpMessageConverter，所以也可以用来处理 <code>application/x-www-form-urlencoded</code> 的内容，处理完的结果放在一个 <code>MultiValueMap&lt;String, String&gt;</code> 里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter API.</p><h3 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h3><p>业务异常可以使用 @ResponseStatus 来注解。当异常被抛出时，ResponseStatusExceptionResolver 会设置相应的响应状态码。DispatcherServlet 会默认注册一个 ResponseStatusExceptionResolver 以供使用。<br>它有两个属性，value 属性是 http 状态码，比如 404，500 等。reason 是错误信息：<br><code>@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=&quot;用户不匹配&quot;)</code><br>通常它是修饰类的，然后在抛出异常的时候就会起作用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value=HttpStatus.FORBIDDEN,reason=<span class="string">"用户不匹配"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotMatchException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testResponseStatus"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseStatus</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserNotMatchException();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，用户看到的异常界面正是我们自己定义的异常，而不再是一大堆用户看不懂的代码，但如果用这个注解来修饰方法，那么<strong>无论它执行方法过程中有没有异常产生，用户都会得到异常的界面。而目标方法正常执行</strong></p><h3 id="ModelAttribute和-SessionAttributes"><a href="#ModelAttribute和-SessionAttributes" class="headerlink" title="@ModelAttribute和@SessionAttributes"></a>@ModelAttribute和@SessionAttributes</h3><p>该 Controller 的所有方法在调用前，先执行此 @ModelAttribute 方法；<br>可以把这个 @ModelAttribute 特性，应用在 BaseController 当中，所有的 Controller 继承 BaseController，即可实现在调用 Controller 时，先执行 @ModelAttribute 方法。<br>@SessionAttributes 即将值放到 session 作用域中，写在 class 上面有效。</p><hr><p><strong>SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型（model）和控制器之间共享数据。</strong> @ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。<br>当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 <code>@ModelAttribute(&quot;attributeName&quot;)</code> 在标记方法的时候指定，<strong>若未指定，则使用返回类型的类名称（首字母小写）作为属性名称</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">( @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpSession session) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">    writer.write( <span class="string">"\r"</span> );</span><br><span class="line">    Enumeration enume = session.getAttributeNames();</span><br><span class="line">    <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">      writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们请求 <code>/myTest/sayHello.do</code> 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值.<br><strong>这时，数据都是放在模型中，而不是存放在 session 属性中</strong>，如果想要也同时放进 Session 中，那么需要加 @SessionAttributes 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">"/myTest"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span> (value=&#123; <span class="string">"intValue"</span> , <span class="string">"stringValue"</span> &#125;, types=&#123;User. <span class="class"><span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyController</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session 中；但是当访问时，Session 中并没有值，第二次访问才有，也就是说：等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中，所以第二次访问才能拿到值。</p><h2 id="绑定Servlet内置对象"><a href="#绑定Servlet内置对象" class="headerlink" title="绑定Servlet内置对象"></a>绑定Servlet内置对象</h2><p>使用注解后确实简单多了，但有一个问题，怎么才能获得 Servlet 中的内置对象呢，比如 request、response、session 之类的，工具类？接口？<br>完全不需要，需要什么定义什么就 OK 了，直接定义在 handler 中的方法参数中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"test/show"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(HttpServletRequest request,HttpServletResponse response,HttpSession session)</span></span>&#123;</span><br><span class="line">	ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	mv.setViewName(<span class="string">"show"</span>);</span><br><span class="line">	</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	sb.append(<span class="string">"request = "</span> + request);</span><br><span class="line">	sb.append(<span class="string">"&lt;br/&gt;response = "</span> + response);</span><br><span class="line">	sb.append(<span class="string">"&lt;br/&gt;session = "</span> + session);</span><br><span class="line">	</span><br><span class="line">	mv.addObject(<span class="string">"msg"</span>, sb.toString());</span><br><span class="line">	<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似不似非常简单方便，这种做法确实非常棒！</p><h2 id="POJO对象绑定"><a href="#POJO对象绑定" class="headerlink" title="POJO对象绑定"></a>POJO对象绑定</h2><p>对于“实体”对象，也是非常的简单，和上面一样，直接在方法参数里写就行了，会自动把请求中的参数注入到这个 POJO 中去；<br>例如，方法为：<code>public ModelAndView show (User user){}</code> ；请求的时候直接 <code>id=1&amp;name=abc</code> 这样就可以了。<br>然后，还有一个对于我们来说最烦人的问题，中文乱码问题…..，如何解决后面再补充</p><hr><p>如果提交的是集合，就是这样：<code>&lt;input name=&quot;users[0].name&quot; /&gt;</code> ；这样提交的不是一个集合或者数组嘛，但是接收不能使用 <code>public ModelAndView show (List&lt;user&gt; users){}</code> 的形式来接收，从上面的简单栗子也可以看得出，填充对象的时候应该是去参数对象中去找相应的 setter 方法进行注入（<del>除非使用 @requestParam 注解，适用于基本数据类型，大概是这样</del>），所以，<strong>你需要将 List 进行对象包装后才可以使用</strong>。<br>虽然这种使用形式并不会经常用到。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/leskang/p/5445698.html" target="_blank" rel="noopener">http://www.cnblogs.com/leskang/p/5445698.html</a></p></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>喜欢就请我吃包辣条吧！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kerronex</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://bfchengnuo.com/2017/10/05/SpringMVC学习笔记/" title="SpringMVC学习笔记">http://bfchengnuo.com/2017/10/05/SpringMVC学习笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/SpringMVC/" rel="tag"><i class="fa fa-tag"></i> SpringMVC</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/09/30/MyBatis学习笔记（二）/" rel="next" title="MyBatis学习笔记（二）"><i class="fa fa-chevron-left"></i> MyBatis学习笔记（二）</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/10/06/SpringMVC学习笔记（二）/" rel="prev" title="SpringMVC学习笔记（二）">SpringMVC学习笔记（二）<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><p class="warninginfo"><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> 评论框加载失败，无法访问 Disqus<br><br>你可能需要魔法上网~~</p></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/image/tx.png" alt="Kerronex"><p class="site-author-name" itemprop="name">Kerronex</p><p class="site-description motion-element" itemprop="description">萝莉控/程序猿<br>夜猫族/不擅长社交</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">119</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope-o"></i> Email</a></span><span class="links-of-author-item"><a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 小伙伴们~</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a></li><li class="links-of-blogroll-item"><a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a></li><li class="links-of-blogroll-item"><a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a></li><li class="links-of-blogroll-item"><a href="https://bfchengnuo.com/MyRecord/#/" title="学习笔记本" target="_blank">学习笔记本</a></li><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/bfchengnuo" title="博客园" target="_blank">博客园</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#框架流程"><span class="nav-number">1.</span> <span class="nav-text">框架流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的栗子"><span class="nav-number">2.</span> <span class="nav-text">一个简单的栗子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化配置文件"><span class="nav-number">2.1.</span> <span class="nav-text">优化配置文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注解"><span class="nav-number">3.</span> <span class="nav-text">使用注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Controller"><span class="nav-number">3.1.</span> <span class="nav-text">@Controller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestMapping"><span class="nav-number">3.2.</span> <span class="nav-text">@RequestMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PathVariable"><span class="nav-number">3.3.</span> <span class="nav-text">@PathVariable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#requestParam"><span class="nav-number">3.4.</span> <span class="nav-text">@requestParam</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CookieValue"><span class="nav-number">3.5.</span> <span class="nav-text">@CookieValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestHeader"><span class="nav-number">3.6.</span> <span class="nav-text">@RequestHeader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResponseBody"><span class="nav-number">3.7.</span> <span class="nav-text">@ResponseBody</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestBody"><span class="nav-number">3.8.</span> <span class="nav-text">@RequestBody</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResponseStatus"><span class="nav-number">3.9.</span> <span class="nav-text">@ResponseStatus</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ModelAttribute和-SessionAttributes"><span class="nav-number">3.10.</span> <span class="nav-text">@ModelAttribute和@SessionAttributes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定Servlet内置对象"><span class="nav-number">4.</span> <span class="nav-text">绑定Servlet内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POJO对象绑定"><span class="nav-number">5.</span> <span class="nav-text">POJO对象绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div></div></section></div></aside></div></main><div style="height:370px;background-image:url(/image/bj.png);background-repeat:no-repeat;margin-left:31%"></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span id="sitetime"></span> <span class="my-face">(●'◡'●)ﾉ♥</span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth(),n=o.getDate(),r=o.getHours(),l=o.getMinutes(),M=o.getSeconds(),s=Date.UTC(2016,3,30,8,0,0),f=Date.UTC(i,a,n,r,l,M)-s,g=Math.floor(f/31536e6),h=Math.floor(f/t-365*g),m=Math.floor(f/t),T=Math.floor((f-(365*g+h)*t)/e),u=Math.floor((f-(365*g+h)*t-T*e)/6e4),d=Math.floor((f-(365*g+h)*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+m+" 天 "+T+" 小时 "+u+" 分钟 "+d+" 秒 "}siteTime()</script></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共428.5k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/affix.js?v=5.1.0"></script><script src="/js/src/schemes/pisces.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname="bfchengnuo",disqus_identifier="2017/10/05/SpringMVC学习笔记/",disqus_title="SpringMVC学习笔记";function run_disqus_script(e){var i=document.createElement("script");i.type="text/javascript",i.async=!0,i.src="//"+disqus_shortname+".disqus.com/"+e,(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(i)}var disqus_config=function(){this.page.url=disqus_url,this.page.identifier=disqus_identifier,this.page.title=disqus_title};run_disqus_script("embed.js")</script><script>var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="/js/src/av-core-mini-0.6.4.js"></script><script>AV.initialize("aztA5nbwUsfTeQsa7DqnqgfF-gzGzoHsz","ri0v7p5gusNlBUnLU3A3Tq3t")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/src/particle.js"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script src="/live2d/device.min.js"></script><script>const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script></body></html>