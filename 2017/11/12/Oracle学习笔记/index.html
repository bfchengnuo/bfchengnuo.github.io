<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.0" rel="stylesheet"><meta name="keywords" content="数据库,Oracle,"><link rel="alternate" href="/atom.xml" title="冰封承諾" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0"><meta name="description" content="关于 Oracle 这个数据库就不需要做什么解释了，名声那么大，怎么还不死都懂得，就是死贵死贵的，还是要学一学，因为企业用的还是挺多的。然后来看一下关于它的一些基本介绍，默认端口为 1521 一般固定不用改，数据库的数据文件是 DBF 结尾。版本有三个，结尾分别为 i（internet）、g（grid）、c（clound）；对应早期、近期、现在；"><meta name="keywords" content="数据库,Oracle"><meta property="og:type" content="article"><meta property="og:title" content="Oracle学习笔记"><meta property="og:url" content="http://bfchengnuo.com/2017/11/12/Oracle学习笔记/index.html"><meta property="og:site_name" content="冰封承諾"><meta property="og:description" content="关于 Oracle 这个数据库就不需要做什么解释了，名声那么大，怎么还不死都懂得，就是死贵死贵的，还是要学一学，因为企业用的还是挺多的。然后来看一下关于它的一些基本介绍，默认端口为 1521 一般固定不用改，数据库的数据文件是 DBF 结尾。版本有三个，结尾分别为 i（internet）、g（grid）、c（clound）；对应早期、近期、现在；"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-02-26T13:09:52.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Oracle学习笔记"><meta name="twitter:description" content="关于 Oracle 这个数据库就不需要做什么解释了，名声那么大，怎么还不死都懂得，就是死贵死贵的，还是要学一学，因为企业用的还是挺多的。然后来看一下关于它的一些基本介绍，默认端口为 1521 一般固定不用改，数据库的数据文件是 DBF 结尾。版本有三个，结尾分别为 i（internet）、g（grid）、c（clound）；对应早期、近期、现在；"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bfchengnuo.com/2017/11/12/Oracle学习笔记/"><title>Oracle学习笔记 | 冰封承諾</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-77463916-1","auto"),ga("send","pageview")</script><div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=1259036521&web_id=1259036521" language="JavaScript"></script></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">冰封承諾</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">立于浮华之世,奏响天籁之音.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-mark"><a href="/mark" rel="section"><i class="menu-item-icon fa fa-fw fa-retweet"></i><br>笔记本</a></li><li class="menu-item menu-item-books"><a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书单</a></li><li class="menu-item menu-item-music"><a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>音乐台</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://bfchengnuo.com/2017/11/12/Oracle学习笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kerronex"><meta itemprop="description" content=""><meta itemprop="image" content="/image/tx.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冰封承諾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Oracle学习笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T21:46:33+08:00">2017-11-12</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/自我提升/" itemprop="url" rel="index"><span itemprop="name">自我提升</span></a></span></span> <span id="/2017/11/12/Oracle学习笔记/" class="leancloud_visitors" data-flag-title="Oracle学习笔记"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">8,716</span></span></div></header><div class="post-body" itemprop="articleBody"><p>关于 Oracle 这个数据库就不需要做什么解释了，名声那么大，<del>怎么还不死</del>都懂得，就是死贵死贵的，还是要学一学，因为企业用的还是挺多的。<br>然后来看一下关于它的一些基本介绍，<strong>默认端口为 1521</strong> 一般固定不用改，数据库的数据文件是 DBF 结尾。<br>版本有三个，结尾分别为 i（internet）、g（grid）、c（clound）；对应早期、近期、现在；<a id="more"></a><br>早期的就不说了，一般没人用了，现在基本用的都是 g 系列，c 系列太贵了是融合了云计算服务器，一般用 g 就够了，g 表示的网格可以简单理解为是一个集群，将多台 Oracle 服务器当做一台主机协调使用</p><h2 id="关于SQL"><a href="#关于SQL" class="headerlink" title="关于SQL"></a>关于SQL</h2><p>准备知识，SQL92/99 标准的四大分类：</p><ul><li>DML（数据操纵语言）：<br>select,insert,update,delete</li><li>DDL（数据定义语言）：<br>create table,alter table，drop table，truncate table</li><li>DCL（数据控制语言）：<br>grant 权限 to scott，revoke 权限 from scott</li><li>TCL（事务控制语言）：<br>commit，rollback，rollback to savepoint</li></ul><p>SQL92/99 标准，可以说是访问任何关系型数据库的标准，基本所有的数据库都或多或少的支持;<br>有些地方会把 DML 再拆分，将查询独立出来形成 DQL（数据查询语言）</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装就不说了，一搜一大把，卸载也有，Oracle 的卸载挺麻烦的，官方给的卸载工具是基本没人用，因为本身无法删除；<br>一般我们把它称作是 Oracle 数据库服务器，听到这个名字其实指的就是平常说的数据库，但是下面我为了省劲直接说 Oracle 了<br>然后就是 Oracle 其实包括两大部分，<strong>实例和数据库</strong>，并且必须通过实例才能操作数据库（SQL 语句是通过实例执行的），数据库可以理解为类，看得见的，比如前面的 DBF 文件，实例理解为对象，是看不见的。<br>一个数据库就是一个目录，可在安装目录下的 oradata 文件夹下查看，Oracle 创建、删除数据库是非常复杂的，需要专门的工具，经过大约 12 步才能搞定。<br>连接 Oracle 可以使用自带的 sqlplus (命令行，需要配环境变量)和 sqldeveloper，或者使用第三方的 PLSQL</p><hr><p>安装完成后会创建一个超级管理员，用户名：sys，角色：dba；<br>Oracle 可以使用账号密码登录也可以使用用户和角色登录；<br>常用的普通用户还有 scott 和 hr，默认都是被锁的，注：从 12c 版本开始 scott 就没了（这其实是最早进入 Oracle 的员工的名字）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  斜线前后：username/pwd，或者用角色登录：</span></span><br><span class="line">&gt; sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">account</span> <span class="keyword">unlock</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> tiger;</span><br><span class="line"></span><br><span class="line">&gt; sqlplus scott/tiger</span><br><span class="line"><span class="comment">-- or sqlplus</span></span><br></pre></td></tr></table></figure><p>上面就是一些安装后基础的设置了</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查看当前用户：<code>show user;</code><br>查询当前用户下所有的对象(tab 表每个用户都有)：<code>select * from tab;</code><br>执行最近一次命令（专有）：<code>/</code><br>查询表结构：<code>desc tName;</code><br>条件查询（其中一种，(不)包括12与18）：<code>select * from users where age (not)between 12 and 18;</code><br>包含关系：<code>select * from users where age (not)in (8,12);</code></p><p>查询不重复的内容关键字一样是 distinct ，记住了。<br>Oracle 中有一张叫 dual 的表，称之为哑表或者伪表，只会返回一行数据（比如查询日期：<code>select sysdate from dual</code> ，返回的格式反正很恶心）。<br>单引号一般用于日期和字符串（字符串），双引号一般用于给列设置别名（常量），字符串与字段可以使用 <code>||</code> 来拼接。<br>可以适用 <code>spool d:/aa.sql</code> 命令开启“日志记录”，最后执行 <code>spool off;</code> 这样期间执行的 sql 和结果都会保存到这个文件；与之对应的是读取 sql 文件执行命令：<code>@ d:/a.sql;</code> 。<br>适用条件查询不等于某个数可以使用 <code>a != 30</code> 也可以使用 <code>a &lt;&gt; 30</code> ；然后 Oracle 中的 where 好像是从右往左进行判断，MySQL 的企业版好像也是（关于效率，现在的版本会自动优化，先去识别筛选最有利的条件）。<br>占位符和 MySQL 是一样的，下划线表示一个，百分号表示零或者多个，需要查询下划线的用转义：<code>like &#39;abc\_&#39; escape &#39;\&#39; ;</code><br>判断字段是否为 null 只能使用 <code>is (not) null</code> ，它不能参与精确比较，null 可以是任何类型，并且在排序的时候把 null 看做为最大的值；not 最好不要常用，能用其他代替的就不用，会影响效率。</p><blockquote><p>格式化日期显示可以设置下环境变量：nls_date_format=YYYY-MM-DD HH24:MI:SS</p></blockquote><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>并不保证在其他的数据库也能适用…..<br>函数分为两类，单行函数（一进一出）和多行函数（多进一出），也就是传入参数个数的问题；<br>用到了去查 API 也可以</p><ul><li><p>NVL<br>用法：NVL(a,b)，如果 a 为 null 就返回 b，如果 a 不为 null 就返回 a</p></li><li><p>NVL2<br>用法：NVL2(a,b,c) ，如果 a <strong>不为</strong> null 则返回 b ，否则取 c</p></li><li><p>NULLIF<br>用法：NULLIF(a, b) ，在类型一致的情况下，如果 a 和 b 相同则返回 null ，否则返回 a</p></li><li><p>case…end 表达式<br>SQL 99 标准里的所以 Mysql 也是支持的，用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, age,</span><br><span class="line">  <span class="keyword">case</span> age</span><br><span class="line">    <span class="keyword">when</span> <span class="number">12</span> <span class="keyword">then</span> age+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> age+<span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span> <span class="string">"测试"</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"></span><br><span class="line">case 字段</span><br><span class="line">  when 条件1 then 表达式1</span><br><span class="line">  else 表达式2</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个…..我倒是真没用过，<strong>这个主要是用于显示，并不会进行写入</strong></p></li><li><p>decode<br>这个函数就是优化了上面的 case 表达式，是 Oracle 专用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, age,</span><br><span class="line">  <span class="keyword">decode</span>(age,<span class="number">12</span>,age+<span class="number">1</span>,age+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure><p>也就是说，decode 的第一个参数是字段最后一个是 else 的表达式，中间可以拼多个 when</p></li></ul><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><p>常用的有：<strong>lower / upper / initcap</strong> ；分别对应为转小写、转大写、首字母大写；<br><code>select upper(&#39;aaaabv&#39;) from dual;</code><br>截取字符串使用 <strong>substr</strong> 函数，两个参数为：从第几个开始取（从 1 开始），取几个；<br>计算长度用 <strong>length</strong> 或 <strong>lengthb</strong> 分别为字符和字节数，字节就和编码有关了；<br>查找某个字符首次出现的位置 <strong>instr(‘hello’, ‘h’)</strong> ，返回的坐标是从 1 开始，找不到返回 0 。<br><code>select trim(&#39;o&#39; from &#39;ooabcodoo&#39;) from dual;</code> ：去掉两边的指定字符。<br><code>select replace(&#39;abcd&#39;,&#39;a&#39;,&#39;t&#39;) from dual;</code> ：把 abcd 中的 a 替换为 t。<br>对数字的处理常用的有 <strong>round / trunc / mod</strong> 分别对应四舍五入、截取、取余(相当于n1/n2)，需要传入两个参数，第二个是精度，前两个可以用在日期类型上，并且日期是可以直接进行简单的四则运算的（sysdate + 1 就是加一天）。<br>对日期处理的函数有 <strong>add_months / next_day / last_day</strong>(最后一天) ，日期的运算是可以负数，就是前一天或者上一个月了</p><h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><p>最常见的多行函数就是 count(*) 了吧（这是SQL查行数的标准，内部会优化），<del>因为会扫描所有字段，这也是不推荐用的原因，还不如用 count(1)</del>，或者用主键，还可以使用类似 <code>count(distinct dep)</code> ；<br>max / min / sum / avg 这些就更不用说了，常用的，不要忘了使用分组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="string">"部门编号"</span> ,trunc(<span class="keyword">avg</span>(sal), <span class="number">0</span>) <span class="string">"部门平均工资"</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> trunc(<span class="keyword">avg</span>(sal), <span class="number">0</span>) &gt; <span class="number">2000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>也是复习下 SQL，虽然和多行函数关系不是很大，记得 order 是放在最后的，因为 where 是先执行而 having 是后执行，所以能用 where 就用 where，避免查询不必要的数据；<br><strong>如果使用 order by ，那么 select 中的字段必须出现在 order by 中，但是反过来在 order by 中出现的不一定要在 select 中</strong></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>隐式的转换自然就不需要说了，关键是显式的转换</p><ul><li>日期转字符串<br>示例：<code>select to_char(sysdate, &#39;yyyy&quot;年&quot;mm dd day hh24:mi:ss&#39;) from dual;</code> 不区分大小写</li><li>数值转字符串<br>示例（比如货币）：<code>select to_char(1234, &#39;L9,999&#39;) from dual;</code> ，9 表示的是数字</li><li>字符串转日期<br>和上面差不多，就是倒过来使用：<code>select to_char(&#39;2017-11-06&#39;, &#39;yyyy-mm-dd&#39;) from dual;</code></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>最简单的笛卡尔集表（列数之和，行数之积，其中很多数据都是不合理的）：<br><code>select * from emp,dept;</code><br>其实这种方式在 SQL 标准中叫做<strong>交叉连接（CROSS JOIN）</strong> ，标准的语法是：<code>SELECT * FROM emp CROSS JOIN dept;</code>。</p><p>还有就是子查询，那个和 MySQL 基本一致就不多说了，可以用在 select 后也可以用在 where 后，非常的灵活；关于连接：</p><ul><li>内连接查询<br>只能查询出符合条件的记录（<strong>使用 where 对笛卡尔表进行过滤</strong>）</li><li>外链接查询<br>既能查询出符合条件的记录，也能根据一方强行将另一方查询出来<br>特别的提一下全（外）连接：<code>FULL OUTER JOIN…ON;</code> –&gt; 把两张表中没有的数据都显示</li></ul><p>然后就来看看左外连接/右外连接吧，下面的这个方法是 Oracle 专用，总结一下就是：那边的数据少就在那边写 <code>(+)</code> 但是只能写在最后，从命名上，如果左边的数据多就叫左外连接….<br>按照这个规则，那么可以总结为：</p><ul><li>(+)=：放在了等号的左边，表示的是右连接；</li><li>=(+)：放在了等号的右边，表示的是左连接；</li></ul><p>其实并不需要刻意的区分左和右，根据查询的结果如果发现有些需要的数据没有显示出来，就使用此符号更改连接方向就行了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept.deptno <span class="string">"部门号"</span> , dept.dname <span class="string">"部门名"</span>, <span class="keyword">count</span>(emp.empno) <span class="string">"人数"</span></span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> emp.deptno(+) = dept.deptno</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept.deptno, dept.dname;</span><br></pre></td></tr></table></figure><p>然后就是比较难的自连接，只要设置好别名，一切都不是问题。<br>涉及到子查询的，又分为两类：</p><ul><li>单行子查询<br>子查询只会返回一个结果，父查询使用 = 、&lt;&gt;、&gt;=、&lt;= 来连接</li><li>多行子查询<br>子查询会返回多个结果，父查询使用 in、any、all 这些符号来比较</li></ul><p>平时尽可能的使用多表查询（最终是查的一张笛卡尔表），效率相对子查询高一些，但是总的来说 <strong>多表查询的性能肯定不高</strong></p><p>更多参考：<a href="https://www.cnblogs.com/mchina/archive/2012/09/07/2651568.html" target="_blank" rel="noopener">https://www.cnblogs.com/mchina/archive/2012/09/07/2651568.html</a></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>首先，确定下他们之间的优先级：<br>from 优先级最高；然后是 where 的优先级次之，group by 的优先级仅次于 where；having 紧随 group by 之后；<br>order by 写在最后的，优先级是最低的；select 的优先级仅仅是高于 order by。<br>对于进行连接查询的，首先进行连接然后再对结果进行 where 过滤，所以在连接之前尽量使用 ON 后的条件进行筛选。</p><p>having 的效率极低，能不用就别用，前面尽量用 where 筛选好。</p><p>因为 in 的效率低，所以用 exists 代替；in 的效率低是因为需要对后面的内容进行一一匹配，当然 exists 并不是完全能替代 in，只是尽量少使用 in（not in）：<br><code>select * from school s where exists (select * from student st where st.sid = s.id);</code></p><hr><p>什么时候使用多表连接？什么时候子查询？</p><ul><li>如果需要查询的数据在多个表中，一定要使用多表连接</li><li>不需要表 A 中的列，但是又有该表 A 的条件，可以用子查询</li><li>子查询中如果使用了 in、some any、all 这几个关键字，效率比较低，可以考虑转换成多表关联的方式</li></ul><hr><p>稍微总结一下就是：</p><ul><li>建议不用 <code>*</code> 来代替所有列名</li><li>用 truncate 代替 delete</li><li>在确保语句完整性的情况下多用 commit 语句（用在 begin..end 中）</li><li>尽量减少表的查询次数（少用子查询）</li><li>用 not exists 代替 not in</li><li><del>表连接时，把能过滤多数据的连接放在右边，执行方式是先 ON 后 where，从右往左执行</del>（新版会自动识别，并不需要刻意排序）</li><li>合理使用索引</li><li>sql 语句尽量用大写的，oracle 总是先解析 sql 语句，把小写的转换成大写的在执行</li><li>连接多个表时尽量使用表的别名，减少解析时间</li><li>优化 group by，将不需要的记录在 group by 之前过滤掉</li></ul><p>SQL 的效率查询，也就是慢查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EXECUTIONS,DISK_READS,BUFFER_GETS, </span><br><span class="line">     <span class="keyword">ROUND</span>((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) HIT_RADIO,</span><br><span class="line">     <span class="keyword">ROUND</span>(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,SQL_TEXT </span><br><span class="line"><span class="keyword">FROM</span> V$SQLAREA </span><br><span class="line"><span class="keyword">WHERE</span> EXECUTIONS &gt; <span class="number">0</span> <span class="keyword">AND</span> BUFFER_GETS &gt; <span class="number">0</span> </span><br><span class="line"><span class="keyword">AND</span> (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">4</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>Mysql 中也有类似的命令，通过这个来排除那些执行慢的 SQL。</p><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>关键字：<br>并集：union（只取相交部分的一个）、union all (相交部分的全部，即使重复)<br>交集：intersect<br>差集：minus（在第一个并且不在第二个中的）<br>这些关键字是用在两条查询语句中的，也就是连接两条 select 语句的。<br>需要注意的有：</p><ul><li>集合操作时，必须保证集合的列数是相等的</li><li>集合操作时，必须保证集合的列类型是对应相等的</li><li>多个集合操作时，结果的列名由前一个集合决定</li><li>A UNION B UNION C = C UNION B UNION A</li></ul><p>从选择来说，优先级：多表查询 –&gt; 子查询 –&gt; 集合查询</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在 Oracle 中没有 limit 关键字，分页还是蛮复杂的；<br>说到这里就得说 Oracle 中的关键字（隐藏列） rownum，它可以当做一个字段写在 select 语句中，与表同存在，并且是一直递增（在一次的查询中，从 1 开始），是 number 类型，能参与运算；<br>需要注意的是 &gt; 、 &gt;= 、 = 都是无值的（0 除外，<code>&gt;=1</code> 也可以），因为 rownum 是随着记录变化的，后面的可能是无限，无法确定的就返回空，并且 <code>&lt;&gt;</code> 和 &lt; 是一样的。<strong>也就是说它只能参与小于或者小于等于的运算</strong>。<br>使用子查询进行分页(查询 2-8 的记录)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xx.*</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">id</span> ,emp.* <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">8</span>) xx</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>注意：子查询中加别名不能使用双引号了。</p><blockquote><p>分页查询中，不要直接使用 order by 进行排序，这样会打乱 rownum 的顺序，如果确实需要按照某个字段来排序，那么只能使用嵌套子查询，比如：<br><code>select rownum,a.* from (select rownum rn,name from (select * from test order by name) where rownum&lt;=30) a where rn&gt;=21;</code></p></blockquote><p>PS：还有一个隐藏列是 rowid ，它映射每一行数据物理地址的唯一标识，通常适用于删除完全重复的数据。<br>例如：<code>delete from lyric where rowid not in (select min(rowid) from lyric group by content);</code></p><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>基本和 MySQL 保持一致吧，或许是 SQL99 的标准吧；<br>参考其他表结构来创建表，但是不要数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> back_emp <span class="keyword">where</span> <span class="number">1</span> &lt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其他的有批量从其他表插入数据的，当然要保证列的类型能对应才行，都写在下面吧：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> back_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择添加</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>) </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> back_emp;</span><br></pre></td></tr></table></figure><p>基本都是一个套路，差不多的</p><h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>事务的开始不需要手动执行某条语句（MySQL 是 start transaction），它默认是从第一条 DML 操作（增删改查）作为事务的开始。<br>提交就是直接输入 commit ，回滚就是 rollback 都一样的了。<br>关于事务的提交，除了使用上面的显式 commit，还可以是 DDL/DCL/exit（sqlplus 工具） 语句，也就是说当你执行一条 DDL 语句默认会先进行事务提交。<br>同样也是有隐式回滚的，当关闭窗口、死机、停电等情况时就会进行自动的回滚。</p><p>下面就是回滚点的知识了，让我们能回滚到一个事务中的指定位置，看个栗子就知道了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">savepoint</span> a; <span class="comment">-- 设置回滚点</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> a;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>回滚点多了也不好，起码会占用空间啊，MySQL 也是一样的；<br>隔离级别我就不说了，前面说过，Oracle 只支持两个</p><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>介绍常用的表修改操作，比如修改表名、增加字段啥的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如何修改已经创建的表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">to</span> teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> email varchar2(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 修改字段名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">column</span> email <span class="keyword">to</span> yx;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 修改字段数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">name</span> varchar2(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 删除字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> yx;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><p>关系比较中 <code>&lt;&gt;</code> 是标准语法，可以移植到其他任何平台，!= 是非标准语法，可移植性差。</p><h2 id="约束相关"><a href="#约束相关" class="headerlink" title="约束相关"></a>约束相关</h2><p>最简单的，约束可以分为这几类：<br>非空：not null<br>唯一：unique<br>检查：check<br>外键约束：foreign key （references）<br>主键约束：primary key<br>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">class</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">3</span>) primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  qq varchar2(<span class="number">20</span>) <span class="keyword">check</span>(<span class="keyword">length</span>(qq)&gt;=<span class="number">8</span>),</span><br><span class="line">  tid <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">references</span> teacher(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何添加约束：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> <span class="keyword">constraint</span> aa  primary <span class="keyword">key</span>(tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何查看已经存在的约束：</span></span><br><span class="line"><span class="keyword">select</span> constraint_name,constraint_type <span class="keyword">from</span> user_constraints</span><br><span class="line"><span class="keyword">where</span> table_name = <span class="keyword">upper</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--如何删除约束：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">drop</span> <span class="keyword">constraint</span> SYS_C0011126;</span><br></pre></td></tr></table></figure><p>创建外键的时候，FOREIGN KEY 关键字是可以省略的，直接写 REFERENCES 。</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>sequence 一个单独的数据对象，是一个能够生成有序的整数列值的对象；oracle 通过调用序列的形式来实现主键自增。<br>关于序列的一些常规操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> seq_test</span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">1</span>/<span class="number">-1</span>  <span class="comment">--增长，一次增1   正数+1  负数-1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>       <span class="comment">--从1开始    升序默认就是+1  降序-1</span></span><br><span class="line"><span class="keyword">minvalue</span> <span class="number">1</span>         <span class="comment">--最小值     -10的26次幂</span></span><br><span class="line">maxvalue <span class="number">100</span>       <span class="comment">--最大值     10的27次幂</span></span><br><span class="line"><span class="keyword">cycle</span>              <span class="comment">--循环       默认 nocycle</span></span><br><span class="line">nocache;           <span class="comment">--不缓存     默认生成20个序列号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前用户下有多少序列</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_sequences;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何获取下一个列的值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(seq_test.nextval,<span class="string">'g'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何获取当前序列的值</span></span><br><span class="line"><span class="keyword">select</span> seq_test.currval <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何删除序列</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">sequence</span> seq_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何修改序列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">sequence</span> seq_test <span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 消除延迟段创建特性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> deferred_segment_creation=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">name</span>(<span class="keyword">id</span> <span class="built_in">number</span>) <span class="keyword">segment</span> <span class="keyword">creation</span> <span class="keyword">immediate</span>;</span><br></pre></td></tr></table></figure><p>关于最后一个 消除延迟段创建特性 ，这是因为在 11g+ 的版本中有了一个新特性，它会导致序列直接从 2 开始，尚不知道有什么用处，解决方案可以在建表的时候就指定立即使用序列。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图 view 可以简单理解为是一张假表，用查询的结果动态生成一张表。<br>视图是编译后将查询语言保存到数据库中，下次调用视图，可以不用在编译，直接执行。<br>创建一个简单的视图：<code>create view 视图名 as select * from student;</code><br>为什么要使用视图？</p><ul><li>节省编译时间，提高查询效率</li><li>屏蔽原表中的字段：避免没有权限的用户查询其他的字段（看到不该看的）</li><li>视图中能够根据原表的状态动态刷新</li><li>简单的视图是可以更新（插入等）原表中的数据</li><li>复杂的视图无法更新（插入等），因为涉及到多个表</li></ul><p>需要注意的一点是创建视图后<del>也许并不会马上进行编译</del>，或者后来表结构发生了变化视图并不会进行更新，如果想立即生效可以尝试进行手动更新：<code>alter view 视图名 compile;</code></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>数据库会在具有唯一性的列上自动添加唯一性索引，索引包含：普通索引（normal）、唯一索引（unique）、位图索引（bitmap）、函数索引。<br>正常操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(字段);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询索引</span></span><br><span class="line"><span class="keyword">select</span> index_name,table_name,uniqueness,<span class="keyword">status</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">user_indexes</span><br><span class="line"><span class="keyword">where</span> table_name = <span class="string">'STUDENT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> index_name <span class="keyword">rename</span> <span class="keyword">to</span> new_index_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一性索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位图索引（分类），这种索引适合用在数据量比较大，基数比较小的列（比如：男/女）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bitmap</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数索引：在一个列上经过函数计算后的结果上创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(函数(列名));</span><br></pre></td></tr></table></figure><p>创建索引的优缺点：</p><ul><li>能够更快的帮助我们进行提高查询效率</li><li>增删改表中的数据，数据库就需要耗费资源去维护索引，降低增删改的效率</li><li>数据量如果很少，没必要用索引</li><li>数据量比较大，不需要经常增删改操作而且查询比较多，适合使用索引</li></ul><h2 id="存储过程-amp-触发器"><a href="#存储过程-amp-触发器" class="headerlink" title="存储过程&amp;触发器"></a>存储过程&amp;触发器</h2><p>什么是存储过程，简单说就是在服务器端，能够被一个或多个应用程序调用的一段 sql 语句集（已被预编译）。<br>存储过程的创建等操作和 MySQL 中也大同小异，看些例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建/覆盖存储过程</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span></span><br><span class="line">过程名（参数名 <span class="keyword">in</span> 参数类型，参数名 <span class="keyword">out</span> 参数类型）</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">变量名 变量类型 := 值;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span>语句集;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span></span><br><span class="line">pro_hi(mykey <span class="keyword">in</span> <span class="built_in">number</span>,<span class="keyword">value</span> <span class="keyword">out</span> <span class="built_in">varchar</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> mykey = <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span> <span class="keyword">value</span> := <span class="string">'你好'</span>;</span><br><span class="line">else if mykey = 2</span><br><span class="line">then value := '再见';</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">declare</span> </span><br><span class="line">变量 类型:=初始值;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">过程名（参数，变量）;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> serveroutput <span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">val varchar2(<span class="number">20</span>):=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">pro_hi(<span class="number">1</span>,val);</span><br><span class="line">dbms_output.put_line(val);</span><br><span class="line">pro_hi(2,val);</span><br><span class="line">dbms_output.put_line(val);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>:=</code> 的意思是赋值，存储过程可以没有参数，如果没有参数则过程名之后不能出现括号。</p><hr><blockquote><p>触发器是在数据库中，在执行对数据有异动的动作时，先行拦截并处理的一种数据库对象，它大部份会设在数据表中，作为强制运行特定动作的程序，因此又称为数据操纵语言触发器</p></blockquote><p>或者可以理解为执行某个操作时自动触发执行存储过程？比如用来日志的记录和主键的自动增长。<br>触发器可具体分为行级触发器和<del>表级触发器</del>，具体的简单使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名</span><br><span class="line"><span class="keyword">before</span>/<span class="keyword">after</span>  <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span>  <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span>语句集;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个行级触发器，当执行插入操作时，自动查询序列的下一个值</span></span><br><span class="line"><span class="comment">-- 将查询到的值赋给表中的 id 列</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> tri_insert_good</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> good</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> seq_ids.nextval</span><br><span class="line"><span class="keyword">into</span>:new.id</span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 增加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> good (good_name) <span class="keyword">values</span> (<span class="string">'loli'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表级触发器，用于记录日志</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> test_dept</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">delete</span> <span class="keyword">or</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span> <span class="keyword">on</span> dept</span><br><span class="line"><span class="keyword">declare</span> var_tag varchar2(<span class="number">20</span>); <span class="comment">--声明一个变量</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> inserting <span class="keyword">then</span></span><br><span class="line">var_tag :=<span class="string">'insert'</span>;</span><br><span class="line">elsif updating then</span><br><span class="line">var_tag :='<span class="keyword">update</span><span class="string">';</span></span><br><span class="line"><span class="string">elsif deleting then</span></span><br><span class="line"><span class="string">var_tag :='</span><span class="keyword">delete</span><span class="string">';</span></span><br><span class="line"><span class="string">end if;</span></span><br><span class="line"><span class="string">insert into test_log values(var_tag,sysdate);</span></span><br><span class="line"><span class="string">end;</span></span><br><span class="line"><span class="string">/</span></span><br></pre></td></tr></table></figure><p>使用 elsif 的形式末尾只需要一个 end if 就可以了，如果使用的是 else if 的形式，那么有多少个 if 就要对应多少个 end if。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>默认情况下，删除表会放进回收站，通过命令 <code>show recyclebin;</code> 可以查看回收站。<br>还原表：<code>flashback table name to before drop;</code> 或者 <code>flashback table name to before drop rename to newName;</code><br>彻底删除表：<code>drop table users purge;</code><br>清空回收站：<code>purge recyclebin;</code></p><hr><p>数据类型中的 varchar2(num) 中的 num 指的是<strong>字节</strong>数。<br>关于约束，Oracle 有专用的 check 约束<br>如果使用 sqlplus 工具进行连接，还可以使用占位符，它会提示你输入相关信息，占位符用 <code>&amp;</code> 符号加描述就可以了，用的应该也不是很多</p><hr><p>关于清空表数据可以用传统的 delete 语句，它是从上往下删，速度比较慢，属于 DML 语句，可以进行回滚；<br>还可以使用表截断：<code>truncate table</code> ，速度快属于 DDL，不可回滚，不支持 where。<br>还有就是 drop 语句了，这个干的很彻底，属于 DDL，如果删错了，那就跑路吧。<code>drop table student purge;</code><br>删除空数据的用 <code>where xx is null</code> ，因为不确定不能用 = 号</p><hr><p>查看自己的权限：<code>select * from user_sys_privs;</code></p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>oracle 中的用户都有属于自己的默认的空间，在一段内存空间中大部分存储的是表，所以称为表空间。<br>表空间可简单的分为：系统用户的表空间和普通用户的表空间。<br>那么，为什么要创建用户的表空间呢？<br>项目中很可能与其他项目使用同一个数据库，多个用户在使用同一个数据库的时候有可能访问同一个数据库文件，就会造成资源争用问题，给不同的用户指定不同的表空间，就可以让他们使用不同的数据文件，解决争用问题。<br>数据最终存储在数据块中，从小往大的顺序是：数据块=&gt;盘区=&gt;段=&gt;数据文件=&gt;表空间。<br>相关操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第1步：创建临时表空间  */</span></span><br><span class="line"><span class="keyword">create</span> temporarytablespace user_temp  </span><br><span class="line">tempfile <span class="string">'D:\app\user_temp.dbf'</span> </span><br><span class="line"><span class="keyword">size</span> <span class="number">50</span>m  </span><br><span class="line"><span class="keyword">autoextend</span> <span class="keyword">on</span>  </span><br><span class="line"><span class="keyword">next</span> <span class="number">50</span>m <span class="keyword">maxsize</span> <span class="number">20480</span>m  </span><br><span class="line"><span class="keyword">extent</span> <span class="keyword">management</span> <span class="keyword">local</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第2步：创建数据表空间  */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> <span class="keyword">user_data</span>  </span><br><span class="line"><span class="keyword">logging</span>  </span><br><span class="line"><span class="keyword">datafile</span> <span class="string">'D:\app\user_data.dbf'</span> </span><br><span class="line"><span class="keyword">size</span> <span class="number">50</span>m  </span><br><span class="line"><span class="keyword">autoextend</span> <span class="keyword">on</span>  </span><br><span class="line"><span class="keyword">next</span> <span class="number">50</span>m <span class="keyword">maxsize</span> <span class="number">20480</span>m  </span><br><span class="line"><span class="keyword">extent</span> <span class="keyword">management</span> <span class="keyword">local</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第3步：创建用户并指定表空间  */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> username <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">password</span>  </span><br><span class="line"><span class="keyword">default</span> <span class="keyword">tablespace</span> <span class="keyword">user_data</span>  </span><br><span class="line"><span class="keyword">temporary</span> <span class="keyword">tablespace</span> user_temp;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第4步：给用户授予权限  */</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>,<span class="keyword">resource</span>,dba <span class="keyword">to</span> username;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户后修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> et1803 <span class="keyword">default</span> <span class="keyword">tablespace</span> 表空间名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表空间</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> 表空间名 <span class="keyword">including</span> ontents <span class="keyword">and</span> datailes;</span><br></pre></td></tr></table></figure><p>删除表空间后，原先指向该表空间的用户仍然默认的空间位置，需要通过 alter user 命令将用户的表空间指向一个有效的表空间。</p><h3 id="truncate-、delete与drop区别"><a href="#truncate-、delete与drop区别" class="headerlink" title="truncate 、delete与drop区别"></a>truncate 、delete与drop区别</h3><blockquote><p><a href="https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html" target="_blank" rel="noopener">https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html</a></p></blockquote><p><strong>相同点：</strong></p><ol><li>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据。</li><li>drop、truncate 都是 DDL 语句(数据定义语言)，执行后会自动提交。</li></ol><p><strong>不同点：</strong></p><ol><li>truncate 和 delete 只删除数据不删除表的结构(定义)，而 drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</li><li>delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。<br>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</li><li>delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动；<br>drop 语句将表所占用的空间全部释放。<br>truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。</li><li><strong>速度，一般来说: drop&gt; truncate &gt; delete</strong></li><li>安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及</li><li>delete 是 DML 语句,不会自动提交。drop/truncate 都是 DDL 语句,执行后会自动提交。</li><li>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。<br>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。</li><li>TRUNCATE TABLE 不能用于参与了索引视图的表。</li></ol><h2 id="附-Select-执行顺序"><a href="#附-Select-执行顺序" class="headerlink" title="附:Select 执行顺序"></a>附:Select 执行顺序</h2><blockquote><p><a href="http://www.cnblogs.com/likeju/p/5039128.html" target="_blank" rel="noopener">http://www.cnblogs.com/likeju/p/5039128.html</a></p></blockquote><p>全文的链接在上面，这里摘出其中的一点：注意多表连接的连接条件的选择与表示。<br>多表连接的连接条件对索引的选择有着重要的意义，所以我们在写连接条件条件的时候需要特别注意。</p><ul><li>多表连接的时候，连接条件必须写全，宁可重复，不要缺漏。</li><li>连接条件尽量使用聚集索引</li><li>注意 ON、WHERE 和 HAVING 部分条件的区别：<br>ON 是最先执行， WHERE 次之，HAVING 最后；<br>因为 ON 是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，WHERE 也应该比 HAVING 快点的，因为它过滤数据后才进行 SUM</li></ul><p>考虑联接优先顺序：</p><ul><li>INNER JOIN</li><li>LEFT JOIN (注：RIGHT JOIN 用 LEFT JOIN 替代)</li><li>CROSS JOIN</li></ul><p>其它注意和了解的地方有：</p><ol><li>在 IN 后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数</li><li>注意UNION和UNION ALL的区别。–允许重复数据用UNION ALL好</li><li>注意使用DISTINCT，在没有必要时不要用</li><li>TRUNCATE TABLE 与 DELETE 区别</li><li>减少访问数据库的次数</li></ol><blockquote><p>查询语句的执行顺序：<br>1、FROM 子句：执行顺序为从后往前、从右到左。数据量较少的表尽量放在后面。<br>2、WHERE子句：执行顺序为自下而上、从右到左。将能过滤掉最大数量记录的条件写在WHERE 子句的最右。<br>3、GROUP BY：执行顺序从左往右分组，最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉。<br>4、HAVING 子句：消耗资源。尽量避免使用，HAVING 会在检索出所有记录之后才对结果集进行过滤，需要排序等操作。<br>5、SELECT子句：少用<em>号，尽量取字段名称。ORACLE 在解析的过程中, 通过查询数据字典将</em>号依次转换成所有的列名, 消耗时间。<br>6、ORDER BY子句：执行顺序为从左到右排序，消耗资源。</p></blockquote><h2 id="附-函数整理补充"><a href="#附-函数整理补充" class="headerlink" title="附:函数整理补充"></a>附:函数整理补充</h2><p><strong>单行函数：</strong></p><ul><li>ceil()：返回大于等于x的最小整数</li><li>floor()：返回小于等于x的最大整数</li><li>round()：四舍五入<br>round(a1,a2) 保留指定位小数位的四舍五入</li><li>trunc()：直接截断<br>trunc(a1,a2)：保留指定位数的小数</li><li>sign()：求符号位 正数：1 负数：-1 零返回0</li><li>power(a,b)：求a的b次方</li><li>sqrt()：求正平方根</li></ul><p><strong>转换函数：</strong></p><ul><li>to_number(C)：将一个字符类型的数字变成数值类型</li><li>to_char()：将数字转换为字符串<br>常用在货币单位，格式化字符串<br>日期转换：<code>to_char(日期，&#39;yyyy-MM-dd HH:mm:ss&#39;)</code> OR <code>to_char(systimestamp,&#39;yyyy-mm-dd hh24:mi:ss:ff3&#39;)</code></li><li>to_date(c1,c2)<br>c1:字符类型的日期<br>c2:格式，例如： to_date(‘2018-03’,’yyyy-mm’)<br>日期可以加减（整数）运算 ，单位是：天，但是日期没法相加</li><li>months_between(c1,c2) 计算两个日期之间的月份，就是 c1-c2</li><li>last_day(c1) 计算给定日期的所在月份的最后一天</li><li>next_day(c1,c2) ，距离周几最近的日期<br>c1:日期<br>c2:周中的某天</li></ul><p><strong>字符函数：</strong></p><ul><li>lower():转换成小写</li><li>upper():转换成大写</li><li>initcap():首字母大写</li><li>length():求长度</li><li>substr(c1,c2,c3) 截取字符串<br>c1:被截取的字符串<br>c2:从哪个位置开始截取<br>c3:截取长度 默认截取到最后</li><li>instr(c1,c2,c3,c4) 索引字符串<br>c1:被查询的字符串<br>c2:希望找到的字符<br>c3:从哪个位置开始找 默认是1<br>c4:第几次出现</li><li>concat(c1,c2) 拼接字符串</li><li>lpad(c1,c2,c3) 左侧补全<br>c1:希望补全的字符串<br>c2:补全到多少位<br>c3:以哪个字符来补全</li><li>rpad(c1,c2,c3) 右侧补全</li><li>trim(c1) 默认c1的两侧去除空格<br>trim(c1 from c2) 把c2的两侧移除指定的c1</li><li>ltrim(c1,c2) 左侧去除<br>c1:被去除的字符串<br>c2:去除的字符串 默认是空格</li><li>rtrim(c1,c2) 右侧去除</li><li>replace(c1,c2,c3) 完全替换<br>c1:原字符串<br>c2:被替换的字符串<br>c3:替换的字符串</li></ul><p><strong>通用函数：</strong></p><ul><li>nvl()：空值处理<br>nvl(字段，替换显示的内容)</li><li>nvl2():空值处理二代<br>nvl2(字段，不是空显示什么，是空显示什么)</li><li>wm_concat(column) 字段合并<br><code>select u_id, wmsys.wm_concat(goods || &#39;(&#39; || num || &#39;斤)&#39; ) goods_sum from name group by u_id</code><br>用法详细展示：<a href="http://www.cnblogs.com/yangxia-test/p/4272493.html" target="_blank" rel="noopener">http://www.cnblogs.com/yangxia-test/p/4272493.html</a></li></ul><p><strong>用于 to_char(numeric) 的模板</strong> ：</p><table><thead><tr><th>模板</th><th>描述</th></tr></thead><tbody><tr><td>9</td><td>带有指定位数的值</td></tr><tr><td>0</td><td>前导零的值</td></tr><tr><td>. （句点）</td><td><strong>小数</strong>点</td></tr><tr><td>, （逗号）</td><td>分组（千）分隔符</td></tr><tr><td>PR</td><td>尖括号内负值</td></tr><tr><td>S</td><td>带负号的负值（使用本地化）</td></tr><tr><td>L</td><td>货币符号（使用本地化）</td></tr><tr><td>D</td><td><strong>小数</strong>点（使用本地化）</td></tr><tr><td>G</td><td>分组分隔符（使用本地化）</td></tr><tr><td>MI</td><td>在指明的位置的负号（如果数字 &lt; 0）</td></tr><tr><td>PL</td><td>在指明的位置的正号（如果数字 &gt; 0）</td></tr><tr><td>SG</td><td>在指明的位置的正/负号</td></tr><tr><td>RN</td><td>罗马数字（输入在 1 和 3999 之间）</td></tr><tr><td>TH or th</td><td>转换成序数</td></tr></tbody></table><p>例子：</p><table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td><strong>to_char</strong>(now(),’Day, HH12:MI:SS’)</td><td><code>&#39;Tuesday , 05:39:18&#39;</code></td></tr><tr><td><strong>to_char</strong>(now(),’FMDay, HH12:MI:SS’)</td><td><code>&#39;Tuesday, 05:39:18&#39;</code></td></tr><tr><td><strong>to_char</strong>(-0.1,’99.99’)</td><td><code>&#39; -.10&#39;</code></td></tr><tr><td><strong>to_char</strong>(-0.1,’FM9.99’)</td><td><code>&#39;-.1&#39;</code></td></tr><tr><td><strong>to_char</strong>(0.1,’0.9’)</td><td><code>&#39; 0.1&#39;</code></td></tr><tr><td><strong>to_char</strong>(12,’9990999.9’)</td><td><code>&#39; 0012.0&#39;</code></td></tr><tr><td><strong>to_char</strong>(12,’FM9990999.9’)</td><td><code>&#39;0012&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’999’)</td><td><code>&#39; 485&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’999’)</td><td><code>&#39;-485&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’9 9 9’)</td><td><code>&#39; 4 8 5&#39;</code></td></tr><tr><td><strong>to_char</strong>(1485,’9,999’)</td><td><code>&#39; 1,485&#39;</code></td></tr><tr><td><strong>to_char</strong>(1485,’9G999’)</td><td><code>&#39; 1 485&#39;</code></td></tr><tr><td><strong>to_char</strong>(148.5,’999.999’)</td><td><code>&#39; 148.500&#39;</code></td></tr><tr><td><strong>to_char</strong>(148.5,’999D999’)</td><td><code>&#39; 148,500&#39;</code></td></tr><tr><td><strong>to_char</strong>(3148.5,’9G999D999’)</td><td><code>&#39; 3 148,500&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’999S’)</td><td><code>&#39;485-&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’999MI’)</td><td><code>&#39;485-&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’999MI’)</td><td><code>&#39;485&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’PL999’)</td><td><code>&#39;+485&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’SG999’)</td><td><code>&#39;+485&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’SG999’)</td><td><code>&#39;-485&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’9SG99’)</td><td><code>&#39;4-85&#39;</code></td></tr><tr><td><strong>to_char</strong>(-485,’999PR’)</td><td><code>&#39;&lt;485&gt;&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’L999’)</td><td><code>&#39;DM 485</code></td></tr><tr><td><strong>to_char</strong>(485,’RN’)</td><td><code>&#39; CDLXXXV&#39;</code></td></tr><tr><td><strong>to_char</strong>(485,’FMRN’)</td><td><code>&#39;CDLXXXV&#39;</code></td></tr></tbody></table></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>喜欢就请我吃包辣条吧！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kerronex</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://bfchengnuo.com/2017/11/12/Oracle学习笔记/" title="Oracle学习笔记">http://bfchengnuo.com/2017/11/12/Oracle学习笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据库/" rel="tag"><i class="fa fa-tag"></i> 数据库</a><a href="/tags/Oracle/" rel="tag"><i class="fa fa-tag"></i> Oracle</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/10/28/Redis入门/" rel="next" title="Redis入门"><i class="fa fa-chevron-left"></i> Redis入门</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/11/16/Java消息中间件/" rel="prev" title="Java消息中间件">Java消息中间件<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><p class="warninginfo"><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> 评论框加载失败，无法访问 Disqus<br><br>你可能需要魔法上网~~</p></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/image/tx.png" alt="Kerronex"><p class="site-author-name" itemprop="name">Kerronex</p><p class="site-description motion-element" itemprop="description">萝莉控/程序猿<br>夜猫族/不擅长社交</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">119</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope-o"></i> Email</a></span><span class="links-of-author-item"><a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 小伙伴们~</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a></li><li class="links-of-blogroll-item"><a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a></li><li class="links-of-blogroll-item"><a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a></li><li class="links-of-blogroll-item"><a href="https://bfchengnuo.com/MyRecord/#/" title="学习笔记本" target="_blank">学习笔记本</a></li><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/bfchengnuo" title="博客园" target="_blank">博客园</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于SQL"><span class="nav-number">1.</span> <span class="nav-text">关于SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本操作"><span class="nav-number">3.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用函数"><span class="nav-number">4.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单行函数"><span class="nav-number">4.1.</span> <span class="nav-text">单行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多行函数"><span class="nav-number">4.2.</span> <span class="nav-text">多行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">4.3.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多表查询"><span class="nav-number">5.</span> <span class="nav-text">多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化"><span class="nav-number">5.1.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合查询"><span class="nav-number">6.</span> <span class="nav-text">集合查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页"><span class="nav-number">7.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批量操作"><span class="nav-number">8.</span> <span class="nav-text">批量操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于事务"><span class="nav-number">9.</span> <span class="nav-text">关于事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表操作"><span class="nav-number">10.</span> <span class="nav-text">表操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#约束相关"><span class="nav-number">11.</span> <span class="nav-text">约束相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列"><span class="nav-number">12.</span> <span class="nav-text">序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-number">13.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引"><span class="nav-number">14.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储过程-amp-触发器"><span class="nav-number">15.</span> <span class="nav-text">存储过程&amp;触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">16.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#表空间"><span class="nav-number">16.1.</span> <span class="nav-text">表空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate-、delete与drop区别"><span class="nav-number">16.2.</span> <span class="nav-text">truncate 、delete与drop区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附-Select-执行顺序"><span class="nav-number">17.</span> <span class="nav-text">附:Select 执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附-函数整理补充"><span class="nav-number">18.</span> <span class="nav-text">附:函数整理补充</span></a></li></ol></div></div></section></div></aside></div></main><div style="height:370px;background-image:url(/image/bj.png);background-repeat:no-repeat;margin-left:31%"></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span id="sitetime"></span> <span class="my-face">(●'◡'●)ﾉ♥</span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth(),n=o.getDate(),r=o.getHours(),l=o.getMinutes(),M=o.getSeconds(),s=Date.UTC(2016,3,30,8,0,0),f=Date.UTC(i,a,n,r,l,M)-s,g=Math.floor(f/31536e6),h=Math.floor(f/t-365*g),m=Math.floor(f/t),T=Math.floor((f-(365*g+h)*t)/e),u=Math.floor((f-(365*g+h)*t-T*e)/6e4),d=Math.floor((f-(365*g+h)*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+m+" 天 "+T+" 小时 "+u+" 分钟 "+d+" 秒 "}siteTime()</script></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共428.5k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/affix.js?v=5.1.0"></script><script src="/js/src/schemes/pisces.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname="bfchengnuo",disqus_identifier="2017/11/12/Oracle学习笔记/",disqus_title="Oracle学习笔记";function run_disqus_script(e){var s=document.createElement("script");s.type="text/javascript",s.async=!0,s.src="//"+disqus_shortname+".disqus.com/"+e,(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(s)}var disqus_config=function(){this.page.url=disqus_url,this.page.identifier=disqus_identifier,this.page.title=disqus_title};run_disqus_script("embed.js")</script><script>var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="/js/src/av-core-mini-0.6.4.js"></script><script>AV.initialize("aztA5nbwUsfTeQsa7DqnqgfF-gzGzoHsz","ri0v7p5gusNlBUnLU3A3Tq3t")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/src/particle.js"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script src="/live2d/device.min.js"></script><script>const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script></body></html>