<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.0" rel="stylesheet"><meta name="keywords" content="Java,线程池,"><link rel="alternate" href="/atom.xml" title="冰封承諾" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0"><meta name="description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~"><meta name="keywords" content="Java,线程池"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE二周目计划（二）"><meta property="og:url" content="http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/index.html"><meta property="og:site_name" content="冰封承諾"><meta property="og:description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://bfchengnuo.com/image/dev/线程池.png"><meta property="og:updated_time" content="2019-02-26T13:05:16.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaSE二周目计划（二）"><meta name="twitter:description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~"><meta name="twitter:image" content="http://bfchengnuo.com/image/dev/线程池.png"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/"><title>JavaSE二周目计划（二） | 冰封承諾</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-77463916-1","auto"),ga("send","pageview")</script><div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=1259036521&web_id=1259036521" language="JavaScript"></script></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">冰封承諾</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">立于浮华之世,奏响天籁之音.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-mark"><a href="/mark" rel="section"><i class="menu-item-icon fa fa-fw fa-retweet"></i><br>笔记本</a></li><li class="menu-item menu-item-books"><a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书单</a></li><li class="menu-item menu-item-music"><a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>音乐台</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kerronex"><meta itemprop="description" content=""><meta itemprop="image" content="/image/tx.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冰封承諾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaSE二周目计划（二）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-21T22:29:45+08:00">2017-12-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span> <span id="/2017/12/21/JavaSE二周目计划（二）/" class="leancloud_visitors" data-flag-title="JavaSE二周目计划（二）"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">6,463</span></span></div></header><div class="post-body" itemprop="articleBody"><p>这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。<br>这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~<a id="more"></a></p><h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><p>代码中经常接触到日期的操作，我们不喜欢它默认的格式，大多数情况是需要进行格式化的，下面就说下最简单的格式化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">sf.format(<span class="keyword">new</span> Date());  <span class="comment">// 格式化当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串格式化为 Date 类型</span></span><br><span class="line"><span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-12-20 18:44:00"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时间是否超过五分钟</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOverstepMinute</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">  Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">  Calendar cal1 = Calendar.getInstance();</span><br><span class="line">  cal1.setTime(date);</span><br><span class="line">  cal1.add(Calendar.MINUTE, +<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cal1.compareTo(cal) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以通过 date 对象获取到年月日等信息，但是很遗憾已经过时，所以就有了 Calendar， Calendar 对象用的也很多，可以看看 API；<br>那么他什么用呢？<br>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，分钟? 我们又如何在日期的这些部分<strong>加上或者减去值</strong>呢? 答案是使用Calendar 类。</p><h2 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h2><p>很遗憾我看的视频里并没有讲这个，但是这个却非常的终于，好在现在知道了。<br>Java 中的队列 Queue 在 util 包下，它是个接口，它更倾向于是一种数据结构，也可以理解为集合吧，毕竟 Queue 是 Collection 的一个子接口，与 List、Set 同一级别。<br>首先来认识下什么是队列：</p><blockquote><p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。</p></blockquote><p>简单易懂的介绍，它本来也不是什么难题；<strong>在 Java 中，队列分为 2 种形式，一种是单队列，一种是循环队列</strong> ，循环队列就是为了解决数组无限延伸的情况，让它们闭合起来形成一个圈，这就不会出现角标越界问题了。<br>通常，都是使用数组来实现队列，假定数组的长度为6，也就是队列的长度为6，如果不指定一般默认是 internet 的最大值。<br>因为 LinkedList 实现了 Queue 接口，所以定义一个接口 new 时可以直接使用 LinkedList ，<strong>但它不是同步的！</strong><br>Java 中给了许多的队列实现，甚至有双端（读写）的、按优先级的，普通常用的就是阻塞和非阻塞的一些同步队列</p><h3 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>这样非阻塞也就明白了吧？<br>阻塞队列提供了四种处理方法：</p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><h3 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h3><p><strong>阻塞队列</strong>，当队列为空是取数据阻塞，队列满，插入数据阻塞<br><strong>线程安全的</strong>(批量操作不是) 是否是有界队列需要看具体的实现<br>常用的实现类有：</p><ul><li>ArrayBlockingQueue<br>规定大小的 BlockingQueue,其构造函数<strong>必须</strong>带一个 int 参数来指明其大小.<br>其所含的对象是以FIFO(先入先出)顺序排序的</li><li><strong>LinkedBlockingQueue</strong><br>大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定.<br>其所含的对象是以 FIFO (先入先出)顺序排序的<br><strong>是作为生产者消费者的首选</strong></li><li>SynchronousQueue<br>特殊的 BlockingQueue，对其的操作必须是放和取交替完成的</li><li>PriorityBlockingQueue<br>类似于 LinkedBlockQueue，但其所含对象的排序<strong>不是 FIFO</strong>，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序</li></ul><p>至于它是如何实现同步的，两个 ReentrantLock 读和写。</p><h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><p>不是按照先进先出的顺序，是按照优先级（Comparator 定义或者默认顺序,数字、字典顺序）<br>每次从队列中取出的是具有最高优先权的元素<br>内部通过堆排序实现 transient Object[] queue; 每次新增删除的时候，调整堆</p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>非阻塞队列一般就直接实现自 Queue 了，特点就不说了，对比上面的阻塞队列就行了，下面说说常见的非阻塞队列：<br><strong>ConcurrentLinkedQueue</strong><br>虽然是非阻塞，但也是线程安全的，按照 FIFO 来进行排序，采用CAS操作，来保证元素的一致性</p><blockquote><p>非阻塞算法通过使用低层次的并发原语，比如比较交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。<br>关键字：CAS<br><strong>线程安全就是说多线程访问同一代码，不会产生不确定的结果</strong></p></blockquote><p>ConcurrentLinkedQueue 的 <code>size()</code> 是要遍历一遍集合的，所以尽量要避免用 size 而改用 <code>isEmpty()</code>，以免性能过慢。</p><h3 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h3><p>一般情况下，操作队列不推荐使用 add 和 remove ，因为如果队列为空它就会抛异常；常使用的是 <strong>offer</strong> 和 <strong>poll</strong> 来添加和取出元素，如果此队列为空，则返回 null，如果使用 peek 取出元素则不会移除此元素，对于阻塞的队列，可以使用 put 和 take 来插入和获取。<br>带有 Deque 的一般是双端队列，不细说，我用的起码是非常少的<br>关于遍历队列如果使用 foreach 的方式相当于仅仅是 peek，也就是不会移除元素，如果需要遍历队列并且是取出，那么可以搭配 where 来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历队列</span></span><br><span class="line">  Order order;</span><br><span class="line">  <span class="keyword">while</span> ((order = queue.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    rechargeOrder(order);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个过程注意 size，如果一边放一边遍历的话是没有尽头的</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>同样视频里是没有提到的，只是讲了多线程的一些使用和注意事项，对于线程池，提及的很少，也许是因为 JavaEE 中并不常用，都是交给 Web 应用服务器来维护。<br>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，和连接池是一个道理。<br>Java 中的线程池，最核心的就是 <strong>ThreadPoolExecutor</strong> 了<br>ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br>下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小<br>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。<br>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数<br>这个参数也是一个非常重要的参数，<strong>它表示在线程池中最多能创建多少个线程</strong>；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。<br>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize，即当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize。<br>但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 corePoolSize 时， keepAliveTime 参数也会起作用，直到线程池中的线程数为 0；</li><li>unit：参数 keepAliveTime 的时间单位<br>有7种取值，比如天、时、分、秒、毫秒等</li><li><strong>workQueue：一个阻塞队列，用来存储等待执行的任务</strong><br>这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;<br>LinkedBlockingQueue;<br>SynchronousQueue;<br>ArrayBlockingQueue 和 PriorityBlockingQueue 使用较少，<strong>一般使用 LinkedBlockingQueue 和 Synchronous</strong>。<br>线程池的排队策略与 BlockingQueue 有关。</li><li>threadFactory：线程工厂，主要用来创建线程；</li><li>handler：表示当拒绝处理任务时的策略<br>有以下四种取值：<br>ThreadPoolExecutor.AbortPolicy ：丢弃任务并抛出 RejectedExecutionException 异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><p>上面仅仅是对构造方法参数的一些介绍，相关的几个类或者接口就是 ThreadPoolExecutor、AbstractExecutorService、ExecutorService 和 Executor，名字越短越抽象，最后的 Executor 为顶级接口</p><h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p>下面来了解下关于线程池中定义的几个方法：</p><ul><li>execute()方法<br>实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li><li>submit()方法<br>在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute() 方法不同，<strong>它能够返回任务执行的结果</strong>，去看 submit() 方法的实现，会发现它<strong>实际上还是调用的 execute() 方法</strong>，只不过它利用了 Future 来获取任务执行结果</li><li>shutdown() 和 shutdownNow() 是用来关闭线程池的。</li></ul><p>其他的方法还有 getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount() 等获取与线程池相关属性的方法，详细介绍去看 API 吧</p><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>当创建线程池后，初始时，线程池处于 <strong>RUNNING</strong> 状态；<br>如果调用了 <code>shutdown()</code> 方法，则线程池处于 <strong>SHUTDOWN</strong> 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果调用了 <code>shutdownNow()</code> 方法，则线程池处于 <strong>STOP</strong> 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于 <strong>SHUTDOWN</strong> 或 <strong>STOP</strong> 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 <strong>TERMINATED</strong> 状态。</p><h3 id="线程池的创建-amp-使用"><a href="#线程池的创建-amp-使用" class="headerlink" title="线程池的创建&amp;使用"></a>线程池的创建&amp;使用</h3><p>先来看一个简单使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                         <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">      MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">      executor.execute(myTask);</span><br><span class="line">      System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                         executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 java doc中，并不提倡我们直接使用 ThreadPoolExecutor，而是使用 Executors 类中提供的几个静态方法来创建线程池：</p><ul><li>Executors.newCachedThreadPool();<br>创建一个缓冲池，缓冲池容量大小为 Integer.MAX_VALUE</li><li>Executors.newSingleThreadExecutor();<br>创建容量为 1 的缓冲池</li><li>Executors.newFixedThreadPool(int);<br>创建固定容量大小的缓冲池</li></ul><p>看一下他们三个的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。<br><strong>newFixedThreadPool</strong> 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；<strong>newSingleThreadExecutor</strong> 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；<strong>newCachedThreadPool</strong> 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。</p><h3 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h3><p>一般需要根据任务的类型来配置线程池大小，当然也是仅供参考：<br>如果是 CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU+1<br>如果是 IO 密集型任务，参考值可以设置为 2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>一提到定时任务，首先想到的是使用 Timer，但是使用 Timer 执行周期性任务时，出现异常后自动退出（全部）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。<br>是的，这也是一个线程池，只不过它支持周期任务而已，看到这里对线程池应该也有所了解了，所以定时任务也就不难了</p><p><img src="/image/dev/线程池.png" alt="线程池.png"></p><p>它继承的 ThreadPoolExecutor 那些就不说了，来看看它特有的几个方法：</p><ul><li><strong>Schedule(Runnable command, long delay, TimeUnit unit)</strong><br>elay 指定的时间后，执行指定的 Runnable 任务，可以通过返回的 <code>ScheduledFuture&lt;?&gt;</code> 与该任务进行交互</li><li><strong>schedule(Callable\<v \>callable, long delay, TimeUnit unit)</v></strong><br><em>delay</em> 指定的时间后，执行指定的 <code>Callable&lt;V&gt;</code> 任务，可以通过返回的 <code>ScheduledFuture&lt;V&gt;</code> 与该任务进行交互。</li><li><strong>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按周期 <em>period</em> 执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，那么第一次执行任务的时间点为 <code>initialDelay</code>，第二次为 <code>initialDelay + period</code>，第三次为 <code>initialDelay + period + period</code>，以此类推。</li><li><strong>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按指定的 <em>delay</em> 延期性的执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，每次任务需要耗时 <code>T(i)</code>（<strong>i</strong> 为第几次执行任务），那么第一次执行任务的时间点为 <code>initialDelay</code>，第一次完成任务的时间点为 <code>initialDelay + T(1)</code>，则第二次执行任务的时间点为 <code>initialDelay + T(1) + delay</code>；第二次完成任务的时间点为 <code>initialDelay + (T(1) + delay) + T(2)</code>，所以第三次执行任务的时间点为 <code>initialDelay + T(1) + delay + T(2) + delay</code>，以此类推。</li></ul><p>简单解释下 scheduleAtFixedRate 和 scheduleWithFixedDelay，前者会开始执行为起始点，如果任务耗时超过了间隔时间，那么在任务完成候第二次会很快（<del>马上</del>）执行，而后者会等待任务执行完后才开始计算周期间隔时间。<br>创建线程池的方式也与上面差不多，都有对应的方法：<br><strong>Executors.newScheduledThreadPool(int corePoolSize)</strong><br><strong>Executors.newSingleThreadScheduledExecutor()</strong></p><p>Apache 的 BasicThreadFactory 或许会更好….待进一步研究</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><code>ScheduledFuture</code> 接口 继承自 <code>Future</code> 接口，所以 <code>ScheduledFuture</code> 和任务的交互方式与 <code>Future</code> 一致。所以通过<code>ScheduledFuture</code>，可以 判断定时任务是否已经完成，获得定时任务的返回值，或者取消任务等<br>关于 <code>Future</code> 后面应该会再进行补充<br>可以先看一下：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">这篇文章</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这个很简单，没什么好说的，简单说就是构造函数的私有化，然后定义一个本类类型的静态变量，通过静态方法进行提供<br>需要注意的是，静态变量的初始化时机，比较一致的观点是：如果你确定这个类肯定要用，那么可以在定义静态变量的时候就直接进行实例化，否则可以放在静态方法中进行实例化（这样会有线程安全问题）比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton is = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是获取的时候实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">    is = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，单例模式需要注意的也就是这里了：<strong>线程安全问题</strong><br>如果你选择了在静态方法中进行实例化，并且使用了多线程技术，那么极有可能它并不是单例的；原因我想大概都知道，当然也有相应的解决方案，一般就从这三种中进行选择：</p><ul><li><p>同步方法<br>这是最简单的方式，如果不考虑性能的情况下是可以使用的，使用同步就意味着可能造成执行效率下降100倍<br><code>public static synchronized getInstance(){}</code></p></li><li><p>急切实例化<br>这个就是上面的第一种方式，在定义的时候就直接实例化<br>在创建运行时负担不重的情况下可以采用</p></li><li><p>双重检查加锁<br>在同步方法中我们发现，其实只需要第一次加锁就可以了，因为第一次创建出 is 后后面都是直接返回的<br>所以，可以进行下面的优化（java5+）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton is;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Test&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">          is = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以大大减少 get 方法的时间消耗，如果确实不考虑性能，使用这个就有点大材小用了。</p><blockquote><p>这个方法表面上看起来很完美，你只需要付出一次同步块的开销，但它依然有问题。<br>除非你声明 is 变量时使用了 volatile 关键字。没有 volatile 修饰符，可能出现 Java 中的另一个线程看到个初始化了一半的 is 的情况，但使用了 volatile 变量后，就能保证先行发生关系（happens-before relationship）<br>参考下面的：无序写入</p></blockquote></li><li><p>静态内部类<br>这也是一种懒汉式的实现，相比双重锁检查，更简单，更高效吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonIniti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonIniti</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonIniti INSTANCE = newSingletonIniti();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonIniti <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>并且外部类可以访问内部类的 private 方法。</p></li></ul><p>单例模式的使用情景并不是太多，并且如果程序有多个类加载器，还是会造成有多个实例的情况，所以如果用到了多个类加载器记得指定使用同一个类加载器</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>关于这个，确实不太常见，很多人以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。<br>Java 语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制。</p><p>对于 synchronized 我们都知道：<br>通过 synchronized 关键字来实现，所有加上 synchronized 和块语句，在多线程访问的时候，同一时刻只能有一个线程能够用 synchronized 修饰的方法 或者 代码块。<br><strong>用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。</strong></p><blockquote><p>在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是 jvm 虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候<strong>变量值信息</strong>。<br>当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值 load 到线程本地内存中，建立一个变量副本，<strong>之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值</strong>，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。<br>这样在堆中的对象的值就产生变化了。</p><p>原文：<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p></blockquote><p>从上面的解释也可以看出 volatile 并不能保证原子性，它的作用就是在每次<strong>使用的时候</strong>获取最新的值</p><h2 id="无序写入"><a href="#无序写入" class="headerlink" title="无序写入"></a>无序写入</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong><br><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong><br>关键原因就是： <code>instance = new Singleton();</code> 不是原子操作。<br>然后从两个方面来看原因：</p><ul><li>有序性：是因为 instance = new Singleton(); 不是原子操作。编译器存在指令重排，从而存在线程1 创建实例后（初始化未完成），线程2 判断对象不为空，但实际对象扔为空，造成错误。</li><li>可见性：是因为线程1 创建实例后还只存在自己线程的工作内存，未更新到主存。线程 2 判断对象为空，创建实例，从而存在多实例错误。</li></ul><p>也就是，要想保证安全，必须保证这句代码的有序性和可见性。<br><strong>volatile 对 singleton 的创建过程的重要性：禁止指令重排序（有序性）。</strong><br>实例化一个对象其实可以分为三个步骤：</p><ol><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ol><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p><ol><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ol><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。<br>因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量，volatile 的禁止重排序保证了操作的有序性。<br>除了这种方案，还有人提出在“构造对象”和“连接引用与实例”之间加上一道内存屏障来保证有序性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//构造与赋值之间随意做点事情保证顺序</span></span><br><span class="line">temp.toString();</span><br><span class="line">instance=temp;</span><br></pre></td></tr></table></figure><p>这想法确实 nice~</p><hr><p>关于可见性，第二次非 null 判断是在加锁以后（也就是说后面的线程在获取锁以后判断 instance 是否为 null 必然是在第一个线程引用赋值完成释放锁以后），则根据这一条，另一个线程一定能看到这个引用被赋值。所以即使没有 volatile，依旧能保证可见性。</p><p><a href="https://www.zhihu.com/question/56606703" target="_blank" rel="noopener">https://www.zhihu.com/question/56606703</a></p><p>PS：据说因为 JVM 的实现不同，volatile 未必能保证绝对的安全，在 HotSpot 应该是没问题的。</p><h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-blocking-queue</a><br><a href="http://blog.csdn.net/xiaohulunb/article/details/38932923" target="_blank" rel="noopener">http://blog.csdn.net/xiaohulunb/article/details/38932923</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a><br><a href="https://segmentfault.com/a/1190000008038848" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008038848</a><br><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">https://blog.csdn.net/chenchaofuck1/article/details/51702129</a><br>拓展：<br><a href="http://www.jianshu.com/p/925dba9f5969" target="_blank" rel="noopener">http://www.jianshu.com/p/925dba9f5969</a><br><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池</a></p></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>喜欢就请我吃包辣条吧！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kerronex</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/" title="JavaSE二周目计划（二）">http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/线程池/" rel="tag"><i class="fa fa-tag"></i> 线程池</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/11/28/JavaSE二周目计划/" rel="next" title="JavaSE二周目计划"><i class="fa fa-chevron-left"></i> JavaSE二周目计划</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/01/03/Java定时任务调度工具/" rel="prev" title="Java定时任务调度工具">Java定时任务调度工具<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><p class="warninginfo"><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> 评论框加载失败，无法访问 Disqus<br><br>你可能需要魔法上网~~</p></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/image/tx.png" alt="Kerronex"><p class="site-author-name" itemprop="name">Kerronex</p><p class="site-description motion-element" itemprop="description">萝莉控/程序猿<br>夜猫族/不擅长社交</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">117</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope-o"></i> Email</a></span><span class="links-of-author-item"><a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 小伙伴们~</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a></li><li class="links-of-blogroll-item"><a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a></li><li class="links-of-blogroll-item"><a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a></li><li class="links-of-blogroll-item"><a href="https://bfchengnuo.com/MyRecord/#/" title="学习笔记本" target="_blank">学习笔记本</a></li><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/bfchengnuo" title="博客园" target="_blank">博客园</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期处理"><span class="nav-number">1.</span> <span class="nav-text">日期处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于队列"><span class="nav-number">2.</span> <span class="nav-text">关于队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于阻塞队列"><span class="nav-number">2.1.</span> <span class="nav-text">关于阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue接口"><span class="nav-number">2.2.</span> <span class="nav-text">BlockingQueue接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue类"><span class="nav-number">2.3.</span> <span class="nav-text">PriorityQueue类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞队列"><span class="nav-number">2.4.</span> <span class="nav-text">非阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列的操作"><span class="nav-number">2.5.</span> <span class="nav-text">队列的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">3.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义的方法"><span class="nav-number">3.1.</span> <span class="nav-text">定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的状态"><span class="nav-number">3.2.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的创建-amp-使用"><span class="nav-number">3.3.</span> <span class="nav-text">线程池的创建&amp;使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置线程池"><span class="nav-number">3.4.</span> <span class="nav-text">配置线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时任务"><span class="nav-number">4.</span> <span class="nav-text">定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">4.1.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">5.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字"><span class="nav-number">6.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无序写入"><span class="nav-number">7.</span> <span class="nav-text">无序写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-amp-拓展"><span class="nav-number">8.</span> <span class="nav-text">参考&amp;拓展</span></a></li></ol></div></div></section></div></aside></div></main><div style="height:370px;background-image:url(/image/bj.png);background-repeat:no-repeat;margin-left:31%"></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span id="sitetime"></span> <span class="my-face">(●'◡'●)ﾉ♥</span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth(),n=o.getDate(),r=o.getHours(),l=o.getMinutes(),M=o.getSeconds(),s=Date.UTC(2016,3,30,8,0,0),f=Date.UTC(i,a,n,r,l,M)-s,g=Math.floor(f/31536e6),h=Math.floor(f/t-365*g),m=Math.floor(f/t),T=Math.floor((f-(365*g+h)*t)/e),u=Math.floor((f-(365*g+h)*t-T*e)/6e4),d=Math.floor((f-(365*g+h)*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+m+" 天 "+T+" 小时 "+u+" 分钟 "+d+" 秒 "}siteTime()</script></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共417.2k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/affix.js?v=5.1.0"></script><script src="/js/src/schemes/pisces.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname="bfchengnuo",disqus_identifier="2017/12/21/JavaSE二周目计划（二）/",disqus_title="JavaSE二周目计划（二）";function run_disqus_script(e){var s=document.createElement("script");s.type="text/javascript",s.async=!0,s.src="//"+disqus_shortname+".disqus.com/"+e,(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(s)}var disqus_config=function(){this.page.url=disqus_url,this.page.identifier=disqus_identifier,this.page.title=disqus_title};run_disqus_script("embed.js")</script><script>var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="/js/src/av-core-mini-0.6.4.js"></script><script>AV.initialize("aztA5nbwUsfTeQsa7DqnqgfF-gzGzoHsz","ri0v7p5gusNlBUnLU3A3Tq3t")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/src/particle.js"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script src="/live2d/device.min.js"></script><script>const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script></body></html>