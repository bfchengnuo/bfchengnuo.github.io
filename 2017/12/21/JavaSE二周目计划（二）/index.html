<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,线程池," />





  <link rel="alternate" href="/atom.xml" title="Sakanoy" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0" />






<meta name="description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~">
<meta name="keywords" content="Java,线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE二周目计划（二）">
<meta property="og:url" content="https://sakanoy.com/2017/12/21/JavaSE二周目计划（二）/index.html">
<meta property="og:site_name" content="Sakanoy">
<meta property="og:description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://sakanoy.com/image/dev/线程池.png">
<meta property="og:updated_time" content="2024-11-14T17:46:09.405Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaSE二周目计划（二）">
<meta name="twitter:description" content="这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~">
<meta name="twitter:image" content="https://sakanoy.com/image/dev/线程池.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sakanoy.com/2017/12/21/JavaSE二周目计划（二）/"/>




<script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-bounce.css">

  <title> JavaSE二周目计划（二） | Sakanoy </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-77463916-1', 'auto');
  ga('send', 'pageview');
</script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sakanoy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">立于浮华之世,奏响天籁之音.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mark">
          <a href="/mark" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-retweet"></i> <br />
            
            笔记本
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            书单
          </a>
        </li>
      
        
        <li class="menu-item menu-item-music">
          <a href="/music" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-music"></i> <br />
            
            音乐台
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://sakanoy.com/2017/12/21/JavaSE二周目计划（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kerronex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/tx.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sakanoy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaSE二周目计划（二）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-21T22:29:45+00:00">
                2017-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i> 热度
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  6,497
                </span>
              

              

              
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <div style="display: none;color: #999" class="note warning" id='timeliness'></div>
        <script language=javascript>
          var days = (new Date().getTime() - 1513895385000) / 86400000;
          if(days > 180) {
            var infoDom = document.getElementById("timeliness");
            infoDom.innerHTML = "提醒：本文发布于 " + Math.round(days) + " 天前，文中所描述的信息可能已发生改变，请谨慎使用。";
            infoDom.style.display = "block"
          }
        </script>
        <p>这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。<br>这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~<a id="more"></a></p>
<h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><p>代码中经常接触到日期的操作，我们不喜欢它默认的格式，大多数情况是需要进行格式化的，下面就说下最简单的格式化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">sf.format(<span class="keyword">new</span> Date());  <span class="comment">// 格式化当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串格式化为 Date 类型</span></span><br><span class="line"><span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-12-20 18:44:00"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时间是否超过五分钟</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOverstepMinute</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">  Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">  Calendar cal1 = Calendar.getInstance();</span><br><span class="line">  cal1.setTime(date);</span><br><span class="line">  cal1.add(Calendar.MINUTE, +<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cal1.compareTo(cal) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外可以通过 date 对象获取到年月日等信息，但是很遗憾已经过时，所以就有了 Calendar， Calendar 对象用的也很多，可以看看 API；<br>那么他什么用呢？<br>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，分钟? 我们又如何在日期的这些部分<strong>加上或者减去值</strong>呢? 答案是使用Calendar 类。</p>
<h2 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h2><p>很遗憾我看的视频里并没有讲这个，但是这个却非常的终于，好在现在知道了。<br>Java 中的队列 Queue 在 util 包下，它是个接口，它更倾向于是一种数据结构，也可以理解为集合吧，毕竟 Queue 是 Collection 的一个子接口，与 List、Set 同一级别。<br>首先来认识下什么是队列：</p>
<blockquote>
<p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。</p>
</blockquote>
<p>简单易懂的介绍，它本来也不是什么难题；<strong>在 Java 中，队列分为 2 种形式，一种是单队列，一种是循环队列</strong> ，循环队列就是为了解决数组无限延伸的情况，让它们闭合起来形成一个圈，这就不会出现角标越界问题了。<br>通常，都是使用数组来实现队列，假定数组的长度为6，也就是队列的长度为6，如果不指定一般默认是 internet 的最大值。<br>因为 LinkedList 实现了 Queue 接口，所以定义一个接口 new 时可以直接使用 LinkedList ，<strong>但它不是同步的！</strong><br>Java 中给了许多的队列实现，甚至有双端（读写）的、按优先级的，普通常用的就是阻塞和非阻塞的一些同步队列</p>
<h3 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>这样非阻塞也就明白了吧？<br>阻塞队列提供了四种处理方法：</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h3 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h3><p><strong>阻塞队列</strong>，当队列为空是取数据阻塞，队列满，插入数据阻塞<br><strong>线程安全的</strong>(批量操作不是) 是否是有界队列需要看具体的实现<br>常用的实现类有：</p>
<ul>
<li>ArrayBlockingQueue<br>规定大小的 BlockingQueue,其构造函数<strong>必须</strong>带一个 int 参数来指明其大小.<br>其所含的对象是以FIFO(先入先出)顺序排序的</li>
<li><strong>LinkedBlockingQueue</strong><br>大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定.<br>其所含的对象是以 FIFO (先入先出)顺序排序的<br><strong>是作为生产者消费者的首选</strong></li>
<li>SynchronousQueue<br>特殊的 BlockingQueue，对其的操作必须是放和取交替完成的</li>
<li>PriorityBlockingQueue<br>类似于 LinkedBlockQueue，但其所含对象的排序<strong>不是 FIFO</strong>，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序</li>
</ul>
<p>至于它是如何实现同步的，两个 ReentrantLock 读和写。</p>
<h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><p>不是按照先进先出的顺序，是按照优先级（Comparator 定义或者默认顺序,数字、字典顺序）<br>每次从队列中取出的是具有最高优先权的元素<br>内部通过堆排序实现 transient Object[] queue; 每次新增删除的时候，调整堆</p>
<h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>非阻塞队列一般就直接实现自 Queue 了，特点就不说了，对比上面的阻塞队列就行了，下面说说常见的非阻塞队列：<br><strong>ConcurrentLinkedQueue</strong><br>虽然是非阻塞，但也是线程安全的，按照 FIFO 来进行排序，采用CAS操作，来保证元素的一致性</p>
<blockquote>
<p>非阻塞算法通过使用低层次的并发原语，比如比较交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。<br>关键字：CAS<br><strong>线程安全就是说多线程访问同一代码，不会产生不确定的结果</strong></p>
</blockquote>
<p>ConcurrentLinkedQueue 的 <code>size()</code> 是要遍历一遍集合的，所以尽量要避免用 size 而改用 <code>isEmpty()</code>，以免性能过慢。</p>
<h3 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h3><p>一般情况下，操作队列不推荐使用 add 和 remove ，因为如果队列为空它就会抛异常；常使用的是 <strong>offer</strong> 和 <strong>poll</strong> 来添加和取出元素，如果此队列为空，则返回 null，如果使用 peek 取出元素则不会移除此元素，对于阻塞的队列，可以使用 put 和 take 来插入和获取。<br>带有 Deque 的一般是双端队列，不细说，我用的起码是非常少的<br>关于遍历队列如果使用 foreach 的方式相当于仅仅是 peek，也就是不会移除元素，如果需要遍历队列并且是取出，那么可以搭配 where 来使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历队列</span></span><br><span class="line">  Order order;</span><br><span class="line">  <span class="keyword">while</span> ((order = queue.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    rechargeOrder(order);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程注意 size，如果一边放一边遍历的话是没有尽头的</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>同样视频里是没有提到的，只是讲了多线程的一些使用和注意事项，对于线程池，提及的很少，也许是因为 JavaEE 中并不常用，都是交给 Web 应用服务器来维护。<br>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，和连接池是一个道理。<br>Java 中的线程池，最核心的就是 <strong>ThreadPoolExecutor</strong> 了<br>ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br>下面解释下一下构造器中各个参数的含义：</p>
<ul>
<li>corePoolSize：核心池的大小<br>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。<br>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；</li>
<li>maximumPoolSize：线程池最大线程数<br>这个参数也是一个非常重要的参数，<strong>它表示在线程池中最多能创建多少个线程</strong>；<br>当核心池大小满了，等待队列也满了，就开始创建非核心线程，直到达到最大线程数。</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。<br>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize，即当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize。<br>但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 corePoolSize 时， keepAliveTime 参数也会起作用，直到线程池中的线程数为 0；</li>
<li>unit：参数 keepAliveTime 的时间单位<br>有7种取值，比如天、时、分、秒、毫秒等</li>
<li><strong>workQueue：一个阻塞队列，用来存储等待执行的任务</strong><br>这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;<br>LinkedBlockingQueue;<br>SynchronousQueue;<br>ArrayBlockingQueue 和 PriorityBlockingQueue 使用较少，<strong>一般使用 LinkedBlockingQueue 和 Synchronous</strong>。<br>线程池的排队策略与 BlockingQueue 有关。</li>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li>handler：表示当拒绝处理任务时的策略<br>有以下四种取值：<br>ThreadPoolExecutor.AbortPolicy ：丢弃任务并抛出 RejectedExecutionException 异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<p>上面仅仅是对构造方法参数的一些介绍，相关的几个类或者接口就是 ThreadPoolExecutor、AbstractExecutorService、ExecutorService 和 Executor，名字越短越抽象，最后的 Executor 为顶级接口</p>
<h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p>下面来了解下关于线程池中定义的几个方法：</p>
<ul>
<li>execute()方法<br>实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li>submit()方法<br>在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute() 方法不同，<strong>它能够返回任务执行的结果</strong>，去看 submit() 方法的实现，会发现它<strong>实际上还是调用的 execute() 方法</strong>，只不过它利用了 Future 来获取任务执行结果</li>
<li>shutdown() 和 shutdownNow() 是用来关闭线程池的。</li>
</ul>
<p>其他的方法还有 getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount() 等获取与线程池相关属性的方法，详细介绍去看 API 吧</p>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>当创建线程池后，初始时，线程池处于 <strong>RUNNING</strong> 状态；<br>如果调用了 <code>shutdown()</code> 方法，则线程池处于 <strong>SHUTDOWN</strong> 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果调用了 <code>shutdownNow()</code> 方法，则线程池处于 <strong>STOP</strong> 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于 <strong>SHUTDOWN</strong> 或 <strong>STOP</strong> 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 <strong>TERMINATED</strong> 状态。</p>
<h3 id="线程池的创建-amp-使用"><a href="#线程池的创建-amp-使用" class="headerlink" title="线程池的创建&amp;使用"></a>线程池的创建&amp;使用</h3><p>先来看一个简单使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                         <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">      MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">      executor.execute(myTask);</span><br><span class="line">      System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                         executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 java doc中，并不提倡我们直接使用 ThreadPoolExecutor，而是使用 Executors 类中提供的几个静态方法来创建线程池：</p>
<ul>
<li>Executors.newCachedThreadPool();<br>创建一个缓冲池，缓冲池容量大小为 Integer.MAX_VALUE</li>
<li>Executors.newSingleThreadExecutor();<br>创建容量为 1 的缓冲池</li>
<li>Executors.newFixedThreadPool(int);<br>创建固定容量大小的缓冲池</li>
</ul>
<p>看一下他们三个的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。<br><strong>newFixedThreadPool</strong> 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；<strong>newSingleThreadExecutor</strong> 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；<strong>newCachedThreadPool</strong> 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。</p>
<h3 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h3><p>一般需要根据任务的类型来配置线程池大小，当然也是仅供参考：<br>如果是 CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU+1<br>如果是 IO 密集型任务，参考值可以设置为 2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>一提到定时任务，首先想到的是使用 Timer，但是使用 Timer 执行周期性任务时，出现异常后自动退出（全部）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。<br>是的，这也是一个线程池，只不过它支持周期任务而已，看到这里对线程池应该也有所了解了，所以定时任务也就不难了</p>
<p><img src="/image/dev/线程池.png" alt="线程池.png"></p>
<p>它继承的 ThreadPoolExecutor 那些就不说了，来看看它特有的几个方法：</p>
<ul>
<li><strong>Schedule(Runnable command, long delay, TimeUnit unit)</strong><br>elay 指定的时间后，执行指定的 Runnable 任务，可以通过返回的 <code>ScheduledFuture&lt;?&gt;</code> 与该任务进行交互</li>
<li><strong>schedule(Callable\<v\> callable, long delay, TimeUnit unit)</v\></strong><br><em>delay</em> 指定的时间后，执行指定的 <code>Callable&lt;V&gt;</code> 任务，可以通过返回的 <code>ScheduledFuture&lt;V&gt;</code> 与该任务进行交互。</li>
<li><strong>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按周期 <em>period</em> 执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，那么第一次执行任务的时间点为 <code>initialDelay</code>，第二次为 <code>initialDelay + period</code>，第三次为 <code>initialDelay + period + period</code>，以此类推。</li>
<li><strong>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按指定的 <em>delay</em> 延期性的执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，每次任务需要耗时 <code>T(i)</code>（<strong>i</strong> 为第几次执行任务），那么第一次执行任务的时间点为 <code>initialDelay</code>，第一次完成任务的时间点为 <code>initialDelay + T(1)</code>，则第二次执行任务的时间点为 <code>initialDelay + T(1) + delay</code>；第二次完成任务的时间点为 <code>initialDelay + (T(1) + delay) + T(2)</code>，所以第三次执行任务的时间点为 <code>initialDelay + T(1) + delay + T(2) + delay</code>，以此类推。</li>
</ul>
<p>简单解释下 scheduleAtFixedRate 和 scheduleWithFixedDelay，前者会开始执行为起始点，如果任务耗时超过了间隔时间，那么在任务完成候第二次会很快（<del>马上</del>）执行，而后者会等待任务执行完后才开始计算周期间隔时间。<br>创建线程池的方式也与上面差不多，都有对应的方法：<br><strong>Executors.newScheduledThreadPool(int corePoolSize)</strong><br><strong>Executors.newSingleThreadScheduledExecutor()</strong></p>
<p>Apache 的 BasicThreadFactory 或许会更好….待进一步研究</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><code>ScheduledFuture</code> 接口 继承自 <code>Future</code> 接口，所以 <code>ScheduledFuture</code> 和任务的交互方式与 <code>Future</code> 一致。所以通过<code>ScheduledFuture</code>，可以 判断定时任务是否已经完成，获得定时任务的返回值，或者取消任务等<br>关于 <code>Future</code> 后面应该会再进行补充<br>可以先看一下：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这个很简单，没什么好说的，简单说就是构造函数的私有化，然后定义一个本类类型的静态变量，通过静态方法进行提供<br>需要注意的是，静态变量的初始化时机，比较一致的观点是：如果你确定这个类肯定要用，那么可以在定义静态变量的时候就直接进行实例化，否则可以放在静态方法中进行实例化（这样会有线程安全问题）比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton is = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是获取的时候实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">    is = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，单例模式需要注意的也就是这里了：<strong>线程安全问题</strong><br>如果你选择了在静态方法中进行实例化，并且使用了多线程技术，那么极有可能它并不是单例的；原因我想大概都知道，当然也有相应的解决方案，一般就从这三种中进行选择：</p>
<ul>
<li><p>同步方法<br>这是最简单的方式，如果不考虑性能的情况下是可以使用的，使用同步就意味着可能造成执行效率下降100倍<br><code>public static synchronized getInstance(){}</code></p>
</li>
<li><p>急切实例化<br>这个就是上面的第一种方式，在定义的时候就直接实例化<br>在创建运行时负担不重的情况下可以采用</p>
</li>
<li><p>双重检查加锁<br>在同步方法中我们发现，其实只需要第一次加锁就可以了，因为第一次创建出 is 后后面都是直接返回的<br>所以，可以进行下面的优化（java5+）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton is;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Test&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">          is = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以大大减少 get 方法的时间消耗，如果确实不考虑性能，使用这个就有点大材小用了。</p>
<blockquote>
<p>这个方法表面上看起来很完美，你只需要付出一次同步块的开销，但它依然有问题。<br>除非你声明 is 变量时使用了 volatile 关键字。没有 volatile 修饰符，可能出现 Java 中的另一个线程看到个初始化了一半的 is 的情况，但使用了 volatile 变量后，就能保证先行发生关系（happens-before relationship）<br>参考下面的：无序写入</p>
</blockquote>
</li>
<li><p>静态内部类<br>这也是一种懒汉式的实现，相比双重锁检查，更简单，更高效吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonIniti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonIniti</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonIniti INSTANCE = newSingletonIniti();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonIniti <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>并且外部类可以访问内部类的 private 方法。</p>
</li>
</ul>
<p>单例模式的使用情景并不是太多，并且如果程序有多个类加载器，还是会造成有多个实例的情况，所以如果用到了多个类加载器记得指定使用同一个类加载器</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>关于这个，确实不太常见，很多人以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。<br>Java 语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制。</p>
<p>对于 synchronized 我们都知道：<br>通过 synchronized 关键字来实现，所有加上 synchronized 和块语句，在多线程访问的时候，同一时刻只能有一个线程能够用 synchronized 修饰的方法 或者 代码块。<br><strong>用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。</strong></p>
<blockquote>
<p>在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是 jvm 虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候<strong>变量值信息</strong>。<br>当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值 load 到线程本地内存中，建立一个变量副本，<strong>之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值</strong>，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。<br>这样在堆中的对象的值就产生变化了。</p>
<p>原文：<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p>
</blockquote>
<p>从上面的解释也可以看出 volatile 并不能保证原子性，它的作用就是在每次<strong>使用的时候</strong>获取最新的值</p>
<h2 id="无序写入"><a href="#无序写入" class="headerlink" title="无序写入"></a>无序写入</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong><br><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong><br>关键原因就是： <code>instance = new Singleton();</code> 不是原子操作。<br>然后从两个方面来看原因：</p>
<ul>
<li>有序性：是因为 instance = new Singleton(); 不是原子操作。编译器存在指令重排，从而存在线程1 创建实例后（初始化未完成），线程2 判断对象不为空，但实际对象扔为空，造成错误。</li>
<li>可见性：是因为线程1 创建实例后还只存在自己线程的工作内存，未更新到主存。线程 2 判断对象为空，创建实例，从而存在多实例错误。</li>
</ul>
<p>也就是，要想保证安全，必须保证这句代码的有序性和可见性。<br><strong>volatile 对 singleton 的创建过程的重要性：禁止指令重排序（有序性）。</strong><br>实例化一个对象其实可以分为三个步骤：</p>
<ol>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ol>
<p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p>
<ol>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ol>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。<br>因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量，volatile 的禁止重排序保证了操作的有序性。<br>除了这种方案，还有人提出在“构造对象”和“连接引用与实例”之间加上一道内存屏障来保证有序性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//构造与赋值之间随意做点事情保证顺序</span></span><br><span class="line">temp.toString();</span><br><span class="line">instance=temp;</span><br></pre></td></tr></table></figure>
<p>这想法确实 nice~</p>
<hr>
<p>关于可见性，第二次非 null 判断是在加锁以后（也就是说后面的线程在获取锁以后判断 instance 是否为 null 必然是在第一个线程引用赋值完成释放锁以后），则根据这一条，另一个线程一定能看到这个引用被赋值。所以即使没有 volatile，依旧能保证可见性。</p>
<p><a href="https://www.zhihu.com/question/56606703" target="_blank" rel="noopener">https://www.zhihu.com/question/56606703</a></p>
<p>PS：据说因为 JVM 的实现不同，volatile 未必能保证绝对的安全，在 HotSpot 应该是没问题的。</p>
<h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-blocking-queue</a><br><a href="http://blog.csdn.net/xiaohulunb/article/details/38932923" target="_blank" rel="noopener">http://blog.csdn.net/xiaohulunb/article/details/38932923</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a><br><a href="https://segmentfault.com/a/1190000008038848" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008038848</a><br><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">https://blog.csdn.net/chenchaofuck1/article/details/51702129</a><br>拓展：<br><a href="http://www.jianshu.com/p/925dba9f5969" target="_blank" rel="noopener">http://www.jianshu.com/p/925dba9f5969</a><br><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>喜欢就请我吃包辣条吧！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Kerronex
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://sakanoy.com/2017/12/21/JavaSE二周目计划（二）/" title="JavaSE二周目计划（二）">https://sakanoy.com/2017/12/21/JavaSE二周目计划（二）/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
            <a href="/tags/线程池/" rel="tag"><i class="fa fa-tag"></i> 线程池</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/28/JavaSE二周目计划/" rel="next" title="JavaSE二周目计划">
                <i class="fa fa-chevron-left"></i> JavaSE二周目计划
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/03/Java定时任务调度工具/" rel="prev" title="Java定时任务调度工具">
                Java定时任务调度工具 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        
          <p class="warninginfo">
            <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
              评论框加载失败，无法访问 Disqus<br><br>
              你可能需要魔法上网~~
          </p>

      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/image/tx.png"
               alt="Kerronex" />
          <p class="site-author-name" itemprop="name">Kerronex</p>
           
              <p class="site-description motion-element" itemprop="description">程序猿/二刺螈<br/>夜猫族/爱折腾</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">130</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope-o"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://sakanoy.com/MyRecord/#/" target="_blank" title="笔记本">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  笔记本
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cnblogs.com/bfchengnuo" target="_blank" title="博客园">
                  
                    <i class="fa fa-fw fa-paw"></i>
                  
                  博客园
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              小伙伴们~
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#日期处理"><span class="nav-number">1.</span> <span class="nav-text">日期处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于队列"><span class="nav-number">2.</span> <span class="nav-text">关于队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于阻塞队列"><span class="nav-number">2.1.</span> <span class="nav-text">关于阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue接口"><span class="nav-number">2.2.</span> <span class="nav-text">BlockingQueue接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue类"><span class="nav-number">2.3.</span> <span class="nav-text">PriorityQueue类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞队列"><span class="nav-number">2.4.</span> <span class="nav-text">非阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列的操作"><span class="nav-number">2.5.</span> <span class="nav-text">队列的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">3.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义的方法"><span class="nav-number">3.1.</span> <span class="nav-text">定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的状态"><span class="nav-number">3.2.</span> <span class="nav-text">线程池的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的创建-amp-使用"><span class="nav-number">3.3.</span> <span class="nav-text">线程池的创建&amp;使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置线程池"><span class="nav-number">3.4.</span> <span class="nav-text">配置线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时任务"><span class="nav-number">4.</span> <span class="nav-text">定时任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">4.1.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式"><span class="nav-number">5.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字"><span class="nav-number">6.</span> <span class="nav-text">volatile关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无序写入"><span class="nav-number">7.</span> <span class="nav-text">无序写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考-amp-拓展"><span class="nav-number">8.</span> <span class="nav-text">参考&amp;拓展</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>
    <div style="height: 370px;background-image: url(/image/bj.png);background-repeat: no-repeat; margin-left: 31%;"></div>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
<span id="sitetime"></span>
<span class="my-face">(●'◡'●)ﾉ♥</span>
<script language=javascript>
function siteTime(){
window.setTimeout("siteTime()", 1000);
var seconds = 1000
var minutes = seconds * 60
var hours = minutes * 60
var days = hours * 24
var years = days * 365

var today = new Date()
var todayYear = today.getFullYear()
var todayMonth = today.getMonth()
var todayDate = today.getDate()
var todayHour = today.getHours()
var todayMinute = today.getMinutes()
var todaySecond = today.getSeconds()

/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) 
year - 作为date对象的年份，为4位年份值
month - 0-11之间的整数，做为date对象的月份
day - 1-31之间的整数，做为date对象的天数
hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
minutes - 0-59之间的整数，做为date对象的分钟数
seconds - 0-59之间的整数，做为date对象的秒数
microseconds - 0-999之间的整数，做为date对象的毫秒数 */
var t1 = Date.UTC(2016,3,30,8,0,0)
var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond)
var diff = t2-t1

var diffYears = Math.floor(diff/years)
var diffDays = Math.floor((diff/days)-diffYears*365)
var diffDaysAll = Math.floor(diff/days)
var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours)
var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes)
var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds)
document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+diffDaysAll+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒 "
}
siteTime()
</script>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共521.4k字</span>

</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'bfchengnuo';
      var disqus_identifier = '2017/12/21/JavaSE二周目计划（二）/';

      var disqus_title = "JavaSE二周目计划（二）";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":130,"height":170,"hOffset":30,"vOffset":-10},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>
