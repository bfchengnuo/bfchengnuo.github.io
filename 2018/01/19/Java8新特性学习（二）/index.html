<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.0" rel="stylesheet"><meta name="keywords" content="Java,"><link rel="alternate" href="/atom.xml" title="冰封承諾" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0"><meta name="description" content="Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认"><meta name="keywords" content="Java"><meta property="og:type" content="article"><meta property="og:title" content="Java8新特性学习（二）"><meta property="og:url" content="http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/index.html"><meta property="og:site_name" content="冰封承諾"><meta property="og:description" content="Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-01-19T11:27:06.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java8新特性学习（二）"><meta name="twitter:description" content="Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/"><title>Java8新特性学习（二） | 冰封承諾</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-77463916-1","auto"),ga("send","pageview")</script><div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=1259036521&web_id=1259036521" language="JavaScript"></script></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">冰封承諾</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">立于浮华之世,奏响天籁之音.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-mark"><a href="/mark" rel="section"><i class="menu-item-icon fa fa-fw fa-retweet"></i><br>笔记本</a></li><li class="menu-item menu-item-books"><a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书单</a></li><li class="menu-item menu-item-music"><a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>音乐台</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kerronex"><meta itemprop="description" content=""><meta itemprop="image" content="/image/tx.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冰封承諾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java8新特性学习（二）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T19:19:59+08:00">2018-01-19</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span> <span id="/2018/01/19/Java8新特性学习（二）/" class="leancloud_visitors" data-flag-title="Java8新特性学习（二）"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">6,965</span></span></div></header><div class="post-body" itemprop="articleBody"><p>Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。<br>上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。<br>这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认为经常用的就这些了，全部的新特性可以见参考的链接。<a id="more"></a></p><h2 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h2><p>Java 8 用默认方法与静态方法这两个新概念来扩展接口的声明。<br>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，如果接口定义了默认方法，那么必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">  <span class="comment">// may not implement (override) them.</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要实现默认方法 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以覆盖默认方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">  Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line"></span><br><span class="line">  defaulable = DefaulableFactory.create( OverridableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM中，<strong>默认方法的实现是非常高效的</strong>，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的 Java 接口，而同时能够保障正常的编译过程。<br>这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：stream()，parallelStream()，forEach()，removeIf()，……<br>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。</p><h3 id="为什么要有默认方法"><a href="#为什么要有默认方法" class="headerlink" title="为什么要有默认方法"></a>为什么要有默认方法</h3><p>在 java 8 之前，接口与其实现类之间的 <strong>耦合度</strong> 太高了（<strong>tightly coupled</strong>），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。<br>这个 forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类。</p><h3 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h3><p>和其它方法一样，接口默认方法也可以被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写默认方法并将它重新声明为抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceD</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InterfaceB() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceC() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceC foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceD() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InterfaceD foo"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.foo(); <span class="comment">// 打印：“InterfaceD foo”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 lambda 表达式</span></span><br><span class="line">    ((InterfaceD) () -&gt; System.out.println(<span class="string">"InterfaceD foo"</span>)).foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口默认方法的继承分三种情况（分别对应上面的 <code>InterfaceB</code> 接口、<code>InterfaceC</code> 接口和 <code>InterfaceD</code> 接口）：</p><ul><li>不覆写默认方法，直接从父接口中获取方法的默认实现。</li><li>覆写默认方法，这跟类与类之间的覆写规则相类似。</li><li>覆写默认方法并将它重新声明为抽象方法，这样新接口的子类必须再次覆写并实现这个抽象方法。</li></ul><hr><p>然后来考虑下多继承的问题，是的，默认方法在接口里，接口可以继承，接口可以多实现，那么自然就带来了默认方法多继承的问题；但是 Java 使用的是单继承、多实现的机制，为的是避免多继承带来的调用歧义的问题。当接口的子类同时拥有具有相同签名的方法时，就需要考虑一种解决冲突的方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在冲突</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，存在冲突</span></span><br><span class="line"><span class="comment">//class ClassB implements InterfaceB, InterfaceC &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceB 的 bar 方法</span></span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceC 的 bar 方法</span></span><br><span class="line">    System.out.println(<span class="string">"ClassB bar"</span>); <span class="comment">// 做其他的事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ClassB 类中，它实现的 InterfaceB 接口和 InterfaceC 接口中都存在相同签名的 foo 方法，需要手动解决冲突。覆写存在歧义的方法，并可以使用 <code>InterfaceName.super.methodName();</code> 的方式手动调用需要的接口默认方法。</p><hr><p>下面来看特殊情况：接口继承行为发生冲突时的解决规则。<br>比如，出现了下面的这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        InterfaceA.super.foo(); // 错误</span></span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 InterfaceB 接口继承了 InterfaceA 接口，那么 InterfaceB 接口一定包含了所有 InterfaceA 接口中的字段方法，因此一个同时实现了 InterfaceA 接口和 InterfaceB 接口的类与一个只实现了 InterfaceB 接口的类完全等价。<br>这很好理解，就相当于 <code>class SimpleDateFormat extends DateFormat</code> 与 <code>class SimpleDateFormat extends DateFormat</code>, Object 等价（如果允许多继承）。<br>而覆写意味着对父类方法的屏蔽，这也是 <strong>Override</strong> 的设计意图之一。因此在实现了 InterfaceB 接口的类中无法访问已被覆写的 InterfaceA 接口中的 foo 方法。<br>这是当接口继承行为发生冲突时的规则之一，即 <strong>被其它类型所覆盖的方法会被忽略</strong>。<br>如果想要调用 InterfaceA 接口中的 foo 方法，只能通过自定义一个新的接口同样继承 InterfaceA 接口并显示地覆写 foo 方法，在方法中使用 <code>InterfaceA.super.foo();</code> 调用 InterfaceA 接口的 foo 方法，最后让实现类同时实现 InterfaceB 接口和自定义的新接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！ 虽然 InterfaceC 接口的 foo 方法只是调用了一下父接口的默认实现方法，但是这个覆写 <strong>不能省略</strong>，否则 InterfaceC 接口中继承自 InterfaceA 接口的隐式的 foo 方法同样会被认为是被 InterfaceB 接口覆写了而被屏蔽，会导致调用 <code>InterfaceC.super.foo()</code> 时出错。<br>通过这个例子，应该注意到在使用一个默认方法前，一定要考虑它是否真的需要。因为 <strong>默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误</strong>。滥用默认方法可能给代码带来意想不到、莫名其妙的错误。</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>当接口继承行为发生冲突时的另一个规则是，<strong>类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AbstractClassA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassA classA = <span class="keyword">new</span> ClassA();</span><br><span class="line">    classA.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    classA.bar(); <span class="comment">// 打印：“AbstractClassA bar”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassA 类中并不需要手动覆写 bar 方法，因为优先考虑到 ClassA 类继承了的 AbstractClassA 抽象类中存在对 bar 方法的实现，同样的因为 AbstractClassA 抽象类中的 foo 方法是抽象的，所以在 ClassA 类中必须实现 foo 方法。<br>虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 <strong>不可相互代替的</strong>：</p><ul><li>接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。</li><li>接口中没有 <code>this</code> 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 <strong>状态</strong>（<strong>state</strong>），抽象方法中可以。</li><li>抽象类不能在 java 8 的 lambda 表达式中使用。</li><li>从设计理念上，接口反映的是 <strong>“like-a”</strong> 关系，抽象类反映的是 <strong>“is-a”</strong> 关系。</li></ul><p>顺便复习了下接口和抽象类的知识点~~</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>补充下其他的知识点：</p><ul><li><code>default</code> 关键字只能在接口中使用（以及用在 <code>switch</code> 语句的 <code>default</code> 分支），不能用在抽象类中。</li><li>接口默认方法不能覆写 <code>Object</code> 类的 <code>equals</code>、<code>hashCode</code> 和 <code>toString</code> 方法。</li><li>接口中的静态方法必须是 <code>public</code> 的，<code>public</code> 修饰符可以省略，<code>static</code> 修饰符不能省略。</li><li>即使使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依赖 IDE。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>其实就是上篇所说的双冒号操作，不知道还有没有印象，即 <code>目标引用::方法</code> ，下面就来看看具体的几种用法。<br>方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象的方法或构造器。与 lambda 联合使用（一般是不能独立使用的），方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>下面来看看 Java 支持的这四种不同的方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;              </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><p>这四类可以定义为：</p><ol><li>类名::new</li><li>类名::静态方法名</li><li>类名::实例方法名<br>这种方法引用有些特殊之处：当使用这种方式时，<strong>一定是 lambda 表达式所接收的第一个参数来调用实例方法，如果lambda表达式接收多个参数，其余的参数作为方法的参数传递进去。</strong><br>参考：<a href="http://sfau.lt/b5ZD16" target="_blank" rel="noopener">http://sfau.lt/b5ZD16</a></li><li>对象::实例方法名</li></ol><p>下面就来解释下上面例子里的四种方式，说的都是在本例的情况下。<br>第一种方法引用是构造器引用，它的语法是 <code>Class::new</code>，或者更一般的 <code>Class&lt; T &gt;::new</code>。new 不就是调用构造函数嘛~请注意构造器没有参数。<br>第二种方法引用是静态方法引用，它的语法是 <code>Class::static_method</code> ，请注意这个方法接受一个 Car 类型的参数。<br>第三种方法引用是特定类的任意对象的方法引用，它的语法是 <code>Class::method</code>。请注意，这个方法没有参数，并且是非静态。<br>最后，第四种方法引用是特定对象的方法引用，它的语法是 <code>instance::method</code>。请注意，这个方法接受一个 Car 类型的参数</p><h2 id="类库新特性"><a href="#类库新特性" class="headerlink" title="类库新特性"></a>类库新特性</h2><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 公司著名的 <strong>Guava</strong> 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。<br>受到 Google Guava 的启发，Optional 类已经成为 Java 8 类库的一部分。<br>Optional 实际上<strong>是个容器</strong>：它可以保存类型 T 的值，或者仅仅保存 null。Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。在 Javadoc 中的描述翻译过来就是：<br><em>这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。</em><br>下面就来看看它的几个方法（在前面说 stream 的时候大量使用了 Optional ）：</p><ul><li>of<br>为<strong>非 null</strong> 的值创建一个 Optional。<br>of 方法通过工厂方法<strong>创建</strong> Optional 类。需要注意的是，创建对象时传入的参数不能为 null。如果传入参数为 null，则抛出 NPE。</li><li>ofNullable<br>为指定的值<strong>创建</strong>一个 Optional，如果指定的值为 null，则返回一个空的 Optional。</li><li>empty<br>此方法用于创建一个没有值的 Optional 对象；如果对 emptyOpt 变量调用 isPresent() 方法会返回 false，调用 get() 方法抛出 NullPointerException 异常。</li><li><strong>isPresent</strong><br>如果值存在返回 true，否则返回 false。</li><li><strong>ifPresent</strong><br>如果 Optional 实例有值则为其调用 consumer（比如 lambda 表达式），否则不做处理</li><li>get<br>如果 Optional 有值则将其返回，否则抛出 NoSuchElementException。</li><li>orElse<br>如果有值则将其返回，否则返回指定的其它值(默认值)。<br><code>empty.orElse(&quot;There is no value present!&quot;);</code></li><li>orElseGet<br>orElseGet 与 orElse 方法类似，区别在于得到的默认值。<br>orElse 方法将传入的字符串作为默认值，orElseGet 方法可以接受 Supplier 接口的实现用来生成默认值。<br><code>empty.orElseGet(() -&gt; &quot;Default Value&quot;);</code></li><li>orElseThrow<br>如果有值则将其返回，否则抛出 supplier 接口创建的异常。<br>在 orElseThrow 中我们可以传入一个 lambda 表达式或方法，如果值不存在来抛出异常。<br><code>empty.orElseThrow(ValueAbsentException::new);</code></li><li>map<br>如果有值，则对其执行调用 mapping 函数得到返回值。<br>如果返回值不为 null，则创建包含 mapping 返回值的 Optional 作为 map 方法返回值，否则返回空 Optional。<br><code>Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</code></li><li>flatMap<br>如果有值，为其执行 mapping 函数返回 Optional 类型返回值，否则返回空 Optional。<br>flatMap 与 map（Funtion）方法类似，区别在于 flatMap 中的 mapper 返回值必须是 Optional。<br>调用结束时，flatMap 不会对结果用 Optional 封装。<br><code>upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</code></li><li>filter<br>如果有值并且满足断言条件返回包含该值的 Optional，否则返回空 Optional。<br>对于 filter 函数我们应该传入实现了 Predicate 接口的 lambda 表达式。<br><code>Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6);</code></li></ul><blockquote><p>要理解 ifPresent 方法，首先需要了解 Consumer 类。<br>简答地说，Consumer 类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。<br>Java8 支持不用接口直接通过 lambda 表达式传入参数。</p></blockquote><p>在 Java 9 中，对 Optional 还进行了增强，多加了几个方法，感兴趣的可以去：<a href="http://sfau.lt/b5KDt8" target="_blank" rel="noopener">http://sfau.lt/b5KDt8</a><br>最后通过一个例子来综合的展示下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Sanaulla"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">"There is some value!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"Sana"</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 提倡函数式编程，新增的许多 API 都可以用函数式编程表示，<code>Optional</code>类也是其中之一。这里有几条关于<code>Optional</code>使用的建议：</p><ol><li>尽量避免在程序中直接调用<code>Optional</code>对象的<code>get()</code>和<code>isPresent()</code>方法(活用 orElse 系列)；</li><li>避免使用<code>Optional</code>类型声明实体类的属性；</li></ol><p>第一条建议中直接调用<code>get()</code>方法是很危险的做法，如果<code>Optional</code>的值为空，那么毫无疑问会抛出 NPE 异常，而为了调用<code>get()</code>方法而使用<code>isPresent()</code>方法作为空值检查，这种做法与传统的用 if 语句块做空值检查没有任何区别。<br>第二条建议避免使用 Optional 作为实体类的属性，它在设计的时候就没有考虑过用来作为类的属性，如果你查看 Optional 的源代码，你会发现它没有实现 <code>java.io.Serializable</code> 接口，这在某些情况下是很重要的（比如你的项目中使用了某些序列化框架），使用了 Optional 作为实体类的属性，意味着他们不能被序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">  <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 if-else</span></span><br><span class="line">User user = ...</span><br><span class="line">  Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user.map(User::getUserName)</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>当你很确定一个对象不可能为 null 的时候，应该使用 <code>of()</code> 方法，否则，尽可能使用 <code>ofNullable()</code> 方法</p><h3 id="新的时间和日期API"><a href="#新的时间和日期API" class="headerlink" title="新的时间和日期API"></a>新的时间和日期API</h3><p>Java 8 另一个新增的重要特性就是引入了新的时间和日期 API，它们被包含在 <code>java.time</code> 包中。借助新的时间和日期 API 可以以更简洁的方法处理时间和日期。<br>在 Java 8 之前，所有关于时间和日期的 API 都存在各种使用方面的缺陷，主要有：</p><ol><li>Java 的 <code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，并且是可变的，也就意味着他们都不是线程安全的；</li><li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个 SimpleDateFormat 对象来处理日期格式化，并且 DateFormat 也是非线程安全，这意味着如果你在多线程程序中调用同一个 DateFormat 对象，会得到意想不到的结果。</li><li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，这意味着从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li></ol><p>由于以上这些问题，出现了一些三方的日期处理框架，例如 <strong>Joda-Time</strong>，data4j 等开源项目。<br>但是，Java 需要一套标准的用于处理时间和日期的框架，于是 Java 8 中引入了新的日期 API。新的日期 API 是 <a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">JSR-310</a> 规范的实现，Joda-Time 框架的作者正是 JSR-310 的规范的倡导者，所以能从 Java 8 的日期 API 中看到很多 Joda-Time 的特性。<br>常用的几个类就是 LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration 等.<br>下面通过几个示例代码来快速学会使用新版的日期时间 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Today's Local date : "</span> + today); <span class="comment">// 2014-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="keyword">int</span> year = today.getYear();</span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue();</span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth();</span><br><span class="line">System.out.printf(<span class="string">"Year : %d  Month : %d  day : %d t %n"</span>, year, month, day);</span><br><span class="line"><span class="keyword">int</span> length = today.lengthOfMonth();  <span class="comment">// 月份的天数</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = today.isLeapYear();  <span class="comment">// 是否为闰年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理特定日期（只需要传入年月日）</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">"Your Date of birth is : "</span> + dateOfBirth); <span class="comment">//  2010-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否相等</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span>(date1.equals(today))&#123;</span><br><span class="line">  System.out.printf(<span class="string">"Today %s and date1 %s are same date %n"</span>, today, date1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查像生日这种周期性事件,类似的还有 YearMonth</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">MonthDay currentMonthDay = MonthDay.from(today);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Many Many happy returns of the day !!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Sorry, today is not your birthday"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间（这次不是日期是时间）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"local time now : "</span> + time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期和时间，还可以进行拼接，或者 toLocalDate 拆分</span></span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间的操作（因为是不可变对象，所以操作后的是新实例）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">LocalTime newTime = time.plusHours(<span class="number">2</span>); <span class="comment">// adding two hours</span></span><br><span class="line">System.out.println(<span class="string">"Time after 2 hours : "</span> +  newTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期的操作，通过 withMonth 等方法可修改指定日期</span></span><br><span class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);  <span class="comment">// 可处理天，周，月</span></span><br><span class="line">System.out.println(<span class="string">"Today is : "</span> + today);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 week : "</span> + nextWeek);</span><br><span class="line"></span><br><span class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS);  <span class="comment">// 处理年</span></span><br><span class="line">System.out.println(<span class="string">"Date before 1 year : "</span> + previousYear);</span><br><span class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, YEARS);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 year : "</span> + nextYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否早于或者晚于一个日期</span></span><br><span class="line">LocalDate tomorrow = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">if</span>(tommorow.isAfter(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Tomorrow comes after today"</span>);</span><br><span class="line">&#125;</span><br><span class="line">LocalDate yesterday = today.minus(<span class="number">1</span>, DAYS);</span><br><span class="line"><span class="keyword">if</span>(yesterday.isBefore(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Yesterday is day before today"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理时区</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">LocalDateTime localtDateAndTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );</span><br><span class="line">System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + dateAndTimeInNewYork);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个日期之间的天数和月数</span></span><br><span class="line">LocalDate java8Release = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">14</span>);</span><br><span class="line">Period periodToNextJavaRelease = Period.between(today, java8Release);</span><br><span class="line">System.out.println(<span class="string">"Months left between today and Java 8 release : "</span></span><br><span class="line">                   + periodToNextJavaRelease.getMonths() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);  <span class="comment">// 第一个参数秒，第二个纳秒</span></span><br><span class="line">System.out.println(<span class="string">"What is value of this instant "</span> + timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化工具，第一个为字符串转日期，第二个日期转字符串</span></span><br><span class="line">String goodFriday = <span class="string">"Apr 18 2014"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);</span><br><span class="line">  LocalDate holiday = LocalDate.parse(goodFriday, formatter);</span><br><span class="line">  System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocalDateTime arrivalDate  = LocalDateTime.now();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy  hh:mm a"</span>);</span><br><span class="line">  String landing = arrivalDate.format(format);</span><br><span class="line">  System.out.printf(<span class="string">"Arriving at :  %s %n"</span>, landing);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所用的 API 大部分都是不可变的，也就是说是线程安全的，可放心食用！<br>Instant 用于表示一个时间戳，它与我们常使用的 <code>System.currentTimeMillis()</code> 有些类似，不过 Instant 可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code> 方法只精确到毫秒（Milli-Second）。<br>类似的还有 Duration、Period 它们通过 between 方法来确定一段时间。</p><h3 id="Base64的API"><a href="#Base64的API" class="headerlink" title="Base64的API"></a>Base64的API</h3><p>在 JDK1.6 之前，JDK 核心类一直没有 Base64 的实现类，有人建议用 Sun/Oracle JDK 里面的 <code>sun.misc.BASE64Encoder</code> 和 <code>sun.misc.BASE64Decoder</code>，使用它们的优点就是不需要依赖第三方类库，缺点就是可能在未来版本会被删除（用 maven 编译会发出警告），而且性能不佳，性能测试见最后的参考链接。<br>JDK1.6 中添加了另一个 Base64 的实现，<code>javax.xml.bind.DatatypeConverter</code> 两个静态方法 parseBase64Binary 和 printBase64Binary，隐藏在 <code>javax.xml.bind</code> 包下面，不被很多开发者知道。<br>在 Java 8 在 <code>java.util</code> 包下面实现了 BASE64 编解码 API，而且性能不俗，API 也简单易懂，下面展示下这个类的使用例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic编码：是标准的BASE64编码，用于处理常规的需求 */</span></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">String asB64 = Base64.getEncoder().encodeToString(<span class="string">"some string"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(asB64); <span class="comment">// 输出为: c29tZSBzdHJpbmc=</span></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">byte</span>[] asBytes = Base64.getDecoder().decode(<span class="string">"c29tZSBzdHJpbmc="</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(asBytes, <span class="string">"utf-8"</span>)); <span class="comment">// 输出为: some string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* URL编码：使用下划线替换URL里面的反斜线“/”  */</span></span><br><span class="line">String urlEncoded = Base64.getUrlEncoder().encodeToString(<span class="string">"subjects?abcd"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(<span class="string">"Using URL Alphabet: "</span> + urlEncoded);</span><br><span class="line"><span class="comment">// 输出为: Using URL Alphabet: c3ViamVjdHM_YWJjZA==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIME编码：使用基本的字母数字产生BASE64输出，而且对MIME格式友好：每一行输出不超过76个字符，而且每行以“\r\n”符结束。 */</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">10</span>; ++t) &#123;</span><br><span class="line">  sb.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] toEncode = sb.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);</span><br><span class="line">System.out.println(mimeEncoded);</span><br></pre></td></tr></table></figure><p>之前我们常用的第三方工具有：<br>Apache Commons Codec library 里面的 <code>org.apache.commons.codec.binary.Base64</code> ；<br>Google Guava 库里面的 <code>com.google.common.io.BaseEncoding.base64()</code> 这个静态方法；<br><code>net.iharder.Base64</code> ，这个 jar 包就一个类；<br>号称 Base64 编码速度最快的 MigBase64，而且是 10 年前的实现.<br>关于他们之间的性能测试去参考里面的最后一个链接查看，总之，用 Java 8 自带的就足足够了！</p><h2 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h2><p>PermGen 空间被移除了，取而代之的是 Metaspace（JEP 122）。<br>JVM 选项 <code>-XX:PermSize</code> 与 <code>-XX:MaxPermSize</code> 分别被 <code>-XX:MetaSpaceSize</code> 与 <code>-XX:MaxMetaspaceSize</code> 所代替。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://ebnbin.com/2015/12/20/java-8-default-methods/" target="_blank" rel="noopener">http://ebnbin.com/2015/12/20/java-8-default-methods/</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">http://www.importnew.com/11908.html</a><br><a href="http://www.importnew.com/6675.html" target="_blank" rel="noopener">http://www.importnew.com/6675.html</a><br><a href="http://www.importnew.com/15637.html" target="_blank" rel="noopener">http://www.importnew.com/15637.html</a><br><a href="https://lw900925.github.io/java/java8-newtime-api.html" target="_blank" rel="noopener">https://lw900925.github.io/java/java8-newtime-api.html</a><br><a href="http://www.importnew.com/14961.html" target="_blank" rel="noopener">http://www.importnew.com/14961.html</a></p></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>喜欢就请我吃包辣条吧！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kerronex</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/" title="Java8新特性学习（二）">http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/</a></li><li class="post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/01/17/Java8新特性学习/" rel="next" title="Java8新特性学习"><i class="fa fa-chevron-left"></i> Java8新特性学习</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/01/29/MongoDB学习笔记/" rel="prev" title="MongoDB学习笔记">MongoDB学习笔记<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><p class="warninginfo"><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> 评论框加载失败，无法访问 Disqus<br><br>你可能需要魔法上网~~</p></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/image/tx.png" alt="Kerronex"><p class="site-author-name" itemprop="name">Kerronex</p><p class="site-description motion-element" itemprop="description">萝莉控/程序猿<br>夜猫族/不擅长社交</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">118</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope-o"></i> Email</a></span><span class="links-of-author-item"><a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 小伙伴们~</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a></li><li class="links-of-blogroll-item"><a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a></li><li class="links-of-blogroll-item"><a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a></li><li class="links-of-blogroll-item"><a href="https://bfchengnuo.com/MyRecord/#/" title="学习笔记本" target="_blank">学习笔记本</a></li><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/bfchengnuo" title="博客园" target="_blank">博客园</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的默认方法与静态方法"><span class="nav-number">1.</span> <span class="nav-text">接口的默认方法与静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有默认方法"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要有默认方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于继承"><span class="nav-number">1.2.</span> <span class="nav-text">关于继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与抽象类"><span class="nav-number">1.3.</span> <span class="nav-text">接口与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">1.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">2.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类库新特性"><span class="nav-number">3.</span> <span class="nav-text">类库新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional"><span class="nav-number">3.1.</span> <span class="nav-text">Optional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的时间和日期API"><span class="nav-number">3.2.</span> <span class="nav-text">新的时间和日期API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64的API"><span class="nav-number">3.3.</span> <span class="nav-text">Base64的API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM新特性"><span class="nav-number">4.</span> <span class="nav-text">JVM新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div></div></section></div></aside></div></main><div style="height:370px;background-image:url(/image/bj.png);background-repeat:no-repeat;margin-left:31%"></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span id="sitetime"></span> <span class="my-face">(●'◡'●)ﾉ♥</span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth(),n=o.getDate(),r=o.getHours(),l=o.getMinutes(),M=o.getSeconds(),s=Date.UTC(2016,3,30,8,0,0),f=Date.UTC(i,a,n,r,l,M)-s,g=Math.floor(f/31536e6),h=Math.floor(f/t-365*g),m=Math.floor(f/t),T=Math.floor((f-(365*g+h)*t)/e),u=Math.floor((f-(365*g+h)*t-T*e)/6e4),d=Math.floor((f-(365*g+h)*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+m+" 天 "+T+" 小时 "+u+" 分钟 "+d+" 秒 "}siteTime()</script></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共426.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/affix.js?v=5.1.0"></script><script src="/js/src/schemes/pisces.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname="bfchengnuo",disqus_identifier="2018/01/19/Java8新特性学习（二）/",disqus_title="Java8新特性学习（二）";function run_disqus_script(e){var s=document.createElement("script");s.type="text/javascript",s.async=!0,s.src="//"+disqus_shortname+".disqus.com/"+e,(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(s)}var disqus_config=function(){this.page.url=disqus_url,this.page.identifier=disqus_identifier,this.page.title=disqus_title};run_disqus_script("embed.js")</script><script>var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="/js/src/av-core-mini-0.6.4.js"></script><script>AV.initialize("aztA5nbwUsfTeQsa7DqnqgfF-gzGzoHsz","ri0v7p5gusNlBUnLU3A3Tq3t")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/src/particle.js"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script src="/live2d/device.min.js"></script><script>const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script></body></html>