<!doctype html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="//fonts.googleapis.com/css?family=Microsoft Yahei:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.0" rel="stylesheet"><meta name="keywords" content="Java,Spring,安全,"><link rel="alternate" href="/atom.xml" title="冰封承諾" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/image/tb.png?v=5.1.0"><meta name="description" content="这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关"><meta name="keywords" content="Java,Spring,安全"><meta property="og:type" content="article"><meta property="og:title" content="SpringSecurity笔记"><meta property="og:url" content="http://bfchengnuo.com/2019/11/24/SpringSecurity笔记/index.html"><meta property="og:site_name" content="冰封承諾"><meta property="og:description" content="这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://bfchengnuo.com/image/SpringSecurity基本原理.png"><meta property="og:image" content="http://bfchengnuo.com/image/表单认证原理.png"><meta property="og:image" content="http://bfchengnuo.com/image/记住我原理.png"><meta property="og:image" content="http://bfchengnuo.com/image/social流程.png"><meta property="og:image" content="http://bfchengnuo.com/image/SpringSecurityOAuth.png"><meta property="og:image" content="http://bfchengnuo.com/image/SpringSecurityOAuth原理.png"><meta property="og:image" content="http://bfchengnuo.com/image/SE授权.png"><meta property="og:updated_time" content="2019-11-23T13:38:51.877Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="SpringSecurity笔记"><meta name="twitter:description" content="这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关"><meta name="twitter:image" content="http://bfchengnuo.com/image/SpringSecurity基本原理.png"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!1,duoshuo:{userId:"undefined",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://bfchengnuo.com/2019/11/24/SpringSecurity笔记/"><title>SpringSecurity笔记 | 冰封承諾</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-77463916-1","auto"),ga("send","pageview")</script><div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=1259036521&web_id=1259036521" language="JavaScript"></script></div><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">冰封承諾</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">立于浮华之世,奏响天籁之音.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-mark"><a href="/mark" rel="section"><i class="menu-item-icon fa fa-fw fa-retweet"></i><br>笔记本</a></li><li class="menu-item menu-item-books"><a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>书单</a></li><li class="menu-item menu-item-music"><a href="/music" rel="section"><i class="menu-item-icon fa fa-fw fa-music"></i><br>音乐台</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://bfchengnuo.com/2019/11/24/SpringSecurity笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kerronex"><meta itemprop="description" content=""><meta itemprop="image" content="/image/tx.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冰封承諾"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SpringSecurity笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-24T16:06:36+08:00">2019-11-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span> <span id="/2019/11/24/SpringSecurity笔记/" class="leancloud_visitors" data-flag-title="SpringSecurity笔记"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span> <span class="post-meta-divider">|</span><span class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计</span> <span title="字数统计">8,736</span></span></div></header><div class="post-body" itemprop="articleBody"><p>这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关，SSO 相关的提了一下，看完之后不是问题。<a id="more"></a></p><p>这篇笔记基于慕课上的一门课，个人认为还是不错的，反反复复看了好几遍，先跟着写了一遍，当然不是完全的照抄，对基础框架做了一点升级和自己的一些处理，之后发现内容太多，决定从头再来一遍，并且整理成这篇笔记。</p><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>这一次我使用的版本是 SB2.x，集成 SpringSecurity 就不需要多说了，一个 starter 搞定，然后它的默认配置会将所有的接口保护起来，使用 http basic 来认证。</p><blockquote><p>需要注意的是：<code>security.basic.enabled</code> 在 SB2.x 被废弃，如果需要禁用 SpringSecurity 请使用 exclude 的方式进行排除，例如:<br><code>@SpringBootApplication(exclude = {SecurityAutoConfiguration.class, ManagementWebSecurityAutoConfiguration.class})</code></p></blockquote><p>接下来就是如何配置了，首先我们可以新建一个 java config 类，继承 WebSecurityConfigurerAdapter 这个适配器类，然后覆盖它的方法，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPasswordAuthenticationConfig</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 使用表单登陆</span></span><br><span class="line">  http.formLogin()</span><br><span class="line">    <span class="comment">// 跳转认证的页面(默认 /login)</span></span><br><span class="line">    .loginPage(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL)</span><br><span class="line">    <span class="comment">// 进行认证的请求地址（UsernamePasswordAuthenticationFilter）</span></span><br><span class="line">    .loginProcessingUrl(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM)</span><br><span class="line">    <span class="comment">// 自定义登陆成功、失败后的处理逻辑</span></span><br><span class="line">    .successHandler(authenticationSuccessHandler)</span><br><span class="line">    .failureHandler(authenticationFailureHandler)</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// 设置授权要求</span></span><br><span class="line">    .authorizeRequests()</span><br><span class="line">    .antMatchers(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL, <span class="string">"/user/register"</span>)</span><br><span class="line">    <span class="comment">// 以上匹配不需要认证</span></span><br><span class="line">    .permitAll()</span><br><span class="line">    <span class="comment">// 其他请求需要进行认证</span></span><br><span class="line">    .anyRequest()</span><br><span class="line">    .authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们来说一下 SpringSecurity 的原理，其实也不难猜，肯定是通过 Filter 实现的，它也确实是通过一组 Filter 链来做的，首先来看一下这个图：</p><p><img src="/image/SpringSecurity基本原理.png" alt="SpringSecurity基本原理"></p><p>很显然，UsernamePasswordAuthenticationFilter 这个过滤器就是来处理表单登陆的相关请求，BasicAuthenticationFilter 那就是来处理 http basic 登陆的相关请求；例如你使用表单提交，UsernamePasswordAuthenticationFilter 会从请求中拿到用户名密码，然后去做登陆校验，如果成功则标记为已认证（通过一个过滤器链的共享变量）；如果拿不到用户名密码就放行，进入到下一个过滤器再做其他方式的登陆校验。<br>过滤链的最后一环是 FilterSecurityInterceptor，它通过那个标志位来判断前面是否已经通过了身份认证，然后根据我们 config 中配置的规则，来控制允不允许访问；如果不过，它会根据不同的原因来抛出不同的异常。<br>那么，在 FilterSecurityInterceptor 前面的 ExceptionTranslationFilter 就是来接受它抛出的异常，然后根据不同类型的异常做出不同的处理，例如未登录的异常会根据前面的配置来引导用户进行登陆。<br>PS：其中，绿色部分是我们可以控制是否开启的。</p><h3 id="自定义用户认证"><a href="#自定义用户认证" class="headerlink" title="自定义用户认证"></a>自定义用户认证</h3><p>拿到用户名密码后，如何判断是否是合法用户呢，这个需求每一个业务系统可能都不一样，所以肯定是可以自定义的，这个过程被抽象成了一个接口叫做 <strong>UserDetailsService</strong>，我们新建一个类，然后实现这个接口（只有一个需要实现的方法 loadUserByUsername），在这个方法中，我们可以拿到请求中的用户名，根据这个用户名如何获取用户信息就全靠我们自己了，使用 Mybatis 的 mapper 或者 JPA，最终只要返回一个 UserDetails 对象即可。<br>说起 UserDetails 对象，我们既可以用 SpringSecurity 的默认实现 User，也可以继承 User 后进行增强，以默认的 User 对象来说，它有几个构造方法，满足我们日常的账号是否禁用、是否锁定、是否过期等等需求。<br>它的判断逻辑也非常简单，你根据用户输入的用户名获取 UserDetails 对象并且返回，SpringSecurity 拿着你返回的这个对象中的秘密与用户输入的密码进行比对，如果错误则抛出用户名或密码错误的异常，如果这个对象的是否锁定为 true，则抛出用户已锁定的异常。<br>最后的一个参数是权限，这个放在后面的鉴权里面说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span>, <span class="title">SocialUserDetailsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// BCryptPasswordEncoder 每次生成的会不一样，应该在注册的时候保存，这里直接拿数据库保存的</span></span><br><span class="line">    String pwd = passwordEncoder.encode(<span class="string">"123123"</span>);</span><br><span class="line">    System.out.println(<span class="string">"PWD："</span> + pwd);</span><br><span class="line">    <span class="comment">// 简单实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(username, pwd,</span><br><span class="line">                    AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin,ROLE_USER"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于密码的处理，这里使用了 BCryptPasswordEncoder，一般情况下，我们数据库中不可能存储明文密码，SpringSecurity 自然也考虑到了，所以它搞出来了个 PasswordEncoder 接口，这个接口主要定义了两个方法，一个是来处理原始密码的 encode，一个是来比较密码的 matches，你可以自己实现，也可以用它提供的几种，例如 BCryptPasswordEncoder。</p><blockquote><p>这里稍微说下 BCryptPasswordEncoder，它根据 hash + salt 的方式生成密码，特点是即使是相同的密码，每次经过它编码后秘文是不一样的！但是他们 matches 后的结果会是 true，提高了安全性。</p></blockquote><h3 id="自定义认证界面"><a href="#自定义认证界面" class="headerlink" title="自定义认证界面"></a>自定义认证界面</h3><p>我们最常用的就是表单认证，至于前端样式，肯定是各不相同，下面就来说如何自定义。<br>然而最开始的配置里已经剧透了，就是通过 <code>http.loginPage()</code> 来指定登陆的 URL，然后你写你的 html 前端就行了，如果要兼容其他客户端例如 App，你可以写一个 Controller 来判断是不是请求的 html，来确定是返回 html 还是 json；最后只需要记得别忘了把这个地址放到白名单中就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SE 在认证时会将原请求缓存进 requestCache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RequestCache requestCache = <span class="keyword">new</span> HttpSessionRequestCache();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RedirectStrategy redirectStrategy = <span class="keyword">new</span> DefaultRedirectStrategy();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当需要身份认证时，执行此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果是浏览器请求，重定向到认证页面；如果是其他返回 401 状态码提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(code = HttpStatus.UNAUTHORIZED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleResponse <span class="title">reqAuth</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  SavedRequest savedRequest = requestCache.getRequest(request, response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (savedRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String redirectUrl = savedRequest.getRedirectUrl();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.endsWithIgnoreCase(redirectUrl, <span class="string">".html"</span>)) &#123;</span><br><span class="line">      redirectStrategy.sendRedirect(request, response, securityProperties.getBrowser().getLoginPage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleResponse(<span class="string">"访问的服务需要授权"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户访问需要授权的接口时，如果检测到未登录，就会重定向到我们配置的登陆页面（浏览器），同时会将 URL 存起来，便于通过认证后再跳转回去，我们通过 RequestCache 这个工具就能拿到 SpringSecurity 存起来的 URL。</p><p>然后通过 <code>http.loginProcessingUrl()</code> 来指定表单的提交地址，也就是真正的后台处理登陆请求的地址，后面就是 UsernamePasswordAuthenticationFilter 那一套了。</p><h3 id="自定义成功和失败Handler"><a href="#自定义成功和失败Handler" class="headerlink" title="自定义成功和失败Handler"></a>自定义成功和失败Handler</h3><p>如何配置前面已经剧透了，想要自定义认证成功或者失败后的逻辑，只需要定义相关的 Handler 即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义登陆失败后处理逻辑</span></span><br><span class="line"><span class="comment"> * 可以实现 &#123;<span class="doctag">@link</span> AuthenticationFailureHandler&#125; 进行自定义；</span></span><br><span class="line"><span class="comment"> * 默认实现： &#123;<span class="doctag">@link</span> SimpleUrlAuthenticationFailureHandler&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by 冰封承諾Andy on 2019/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationFailureHandler</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义登陆成功后的行为，默认为跳转回原来的地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也可以选择实现 &#123;<span class="doctag">@link</span> AuthenticationSuccessHandler&#125; 的方式来定制;</span></span><br><span class="line"><span class="comment"> * 默认规则为 &#123;<span class="doctag">@link</span> SavedRequestAwareAuthenticationSuccessHandler&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by 冰封承諾Andy on 2019/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> SecurityProperties securityProperties;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RequestCache requestCache = <span class="keyword">new</span> HttpSessionRequestCache();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    SavedRequest savedRequest = requestCache.getRequest(httpServletRequest, httpServletResponse);</span><br><span class="line">    String redirectUrl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (savedRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      redirectUrl = savedRequest.getRedirectUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当访问非 html 并且设置为 JSON 类型是返回 JSON 格式用户信息</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.endsWithIgnoreCase(redirectUrl, <span class="string">".html"</span>)</span><br><span class="line">        &amp;&amp; LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) &#123;</span><br><span class="line">      httpServletResponse.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">      httpServletResponse.getWriter().write(objectMapper.writeValueAsString(authentication));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 跳转回原来的 URL</span></span><br><span class="line">      <span class="keyword">super</span>.onAuthenticationSuccess(httpServletRequest, httpServletResponse, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Authentication 对象封装了认证相关的信息，包括我们自定义的 UserDetails 对象，密码相关的敏感信息如果返回到前端会自动进行过滤。</p><h3 id="基于表单的认证流程"><a href="#基于表单的认证流程" class="headerlink" title="基于表单的认证流程"></a>基于表单的认证流程</h3><p>表单方式应该是我们用的最多的，所以就来看看它的处理过程，照例上一张图：</p><p><img src="/image/表单认证原理.png" alt="表单认证原理"></p><p>当认证请求进入 UsernamePasswordAuthenticationFilter 这个过滤器后，它会从请求取出用户名和密码信息，封装到一个 UsernamePasswordAuthenticationToken（未认证状态） 中，接下来就到了 AuthenticationManager，它本身不包含认证的逻辑，但它会从一堆 AuthenticationProvider 中选出一个最合适的来进行认证（校验），至于挑选的过程主要是根据 Authentication 的类型进行匹配；<br>在这些 AuthenticationProvider 中，有一个 supports 方法，它会验证是否支持当前的 AuthenticationToken，如果支持，就进行后面的认证了（会调用我们 UserDetailsService 中的 loadUserByUsername 方法），不支持就跳过，进行下一次循环；<br>认证过程会通过 UserDetailsService 来获取用户信息（UserDetails），然后进行比较和校验，如果顺利，就会把 UsernamePasswordAuthenticationToken 做一个”已认证”的标记，然后将信息保存到 session，最后的一个步骤会调用我们设置的 Handler，失败的处理流程也是类似。</p><p>那么关于请求直接信息共享，还记得在过滤器链最前端有一个 SecurityContextPersistenceFilter，它的作用简单说就是当请求进来的时候检查 session 是否有 Authentication 信息，如果有就将它取出来放到一个 ThreadLocal 里；<br>当请求完成响应时，它检查 ThreadLocal 是否有认证信息，如果有就放到 session 中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登陆的用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以通过 SecurityContextHolder.getContext().getAuthentication() 来进行获取</span></span><br><span class="line"><span class="comment"> * 有条件可以直接注入 Authentication 的方式来获取；</span></span><br><span class="line"><span class="comment"> * 或者使用 <span class="doctag">@AuthenticationPrincipal</span> 注解选择性的获取部分信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SecurityContextHolder 可以简单理解为一个 ThreadLocal，通过最前端的 &#123;<span class="doctag">@link</span> org.springframework.security.web.context.SecurityContextPersistenceFilter&#125; 过滤器，</span></span><br><span class="line"><span class="comment"> * 在每次请求到达时检查 session 是否有登陆信息，有则放到 SecurityContextHolder 中;</span></span><br><span class="line"><span class="comment"> * 在请求返回时，检查是否存在 SecurityContextHolder，如果存在则放到 session 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/me"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication,</span></span></span><br><span class="line"><span class="function"><span class="params">                             @AuthenticationPrincipal UserDetails user)</span> </span>&#123;</span><br><span class="line">  Authentication authentication1 = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">  <span class="comment">// 获取的就是 UserService 中的对象</span></span><br><span class="line">  <span class="comment">// User user =  (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span></span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体到代码，就是通过 SecurityContextHolder 这个类可以随时随地获取认证信息。</p><hr><p>当然，还可以加一些自定义的过滤器，例如来做验证码的校验，示例参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/validate/code/ValidateCodeFilter.java" target="_blank" rel="noopener">Github</a>，往过滤链中添加我们自己的过滤器最简单的方案就是直接在文章开始的配置类调用 http 的 addFilterBefore 方法。<br>现在流行的还有短信验证码，与普通的图形验证码最大的区别就是，使用短信验证码验证通过后是直接认证通过了，而不是单单一个验证码的校验，也可以说它其实是一种登陆方式。</p><h3 id="记住我功能"><a href="#记住我功能" class="headerlink" title="记住我功能"></a>记住我功能</h3><p>这个也是 Web 应用中常见的一个功能，也有不同的实现方式，在 Spring Security 中的方案是基于 Token 和数据库的，整理成流程图就是这样：</p><p><img src="/image/记住我原理.png" alt="记住我原理"></p><p>这个 RememberMeAuthenticationFilter 过滤器的位置处在靠后的位置，当前面的认证都无效时再进行“记住我”认证，表单中的 checkbox 控件固定名称是：<strong>remember-me</strong>。<br>主要的 Java 配置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 基于 JDBC 的 “记住我” 实现</span></span><br><span class="line">  JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">  jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">  <span class="comment">// 自动执行建表语句</span></span><br><span class="line">  <span class="comment">// jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.</span><br><span class="line">    <span class="comment">// 记住我 配置</span></span><br><span class="line">    .rememberMe()</span><br><span class="line">    .tokenRepository(persistentTokenRepository())</span><br><span class="line">    .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds())</span><br><span class="line">    <span class="comment">// 自定义密码处理</span></span><br><span class="line">    .userDetailsService(userDetailsService)</span><br><span class="line">    .and()</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是基于数据库，那么肯定会需要有一张表，你可以让他自己创建，或者进入到 JdbcTokenRepositoryImpl 的源码中，把里面定义的 SQL 手动执行一下。</p><h3 id="自定义认证方式"><a href="#自定义认证方式" class="headerlink" title="自定义认证方式"></a>自定义认证方式</h3><p>当了解完默认表单登陆的逻辑后，自定义其他登陆方式也就不那么难了，这里就以短信验证码登陆为例，用的也是蛮多的；首先是要明确的是，短信登陆与表单登陆是完全不同的一种方式，所以不可能在表单认证的 Filter 中搞，肯定是要自己搞一套，那么也就是需要一个拦截短信验证码的 Filter，以及一个进行校验的 Provider，然后校验通过把标识设置为 true 就好了，其他的跟表单方式基本一致。<br>那么接下来就稍微整理下需要重写的主要类：</p><ul><li>封装用户信息的 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationToken.java" target="_blank" rel="noopener">SmsCodeAuthenticationToken</a> 参考 UsernamePasswordAuthenticationToken，去掉了密码部分，因为短信登陆不需要。</li><li>拦截 SMS 请求的过滤器 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationFilter.java" target="_blank" rel="noopener">SmsCodeAuthenticationFilter</a>，它负责从请求取出相关信息封装 SmsCodeAuthenticationToken 等必要的对象。</li><li>具体的处理实现 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationProvider.java" target="_blank" rel="noopener">SmsCodeAuthenticationProvider</a>，还记得之前说过 AuthenticationManager 会调用它的 supports 方法来根据 Token 对象的类型匹配是不是用它做认证。</li><li>具体做验证的统一 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/validate/code/ValidateCodeFilter.java" target="_blank" rel="noopener">ValidateCodeFilter</a>，处在最前端，仅负责校验验证码。</li></ul><p>简单来说执行步骤是：SmsFilter –&gt; AuthenticationToken –&gt; AuthenticationManager –&gt; AuthenticationProvider –&gt; UserDetailsService –&gt; UserDetails –&gt; 获得 Authentication 已认证信息。<br>既然所需要的类都准备好了，下一步就是将他们配置到 Spring 的环境中，可以定义以下配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsCodeAuthenticationSecurityConfig</span> <span class="keyword">extends</span> <span class="title">SecurityConfigurerAdapter</span>&lt;<span class="title">DefaultSecurityFilterChain</span>, <span class="title">HttpSecurity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">  <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 Filter 类似 ValidateCodeFilter，主类</span></span><br><span class="line">    SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = <span class="keyword">new</span> SmsCodeAuthenticationFilter();</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationManager(httpSecurity.getSharedObject(AuthenticationManager.class));</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(authenticationSuccessHandler);</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationFailureHandler(authenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">    SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = <span class="keyword">new</span> SmsCodeAuthenticationProvider();</span><br><span class="line">    smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加配置，加入到认证之后</span></span><br><span class="line">    httpSecurity.authenticationProvider(smsCodeAuthenticationProvider)</span><br><span class="line">      .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以在文章最开始的那个配置类中，调用 <code>http.apply()</code> 方法让其生效即可。<br>至此，我们再重新梳理一下流程，首先请求进入 ValidateCodeFilter 进行校验验证码（当然它也可以同时负责校验图形验证码），通过之后就继续过滤链，被 SmsCodeAuthenticationFilter 匹配捕获，然后封装 Token 信息，后面就是 Provider 拿着这些信息去 UserDetailsService 将用户信息获取出来，然后置为“已认证”状态了。</p><h2 id="OAuth协议"><a href="#OAuth协议" class="headerlink" title="OAuth协议"></a>OAuth协议</h2><p>这里简单回顾一下 OAuth 协议，之前我就写过，<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AD%98%E6%A1%A3/OAuth.md" target="_blank" rel="noopener">连接在这里</a>，虽然写的也是很简单就是了，这里再重新温习一下，OAuth 协议主要包含角色：</p><ul><li>服务提供商（Provider）<ul><li>认证服务器（Authorization Server）</li><li>资源服务器（Resource Server）</li></ul></li><li>资源所有者（Resource Owner）</li><li>客户端（Client）</li></ul><p>接下来说说运作的基本流程：<br>资源所有者（也就是用户）去访问某个应用的服务（暂且称为客户端吧），然后需要获取其他应用（服务提供商）中的此用户数据，所以客户端会向用户请求授权，用户同意后，服务提供商会发放一个有有效期的令牌给客户端（用户同意操作在服务提供商完成）； 之后客户端可以拿着这个令牌去资源服务器获取资源，资源服务器会验证这个令牌的合法性，通过即可返回需要的资源。<br>具体例子的话，可以想象任何网站的微信、微博登录功能，其中客户端指的就是你访问的那个网站，服务提供商就是微信或者微博，点击后是不是需要跳转到微信扫码或者微博授权页的那个地址呢。</p><p>其中，最重要的就是用户同意这个步骤了，至于同意后如何获取令牌，一般我们采用的也就是<strong>授权码模式</strong>（Authorization Code）和<strong>客户端模式</strong>（Client Credentials），其中授权码模式最为广泛（更加安全，因为不用将密码暴露给第三方）。</p><p>授权码模式的流程（其实跟上面那个基本是一致的，上面就是以授权码模式为例的）：<br>需要授权时，客户端会将用户导向服务提供商的认证服务器，用户需要<strong>在认证服务器上完成同意授权</strong>，然后认证服务器会返回一个授权码，一般是将这个授权码返回到客户端的后台，然后客户端的后台根据这个授权码再去认证服务器换取令牌； 这样令牌就拿到了，整个过程需要两步，认证服务器也能通过导向的连接携带的参数来确定是那个客户端需要授权； 这样不直接返回令牌而是授权码大大加强来应用间的安全性。</p><h2 id="SpringSocial"><a href="#SpringSocial" class="headerlink" title="SpringSocial"></a>SpringSocial</h2><blockquote><p>因为 social 项目调整，目前被标记为 <strong>in the Attic</strong>，在 Spring2.x 版本中，将相关源码进行了去除，如果使用到了相关到类，只能手动补全.<br>参见：<a href="https://www.jianshu.com/p/e6de152a0b4e" target="_blank" rel="noopener">https://www.jianshu.com/p/e6de152a0b4e</a></p></blockquote><p>基本原理： social 封装了绝大部分的 OAuth 协议步骤，会在过滤器链加入 Social 自己的过滤器，通过这个过滤器来简化我们的 OAuth 流程，其中根据令牌获取用户信息的实现各不相同只能由用户来提供，其中涉及的 URL 以及必要的参数也要由用户提供；，基本的组成部分可以概括为：</p><ul><li>ServiceProvider：服务提供商的一个抽象<br>必须继承 AbstractOAuth2ApiBinding 类； 它包含 OAuth2Template 这个默认实现和 Api（AbstractOAuth2ApiBinding）<br>因为每一个服务提供商定义的接口或者数据对象都可能不同，所以针对每一个服务提供商都应该提供一个抽象与之对应，这个当然就需要用户自己实现。<br>示例：<a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/qq/api/QQImpl.java" target="_blank" rel="noopener">QQImpl</a>、<a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/qq/connect/QQServiceProvider.java" target="_blank" rel="noopener">QQServiceProvider</a></li><li>ConnectionFactory<br>提供的默认实现包含 ServiceProvider 和 ApiAdapter（负责将服务提供商个性化的格式转换为 social 通用的格式）</li><li>Connection</li><li>UsersConnectionRepository<br>最常用的就是 JDBC 的实现了，需要自己加入到 Spring 容器中，作用就是对数据库中 UsersConnection 表的 CRUD 操作 。</li></ul><p>最终的目的就是获得某用户的 Connection，然后联合数据库来获取相关的信息； 想要得到 Connection 就需要 ConnectionFactory，而创建工厂需要 ServiceProvider 和 ApiAdapter； 其中有一些是 social 给我们提供了的，剩下的就需要我们自己实现了。</p><p>说到入口，因为 Social 是通过一个 SocialAuthenticationFilter 过滤器来进行操作的，在这个过滤器中默认拦截的是 <code>/auth/{providerId}</code> 请求，用户同意授权后也会再跳转回这个地址，不过是带着授权码 code 回来的，而这个过滤器就是通过是否携带授权码来区分是哪一个步骤的；<br>当检测到是有 code 的时候，就会去自动的触发换取 token 的机制，如果失败默认的失败路径是 <code>/signin</code>，如果成功解析，它就会拿着获取到的 id 去数据库查相关信息，如果没有查到就跳转到 <code>/signup</code> 默认的注册请求，国内很多网站这里会让你绑定一个手机号（注册逻辑）或者绑定已有账号，但是你也可以让其自动注册然后自动登录（UsersConnectionRepository 会判断 ConnectionSignUp 是否为空，如果不为空会调用这个接口来获取一个 id，从而避免跳转），当然这些配置我们可以配，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/SocialConfig.java" target="_blank" rel="noopener">SocialConfig</a>。<br>并且我们通过配置 ProviderSignInUtils 工具类，可以在自定义的注册或者绑定逻辑里拿到 Social 获取到的第三方用户信息，因为在跳转之前 SocialAuthenticationFilter 会将信息保存到 session 中，这个工具也已经封装了注册（绑定）的方法。<br>简略流程可以参考：</p><p><img src="/image/social流程.png" alt="social流程"></p><p>本质与 SpringSecurity 没啥区别，都是获取用户信息，校验，最后置为“已认证”状态放到 Context 中，区别的就是获取用户信息与校验的不同。（蓝色的是 Social 提供的，橘色的是我们自己实现的）</p><h3 id="绑定与解绑"><a href="#绑定与解绑" class="headerlink" title="绑定与解绑"></a>绑定与解绑</h3><p>首先，要获取到当前用户的绑定情况，然后再判断是否进行绑定或者解绑；<br>它默认提供了一个 地址，用来获取登陆用户的绑定信息，最终会跳转到一个叫 <code>connect/status</code> 的视图，一般情况都是会自定义这个视图的，拼装后返回符合我们期望的数据结构，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/view/CustomizeConnectionStatusView.java" target="_blank" rel="noopener">CustomizeConnectionStatusView</a></p><p>绑定与解绑 Social 也基本都替我们写好了，只需要在登陆状态下 POST 方式访问 <code>/connect/{providerId}</code> 就可以了，对应的它最后也会跳转到一个 <code>/connect/{providerId}Connected</code> 的视图，这个还是要自定义的，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/view/CustomizeConnectView.java" target="_blank" rel="noopener">CustomizeConnectView</a>。<br>解绑与绑定一致，只是请求方式换成了 DELETE，返回的视图名是 <code>/connect/{providerId}Connect</code></p><p>PS：集成 Social 后，UserDetailsService 记得实现 SocialUserDetailsService 接口，然后返回一个 SocialUserDetails，这个里面才有 id 关于 OAuth 的那些信息。</p><h2 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h2><p>无论你用哪一种方式登陆，最终登陆成功后的用户信息默认是存在服务器的 session 中的，紧接着就会有超时或者说过期的问题，在集群环境下单机 session 更是一个问题。<br>通常，在 SB 的配置文件中，可以设置超时时间，最低为 1 分钟，在 SecurityConfig 配置类中也可以进行一定的配置，比如失效后的跳转逻辑、在线数量、并发逻辑等。</p><p>要解决集群 session 的问题，只要把 session 不放在单独的服务器就行了，例如可以统一放在 Redis，SpringSession 可以简化这套流程的开发，只需要在配置文件中配置 <code>spring.session.store-type</code> 就可以了，基本上是透明的，非侵入，并且配置的 session 管理项也都是有效的。<br>因为 session 读取会非常频繁，还具有时效性，所以放在 Redis 里是比较合适的。</p><h2 id="SpringSecurityOAuth"><a href="#SpringSecurityOAuth" class="headerlink" title="SpringSecurityOAuth"></a>SpringSecurityOAuth</h2><p>对于浏览器这种客户端，使用 Cookie-Session 的机制还算是方便，但是对于 App 这一类的客户端，再使用 Cookie-Session 的这种机制做认证就显得十分麻烦，难道每次都要手动保存和添加 cookie 到请求头？当然还有很多一些其他因素，这促使我们使用一种简单方便并且安全的机制来做认证，解决 HTTP 无状态的问题，然后 OAuth 就来了，简单说就是使用令牌来做认证。</p><p><img src="/image/SpringSecurityOAuth.png" alt="SpringSecurityOAuth"></p><p>OAuth 协议应该有所了解了，SpringSecurityOAuth 相当于简化了我们作为服务提供商的功能开发，服务提供商一般由认证服务器和资源服务器组成，这个前面说过，其中认证服务器最常见的是那四种授权模式，这个 Spring 已经帮我们实现了。</p><p>而资源服务器的角色，就是保护我们的资源（接口），他们两个物理上可以是一台机器，资源服务器简单说就是通过一个 Filter 来进行令牌的校验，跟前面所说的 SpringSecurity 原理差不多。</p><p>当然，自带的四种授权模式未必能满足我们，例如手机验证码登陆的需求，我们可以进行自定义授权模式，包括存储逻辑与令牌的生成也可以进行个性化。</p><h3 id="认证服务器"><a href="#认证服务器" class="headerlink" title="认证服务器"></a>认证服务器</h3><p>在 SpringSecurityOAuth 的加持下，实现一个认证服务器非常简单，只需要在 Java 配置类上增加一个 <code>@EnableAuthorizationServer</code> 注解即可。<br>加入这个注解后，Spring 就会把四种基本的授权模式与 Token 的存储逻辑（默认内存存储）进行自动装配，直接就可以用了，下面以最常用的授权码模式与密码模式来简单说明。</p><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式的流程不在多说，上面已经讲过了，默认情况下开启注解会发现有这样两个地址映射：</p><ul><li><code>/oauth/authorize</code><br>这一个就是默认提供的让用户确认授权的页面，类似你用第三方登录跳到的那个页面，让用户选择哪个账户、什么权限。<br>访问这个地址是需要一些参数的，在 OAuth2 协议的官方文档有明确规定。<br>PS：要想使用此功能，你系统的用户要有 <code>ROLE_USER</code> 权限，记得在你的 UserDetailsService 中进行配置。</li><li><code>/oauth/token</code><br>这个就是用来换取 accessToken 的接口，如果使用授权码模式，就是用上一步得到的 code 来换取 accessToken。<br>发送 POST 请求的时候记得要带你申请的 appid 之类的信息，一般通过请求头带 authorization 类型为 Base 的方式编码。</li></ul><p>拿到 accessToken 之后就可以去资源服务器获取信息了，只需要在头带上 authorization，这里类型默认用 bearer，值就是 accessToken。<br>它适合给第三方应用做授权，能避免第三方应用接触到我们应用用户的账号密码的风险。</p><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式比授权码模式要更简单，省去了获取 code 的步骤，这种方式用在同一家应用之间是没问题的，就算授权过程需要提供账户密码，但是因为都是自家的应用，还好，就相当于使用账号密码登录了。<br>过程也没啥说的，参考授权码模式的第二步，仅仅是参数的变化，参数在 OAuth2 规范有明确定义。</p><h4 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h4><p>无论使用哪种方式授权，最终获得的 accessToken 是一样的，Spring 会判断这个用户的 accessToken 是否过期，如果没过期，无论用哪种方式授权，得到的 accessToken 都是一致的。<br>当然，服务器除了返回 accessToken 过期时间等必要信息，还会有一个刷新的 token，使用这个可以进行刷新 accessToken，使 accessToken 到期时用户可以无感知的“续期”令牌。</p><h3 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>资源服务器也是类似，一个 <code>@EnableResourceServer</code> 注解即可搞定，并且可以与认证服务器的注解写在一起，毕竟他们不需要物理上隔离，只是逻辑上的概念。<br>按照前面所说，它其实是加了一个 Filter，坚持请求头的 authorization 的 bearer 是否合法。<br>认证过程就区别于传统的 Session 方式了，更加自由一些。</p><h3 id="流程解读"><a href="#流程解读" class="headerlink" title="流程解读"></a>流程解读</h3><p>大体的流程可以参考下面这张图：</p><p><img src="/image/SpringSecurityOAuth原理.png" alt="SpringSecurityOAuth原理"></p><p>其中绿色为类，蓝色为接口（括号里为默认实现）。</p><ul><li><strong>ClientDetailsService</strong><br>用来根据你传递的 client-id 信息读取客户端信息，内容会封装在 ClientDetails 实体。</li><li><strong>TokenRequest</strong><br>它封装了第三方应用请求信息，就是 OAuth 协议中规定的那些请求参数都在这里面。<br>同时，Spring 会把 ClientDetails 放进来。</li><li><strong>TokenGranter</strong><br>它背后就是那四种标准的授权模式实现了（外加一种刷新令牌的实现），它会根据 TokenRequest 中的类型来选一个具体实现，然后执行授权。<br>不管是哪一种授权，最后都会生成一个 OAuth2Request （TokenRequest 和 ClientDetails 的整合体）和 Authentication（包含授权用户的一些信息，那个用户在做授权，由 UserDetailsService 获得），他们两个最后会合并到 OAuth2Authentication 中去。</li><li><strong>AuthorizationServerTokenServices</strong><br>这就是具体生成令牌的接口了，它根据 OAuth2Authentication 的信息就可以生成、存储令牌，并且允许通过 Enhancer 对令牌进行改造。</li></ul><p>在授权码的方式中，权限是由用户最终决定的，你想获取用户的全部信息，用户未必会全部给你，当然需要支持用户勾选的情况下，所以在 TokenEndpoint 过程中，如果是授权码模式的第一阶段会把 Scope 置空，由第二步的用户来进行填充。<br>创建令牌的过程中，会先检查当前用户是否已经创建过令牌、令牌是否过期、是否有刷新令牌，都没有后才会执行创建逻辑，创建的最后一步会判断你是否定义了增强类，如果有就按照你的逻辑来对令牌进行自定义。</p><h3 id="自定义登陆"><a href="#自定义登陆" class="headerlink" title="自定义登陆"></a>自定义登陆</h3><p>自带的标准的四种方式并不一定会满足我们的业务需求，就像之前的短信验证码登陆，这里同样也需要自己实现。<br>根据流程图可以知道，只需要调用 AuthorizationServerTokenServices 就可以产生令牌了，而构建它需要 OAuth2Authentication 对象，也就是 OAuth2Request 和 Authentication。<br>然后在 SpringSecurity 中我们知道有个 handle 处理逻辑，只需要在成功的 handle 中调用一下这个 service 就可以了，并且 Authentication 对象是直接有现成的，那就只剩下 OAuth2Request 对象，而它可以从请求中提取数据拼装。<br>示例可参考 MyAuthenticationSuccessHandler，经过它改造后，使用普通的表单登陆地址，只需要填入用户名和密码就可以拿到 assessToken 了。</p><p>对于 App 短信登陆，要解决的就是去 session 后验证码的校验，App 肯定不会携带 cookie 这一类用来标识，也就是服务器端不可能存在传统的 session 中进行验证；可以将验证码存在 Redis，以一个机器 id 作为 key 或者手机号作为 key，用户登陆的时候需要在请求头或者请求参数携带这个标识，用于校验，这也就要重写 SMS 验证码的校验逻辑。</p><p>对于 App 中的第三方登录，一般都是有专门的 SDK，最终用户同意后会拿到一个 openid ，而我们的系统需要提供一个接口，使用 openid 来换取 AssessToken，这样就算是登录了。<br>当然也不一定第三方应用会给 openid，也可能会给一个授权码，需要服务器后台拿着授权码去换 token，这样的情况也需要单独处理，即在 App 的后端，要通过后处理器来处理授权码模式的请求，跟成功的 handle 一样，最后返回个 assessToken 就好了。</p><h3 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h3><p>首先简单说一下 JWT 的特点：</p><ul><li>自包含</li><li>密签（签名，并不是加密）</li><li>可扩展</li></ul><p>因为这些特点，它肯定也是比默认的 UUID 长不少，携带的信息越多自然就越长，我的话还是习惯用简洁一点的 UUID，虽然它并不能代表什么信息。<br>要想使用 JWT，比较好的一种方案就是通过 TokenStore 将它默认的 UUID 进行转换和存储，示例参考 TokenStoreConfig 这个类。</p><p>SpringSecurity 默认是支持 SSO 的，不过这部分我没去细细研究，客户端只需要使用 @EnableOAuth2Sso 注解和一点配置就可以了，自动授权的相关类见 WhitelabelApprovalEndpoint，具体的示例参考见：<a href="https://github.com/jojozhai/security" target="_blank" rel="noopener">https://github.com/jojozhai/security</a></p><h2 id="SpringSecurity授权"><a href="#SpringSecurity授权" class="headerlink" title="SpringSecurity授权"></a>SpringSecurity授权</h2><p>简单说，就是控制你能干什么，不能干什么；在 SpringSecurity 中最简单的一种配置就是之前继承的 AbstractChannelSecurityConfig 类中的那个 http 对象，继续往下写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">    .antMatchers(HttpMethod.POST, <span class="string">"/user/*"</span>)</span><br><span class="line">    .hasRole(<span class="string">"Admin"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就需要你在 UserDetailsService 中赋予 “ROLE<em>Admin” 权限后才能访问此 URL，记得加 `ROLE</em>` 前缀。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>这里还是简单看一下它的执行过程，相信这张图还是很有印象的：</p><p><img src="/image/SE授权.png" alt="SE授权"></p><p>这次的焦点是在 AnonymousAuthenticationFilter，处于那一堆身份认证的最后一个，它的作用也很简单，当检测到到达这个过滤器时 Authentication 还是空的话，也就是前面那些都没有匹配到，就会创建一个 AnonymousAuthenticationToken，也就是代表匿名用户了（放进去的用户信息为 anonymousUser - ROLE_ANONYMOUS）。<br>最终，由 FilterSecurityInterceptor （是个过滤器）来判断用户是否有足够的权限请求的资源，具体的执行逻辑会委托给 AccessDecisionManager，它有一个抽象实现 AbstractAccessDecisionManager 和几个具体实现：</p><ul><li>AffirmativeBased（默认），只要一个否定就否定</li><li>ConsensusBased，少数服从多数</li><li>UnanimousBased，只要有一个成功，即算作成功</li></ul><p>简单说，它就是来统计投票的，具体投票是一堆 AccessDecisionVoter 对象（现在主要有 WebExpressionVoter 承担了，因为 3 之后的版本有了 Spring 表达式），根据选票与选择的 AccessDecisionManager，最终决定是否放行。<br>如果投票不通过就会抛出一个异常，被前面的过滤器捕获，然后进行相应的处理。</p><h3 id="权限表达式"><a href="#权限表达式" class="headerlink" title="权限表达式"></a>权限表达式</h3><p>最终由 AccessDecisionVoter 评估的就是权限表达式，到达 AccessDecisionVoter 之前 Spring 会将权限信息转换成权限表达式的类型，之前在代码中写的 <code>permitAll()</code> 就是一个权限表达式，相信列表请参考<a href="http://www.mossle.com/docs/springsecurity3/html/el-access.html" target="_blank" rel="noopener">这里</a>，当然也可以使用多个，但是就需要手动写表达式了，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.access(<span class="string">"hasRole('admin') and hasIpAddress('192.168.1.0/24')"</span>);</span><br></pre></td></tr></table></figure><p>当然也能使用自己写的方法来进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;</span><br><span class="line">  config</span><br><span class="line">    .antMatchers(HttpMethod.GET, <span class="string">"/fonts/**"</span>).permitAll()</span><br><span class="line">    .antMatchers(HttpMethod.GET, </span><br><span class="line">                 <span class="string">"/**/*.html"</span>,</span><br><span class="line">                 <span class="string">"/resource"</span>).authenticated()</span><br><span class="line">    .anyRequest()</span><br><span class="line">    .access(<span class="string">"@rbacService.hasPermission(request, authentication)"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>其中 rbacService 指的是 Bean 的名字，hasPermission 是验证方法，返回一个布尔，后面跟上参数就 OK 了。</p><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>这些权限的对应简单的话还好，如果非常复杂使用硬编码的方式就很蛋疼了，那肯定支持从数据库读取，建表就采用一般的 RBAC 基于角色的控制就行了，具体就是用户表、角色表、资源表、用户角色关系表、角色资源关系表。<br>然后自定义你的 UserDetailsService 和 UserDetails 从数据库读取，加入该用户对应的权限信息，然后通过上面的自定义验证方法来进行校验。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT（JSON Web Token）</a></p></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>喜欢就请我吃包辣条吧！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/image/pay/wx.jpg" alt="Kerronex WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/image/pay/zfb.jpg" alt="Kerronex Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kerronex</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://bfchengnuo.com/2019/11/24/SpringSecurity笔记/" title="SpringSecurity笔记">http://bfchengnuo.com/2019/11/24/SpringSecurity笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/Spring/" rel="tag"><i class="fa fa-tag"></i> Spring</a><a href="/tags/安全/" rel="tag"><i class="fa fa-tag"></i> 安全</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/09/14/ECMAScript常用语法整理/" rel="next" title="ECMAScript常用语法整理"><i class="fa fa-chevron-left"></i> ECMAScript常用语法整理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/11/26/CSS布局之Flex布局/" rel="prev" title="CSS布局之Flex布局">CSS布局之Flex布局<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><p class="warninginfo"><i class="fa fa-exclamation-triangle" aria-hidden="true"></i> 评论框加载失败，无法访问 Disqus<br><br>你可能需要魔法上网~~</p></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/image/tx.png" alt="Kerronex"><p class="site-author-name" itemprop="name">Kerronex</p><p class="site-description motion-element" itemprop="description">萝莉控/程序猿<br>夜猫族/不擅长社交</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">119</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">64</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="Mailto:bfchengnuo@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-envelope-o"></i> Email</a></span><span class="links-of-author-item"><a href="https://GitHub.com/bfchengnuo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 小伙伴们~</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://heartsky.info" title="HeartSky" target="_blank">HeartSky</a></li><li class="links-of-blogroll-item"><a href="http://blog.kiuber.me" title="Kiuber" target="_blank">Kiuber</a></li><li class="links-of-blogroll-item"><a href="http://blog.csdn.net/nightcharm" title="夜Charm" target="_blank">夜Charm</a></li><li class="links-of-blogroll-item"><a href="https://bfchengnuo.com/MyRecord/#/" title="学习笔记本" target="_blank">学习笔记本</a></li><li class="links-of-blogroll-item"><a href="http://www.cnblogs.com/bfchengnuo" title="博客园" target="_blank">博客园</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringSecurity"><span class="nav-number">1.</span> <span class="nav-text">SpringSecurity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义用户认证"><span class="nav-number">1.1.</span> <span class="nav-text">自定义用户认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义认证界面"><span class="nav-number">1.2.</span> <span class="nav-text">自定义认证界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义成功和失败Handler"><span class="nav-number">1.3.</span> <span class="nav-text">自定义成功和失败Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于表单的认证流程"><span class="nav-number">1.4.</span> <span class="nav-text">基于表单的认证流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记住我功能"><span class="nav-number">1.5.</span> <span class="nav-text">记住我功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义认证方式"><span class="nav-number">1.6.</span> <span class="nav-text">自定义认证方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth协议"><span class="nav-number">2.</span> <span class="nav-text">OAuth协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringSocial"><span class="nav-number">3.</span> <span class="nav-text">SpringSocial</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定与解绑"><span class="nav-number">3.1.</span> <span class="nav-text">绑定与解绑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session管理"><span class="nav-number">4.</span> <span class="nav-text">Session管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringSecurityOAuth"><span class="nav-number">5.</span> <span class="nav-text">SpringSecurityOAuth</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#认证服务器"><span class="nav-number">5.1.</span> <span class="nav-text">认证服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#授权码模式"><span class="nav-number">5.1.1.</span> <span class="nav-text">授权码模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#密码模式"><span class="nav-number">5.1.2.</span> <span class="nav-text">密码模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他补充"><span class="nav-number">5.1.3.</span> <span class="nav-text">其他补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源服务器"><span class="nav-number">5.2.</span> <span class="nav-text">资源服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程解读"><span class="nav-number">5.3.</span> <span class="nav-text">流程解读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义登陆"><span class="nav-number">5.4.</span> <span class="nav-text">自定义登陆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用JWT"><span class="nav-number">5.5.</span> <span class="nav-text">使用JWT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringSecurity授权"><span class="nav-number">6.</span> <span class="nav-text">SpringSecurity授权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行原理"><span class="nav-number">6.1.</span> <span class="nav-text">运行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限表达式"><span class="nav-number">6.2.</span> <span class="nav-text">权限表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化存储"><span class="nav-number">6.3.</span> <span class="nav-text">持久化存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓展"><span class="nav-number">7.</span> <span class="nav-text">拓展</span></a></li></ol></div></div></section></div></aside></div></main><div style="height:370px;background-image:url(/image/bj.png);background-repeat:no-repeat;margin-left:31%"></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span id="sitetime"></span> <span class="my-face">(●'◡'●)ﾉ♥</span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth(),n=o.getDate(),r=o.getHours(),l=o.getMinutes(),M=o.getSeconds(),s=Date.UTC(2016,3,30,8,0,0),f=Date.UTC(i,a,n,r,l,M)-s,g=Math.floor(f/31536e6),h=Math.floor(f/t-365*g),m=Math.floor(f/t),T=Math.floor((f-(365*g+h)*t)/e),u=Math.floor((f-(365*g+h)*t-T*e)/6e4),d=Math.floor((f-(365*g+h)*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 本站已萌萌哒运行 "+m+" 天 "+T+" 小时 "+u+" 分钟 "+d+" 秒 "}siteTime()</script></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共428.5k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/affix.js?v=5.1.0"></script><script src="/js/src/schemes/pisces.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname="bfchengnuo",disqus_identifier="2019/11/24/SpringSecurity笔记/",disqus_title="SpringSecurity笔记";function run_disqus_script(e){var i=document.createElement("script");i.type="text/javascript",i.async=!0,i.src="//"+disqus_shortname+".disqus.com/"+e,(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(i)}var disqus_config=function(){this.page.url=disqus_url,this.page.identifier=disqus_identifier,this.page.title=disqus_title};run_disqus_script("embed.js")</script><script>var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="/js/src/av-core-mini-0.6.4.js"></script><script>AV.initialize("aztA5nbwUsfTeQsa7DqnqgfF-gzGzoHsz","ri0v7p5gusNlBUnLU3A3Tq3t")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/src/particle.js"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:0;z-index:999;pointer-events:none;bottom:-20px}</style><script src="/live2d/device.min.js"></script><script>const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/koharu.model.json", 0.5);});
})();</script></body></html>