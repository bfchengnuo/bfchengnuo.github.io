<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakanoy</title>
  <icon>https://www.gravatar.com/avatar/f08a170c76cf99aa6ee4da7e6c7775c2</icon>
  <subtitle>立于浮华之世,奏响天籁之音.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sakanoy.com/"/>
  <updated>2024-11-14T17:46:09.401Z</updated>
  <id>https://sakanoy.com/</id>
  
  <author>
    <name>Kerronex</name>
    <email>bfchengnuo@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一台小主机的 AIO 之旅</title>
    <link href="https://sakanoy.com/2024/11/14/AIO%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    <id>https://sakanoy.com/2024/11/14/AIO折腾记录/</id>
    <published>2024-11-14T19:44:01.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>All in boom 来啦，PVE + OpenWrt + 黑群晖 DSM + Windwos10 + Ubuntu + Docker + HAOS。<br>亡命之徒直接冲 RAID0 ！！<br>硬件：GMK M6 + D2-320 磁盘阵列 2x4T。<br>Q：”文章可以多配些步骤图吗，更直观”<br>A：”不行，我懒人，太麻烦，省电模式中，再说吧”<br><a id="more"></a></p><h2 id="安装-PVE"><a href="#安装-PVE" class="headerlink" title="安装 PVE"></a>安装 PVE</h2><p>去官网下载 ISO 镜像，我使用 Ventoy 来进行引导，也可以通过写盘工具直接把 ISO 写到 U 盘，这里最开始我卡 loading，原因是 Ventoy 的版本太老了，升级一下就正常了（不需要格盘）。<br>安装 PVE 的教程很多，也没什么注意的点，IP 只要写对就没啥问题，安装的时候 Ventoy 引导就保持默认第一个。<br>参考视频: <a href="https://www.bilibili.com/video/BV1bc411v7A3/?share_source=copy_web&amp;vd_source=bb09006a95944f3a8aec376ed6eeb2e7" target="_blank" rel="noopener">利用PVE虚拟机，来打造属于自己的All In One系统吧！</a></p><p>PVE 装完后的两个比较好用的工具：<br><a href="https://bbs.x86pi.cn/thread?topicId=20" target="_blank" rel="noopener">https://bbs.x86pi.cn/thread?topicId=20</a><br><a href="https://github.com/ivanhao/pvetools" target="_blank" rel="noopener">https://github.com/ivanhao/pvetools</a><br>就是改个源，去除个订阅提示，硬盘直通可以使用 pvetools。</p><p>关于标记：点数据中心 - 选项 - 标记样式设定 - 完整；然后去每个节点上最上面一栏加标记即可。</p><h2 id="OpenWrt"><a href="#OpenWrt" class="headerlink" title="OpenWrt"></a>OpenWrt</h2><p>软路由还是建议安装一下，但是不推荐主力使用，做一个旁路网关就好，例如安装魔法后解决后面 Docker 拉不到镜像等问题。<br>软路由推荐不良林的视频，说的很清楚：<a href="https://youtu.be/JfSJmPFiL_s?si=09dZqcEKDu1anurs" target="_blank" rel="noopener">视频链接</a></p><p>由于官方固件太简洁，这里选择 immortalwrt，首先去<a href="https://firmware-selector.immortalwrt.org/?version=23.05.4&amp;target=x86%2F64&amp;id=generic" target="_blank" rel="noopener">下载固件</a>，建议选择 COMBINED-EFI (SQUASHFS-COMBINED-EFI.IMG.GZ)版本，因为是 X86 架构直接选。</p><p>上传镜像，然后使用命令:<code>qm importdisk 100 /var/lib/vz/template/iso/openwrt.img local-lvm</code> 导入到虚拟机。</p><p>安装魔法三件套，openClash、homeProxy、passwall</p><p>网卡优先半虚拟化不行的话就切回 E1000，CPU 能 Host 就 Host。</p><blockquote><p>经过测速，起码 PVE8 是不需要 img2kvm 这个工具了，直接 qm 命令导入即可，一般情况下 2 核 1G 的配置够用了。</p></blockquote><p>不过到现在我也还是没搞明白 OpenWrt 的配置，还是挺复杂的，理解为啥有那么多人用爱快了，后面再研究吧，现在网卡都让我删没了。。。但是能用！</p><hr><p>安装 DDNS-Go 配合路由器的端口转发可以实现外网访问，需要一个域名、光猫是桥接，有公网 IP。</p><h2 id="DSM"><a href="#DSM" class="headerlink" title="DSM"></a>DSM</h2><p>采用的是 <a href="https://wp.gxnas.com/11849.html" target="_blank" rel="noopener">GXNAS</a> 的引导文件，或者可以看看著名的原生 RR 引导，复活版的哦 <a href="https://github.com/RROrg/rr" target="_blank" rel="noopener">https://github.com/RROrg/rr</a></p><p>GXNAS 大佬的镜像直接是支持虚拟网卡的，所以直接选半虚拟化就行，性能更好。</p><p>作为 All in boom，我这里当然选的是 RAID0，直接拉满，数据安全什么的全靠我定期冷备份。</p><p>启用 MacOS 的时间机器支持：<a href="https://kb.synology.cn/zh-cn/DSM/tutorial/How_to_back_up_files_from_Mac_to_Synology_NAS_with_Time_Machine" target="_blank" rel="noopener">官方文档</a>，总结就是新建好共享文件夹，给新建个用户(配额还是建议写一下 300-500G 够用了)，开启 <strong>SMB</strong> 服务，高级设置里<strong>启用 Bonjour 服务发现</strong>和<strong>启用通过 SMB 进行 Bonjour Time Machine 播送</strong>，设置下文件夹完成。</p><p>备份 PVE：和时间机器差不多，新建个文件夹，开启共享的 NFS 服务，然后在 NFS 权限里添加 PVE 的 IP 权限，映射为 admin，所有能勾的都勾上。然后去 PVE 存储里添加 NFS 即可，内容选 VZDump备份（或者你还想存其他东西）。<br>PS：不要备份 DSM 本身，会出问题，快照最快最小，需要本体才能恢复，停止和挂起基本一致，可以 PVE Boom 了进行恢复，建议停止模式，备份时虚拟机会暂停几分钟直到备份后启动。</p><h2 id="Windows-Linux"><a href="#Windows-Linux" class="headerlink" title="Windows/Linux"></a>Windows/Linux</h2><p>我这里装的是 Win10 LTSC，Win11 有点复杂，要开 UEFI + TPM，还要登录，就不想搞的那么复杂。</p><p>PS：目前最新的 Win11 优化的也很到位了 2G 内存跑轻度任务都是很流畅的。</p><p>VirtIO 驱动镜像可以通过访问页面找到<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso" target="_blank" rel="noopener">download the latest stable</a> 点击下载，详情移步 <a href="https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers" target="_blank" rel="noopener">https://pve.proxmox.com/wiki/Windows_VirtIO_Drivers</a></p><p>Win 一般肯定是通过远程桌面使用，在计算机右键属性里打开即可，就可以使用 mstsc 进行连接了；Win10 的 LTSC 刚装上可能会导致风扇狂转，这是一个 bug，更新下系统重启后就好了。</p><hr><p>Linux 没啥可以说的很简单，一路下一步和实体机没区别，我装了个 Ubuntu Server。<br>Docker 安装可以使用一键脚本 <code>bash &lt;(curl -sSL https://linuxmirrors.cn/docker.sh)</code> ，换源也有类似的一键换源脚本 <code>bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh)</code>。</p><p>需要允许远程 ssh 登陆的话修改 <code>/etc/ssh/sshd_config</code> 将 <code>PermitRootLogin prohibit-password</code> 改为 <code>PermitRootLogin yes</code> 然后重启服务 <code>service ssh restart</code></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>这里我选择使用 LXC 来创建一个 Docker，首先要下载一个 CT 模板，我使用的是 Ubuntu 的，因为要使用 DockerHub 这里网关使用前面 OpenWrt 的；一定要去掉五特权容器的勾；完成后去选项里面把功能里的嵌套之类全勾上。</p><p>需要注意的是，LXC 虚拟虽然效率高但是不是完全的虚拟，还是会共用宿主机的一些东西或者有限制，所以 Linux 我没用 LXC，Docker 的话感觉还是可以的。</p><p>为了保证 Docker 可以启动，需要在 PVE 修改一下对应 LXC 的配置，在 <code>/etc/pve/lxc/{CTID}.conf</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxc.apparmor.profile: unconfined</span><br><span class="line">lxc.cgroup.devices.allow: a</span><br><span class="line">lxc.cap.drop:</span><br></pre></td></tr></table></figure><p>大部分情况下 Docker 是可以正常运行了。</p><p>使用快捷指令 <code>bash &lt;(curl -sSL https://linuxmirrors.cn/docker.sh)</code> 安装 Docker，源就不换了。</p><p>安装完毕后先装一个 portainer：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data outlovecn/portainer-cn:latest</span><br></pre></td></tr></table></figure><p>服务推荐：跑一个 <a href="https://github.com/librespeed/speedtest/blob/master/doc_docker.md" target="_blank" rel="noopener">speedtest</a> 测速下局域网的网速，或者使用 iperf3 也可以。</p><h2 id="HAOS"><a href="#HAOS" class="headerlink" title="HAOS"></a>HAOS</h2><p>建议使用<a href="https://bbs.hassbian.com/thread-24065-1-1.html" target="_blank" rel="noopener">冬瓜 HAOS</a>，直接使用 PE 版本的 ISO，一键安装。</p><p>还没时间仔细研究，一些插件：</p><ul><li>米家 - Xiaomi MIoT</li><li>美的美居 - Midea AC LAN</li><li>海尔智家 - <a href="https://github.com/banto6/haier" target="_blank" rel="noopener">haier</a></li><li>格力 - <a href="https://www.home-assistant.io/integrations/gree/" target="_blank" rel="noopener">Gree Climate</a></li><li>石头 - <a href="https://github.com/humbertogontijo/homeassistant-roborock" target="_blank" rel="noopener">homeassistant-roborock</a></li><li>HomeKit Bridge - 设备接入苹果家庭</li></ul><p>还没仔细研究，貌似有点复杂。</p><h2 id="Tailscale"><a href="#Tailscale" class="headerlink" title="Tailscale"></a>Tailscale</h2><p>最开始是想装到 Docker 里的，没发现特别好的文章，也不想自己搞了，后来看很多都是装 OpenWrt，有大部分是爱快里装的，比较简单，但是显然不适合我，但是有两个项目感觉不错：</p><p><a href="https://github.com/CH3NGYZ/tailscale-openwrt" target="_blank" rel="noopener">https://github.com/CH3NGYZ/tailscale-openwrt</a><br><a href="https://github.com/adyanth/openwrt-tailscale-enabler" target="_blank" rel="noopener">https://github.com/adyanth/openwrt-tailscale-enabler</a></p><p>不过很可惜的是装完我能登录，但是配置的子网路由无效，大概可能是和我 OpenWrt 前面折腾删掉网口有关，最后还是放弃；</p><p>最终采用了<a href="https://acchw.top/posts/3940/index.html" target="_blank" rel="noopener">这位大佬</a> 的方案，使用 LXC 来安装，和之前配置 Docker 一样，需要在 <code>/etc/pve/lxc/{CTID}.conf</code> 文件中加入开启 TUN：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这个 10 200 可以通过在 pve 上执行 ls -al /dev/net/tun 获得，一般都是 10 200</span><br><span class="line">lxc.cgroup2.devices.allow: c 10:200 rwm</span><br><span class="line">lxc.mount.entry: /dev/net/tun dev/net/tun none bind,create=file</span><br></pre></td></tr></table></figure><p>还需要在 LXC 中的 <code>/etc/sysctl.conf</code> 开启转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv6.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line"># 执行生效</span><br><span class="line"># sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>然后使用官方的脚本安装：<code>curl -fsSL https://tailscale.com/install.sh | sh</code><br>执行 <code>tailscale up --authkey=xxxxx --accept-routes --advertise-routes=192.168.0.0/24</code> 开启，记得换成自己的网段和 authkey。<br>配置自动启动：<br>使用 systemd 来进行开启自启。在 <code>/etc/systemd/system</code> 下新建一个配置文件: <code>tailscale.service</code>, 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Description=AutoStart tailscale</span><br><span class="line">   After=tailscale.service</span><br><span class="line">Requires=tailscale.service</span><br><span class="line">   [Service]</span><br><span class="line">   Type=oneshot</span><br><span class="line">   ExecStart=/usr/bin/tailscale up --authkey=你的authKey --accept-routes --advertise-routes=你的转发范围</span><br><span class="line">   ExecStop=/usr/bin/tailscale down</span><br><span class="line">   RemainAfterExit=yes</span><br><span class="line">   Restart=on-failure</span><br><span class="line">   [Install]</span><br><span class="line">   WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable tailscale.service</span><br><span class="line">systemctl start tailscale.service</span><br></pre></td></tr></table></figure><p>登录后首先去 Web 控制台重命名设备名字，关掉登录过期，开启自定义路由转发，之后就可以像访问内网那样在外面访问内网服务了。</p><h2 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h2><p>修改 LXC 的主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/lxc/容器的id编号/config</span><br><span class="line">/etc/pve/lxc/容器的id编号.conf</span><br></pre></td></tr></table></figure><p>只修改后面这个文件也可以，建议都改。</p><p>串流，未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;All in boom 来啦，PVE + OpenWrt + 黑群晖 DSM + Windwos10 + Ubuntu + Docker + HAOS。&lt;br&gt;亡命之徒直接冲 RAID0 ！！&lt;br&gt;硬件：GMK M6 + D2-320 磁盘阵列 2x4T。&lt;br&gt;Q：”文章可以多配些步骤图吗，更直观”&lt;br&gt;A：”不行，我懒人，太麻烦，省电模式中，再说吧”&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="https://sakanoy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="AIO" scheme="https://sakanoy.com/tags/AIO/"/>
    
      <category term="DSM" scheme="https://sakanoy.com/tags/DSM/"/>
    
      <category term="PVE" scheme="https://sakanoy.com/tags/PVE/"/>
    
      <category term="OpenWrt" scheme="https://sakanoy.com/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>探索Kubernetes容器编排</title>
    <link href="https://sakanoy.com/2023/05/28/Kubernetes%E5%85%A5%E9%97%A8/"/>
    <id>https://sakanoy.com/2023/05/28/Kubernetes入门/</id>
    <published>2023-05-28T19:44:01.000Z</published>
    <updated>2024-11-14T17:46:09.405Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇笔记是在已经大体了解 Kubernetes 是什么东西的基础上的，如果不理解我很久之前写过一篇烂尾文可以参考 <a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/TODO/Kubernetes%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener">K8s入门</a>。。。<br>那么为什么又想起来看 K8s，云原生是趋势，对于小公司和项目也许选择云计算服务商会是个低成本还算好的解决方案，但是一旦做大，这笔账其实就不合算了，最终都会自建云原生平台，作为一个后端，也愈发感觉到 DevOps 的重要性，开发与运维的边界在某些情况下变得模糊，或者说都要懂一点才能更好的适应现在的环境。<br>这一系列文章记录我学习历程，作为后端并不会在这上面耗费太多精力，力求达到平均水平即可。<br><a id="more"></a><br>学习新东西，对我来说最大的问题是开始阶段，无从下口的感觉，不知道从哪开始，这时候如果能建立一个大体的框架，然后再慢慢去填充这种方式感觉比较合理；但是大体框架的建立也是让人不知所措，我一般从入门书籍或者网上找课程的方式建立，本次依旧是这样，祝我学习顺利。</p><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>k8s 确实有点过于复杂，搭建过程有很多细节，并且需要非常多的组件来支持，机器性能也是个问题，碍于手头机器配置不够，云主机也不太想购买，目前只能停在纸上谈兵上，等日后再实践踩坑；本阶段先扫盲一下相关的概念。</p><ul><li>ChatGPT 出来后，对于一些常用命令和资源清单的编写貌似不需要罗列了，让它给你写比看文章更高效，不过记得校验一下，如果不正确还是要进行二次确认。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装上可以简单分为三类：</p><ol><li><a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">Minikube</a> （推荐安装 K3s）<br>Minikube 可以实现一种轻量级的 Kubernetes 集群，通过在本地计算机上创建虚拟机并部署只包含单个节点的简单集群。Minikube 适用于 Linux，MacOS 和 Windows 系统。Minikube CLI 提供集群管理的基本操作，包括 start、stop、status、和 delete。<br>简单说，就是为了便于开发，开发我门可能没那么多机器和资源，使用它就可以快速的体验 k8s。</li><li>云计算厂商<br>安装最简单，master 节点一般由厂商进行托管，通过 UI 选一下机器和配置下一步付钱即可。</li><li>裸机<br>就是准备几台物理机，不管是实际的机器还是 VPS，还是虚拟化的机器。</li></ol><p>其中裸机上最常见的安装方式，一般分为两种：二进制和 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">kubeadm 方式</a> （使用 <code>kubeadm config print init-defaults</code> 查看默认配置），后者官方比较推荐，kubeadm 方式比较简单，适合规模不大的情况，基本都是利用容器的方式来安装，这样也会导致完全启动的时间会比较长；大型生产环境中建议使用二进制方式。</p><blockquote><p>从 Kubernetes 1.24 开始，dockershim 已经从 kubelet 中移除，但因为历史问题 Docker 却不支持 Kubernetes 主推的 CRI（容器运行时接口）标准，所以 Docker 不能再作为 Kubernetes 的容器运行时了，即从Kubernetes v1.24 开始不再使用 Docker了。</p><p>但是如果想继续使用 Docker 的话，可以在 Kubelet 和 Docker 之间加上一个中间层 cri-docker。cri-docker 是一个支持 CRI 标准的 shim（垫片）。一头通过 CRI 跟 Kubelet 交互，另一头跟 Docker Api 交互，从而间接的实现了 Kubernetes 以 Docker 作为容器运行时。但是这种架构缺点也很明显，调用链更长，效率更低。</p><p>可以考虑将 Containerd 作为 Kubernetes 的容器运行时. 相关内容可以搜一下相关科普文章，或者看我整理的<a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/云原生/Docker、Containerd、RunC扫盲.md" target="_blank" rel="noopener">Docker、Containerd、RunC扫盲</a></p></blockquote><p>具体的安装步骤就不说了，还是挺复杂的，网上也一大把的文档，总结几个关键点；<br>修改主机名（hostnamectl）、节点信息写入 host、关防火墙和 swap、安装 ntpdate 同步服务器时间、通过一个虚拟 IP（VIP）做负载均衡，入口是在 service，然后访问 pod，master 节点的网段跟 service 不要在一个网段、高可用（主节点安装 HAproxy，keep-alive）、如果使用的是 docker 还需要将 cgroup driver 设置为 systemd（默认是 cgroupfs），配置日志 journald 等等。</p><h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><p>K8s 必然是跑在集群中的，再来复习一下基本的概念：</p><ul><li><p>master<br>主节点，控制平台，不需要很高性能，不跑任务，通常一个就行了，也可以开多个主节点来提高集群可用度。</p></li><li><p>worker<br>工作节点，可以是虚拟机或物理计算机，任务都在这里跑，机器性能需要好点；通常都有很多个，可以不断加机器扩大集群；每个工作节点由主节点管理</p></li></ul><p>所以正常情况下，使用 k8s 必须有两台机器，一台 master 节点，一台做 worker 节点。</p><p><img src="/image/k8s1.png" alt="img"></p><p>对于高可用架构，例如 Master 节点尽量维持在奇数，避免投票机制带来的选举冲突问题。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><blockquote><p>Node 是 Kubernetes 中的<strong>工作节点</strong>，最开始被称为 minion。一个 Node 可以是 VM 或物理机。<br>每个 Node（节点）具有运行 pod 的一些必要服务，<strong>并由 Master 组件进行管理</strong>，Node 节点上的服务包括 Docker、kubelet 和 kube-proxy。</p></blockquote><p>Node 也算是 K8s 的一个组件，节点组件运行在 Node，提供 Kubernetes 运行时环境，以及维护 Pod。可以说 Node 节点的作用就是来运行应用的工作节点。<br>处理生产级流量的 Kubernetes 集群至少应具有三个 Node。<br>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。终端用户也可以使用 Kubernetes API 与集群交互。</p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>K8S 调度、管理的最小单位，一个 Pod 可以<strong>包含一个或多个容器</strong>，每个 Pod 有自己的虚拟 IP。一个工作节点可以有多个 pod，主节点会考量负载自动调度 pod 到哪个节点运行。<br>同一容器集（Pod）中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源（存储、网络、以及怎样运行这些容器的声明）。容器集会将网络和存储从底层容器中抽象出来。<br>注意：自己手动创建的容器无法被管理。</p><p>Pod实现共享网络的机制：</p><blockquote><p>Pod 创建时，会先起一个 Pause 容器，或者叫 init 容器、根容器，<br>之后才会创建一个或多个业务容器，这些业务容器会共用 Pause 网络协议栈（以及存储等），所以业务容器之间的端口不能重复。</p></blockquote><p>在一个 Pod 中起多个容器的情况，多数是他们有互相依赖关系，尤其是 I/O、网络的依赖。</p><h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><p>下面来说说 Pod 控制器，<del>RC（ReplicationController）</del>、RS（ReplicaSet），RC 用于确保在集群中运行指定数量的 Pod 副本，并在 Pod 发生故障时进行自动替换，我们称之为自愈能力。在新版本中官方更推荐使用 RC 的升级版 RS。</p><p>RC 和 RS 是实现 Pod 副本控制的核心控制器，而 Deployment 是在它们的基础上构建的更高级别的控制器。Deployment 可以看作是 RC 和 RS 的上层抽象，它使用 RS 来确保 Pod 副本数量的正确性，<strong>并实现了滚动升级和回滚等功能</strong>。</p><p>Deployment 不直接参与 Pod 创建，是通过 RS 来实现的，Deployment 实现回滚和滚动升级的原理是通过管理多个 RS 版本来实现的；每次更新 Deployment 时，它会创建一个新的 RS；回滚时，Deployment 会找到上一个版本的 RS，并将其 Pod 数量恢复到原来的状态。<br>如何判断是否满足数量其实是根据标签 label 来匹配的。在更新和回滚的时候，默认是按 25% 来进行操作，例如先创建 25% 新的 Pod，然后删除 25% 的旧的，通过对应的 RS 操作完成。<br>有一种特殊情况是：当需要创建 5 个，创建到 3 个也就是没有完全创建完成时，突然更新了版本，那么 RS 会立即杀掉创建好的 3 个，然后开始建新版本，并不会等到旧版本全部创建完毕后再进行。同时默认保存所有历史版本。</p><h4 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h4><p>HPA 是 Horizontal Pod Autoscaler 的缩写，它是 Kubernetes 提供的一种<strong>自动扩展 Pod 数量的机制</strong>。<br>HPA 可以根据 CPU 使用率、内存使用率等指标自动调整 Pod 的数量，从而实现自动扩缩容。HPA 的工作原理是通过定期检查 Pod 的 CPU 使用率、内存使用率等指标，然后根据指标的变化情况来调整 Pod 的数量。<br>HPA 支持 ReplicaSet、StatefulSet 和 Deployment 部署。</p><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet 通常用于在每个节点上运行集群守护进程、日志收集守护进程、监控守护进程等。<br><strong>DaemonSet</strong> 确保全部（或者某些）<strong>节点上</strong>运行<strong>一个</strong> Pod 的副本。 当有节点加入集群时，也会为他们新增一个 Pod。当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><blockquote><p>关于 apiVersion 的选择，在 Kubernetes 1.9 及更早期版本中，DaemonSet 只能通过 extensions/v1beta1 API 进行管理，而在 Kubernetes 1.10 及之后的版本中，DaemonSet 已经被调整为 apps/v1 API，并逐步废弃了 extensions/v1beta1 API。<br><code>v1</code> 是最基本的 API 版本，一般情况下足够用。</p></blockquote><h4 id="Job与CronJob"><a href="#Job与CronJob" class="headerlink" title="Job与CronJob"></a>Job与CronJob</h4><p>Job 用于管理短暂任务，会创建一个或者多个 Pod，如果非正常终止，将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。<br>当一个 Job 执行完毕，会保留在 API 中，以便观察是否成功以及执行过程，当然也可以配置自动清理。</p><p>CronJob 用于创建基于时隔重复调度的 Job，CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 crontab（cron table）文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p><h3 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h3><p>任何技术中的生命周期都非常重要，了解生命周期可以更方便的进行排查问题、扩展等。</p><ul><li><p>init 容器<br>如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。<br>它们用于在启动应用程序之前执行一些必要的操作或者检查，并确保所需的资源可用。例如，可能需要等待某个服务启动完毕、加载配置文件、运行数据库迁移脚本等操作。如果这些操作失败，则 Pod 不会进入 Running 状态，所以可以作为一种延迟主容器启动的方案。<br>如果有多个，Init Container 将按照定义的顺序逐个运行。每个容器都必须成功完成后，才能执行下一个容器，执行完毕后就会退出，不会一直存在，也就是只存在于初始阶段。</p><p>在 Kubernetes 中，Secret 是一种用于存储敏感信息的机制，例如密码、API 密钥或其他机密数据，Secret 可以加密存储，并且只能通过授权的 Pod 访问。<br>Init Container 可以访问和使用 Secret 存储的敏感信息。这对于需要在容器启动之前加载密码或其他机密信息的应用程序非常有用。<br>在 Pod 启动时，Kubernetes 将加载该 Secret，并将其作为环境变量传递给容器，所以也可以用环境变量的方式来获取，不过对于机密文件，可能就需要 init c 了。</p><p>一个 Pod 里可能有多个容器，每一个容器都有一套完整的以上 init 过程。</p></li><li><p>Pending 挂起<br>Pod 已经被创建，但是它的容器还没有被调度到一个节点上。例如需要的镜像还没有下载完成。</p></li><li><p>Running<br>Pod 中的容器已经被调度到了一个节点上，并且正在运行中（包括正处于启动和重启中）。如果配置了 <code>postStart</code> 回调，那么该回调已经执行且已完成。<br>处于该状态时，并不代表你的服务可以正常访问（就绪 <strong>Ready</strong> 才是表示可以对外服务）。</p></li><li><p>Succeeded<br>Pod 中的所有容器都已经成功地执行完任务并退出了。</p></li><li><p>Failed<br>Pod 中的某个容器因为错误而终止了执行。</p></li><li><p>Unknown<br>Kubernetes 无法确定 Pod 的状态。这通常是由于与 Pod 相关的信息丢失或不可访问导致的。</p></li></ul><p>在 init 后主容器运行时，可以在开始与结尾进行一个回调，做一下准备和收尾工作，这个就不展开了很简单。<br>与生命周期密切相关的，还有两种探测（由 kubelet 执行）：</p><ol><li>生存探测（Liveness Probe）<br>用于检查容器是否在运行中，如果容器无法响应，则 Kubernetes 会将其标记为失败，并尝试重启该容器。例如，可以通过执行某个特定的命令或者发送一个 HTTP 请求来进行生存探测。<br>一般会一直伴随主容器的运行，支持的方式可以是 TCP、HTTP、命令等。</li><li>就绪探测（Readiness Probe）<br>用于检查容器是否已经准备好接受流量，如果容器还没有完全启动或者正在加载数据，则 Kubernetes 不会将流量路由到该容器。这有助于确保应用程序不会接收到无法处理的请求。例如，可以通过监视某个特定的端口或者等待某个文件创建完成来进行就绪探测。<br>一般发生在 init 后主容器的开始阶段。</li></ol><p>有些时候容器虽然 Running 但是可能进程还没准备好对外服务，或者进程出现了假死；这种情况探测技术就变的非常有用。</p><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 主要用于部署有状态服务，需要搭配 HeadLess 和 PVC 使用，可能需要先了解一下这两部分知识：</p><ul><li>稳定的持久化存储，PVC 实现<br>举例来说，当 StatefulSet 中的一个 Pod 被删除后，根据副本数量会重新创建，新的 Pod 的 IP 与被删的肯定是不一致的，但是由于 Pod 仍然具有相同的网络标识符，因此会尝试重用之前分配给该 Pod 的 PVC，所以新 Pod 与 PVC 的绑定关系不会丢失（每一个副本都有自己的 PVC）。</li><li>稳定的网络标识，<em>HeadLess</em>（SVC 的一种）实现（clusterIP: None），在下面 SVC 中理解。<br>DNS 规则一般是：<code>&lt;pod-name&gt;.&lt;headless-service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，当服务处于相同的命名空间下时，可以省略写为：<code>&lt;pod-name&gt;.&lt;headless-service-name&gt;</code><br>如果查询 <code>&lt;headless-service-name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 的 DNS 记录，将会返回所有副本 Pod 节点的 IP。</li><li>有序部署和回收，基于 Pause（init c），例如先启动 MySQL 再 Java</li></ul><p>在 StatefulSet 中，由于每个 Pod 都有自己独立的名称（例如 web-0、web-1 等），因此也需要为每个 Pod 分配一个唯一的 PVC。这样才能保证每个 Pod 都有自己独立的存储卷，并且可以在重启或迁移时保留其之前的数据。<br>通过 Headless Service 则可以将每个 Pod 映射到一个唯一的 DNS 记录中。这样，在调用应用程序时，就可以通过 DNS 解析来直接访问特定的 Pod，从而实现数据的有序访问。<br>在应用程序中，使用 Headless Service 的名称加上 Pod 的名称或索引编号等信息作为域名，来直接访问特定的 Pod。</p><p>在创建 StatefulSet 资源清单时，可以直接使用模板（volumeClaimTemplate）来创建 PVC，当副本先被创建时，如果 PVC 还不存在， Kubernetes 控制面会为该副本自动创建一个 PVC。<br>当资源被删除时，可以使用 StatefulSetAutoDeletePVC 特性来自动删除 PVC，它有几种策略可选，默认与之前策略一致，删除时 PVC 不受影响。 </p><p>但是目前来说，总有一些有状态服务不方便使用 StatefulSet 部署，甚至说不方便使用 K8s 部署，例如 MySQL，这里说的不方便不是不能，而是没有想象中的那么稳定；也不是说数据库服务就不行，例如 MongoDB 就可以很稳定的部署；这个具体分情况。</p><h2 id="K8s组件与工具"><a href="#K8s组件与工具" class="headerlink" title="K8s组件与工具"></a>K8s组件与工具</h2><p>控制相关：</p><ul><li>kube-apiserver API 服务器<br>公开了 Kubernetes API</li><li>etcd 键值数据库<br>可以作为保存 Kubernetes 所有集群数据的后台数据库，分布式、高可用。<br>相比 Redis，etcd 更适合分布式、强一致性、高可靠性的场景。例如服务发现、集群协调等场景。</li><li>kube-scheduler<br>调度 Pod 到哪个节点运行</li><li>kube-controller<br>集群控制器</li><li>cloud-controller<br>与云服务商交互</li></ul><p>Node 相关（节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境）：</p><ul><li>kubelet<br>在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中，并确保处于运行的健康状态；kubelet 不会管理不是由 Kubernetes 创建的容器（自主式与控制器管理的）。</li><li>kube-proxy<br>是 Node 上的运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。它维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。<br>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</li><li>Container Runtime<br>Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。</li></ul><p>其他工具：</p><ul><li>kubectl<br>Kubernetes 命令行工具 kubectl， 让你可以对 Kubernetes 集群运行命令。 你可以使用 kubectl 来部署应用、监测和管理集群资源以及查看日志。</li><li>CoreDNS<br>可以让集群内（SVC）使用自定义域名来访问</li><li>Ingress<br>官方默认 4 层负载均衡，它可以实现 7 层。</li><li>Prometheus<br>集群监控能力</li><li>ELK<br>日志接入、分析平台</li><li>Federation<br>跨集群统一管理支持</li></ul><p>在命令行界面使用 Kubectl 创建和管理 Deployment。Kubectl 是使用 Kubernetes API 与集群进行交互的。</p><h2 id="Service-SVC"><a href="#Service-SVC" class="headerlink" title="Service/SVC"></a>Service/SVC</h2><p>Service 是将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法（或者说是用于暴露应用程序网络服务的对象类型）。Kubernetes 服务代理会自动将服务请求分发到正确的容器集，无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉（Pod 销毁重建后 IP 会改变）。具有的特性：</p><ul><li>Service 通过 label 关联对应的 Pod</li><li>Servcie 生命周期不跟 Pod 绑定，不会因为 Pod 重创改变 IP</li><li>提供了负载均衡功能，自动转发流量到不同 Pod</li><li>可对集群外部提供访问端口</li><li>集群内部可通过服务名字访问</li></ul><p>Service 可以将应用程序的一个或多个副本绑定在一个虚拟 IP（ClusterIP）上，并为集群中的其他对象提供一个固定的 DNS 名称。Service 可以用来实现应用程序的负载均衡、服务发现和内部通信等功能。<br>Kubernetes 支持以下几种类型的 Service：</p><ol><li>ClusterIP：将 Service 暴露在集群内部，只能通过集群内部的 IP 地址访问，仅在集群内部可用（默认）。<br>适用于服务间通信，通常用于微服务架构中，例如 Web 后端和数据库之间的通信。可以避免服务重启后的 IP 变动的影响；</li><li>NodePort：将 Service 暴露在每个节点上的固定端口上，可以通过<strong>节点</strong>的 IP 地址和端口号访问，内部也可以使用该 Service 的 DNS 名称来访问集群内的服务，有一定的 LB 效果。<br>适用于需要将 Service 暴露给集群外部的情况。</li><li>LoadBalancer：将 Service 暴露在外部负载均衡器上，可以通过负载均衡器的 IP 地址和端口号访问，一般需要花钱购买云服务商提供的 LB 服务。</li><li>ExternalName：将 Service 作为一个 DNS 名称暴露出去，可以通过该名称访问 Service，相当于是一条内部的 CNAME 记录。<br>如果正在使用外部系统作为后端服务，并希望在 Kubernetes 中将其命名为 Service，可以使用 ExternalName 来实现。</li></ol><p>Service 可以与 Deployment、StatefulSet、DaemonSet 等控制器对象类型配合使用，以实现应用程序的水平扩展和负载均衡等功能。</p><p>Service 的 ClusterIP 地址是由 kube-proxy 组件负责维护和更新的。kube-proxy 主要有三种模式：userspace、iptables 和 ipvs。不同的模式实现方式不同，但其基本原理都相同，都是通过监听 Kubernetes API Server 发送的事件来实现 Service IP 地址的自动更新。<br>主要用到的就是两种，目前最新版本都推荐使用 IPVS；</p><ul><li>iptables<br>kube-proxy 组件使用 iptables 规则来实现 Service 的负载均衡和 IP 地址转发。在该模式下，kube-proxy 会监控 Kubernetes API Server 发送的事件，并根据事件信息生成或更新相应的 iptables 规则。这些规则可以将请求转发到正确的后端 Pod，并保证源 IP 地址不变。<br>客户端访问 SVC，通过 iptables 路由到具体 pod。</li><li>ipvs<br>kube-proxy 组件使用 Linux 内核中的 IPVS（IP Virtual Server）模块来实现 Service 的负载均衡和 IP 地址转发。与 iptables 不同，ipvs 可以快速处理大量的网络连接，并支持多种负载均衡算法和自动故障检测与恢复机制。在该模式下，kube-proxy 会监控 Kubernetes API Server 发送的事件，并根据事件信息生成或更新相应的 ipvs 规则。</li></ul><p>总之就是它们原理上差不多，但是 ipvs 具有更好的性能。这里有个点可能不太好理解，就是 SVC 也要使用 Node 节点的 IP 访问，我直接暴露 pod 的端口不就行了吗？</p><p>首先，集群内部的情况下，更普遍地会使用 Service 名称来访问 Service，而不是直接使用其 IP 地址。当创建一个 Service 后，Kubernetes 会自动为该 Service 分配一个 DNS 名称，并将该名称与 Service 的 ClusterIP 绑定。<br>例如使用 NodePort 方式时，会在每个节点上分配一个端口，并将<strong>该端口映射到 Service 的 ClusterIP 上</strong>。ClusterIP 是一个虚拟 IP 地址，这个 ClusterIP 不属于任何一个节点，而是由 Kubernetes 控制平面管理。<br>外部客户端也可以使用任何的节点 IP 和暴露的端口进行访问，请求会根据其端口对应的 Service 配置找到与该服务关联的 ClusterIP 地址，并将客户端的请求路由到该地址。<br>一旦请求到达 Service 后，Kubernetes 将使用负载均衡算法（例如 Round Robin），将请求路由到后面运行的一组 Pod 上。这些 Pod 可以运行任何位置，包括不同节点上的多个 Pod。</p><hr><p>Headless Service 是一种特殊的 Service 类型，它不会为 Service 分配 Cluster IP（<code>clusterIP: None</code>），而是直接返回后端 Pod 的 IP 地址列表。换句话说，Headless Service <strong>不会负责转发请求到具体的 Pod</strong>。一个非常有用的作用是 StatefulSet。<br>它主要用于 DNS 解析和集群内服务的发现。例如，当用户使用 DNS 名称来访问 Service 时，Kubernetes 可以通过 Headless Service 将 DNS 请求解析成与 Service 相关联的所有 Pod 的 IP 地址列表，并返回给用户。这样，用户就可以直接与 Pod 进行通信，<strong>而无需经过 Service 和其背后的负载均衡器</strong>。<br>由于 Headless Service <strong>不涉及负载均衡和 IP 地址转发</strong>，因此它的性能和稳定性通常比普通 Service 更高。此外，Headless Service 还支持 Kubernetes 中的服务发现机制，能够自动监测和更新后端 Pod 的状态变化，确保始终返回最新的 IP 地址列表。因为如果直接暴露了 Pod 的 IP 地址，因此必须提前考虑好网络安全和访问控制等问题。</p><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress 是一种 API 对象，<strong>用于将外部流量路由到集群内的 Service 上</strong>。它提供了一种灵活、统一和扩展性强的方式来管理 HTTP 和 HTTPS 流量，并支持多种负载均衡算法、路径匹配规则和 TLS 加密等功能。</p><p>使用 Ingress 能够方便地管理集群中的<strong>多个 Service</strong>，并将其暴露给外部客户端。Ingress 可以实现以下功能：</p><ol><li>路径匹配：可以根据请求的 URL 路径将流量路由到不同的后端 Service 上。</li><li>主机名匹配：可以根据请求的主机名（即域名）将流量路由到不同的后端 Service 上。</li><li>TLS 加密：可以对 Ingress 进行 TLS 加密，保护客户端与服务端之间的通信安全。</li><li>多种负载均衡算法：可以根据需求选择不同的负载均衡算法，如轮询、最小连接数等。</li></ol><p>需要注意的是，要使用 Ingress 需要满足以下条件：</p><ol><li>集群中必须存在一个符合规范的 Ingress Controller（如 Nginx、Traefik、Haproxy 等），用于监听 Ingress 对象的变化并更新对应的负载均衡器或反向代理。</li><li>需要为每个 Ingress 配置一个规则，指定其路径、主机名、后端 Service （其类型设置为 <code>NodePort</code> 或 <code>LoadBalancer</code>）等相关信息。</li><li>如果需要对 Ingress 进行 TLS 加密，则需要先创建一个 Kubernetes Secret，用于存储证书和私钥等敏感信息，并将其与 Ingress 绑定。</li></ol><p>使用最多的还是 Ingress-Nginx，本质来说其实就是启动了一个 Nginx，只不过不需要我们去写 NG 的配置文件而使用 k8s yml 自动完成了。<br>Ingress 可以帮我们实现七层代理，原本只支持到四层代理。</p><blockquote><p>七层代理和四层代理都是计算机网络中常用的代理类型，它们在不同的 OSI 模型层次上工作并提供了不同的功能。</p><ul><li>四层代理（传输层代理）：工作在 OSI 模型的传输层，主要负责对网络连接进行管理和控制。四层代理能够根据源 IP 地址、目标 IP 地址、源端口号和目标端口号等信息来对传输的数据进行转发，以达到负载均衡、流量控制和安全过滤等目的。</li><li>七层代理（应用层代理）：工作在 OSI 模型的应用层，具有更高的可扩展性和灵活性。七层代理能够深入了解应用程序的协议、数据格式和语义，并对传输的数据进行精细化处理。七层代理可以根据应用程序的特殊需求，对数据进行修改、重写和过滤，以实现更高级别的功能，如内容缓存、反向代理、Web 加速和应用层防火墙等。</li></ul><p>四层代理更依赖于基本的网络传输协议，而七层代理则更加注重应用程序的细节和语义。<br>简单说就是四层代理更加底层，速度快延迟低，占用资源也少，而七层具有更高的灵活性。</p></blockquote><p>Ingress 与 SVC 之间可能会有点难以理解，尤其是跟 SVC 的 NodePort 对比，简单说 Ingress 是已经暴露了一个 IP 和端口，终端用户可以直接通过 Ingress 暴露的 IP 进行访问。此时，后面运行的 Service 的 type 类型是否为 ClusterIP 或 NodePort 在某种程度上已经不再重要了。</p><p>不过在同等条件下，NodePort 类型的 Service 可能会比 ClusterIP 类型的 Service 略微快一些；<br>NodePort 类型的 Service 可能会更加不可靠一些，因为它需要暴露节点上的端口，可能会遇到端口号冲突、网络分区等问题。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>ConfigMap 是一种用于存储配置数据的 API 对象，它可以将配置数据从 Pod 代码中分离出来，实现了配置和代码的分离，提高了应用程序的可移植性和可维护性。<br>ConfigMap 可以是一个文件或者文件夹，或者是硬编码到 YAML 中；使用上可以通过环境变量或者挂载 Volume 的方式；<br>需要注意的是，ConfigMap 存储的数据为纯文本格式，因此不适合存储大型二进制文件。</p><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret 是一种用于存储敏感信息的 API 对象，例如密码、证书等。Secret 可以对数据进行加密处理，并提供各种不同类型的加密方式和安全性保障。<br>Kubernetes 中的 Secret 存储常用的三种类型：</p><ol><li>Opaque：Opaque 类型的 Secret 是最通用的类型，它可以存储任意格式的数据。Opaque Secret 中的数据将会被编码为 <strong>base64 格式，但并未进行加密</strong>。</li><li>Service Account：Service Account 类型的 Secret 主要用于身份验证和授权，包含了一个或多个令牌，用于验证 Pod 中的容器是否具有访问其他资源的权限。</li><li>docker-registry：用来存储 Docker 仓库的认证信息和配置信息，并在容器中使用该 Secret 来进行身份验证和授权操作。<br>在资源清单中使用 imagePullSecrets 来在 pull 镜像时进行认证。</li></ol><p>Kubernetes 中的 Service Account 只能用于访问 Kubernetes API 或其他与 Kubernetes 集群相关的资源和对象，并且不适用于外部服务或资源的访问。<br>Service Account 通常由应用程序自动使用，并由 Kubernetes 自动处理。如果声明了 Service Account 会自动挂载到 <code>/run/secrets/kubernetes.io/serviceaccount</code>，部分发行版或者老的 Linux 会在 <code>/var/run</code> 下。</p><p>Opaque 在使用时，不管是环境变量还是挂载，都会自动解码，当然存储的时候也要求值必须是 base64.</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 是一种用于持久化和共享数据的抽象概念。Volume 可以将不同类型的存储介质（例如本地磁盘、网络存储或云存储等）封装为统一的接口，并在 Pod 中使用。<br>Volume 一些常见的类型：</p><ul><li>emptyDir<br>emptyDir 是一种<strong>临时性</strong>的 Volume，用于在<strong>单个 Pod 的多个容器之间</strong>共享数据。emptyDir 将数据存储在 Pod 所在的节点上，并在 <strong>Pod 被删除或重新调度时自动清理</strong>。<br>需要注意的是，当 Pod 中的容器崩溃尝试重启/新建时 Volume 不会清除数据。</li><li>hostPath<br>hostPath 是一种将主机节点上的文件或目录作为 Volume 挂载到 Pod 中的方法。hostPath 可以让 Pod 访问主机节点上的文件系统（或者主机访问 Pod 中的文件），但也可能导致安全性问题和资源争用。</li></ul><p>其他的还有很多类型，因为用的不多就不贴了。</p><h3 id="PV-PVC"><a href="#PV-PVC" class="headerlink" title="PV/PVC"></a>PV/PVC</h3><p>PersistentVolume（PV）是一种用于持久化存储数据的资源对象。PV 可以将不同类型和容量的存储介质（例如本地磁盘、网络存储或云存储等）封装为统一的接口，并在整个 Kubernetes 集群中使用。<br>区别与 Volume 的几个特点：</p><ul><li>范围<br>Volume 是一个容器级别的概念，用于将数据持久化到 Pod 中。而 PV 是一个集群级别的概念，用于将数据持久化到整个 Kubernetes 集群中。</li><li>生命周期<br>Volume 的生命周期与 Pod 相关联，当 Pod 被删除或重启时，相关的 Volume 也会被删除或重新创建。而 PV 则独立于 Pod 存在，并且可以在多个 Pod 之间共享和复用。</li><li>管理方式<br>Volume 可以在 Pod 中直接定义和管理，而 PV 则需要通过 PersistentVolume 和 PersistentVolumeClaim 对象进行定义和管理。</li><li>耦合性<br>PV 将存储介质与 Pod 解耦，使得 Pod 可以从实际存储细节中隔离出来。这使得存储介质可以轻松地更换和升级，而无需对 Pod 进行修改。<br>同理，当 Pod 删除时，PVC 并不会被删除，依然可以为其他 Pod 提供服务。</li></ul><p>而 PersistentVolumeClaim（PVC）则可以理解为存储资源的使用者，它定义了<strong>对 PV 的访问要求</strong>，例如存储类型、访问模式和容量等信息。PVC 可以请求 Kubernetes 动态分配或静态绑定一个 PV，并将其挂载到 Pod 中，以实现数据的持久化和共享。</p><p>PVC 概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载）。</p><p>当 PVC 请求一个 PV 时，Kubernetes 会根据 PVC 的要求，在可用的 PV 池中寻找匹配的 PV。如果找到多个匹配的 PV，则 Kubernetes 会按照一定的策略进行选择和绑定。一旦绑定成功，PVC 和 PV 就形成了一种类似于 “占位符” 的关系。当 PVC 被删除时，它会释放与之关联的 PV。<br>一个 PV 可以被多个 PVC 绑定和使用，但每个 PVC 只能绑定一个 PV。如果多个 PVC 请求同一个 PV，则 Kubernetes 会按照先来先服务的原则进行分配，直到 PV 的容量用尽为止。</p><hr><p>根据 PV 的创建方式可分为两种：</p><ol><li>静态PV<br>手动分配的方式，它要求管理员提前创建好一定数量的 PV，并将其存储属性和访问模式等信息进行配置。<br>静态 PV 的优点是稳定可靠，但缺点是不够灵活，难以应对动态变化的需求。</li><li>动态PV<br>自动分配的方式，它利用 Kubernetes 动态资源管理特性，根据 PVC 对 PV 的请求，动态地创建、绑定和管理 PV。<br>动态 PV 的优点是灵活方便，可以动态适应不同的需求，但缺点是可能会产生较大的管理负担。</li></ol><p>动态 PV 一般是配合云计算服务来使用的，主要是价格昂贵。</p><hr><p>每个 PersistentVolume（PV）都有一个访问模式（Access Mode），用于定义 Pod 如何访问 PV 中的数据。Kubernetes 支持以下三种访问模式：</p><ol><li>ReadWriteOnce（RWO）：<br>只允许单个节点以读写方式挂载 PV。这意味着同一时间内只能有一个 Pod 访问该 PV，并且只能将其挂载到同一个节点上。</li><li>ReadOnlyMany（ROX）：<br>允许多个节点以只读方式挂载 PV。这意味着多个 Pod 可以同时访问该 PV，并且可以将其挂载到多个节点上，但不能进行写操作。</li><li>ReadWriteMany（RWX）：<br>允许多个节点以读写方式挂载 PV。这意味着多个 Pod 可以同时访问该 PV，并且可以将其挂载到多个节点上，也可以进行读写操作。</li></ol><hr><p>当 PersistentVolume（PV）上的数据不再需要时（当其被从申领中释放时如何处理该数据卷），可以使用回收策略对 PV 进行清理和释放。Kubernetes 提供了以下三种回收策略：</p><ol><li>Retain（保留）：<br>指定在被释放后保留其数据。这意味着 PV 中的数据不会被删除，并且管理员需要手动清理它们。通常用于需要手动备份或迁移数据的场景。<br>例如当 PVC 被删除时，由于卷上仍然存在这前一申领人的数据，该卷还不能用于其他申领。 </li><li>Delete（删除）：<br>删除 PVC 时也会将 PV 对象从 Kubernetes 中移除，同时也会从外部基础设施（如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）中移除所关联的存储资产。</li><li>Recycle（回收）：<br>在被释放后重新格式化存储介质并清除所有数据。<br>在新版本中，回收策略 <code>Recycle</code> 已被废弃。取而代之的建议方案是使用动态制备。</li></ol><p><strong>PV 的回收策略是在 PersistentVolumeClaim（PVC）被删除后触发的</strong>。具体而言，当一个 PVC 被删除时，Kubernetes 会检查其绑定的 PV 是否仍然被其他 PVC 使用，如果没有，则会按照该 PV 的回收策略进行清理和释放。</p><hr><p>使用 PV 时，每个卷会处于以下阶段（Phase）之一：</p><ul><li>Available（可用）– 卷是一个空闲资源，尚未绑定到任何申领；</li><li>Bound（已绑定）– 该卷已经绑定到某申领（PVC）；</li><li>Released（已释放）– 所绑定的申领已被删除，但是资源尚未被集群回收；也就是对应的 PVC 被删除。</li><li>Failed（失败）– 卷的自动回收操作失败。</li></ul><p>区别于 PVC 的状态，当查看 PVC 状态时，也会列出绑定的 PV 的状态，而 PVC 的状态一般是：Pending/Bound/Lost。</p><p>对于 StatefulSet 当 Pod 重建后依然有相同的网络标识符，可以绑定之前的 PVC 保证数据不会丢失（每一个副本会有单独的 PVC）；对于在 Deployment 资源清单中配置的副本和 PVC，所有 Pod 会共享 PVC，也不需要考虑新建还是更新的了（猜测，未证实）。</p><h2 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h2><p>在 Kubernetes 中，有两种主要的网络模型：Overlay 网络和基于主机的网络。</p><ol><li>Overlay 网络：Overlay 网络是一种虚拟网络，它在物理网络之上创建一个逻辑网络，用于容器之间的通信。Overlay 网络通常使用隧道技术（如 VXLAN、GRE、IPsec 等）将容器数据包封装在物理网络的数据包中传输。Kubernetes 中的 Flannel、Calico（更推荐吧）、Weave Net 等网络插件都是基于 Overlay 网络实现的。</li><li>基于主机的网络：基于主机的网络是一种直接将容器连接到主机网络上的网络模型，容器与主机之间共享同一个网络命名空间。这种网络模型通常使用 Linux Bridge 或者直接使用主机网络接口来实现。Kubernetes 中的 kube-proxy 就是基于主机的网络模型实现的。</li></ol><p>Flannel 是一个用于容器网络的开源项目，旨在为 Kubernetes 集群提供简单、快速、可靠的网络连接。Flannel 的主要作用是将容器连接到同一网络中，并允许它们之间进行通信。Flannel 通过在每个节点上创建一个虚拟网络（VXLAN 或 UDP），将容器的 IP 地址映射到集群中的其他节点上。这种方式可以实现跨节点的容器通信，同时<strong>保证容器的 IP 地址在整个集群中唯一</strong>。<br>对于实现的原理，简单说就是维护一个路由表（使用 ETCD），因为每个 Node 都有 Flanneld，利用路由表可以共享 IP 对应信息，在进行集群初始化的时候需要安装一下，可以在 kubeadm 的默认模板中事先配置好。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 修改配置文件，例如 - --iface=eth0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"><span class="comment"># 查看 pod</span></span><br><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><p>以上，可以在 kubeadm 初始化完成后使用 kubectl 快速安装。</p><h2 id="集群调度"><a href="#集群调度" class="headerlink" title="集群调度"></a>集群调度</h2><p>在 Kubernetes 中，调度 是指将 Pod 放置到合适的节点上，以便对应节点上的 Kubelet 能够运行这些 Pod。默认的调度器就是 kube-scheduler。<br>调度过程一般可划分为两个阶段，过滤和打分；<br>过滤阶段会将所有满足 Pod 调度需求的节点选出来。 例如，PodFitsResources 过滤函数会检查候选节点的可用资源能否满足 Pod 的资源请求。<br>在打分阶段，调度器会为 Pod 从所有可调度节点中选取一个最合适的节点。 根据当前启用的打分规则，调度器会给每一个可调度节点进行打分。最后会将 Pod 调度到得分最高的节点上。如果存在多个得分最高的节点，kube-scheduler 会从中随机选取一个。<br>这里会有一些可选的调度策略，例如 CPU 或者 内存占用最低的优先。</p><p><code>podspec.nodename</code> 是 PodSpec 的另一个属性，用于指定 Pod 所部署的节点名称。当 Pod 的 <code>podspec.nodename</code> 属性被设置时，Kubernetes 调度器将不会再考虑其他节点来调度该 Pod，并且会直接将该 Pod 分配给指定的节点上运行；这种方式称为静态 Pod 调度，当然也可以使用标签选择。</p><p>节点亲和性（Node Affinity）是指将 Pod 调度到与其相关的节点上的能力。通俗来说，它可以让我们通过一些限制条件（如硬件配置、软件环境等）来控制 Pod 应该部署在哪些节点上；其中又分为软策略和硬策略，也就是尽量满足和必须满足。</p><p>污点（Taint）是一种标记，用于指示节点上存在特定的限制条件，这些条件会影响 Pod 在该节点上的调度。与节点亲和性（Node Affinity）相反，污点可以使节点更具有选择性，以便根据实际需求来控制 Pod 不能被调度到某些节点上。<br>容忍度（Toleration） 是应用于 Pod 上的。容忍度允许调度器调度带有对应污点的 Pod。 容忍度允许调度但并不保证调度：作为其功能的一部分， 调度器也会评估其他参数。<br>污点和容忍度（Toleration）相互配合，可以用来避免 Pod 被分配到不合适的节点上。 每个节点上都可以应用一个或多个污点，这表示对于那些不能容忍这些污点的 Pod， 是不会被该节点接受的。<br>我们建立的 Pod 不会运行在 Master 节点就是使用了这个特性打了一个 NoSchedule。</p><h2 id="K3s"><a href="#K3s" class="headerlink" title="K3s"></a>K3s</h2><p>Rancher Labs 是业界领先的容器软件提供商，其旗舰产品 Rancher 是一款开源的企业级 Kubernetes 管理平台，极为出色地管理和安装 Kubernetes 集群。</p><p>k3s 将安装 Kubernetes 所需的一切打包进仅有 60MB 大小的二进制文件中，并且完全实现了 Kubernetes API。为了减少运行 Kubernetes 所需的内存，Rancher 删除了很多不必要的驱动程序，并用附加组件对其进行替换。K3s 仅需要 kernel 和 cgroup 挂载。<br>k3s 是一款完全通过 CNCF 认证的 Kubernetes 发行版，这意味着你可以编写 YAML 来对完整版的 Kubernetes 进行操作，并且它们也将适用于 k3s 集群。<br>由于它只需要极低的资源就可以运行，因此它能够在任何 512MB RAM 以上的设备上运行集群，换言之，我们可以让 pod 在 master 和节点上运行。专为物联网及边缘计算设计。</p><p>所以，对于日常开发用，K3s 是个比 Minikube 更好的选择，介于 Minikube 和 K8s 之间的最优解。如果你处于边缘计算等小型部署的场景或仅仅需要部署一些非核心集群进行开发/测试，那么选择 k3s 则是性价比更高的选择。</p><p>与 K8s 对比：</p><ul><li>移除过时的功能、Alpha 功能、非默认功能，这些功能在大多数 Kubernetes 集群中已不可用。</li><li><p>删除内置插件(比如云供应商插件和存储插件)，可用外部插件程序替换。K3s 在默认状态下只会启动除自身进程之外的两个应用：coredns 和 traefik。</p></li><li><p>添加 SQLite3 作为默认的数据存储。etcd3 仍然可用，但并非默认项。</p></li><li><p>默认执行容器从 docker 换成了 containerd。</p></li><li><p>封装在简单的启动程序中，该启动程序处理很多复杂的 TLS 和选项。</p></li><li>内置了 local storage provider、service load balancer、helm controller、Traefik ingress controller，开箱即用。</li><li>所有 Kubernetes 控制平面组件如 api-server、scheduler 等封装成为一个精简二进制程序，控制平面只需要一个进程即可运行。</li></ul><p>综上，一般来说，K3s 基本也满足大部分需求了。k3s 官方准备了一键安装脚步，部署非常方便：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主/Server 节点</span></span><br><span class="line">curl -sfL https://get.k3s.io | sh -</span><br><span class="line"></span><br><span class="line"><span class="comment"># node/Agent 节点</span></span><br><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -</span><br></pre></td></tr></table></figure><p>接着就可以部署 Rancher 进行多集群管理了，最好找一台独立的机器，支持 Helm 或者 Docker 的方式进行部署，操作也非常简单，一行命令搞定，然后根据引导界面选择新建集群还是导入已有集群，也就是执行几行命令的事，因为 K8s 已经不支持 dockershim，之前都是用 docker 作为容器运行时，目前新版的 k3s 已经切换到 containerd，当然也可以通过 cri-dockerd 继续使用 Docker。</p><p>而另一个 Rancher 出品的 k8s 集群部署工具 RKE 也挺不错的，功能类似 kubeadm 都主要用来快速初始化集群。</p><blockquote><p>RKE（Rancher Kubernetes Engine）是经过认证的 Kubernetes 发行版，也是用于创建和管理 Kubernetes 集群的 CLI 工具和库。<br>RKE 是一款经过 CNCF 认证的开源 Kubernetes 发行版，可以在 Docker 容器内运行。它通过删除大部分主机依赖项，并为部署、升级和回滚提供一个稳定的路径，从而解决了 Kubernetes 最常见的安装复杂性问题。</p><p>RKE2，也称为 RKE Government，是 Rancher 的下一代 Kubernetes 发行版。RKE2 完美结合了 1.x 版本的 RKE（以下简称 RKE1）和 K3s。<br>重要的是，<strong>RKE2 不像 RKE1 一样依赖 Docker</strong>。RKE1 使用 Docker 来部署和管理 control plane 组件以及 Kubernetes 的容器运行时。RKE2 将 control plane 组件作为由 kubelet 管理的静态 pod 启动。嵌入式容器运行时是 containerd。</p></blockquote><p>无论安装哪一个，安装的时候一定要注意版本对应，可以从<a href="https://www.suse.com/suse-rancher/support-matrix/all-supported-versions/rancher-v2-7-3/" target="_blank" rel="noopener">这里</a>查阅版本的支持范围。</p><ul><li><a href="https://docs.k3s.io/zh/" target="_blank" rel="noopener">k3s 文档</a></li><li><a href="https://docs.rancher.cn/docs/rke/installation/_index/" target="_blank" rel="noopener">RKE 文档</a></li><li><a href="https://docs.rke2.io/zh/" target="_blank" rel="noopener">RKE2 文档</a></li><li><a href="https://ranchermanager.docs.rancher.com/zh/pages-for-subheaders/installation-requirements" target="_blank" rel="noopener">Rancher 文档</a></li></ul><p>不得不说，Rancher 真是把 k8s 弄到了开箱即用，生产环境下也完全不是问题，并且文档有中文，赞。<br>爱折腾的可以尝试使用 <a href="https://docs.rancherdesktop.io/zh/" target="_blank" rel="noopener">Rancher Desktop</a> 来代替开发机的 Docker，它内置 k3s 应该表现还是可以的。</p><h2 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h2><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动集群</span></span><br><span class="line">minikube start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点。kubectl 是一个用来跟 K8S 集群进行交互的命令行工具</span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止集群</span></span><br><span class="line">minikube stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空集群</span></span><br><span class="line">minikube delete --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装集群可视化 Web UI 控制台</span></span><br><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure><h3 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 部署应用，使用 create 创建如果存在会返回失败</span></span><br><span class="line">kubectl apply -f app.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 快速创建一个 pod，1.18 后是使用 Deployment 来创建的</span></span><br><span class="line">kubectl run mypod --image=myimage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment，rs 也一样</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> get 可以跟 pod/deployment/svc/rs</span></span><br><span class="line">kubectl get deployment</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pod 详细信息</span></span><br><span class="line">kubectl get pod -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统命名空间的 pod，默认是 default</span></span><br><span class="line">kubectl get pod -n kube-system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pod 详情</span></span><br><span class="line">kubectl describe pod pod-name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 <span class="built_in">log</span></span></span><br><span class="line">kubectl logs pod-name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 Pod 容器终端， -c container-name 可以指定进入哪个容器。</span></span><br><span class="line">kubectl exec -it pod-name -- bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 伸缩扩展副本</span></span><br><span class="line">kubectl scale deployment test-k8s --replicas=5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把集群内端口映射到节点</span></span><br><span class="line">kubectl port-forward pod-name 8090:8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看历史</span></span><br><span class="line">kubectl rollout history deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到上个版本</span></span><br><span class="line">kubectl rollout undo deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到指定版本</span></span><br><span class="line">kubectl rollout undo deployment test-k8s --to-revision=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除部署</span></span><br><span class="line">kubectl delete deployment test-k8s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看全部</span></span><br><span class="line">kubectl get all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新部署</span></span><br><span class="line">kubectl rollout restart deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令修改镜像，--record 表示把这个命令记录到操作历史中</span></span><br><span class="line">kubectl set image deployment test-k8s test-k8s=ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v2-with-error --record</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂停运行，暂停后，对 deployment 的修改不会立刻生效，恢复后才应用设置</span></span><br><span class="line">kubectl rollout pause deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复</span></span><br><span class="line">kubectl rollout resume deployment test-k8s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出到文件</span></span><br><span class="line">kubectl get deployment test-k8s -o yaml &gt;&gt; app2.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除全部资源</span></span><br><span class="line">kubectl delete all --all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将一个已有的 Kubernetes 资源对象暴露为一个新的 Service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将名为 myapp 的 Deployment 暴露为一个新的 LoadBalancer 类型的 Service</span></span><br><span class="line">kubectl expose deployment myapp --type=LoadBalancer --port=80 --target-port=8080</span><br><span class="line">kubectl get svc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 SVC 网络类型</span></span><br><span class="line">kubectl edit svc xxxx</span><br></pre></td></tr></table></figure><p>更多可以直接问 ChatGPT。</p><h2 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h2><p>在 Kubernetes 中，资源清单（Resource Manifest）是一个包含 Kubernetes 对象定义的 YAML 文件。它描述了在 Kubernetes 集群中创建、配置或管理的任何一种对象，例如 Pod、Service、Deployment、ConfigMap 等。通常可以与 Kubectl 命令一起使用，例如：<code>kubectl apply -f deployment.yaml</code></p><p>资源分类：</p><ul><li>命名空间级别<br>即：只在当前的命名空间有效，</li><li>集群级别<br>全集群可用，可跨命名空间</li><li>元数据型<br>类似 HPA 这种通过指标来进行操作。也可归属于上面两种</li></ul><p>资源清单中有一些属性属于必选：</p><ol><li>apiVersion<br>Kubernetes API 的版本号。可通过 <code>kubectl api-versions</code> 查询</li><li>kind<br>资源对象的类型，例如 Pod、Service 或 Deployment。</li><li>metadata<br>元数据，包括资源对象的名称和标签等信息。</li><li>spec<br>资源对象的规格，包括容器设置、网络设置、存储设置以及其他相关信息。具体内容取决于资源对象的类型。</li></ol><p>对于 metadata 和 spec，下面细分了很多项，下面展示一个最简单的清单文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line">  <span class="comment"># 标签易于管理</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mycontainer</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>后续生成资源清单可以使用 Helm，然后配合 ChatGPT 进行微调。</p><h2 id="补充：Cgroup"><a href="#补充：Cgroup" class="headerlink" title="补充：Cgroup"></a>补充：Cgroup</h2><p>Cgroup，全称 Control Group（控制组），是 Linux 系统内核提供的一个特性（Linux 2.6.24内核开始将 Cgroup 加入主线），主要用于限制和隔离一组进程对系统资源的使用，也就是做资源 QoS。可控制的资源主要包括 CPU、内存、block I/O、网络带宽等等。</p><p>Cgroup 提供了一个原生接口并通过 cgroupfs 提供（从这句话我们可以知道 cgroupfs 就是 Cgroup 的一个接口的封装）。类似于 procfs 和 sysfs，是一种虚拟文件系统。并且 cgroupfs 是可以挂载的，默认情况下挂载在 <code>/sys/fs/cgroup</code> 目录。</p><p>Systemd 也是对于 Cgroup 接口的一个封装。systemd 以 PID 的形式在系统启动的时候运行，并提供了一套系统管理守护程序、库和实用程序，用来控制、管理 Linux 计算机操作系统资源。</p><p>相对来说 Systemd 更加简单，而且目前已经被主流 Linux 发行版所支持（Red Hat 系列、Debian 系列等），而且经过几个版本的迭代已经很成熟了，所以不管是 Docker 本身还是在 K8S 中建议使用 Systemd 来进行资源控制与管理。</p><p>cgroupfs 是文件驱动修改，内核功能没有提供任何的系统调用接口，而是对 linux vfs 的一个实现，因此可以用类似文件系统的方式进行操作。</p><p>systemd 封装了 cgroups 的软件也能让你通过它们定义的接口控制 cgroups 的内容，因此是通过接口调用驱动修改。</p><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>对于一些场景，我们需要使用代码来控制 K8s，这方面可以使用 Kubernetes API 来实现，官方提供了 REST API 的接口，也可以使用相关语言的 SDK 来实现。</p><p>文档参考：<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/</a></p><p>集群之间都是通过证书来进行认证的，证书由 Master 进行签发，而 Pod 因为会频繁新建和销毁，签发证书的方式就不太合适，使用的是 Service Accounts 它被用于为 Pod 提供访问 Kubernetes API 和其他 Kubernetes 资源的标准方式。每个 Service Account 都会分配一个唯一的名称和一个对应的 Token，该 Token 可以被应用程序用来进行身份验证和授权。每个 Pod 都有一个默认的 Service Account，上面 Secret 中介绍过。</p><p>关于鉴权，则推荐使用 RBAC 方式，它声明了四种 Kubernetes 对象：<strong>Role</strong>、<strong>ClusterRole</strong>、<strong>RoleBinding</strong> 和 <strong>ClusterRoleBinding</strong>。带有 Cluster 的则表示是集群级别的权限，否则需要指定是那个命名空间下的权限。<br>Role 通常与 Role Binding 结合使用，用于将指定的角色分配给特定的用户或服务账户。而 ClusterRole 则通常与 ClusterRoleBinding 结合使用，用于将角色分配给整个集群的用户或服务账户。<br>K8s 不提供用户管理，在证书签发时已经包含了这部分信息。</p><p>可视化可以使用 <a href="https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard" target="_blank" rel="noopener">kubernetes-dashboard</a><br>监控可以用 Prometheus、Grafana</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/TODO/Kubernetes%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener">K8s入门</a><br><a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/云原生/Docker、Containerd、RunC扫盲.md" target="_blank" rel="noopener">Docker、Containerd、RunC扫盲</a><br><a href="http://docs.kubernetes.org.cn/683.html" target="_blank" rel="noopener">kubectl命令表</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/" target="_blank" rel="noopener">Kubernetes组件</a><br><a href="https://juejin.cn/post/6955368911705473060" target="_blank" rel="noopener">k3s vs k8s vs k9s</a><br><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">鉴权</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇笔记是在已经大体了解 Kubernetes 是什么东西的基础上的，如果不理解我很久之前写过一篇烂尾文可以参考 &lt;a href=&quot;https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/TODO/Kubernetes%E5%85%A5%E9%97%A8.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K8s入门&lt;/a&gt;。。。&lt;br&gt;那么为什么又想起来看 K8s，云原生是趋势，对于小公司和项目也许选择云计算服务商会是个低成本还算好的解决方案，但是一旦做大，这笔账其实就不合算了，最终都会自建云原生平台，作为一个后端，也愈发感觉到 DevOps 的重要性，开发与运维的边界在某些情况下变得模糊，或者说都要懂一点才能更好的适应现在的环境。&lt;br&gt;这一系列文章记录我学习历程，作为后端并不会在这上面耗费太多精力，力求达到平均水平即可。&lt;br&gt;
    
    </summary>
    
      <category term="云计算" scheme="https://sakanoy.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="k8s" scheme="https://sakanoy.com/tags/k8s/"/>
    
      <category term="Kubernetes" scheme="https://sakanoy.com/tags/Kubernetes/"/>
    
      <category term="k3s" scheme="https://sakanoy.com/tags/k3s/"/>
    
      <category term="Rancher" scheme="https://sakanoy.com/tags/Rancher/"/>
    
  </entry>
  
  <entry>
    <title>ClashX使用入门</title>
    <link href="https://sakanoy.com/2021/06/23/ClashX%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://sakanoy.com/2021/06/23/ClashX使用入门/</id>
    <published>2021-06-23T21:42:16.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>起因还要从去年还是前年的那次大规模封杀说起，因为种种原因 SS 原作者早已弃坑，SSR 作者也是如此，以现在的防火墙技术识别 SS 的流量特征应该不难，每次都是大规模的『关机保平安』；<br>我买的机场也开始提供 SS + V2ray 的方式，并且建议优先使用 V2ray，我也就顺势切换了，接下来遇到的一个问题就是 SS 客户端不支持，需要找一个替代的，最好多种协议都支持，一轮调研下来，Clash 脱颖而出（当时起码是 Star 最高的），于是就开始使用 ClashX。<a id="more"></a></p><p>不像其他的客户端，可以有完整的 GUI 配置，ClashX 比较传统的使用配置文件方式，说起配置文件，V2ray 本身就以复杂的配置著称，不过换来的是高稳定性与强大的功能。<br>起初我只是找了份模版，然后简单加上节点信息，这样跟之前的 SS 没太大区别，用了好长时间。<br>后来，闲得无聊，搜了下配置文件相关的信息，发现可配置的东西是真的多，功能也是真牛逼，我也没完全掌握，以后用到相关的功能再更新吧。</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>Clash 有两个版本，普通版和 Pro 版，对应到 Mac 平台就是 ClashX 和 ClashX Pro，倒不是说 Pro 收费，是 Pro 支持更多的功能，如 TUN、代理集、规则集、脚本等，但是不开源，但是还是建议使用 Pro 版本，获得更好的体验（例如通过 TUN 可接管设备的所有 TCP 和 UDP 流量，可以做软路由等等）。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>首先说明，因为我的机场不提供订阅服务，虽然可以进行转换，但我还是更愿意使用传统的手动增加节点方式，订阅相关的规则暂时略过。</p><p>ClashX 主文件 Config.yaml 内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#---------------------------------------------------#</span></span><br><span class="line"><span class="comment">## 配置文件需要放置在 $HOME/.config/clash/*.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 这份文件是clashX的基础配置文件，请尽量新建配置文件进行修改。</span></span><br><span class="line"><span class="comment">## ！！！只有这份文件的端口设置会随ClashX启动生效</span></span><br><span class="line"><span class="comment">#---------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="attr">port:</span> <span class="number">1090</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">1080</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9090</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Proxy:</span></span><br><span class="line"></span><br><span class="line"><span class="string">Proxy</span> <span class="attr">Group:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Rule:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,google.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-KEYWORD,google,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN,google.com,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,ad.com,REJECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GEOIP,CN,DIRECT</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">MATCH,DIRECT</span></span><br></pre></td></tr></table></figure><p>这些都是最基本的端口与规则模式信息，一般情况都是会另新建一个配置文件来配置详细的规则和节点。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>这部分的功能非常实用，虽然最开始我完全看不懂，也不知道什么意思，在这里的配置也让我踩坑了好几次，首先来看一个示例配置（Pro 版）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DNS 服务器配置(可选；若不配置，程序内置的 DNS 服务会被关闭)</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  listen:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:53</span></span><br><span class="line"><span class="attr">  ipv6:</span> <span class="literal">true</span> <span class="comment"># 当此选项为 false 时, AAAA 请求将返回空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 以下填写的 DNS 服务器将会被用来解析 DNS 服务的域名</span></span><br><span class="line">  <span class="comment"># 仅填写 DNS 服务器的 IP 地址</span></span><br><span class="line"><span class="attr">  default-nameserver:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line"><span class="attr">  enhanced-mode:</span> <span class="string">fake-ip</span> <span class="comment"># 或 redir-host</span></span><br><span class="line"><span class="attr">  fake-ip-range:</span> <span class="number">198.18</span><span class="number">.0</span><span class="number">.1</span><span class="string">/16</span> <span class="comment"># Fake IP 地址池 (CIDR 形式)</span></span><br><span class="line">  <span class="comment"># use-hosts: true # 查询 hosts 并返回 IP 记录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 在以下列表的域名将不会被解析为 fake ip，这些域名相关的解析请求将会返回它们真实的 IP 地址</span></span><br><span class="line"><span class="attr">  fake-ip-filter:</span></span><br><span class="line">    <span class="comment"># 以下域名列表参考自 vernesong/OpenClash 项目，并由 Hackl0us 整理补充</span></span><br><span class="line">    <span class="comment"># === LAN ===</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.lan'</span></span><br><span class="line">    <span class="comment"># === Linksys Wireless Router ===</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.linksys.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.linksyssmartwifi.com'</span></span><br><span class="line">    <span class="comment"># === Apple Software Update Service ===</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'swscan.apple.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'mesu.apple.com'</span></span><br><span class="line">    <span class="comment"># === Windows 10 Connnect Detection ===</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.msftconnecttest.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.msftncsi.com'</span></span><br><span class="line">    <span class="comment"># === NTP Service ===</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time.*.gov'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time.*.edu.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time.*.apple.com'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time1.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time2.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time3.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time4.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time5.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time6.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time7.*.com'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp1.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp2.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp3.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp4.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp5.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp6.*.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'ntp7.*.com'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.time.edu.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.ntp.org.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.pool.ntp.org'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'time1.cloud.tencent.com'</span></span><br><span class="line">    <span class="comment"># === Music Service ===</span></span><br><span class="line">    <span class="comment">## NetEase</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.music.163.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.126.net'</span></span><br><span class="line">    <span class="comment">## Baidu</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'musicapi.taihe.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'music.taihe.com'</span></span><br><span class="line">    <span class="comment">## Kugou</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'songsearch.kugou.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'trackercdn.kugou.com'</span></span><br><span class="line">    <span class="comment">## Kuwo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.kuwo.cn'</span></span><br><span class="line">    <span class="comment">## JOOX</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'api-jooxtt.sanook.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'api.joox.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'joox.com'</span></span><br><span class="line">    <span class="comment">## QQ</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.y.qq.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.music.tc.qq.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'aqqmusic.tc.qq.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.stream.qqmusic.qq.com'</span></span><br><span class="line">    <span class="comment">## Xiami</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'*.xiami.com'</span></span><br><span class="line">    <span class="comment">## Migu</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.music.migu.cn'</span></span><br><span class="line">    <span class="comment"># === Game Service ===</span></span><br><span class="line">    <span class="comment">## Nintendo Switch</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.srv.nintendo.net'</span></span><br><span class="line">    <span class="comment">## Sony PlayStation</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.stun.playstation.net'</span></span><br><span class="line">    <span class="comment">## Microsoft Xbox</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'xbox.*.microsoft.com'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'+.xboxlive.com'</span></span><br><span class="line">    <span class="comment"># === Other ===</span></span><br><span class="line">    <span class="comment">## QQ Quick Login</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'localhost.ptlogin2.qq.com'</span></span><br><span class="line">    <span class="comment">## Golang</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'proxy.golang.org'</span></span><br><span class="line">    <span class="comment">## STUN Server</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'stun.*.*'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'stun.*.*.*'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 支持 UDP / TCP / DoT / DoH 协议的 DNS 服务，可以指明具体的连接端口号。</span></span><br><span class="line">  <span class="comment"># 所有 DNS 请求将会直接发送到服务器，不经过任何代理。</span></span><br><span class="line">  <span class="comment"># Clash 会使用最先获得的解析记录回复 DNS 请求</span></span><br><span class="line"><span class="attr">  nameserver:</span></span><br><span class="line"><span class="attr">    - https:</span><span class="string">//doh.pub/dns-query</span></span><br><span class="line"><span class="attr">    - https:</span><span class="string">//dns.alidns.com/dns-query</span></span><br><span class="line">     </span><br><span class="line">  <span class="comment"># 当 fallback 参数被配置时, DNS 请求将同时发送至上方 nameserver 列表和下方 fallback 列表中配置的所有 DNS 服务器.</span></span><br><span class="line">  <span class="comment"># 当解析得到的 IP 地址的地理位置不是 CN 时，clash 将会选用 fallback 中 DNS 服务器的解析结果。</span></span><br><span class="line">  <span class="comment"># fallback:</span></span><br><span class="line">  <span class="comment">#   - https://dns.google/dns-query</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果使用 nameserver 列表中的服务器解析的 IP 地址在下方列表中的子网中，则它们被认为是无效的，</span></span><br><span class="line">  <span class="comment"># Clash 会选用 fallback 列表中配置 DNS 服务器解析得到的结果。</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># 当 fallback-filter.geoip 为 true 且 IP 地址的地理位置为 CN 时，</span></span><br><span class="line">  <span class="comment"># Clash 会选用 nameserver 列表中配置 DNS 服务器解析得到的结果。</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># 当 fallback-filter.geoip 为 false, 如果解析结果不在 fallback-filter.ipcidr 范围内，</span></span><br><span class="line">  <span class="comment"># Clash 总会选用 nameserver 列表中配置 DNS 服务器解析得到的结果。</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># 采取以上逻辑进行域名解析是为了对抗 DNS 投毒攻击。</span></span><br><span class="line"><span class="attr">  fallback-filter:</span></span><br><span class="line"><span class="attr">    geoip:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    ipcidr:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">240.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/4</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/32</span></span><br><span class="line">    <span class="comment"># domain:</span></span><br><span class="line">    <span class="comment">#   - '+.google.com'</span></span><br><span class="line">    <span class="comment">#   - '+.facebook.com'</span></span><br><span class="line">    <span class="comment">#   - '+.youtube.com'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tun:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment">#如果需要启用 TUN 模式，请设置为 true</span></span><br><span class="line"><span class="attr">  stack:</span> <span class="string">system</span> <span class="comment"># 或 gvisor</span></span><br><span class="line"><span class="attr">  macOS-auto-route:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  macOS-auto-detect-interface:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dns-hijack:</span></span><br><span class="line"><span class="attr">    - tcp:</span><span class="string">//8.8.8.8:53</span></span><br><span class="line"><span class="attr">    - tcp:</span><span class="string">//8.8.4.4:53</span></span><br></pre></td></tr></table></figure><p>clash DNS 请求逻辑：</p><ol><li>当访问一个域名时，nameserver 与 fallback 列表内的所有服务器并发请求，得到域名对应的 IP 地址。</li><li>clash 将选取 nameserver 列表内，解析最快的结果。</li><li>若解析结果中，IP 地址属于国外，那么 clash 将选择 fallback 列表内，解析最快的结果。</li></ol><p>因此，在 nameserver 和 fallback 内都放置无污染、解析速度较快的国内 DNS 服务器，以达到最快的解析速度。<br>但是 fallback 列表内服务器会用在解析境外网站，为了结果绝对无污染，尽量使用支持 DoT/DoH 的服务器。</p><p>DNS 配置注意事项：</p><ol><li>如果您为了确保 DNS 解析结果无污染，请仅保留列表内以 tls:// 或 https:// 开头的 DNS 服务器，但是通常对于国内域名没有必要。</li><li>如果您不在乎可能解析到污染的结果，更加追求速度。请将 nameserver 列表的服务器插入至 fallback 列表内，并移除重复项。</li></ol><p>关于 DNS over HTTPS (DoH) 和 DNS over TLS (DoT) 的选择：<br>对于两项技术双方各执一词，而且会无休止的争论，各有利弊。各位请根据具体需求自行选择，但是配置文件内默认启用 DoT，<del>因为目前国内没有封锁或管制</del>。<br><strong>DoH:</strong> 以 https:// 开头的 DNS 服务器。拥有更好的伪装性，且几乎不可能被运营商或网络管理封锁，但查询效率和安全性可能略低。<br><strong>DoT:</strong> 以 tls:// 开头的 DNS 服务器。拥有更高的安全性和查询效率，但端口有可能被管制或封锁。</p><blockquote><p>这里有个坑，或许是我网络的问题，fallback 中的地址我全部连不上，这就导致一个很严重的后果，国外的网站全部无法命中，甚至 AppStore 都挂了。。。<br>后面通过调整日志等级到 DEBUG 才知道是 DNS 解析的问题。<br>除非你所在的地区 DNS 污染特别严重，否则非常不建议使用 fallback，拖慢速度还不稳定，一般情况 fake-Ip 足够了。</p></blockquote><h3 id="fake-ip"><a href="#fake-ip" class="headerlink" title="fake-ip"></a>fake-ip</h3><p>下面补充说明下这个 fake-ip 是什么东西；</p><blockquote><p>虽然 Fake IP 这个概念早在 2001 年就被提出来了，但是到 Clash 提供 fake-ip 增强模式以后，依然有很多人对 Fake IP 这个概念以及其作用知之甚少。</p><p>参考：<a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/" target="_blank" rel="noopener">https://blog.skk.moe/post/what-happend-to-dns-in-proxy/</a></p></blockquote><p>当 TCP 连接建立时，Clash DNS 会直接返回一个保留地址的 IP（即 Fake IP；Clash 默认使用 198.18.0.0/16），同时 Clash 继续解析域名规则和 IP 规则。<br>PS：开启增强模式后可以尝试 nslookup 看一下解析情况。</p><p>由于 TCP/IP 的协议特性，在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。<br>在不使用代理的情况下，DNS 查询流程想必大家很熟悉了，如果使用了代理，直连模式下以使用 SOCKS5 代理的浏览器为例：</p><ol><li>浏览器不再需要从自己的 DNS 缓存中寻找域名对应的 ip，因为已经有了 SOCKS5 代理，浏览器可以直接将域名封装在 SOCKS5 流量之中发往代理客户端（clash）</li><li>代理客户端从 SOCKS5 流量中抽出域名并设法获得解析结果</li><li>代理客户端将你的 SOCKS5 流量还原成标准的 TCP 请求</li><li>代理客户端将这个 TCP 连接建立起来，TCP 连接可以承载的是 HTTPS</li></ol><p>传统上，大部分浏览器等应用都会调用系统的内置方法去解析域名，这时候如果你想做一些魔法操作，那么就是在系统这一层上，你可以在本地或者其他地方搭建一个黑魔法 DNS 服务器，然后设置系统的 DNS 为它，就可以实现一些黑魔法效果。</p><p>例如，在上面的 2 和 3 之间，可以插入一步：代理客户端使用 <strong>某种协议</strong> 将浏览器发出的 SOCKS5 的流量重组并发给远端服务器；<br>远端服务器使用相同的协议还原，然后拿到域名，进行解析；这样就实现了域名在远端进行解析。<br>这种就是非直连的方式代理，各有优劣，各自体会。</p><hr><p>然后再说说分流；分流是一个麻烦事。一般情况下，你可能会需要使用域名进行分流（不论是白名单还是黑名单）。不过更多情况下你会使用到基于 IP 的规则来进行分流。<br>这里可以通过 GUI 的界面来观察连接，如果 TUN 显示一个域名使用了大量端口占用了大量的 ip 池资源，可以考虑将它放到 fake-ip-filter 中不使用 fake-ip。</p><p>在域名规则下，如果判断是直连，那么代理客户端没必要进行 DNS 解析，交给原本的流程使用系统接口即可。<br>在 ip 规则下，当然需要先解析域名，然后匹配规则，但是由于某种协议可以封装域名，因此最终还是会讲域名发给远端，也就是你本地匹配规则的 ip 与最终代理请求的 ip 可能并不是一个。</p><h3 id="全局流量代理TUN"><a href="#全局流量代理TUN" class="headerlink" title="全局流量代理TUN"></a>全局流量代理TUN</h3><p>全局流量代理可能会出现在路由器上或者 TUN/TAP 型的支持全局代理客户端上。用户不再主动为每个应用程序设置代理。<strong>此时应用程序是不会感知到代理客户端的存在，它们会正常的发起 TCP 连接</strong>，ClashX 的增强模式或者说 TUN 模式，会接管设备的 TCP 协议栈，并且由于 TCP/IP 协议在拿到 DNS 解析结果之前，连接是不能建立的。</p><p>这时候配合上面说的 DNS 解析过程就比较有趣了，前半部分不变，最终会调用系统接口进行解析域名，这时候会向系统配置的 DNS 服务器发起请求；<br>如果我们在系统的网络设置之中有设置上游 DNS 地址，例如代理客户端可能会修改系统设置中的 DNS 到 127.0.0.1 或者别的 IP、也可能保留用户之前的设置，这无所谓，因为… <strong>操作系统发出的 DNS 解析请求会经过代理客户端并最终被截获</strong>；<br>代理客户端可以将这个解析请求原样发出去、或者用自己的黑魔法，总之都会拿到一个解析结果；<br>代理客户端将这个解析结果返回回去，操作系统拿到了这个解析结果并返回给浏览器 浏览器对这个解析结果的 IP 建立一个 TCP 连接并发送出去，<strong>这个 TCP 连接被代理客户端截获</strong>。<br>由于之前代理客户端进行的 DNS 解析请求这一动作，代理客户端可以找到这个只包含目标 IP 的 TCP 连接原来的目标域名；<br>如果是支持 redir 的代理客户端，那么代理客户端就会直接将域名和 TCP 连接中的其它数据封装成 <strong>某种协议</strong> 发给远端服务器；或者封装成 SOCKS5 后交给支持 SOCKS5 的代理客户端。</p><p>和应用程序直接将流量封装成 SOCKS5 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此除非得到一个 DNS 解析结果，否则 TCP 连接不会建立；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名。<br>你大概能够发现，浏览器、应用程序直接设置 SOCKS5 代理的话，可以不在代理客户端发起 DNS 解析请求就能将流量发送给远端服务器；<br>而<strong>在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接</strong>。 有没有办法能像直接设置 SOCKS5 代理一样省掉一次 DNS 解析呢？<br>有，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接。</p><p>有了 Fake IP，代理客户端无需进行 DNS 解析。最后不论是浏览器、代理客户端还是远端服务器都不会去和 Fake IP 进行连接，因为在代理客户端这里就已经完成了截获、重新封装。<br>即使按照域名规则分流，代理客户端都没有进行 DNS 解析的需要。只有在遇到了按照 IP 进行分流的规则时，代理客户端才需要进行一次解析拿到一个 IP 用于判断。即便如此，这个 IP 只用于分流规则的匹配，不会被用于实际的连接。</p><p>PS：Clash 的增强模式既有 redir-host 也有 Fake IP，目前流行的是 Fake IP 模式。</p><hr><p>这里有个很有意思的问题，如果操作系统或者浏览器缓存了 Fake IP，但是代理客户端中 Fake IP 和域名的映射表丢失以后，会出现什么状况？可能会出现什么错误信息？<br>你应该大概意识到 Clash 在 Fake IP 模式下偶发的无法上网的原因了。</p><p>在使用 Fake-ip 模式后，Application 拿到的是 Clash DNS 返回的 Fake IP，所以也不会出现某些应用程序拒绝连接一些 IP 的情况；和 redir-host 模式一样，在大部分情况下 fake-ip 模式下也可以完全无视 DNS 污染。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>这部分可参考 SS-Rule，写的很好，或者可以看看官方推荐的<a href="https://lancellc.gitbook.io/clash/clash-config-file/proxies/config-a-vmess-proxy" target="_blank" rel="noopener">文档</a>或者 wiki，我因为没有订阅连接，只能自己手动配置，下面是我用到的几个：<br>需要注意的是，在 <a href="https://github.com/Dreamacro/clash/releases/tag/v1.9.0" target="_blank" rel="noopener">v1.9</a> 版本后，作者调整了配置的格式（改动很小），下面使用的是最新的个数，详情可以看官方的说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="comment"># shadowsocks</span></span><br><span class="line">  <span class="comment"># 支持加密方式：</span></span><br><span class="line">  <span class="comment">#   aes-128-gcm aes-192-gcm aes-256-gcm</span></span><br><span class="line">  <span class="comment">#   aes-128-cfb aes-192-cfb aes-256-cfb</span></span><br><span class="line">  <span class="comment">#   aes-128-ctr aes-192-ctr aes-256-ctr</span></span><br><span class="line">  <span class="comment">#   rc4-md5 chacha20 chacha20-ietf xchacha20</span></span><br><span class="line">  <span class="comment">#   chacha20-ietf-poly1305 xchacha20-ietf-poly1305</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"ss1"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">ss</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    cipher:</span> <span class="string">chacha20-ietf-poly1305</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">"password"</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># vmess</span></span><br><span class="line">  <span class="comment"># 支持加密方式：auto / aes-128-gcm / chacha20-poly1305 / none</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"vmess"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">vmess</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    uuid:</span> <span class="string">uuid</span></span><br><span class="line"><span class="attr">    alterId:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">    cipher:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># tls: true</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">    <span class="comment"># servername: example.com # 优先级高于 wss host</span></span><br><span class="line">    <span class="comment"># network: ws</span></span><br><span class="line">    <span class="comment"># ws-opts:</span></span><br><span class="line">    <span class="comment">#   path: /path</span></span><br><span class="line">    <span class="comment">#   headers:</span></span><br><span class="line">    <span class="comment">#     Host: v2ray.com</span></span><br><span class="line">    <span class="comment">#   max-early-data: 2048</span></span><br><span class="line">    <span class="comment">#   early-data-header-name: Sec-WebSocket-Protocol</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"vmess-http"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">vmess</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    uuid:</span> <span class="string">uuid</span></span><br><span class="line"><span class="attr">    alterId:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">    cipher:</span> <span class="string">auto</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># network: http</span></span><br><span class="line">    <span class="comment"># http-opts:</span></span><br><span class="line">    <span class="comment">#   # method: "GET"</span></span><br><span class="line">    <span class="comment">#   # path:</span></span><br><span class="line">    <span class="comment">#   #   - '/'</span></span><br><span class="line">    <span class="comment">#   #   - '/video'</span></span><br><span class="line">    <span class="comment">#   # headers:</span></span><br><span class="line">    <span class="comment">#   #   Connection:</span></span><br><span class="line">    <span class="comment">#   #     - keep-alive</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">vmess-grpc</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">vmess</span></span><br><span class="line"><span class="attr">    uuid:</span> <span class="string">uuid</span></span><br><span class="line"><span class="attr">    alterId:</span> <span class="number">32</span></span><br><span class="line"><span class="attr">    cipher:</span> <span class="string">auto</span></span><br><span class="line"><span class="attr">    network:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">    tls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    servername:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line"><span class="attr">    grpc-opts:</span></span><br><span class="line"><span class="attr">      grpc-service-name:</span> <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># socks5</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"socks"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">socks5</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line">    <span class="comment"># username: username</span></span><br><span class="line">    <span class="comment"># password: password</span></span><br><span class="line">    <span class="comment"># tls: true</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># http</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"http"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line">    <span class="comment"># username: username</span></span><br><span class="line">    <span class="comment"># password: password</span></span><br><span class="line">    <span class="comment"># tls: true # https</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Trojan</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"trojan"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">trojan</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span>  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"trojan"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">trojan</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">yourpsk</span></span><br><span class="line">    <span class="comment"># udp: true</span></span><br><span class="line">    <span class="comment"># sni: example.com # aka server name</span></span><br><span class="line">    <span class="comment"># alpn:</span></span><br><span class="line">    <span class="comment">#   - h2</span></span><br><span class="line">    <span class="comment">#   - http/1.1</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">trojan-grpc</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">trojan</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">"example"</span></span><br><span class="line"><span class="attr">    network:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">    sni:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line"><span class="attr">    udp:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    grpc-opts:</span></span><br><span class="line"><span class="attr">      grpc-service-name:</span> <span class="string">"example"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">trojan-ws</span></span><br><span class="line"><span class="attr">    server:</span> <span class="string">server</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">trojan</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">"example"</span></span><br><span class="line"><span class="attr">    network:</span> <span class="string">ws</span></span><br><span class="line"><span class="attr">    sni:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="comment"># skip-cert-verify: true</span></span><br><span class="line"><span class="attr">    udp:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># ws-opts:</span></span><br><span class="line">      <span class="comment"># path: /path</span></span><br><span class="line">      <span class="comment"># headers:</span></span><br><span class="line">      <span class="comment">#   Host: example.com</span></span><br></pre></td></tr></table></figure><p>我用的是原版 SS，SSR 上面没贴，如果需要支持 UDP，需要手动开启；Trojan 也支持，听说很牛逼，vmess 如果效果还是不理想可以切换试试看，我暂时还没用过。<br>我主力就是 vmess，订阅模式使用 proxy-providers 来定义，体验应该最好，使用的时候通过 use 关键字。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Proxy</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">url-test</span></span><br><span class="line"><span class="attr">    use:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">provider1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line"><span class="attr">  provider1:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line">    <span class="comment"># 使用 url 在线订阅</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"url"</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./conf/provider1.yaml</span></span><br><span class="line"><span class="attr">    health-check:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      interval:</span> <span class="number">600</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://cp.cloudflare.com/generate_204</span></span><br><span class="line"><span class="attr">  test:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">file</span></span><br><span class="line">    <span class="comment"># 从文件中读取</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/test.yaml</span></span><br><span class="line">    <span class="comment"># 可以使用正则来过滤节点</span></span><br><span class="line"><span class="attr">    filter:</span> <span class="string">'(香港|台湾|美国).*'</span></span><br><span class="line"><span class="attr">    health-check:</span></span><br><span class="line"><span class="attr">      enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      interval:</span> <span class="number">36000</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://www.gstatic.com/generate_204</span></span><br></pre></td></tr></table></figure><p>使用 proxy-providers 省去了我们自己维护 proxy 节点，直接从在线或者本地文件读取 proxy 节点信息，其他规则还是我们自己定义，顺便提一嘴，如果你没机场只是偶尔临时用，可以看看 <a href="https://github.com/zu1k/proxypool" target="_blank" rel="noopener">proxypool</a> 这个项目，从互联网爬取免费的节点，还有好心人提供了 proxy-providers 的在线地址，可以临时顶一顶，不过毕竟免费风险还是有的，这个自己取舍。</p><p>订阅模式需要注意的是拉取的不一定只有节点，包括代理组、规则集可能都有，这样就可能面临一个问题，如果你使用远程订阅，你自定义的一些规则等配置在下一次更新订阅后可能会丢失，使用 proxy-providers 是一个很不错的解决方案，我目前就是使用的这种方式来订阅多个机场，并且统一使用我自定义的配置，或者也可以尝试使用 Parser 规则解决。<br>如果你的机场不提供 clash 订阅连接，可以使用在线服务进行转换，这个一搜一大堆不多说。</p><h2 id="代理组"><a href="#代理组" class="headerlink" title="代理组"></a>代理组</h2><p>这部分也很重要，配合上门的节点分组，避免一个节点挂掉还得手动换，选择最佳的节点连接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="comment"># 代理的转发链, 在 proxies 中不应该包含 relay. 不支持 UDP.</span></span><br><span class="line">  <span class="comment"># 流量: clash &lt;-&gt; http &lt;-&gt; vmess &lt;-&gt; ss1 &lt;-&gt; ss2 &lt;-&gt; 互联网</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"relay"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">relay</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">http</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">vmess</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># url-test 可以自动选择与指定 URL 测速后，延迟最短的服务器</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"auto"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">url-test</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss1</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">'http://www.gstatic.com/generate_204'</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">300</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"auto"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="comment"># 使用订阅节点</span></span><br><span class="line"><span class="attr">    use:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">provider1</span></span><br><span class="line"><span class="attr">    tolerance:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># fallback 可以尽量按照用户书写的服务器顺序，在确保服务器可用的情况下，自动选择服务器</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"fallback-auto"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">fallback</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss1</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">'http://cp.cloudflare.com/generate_204'</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># load-balance 可以使相同 eTLD 请求在同一条代理线路上</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"load-balance"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">load-balance</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">vmess1</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">'http://www.youtube.com/generate_204'</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># select 用来允许用户手动选择 代理服务器 或 服务器组</span></span><br><span class="line">  <span class="comment"># 您也可以使用 RESTful API 去切换服务器，这种方式推荐在 GUI 中使用</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Proxy</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">select</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ss2</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">vmess1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure><p>这里注意 Proxy 这个关键组，GUI 默认使用这个（其实是后面的规则配的是这个），它的类型是 select 可以允许我们在 GUI 中手动选择一个节点或者组，默认我使用 auto，也就是 url-test 模式的。<br>如果你在配置文件中设置了 tolerance，Clash 将会计算所有代理服务器的延迟时间，然后以最快的代理服务器的延迟时间为基准，根据 tolerance 的值来筛选其他的代理服务器。只有当一个代理服务器的延迟时间小于基准延迟时间加上 tolerance 时，它才会被选择作为请求的代理服务器，换句话说就是只要在这个范围就不会自动切换，以避免频繁切换带来的体验差。</p><h2 id="规则集"><a href="#规则集" class="headerlink" title="规则集"></a>规则集</h2><p>这个功能只有 Pro 版本才支持，普通版只有规则；简单说就是一组规则的集合，只不过可以在线获取，定时更新，也就是可以直接用别人写好的分流规则，非常爽啊：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule-providers:</span></span><br><span class="line"><span class="attr">  apple-direct:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/Basic/Apple-direct.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/Apple-direct.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  icloud:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">domain</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/icloud.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  apple:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">domain</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/apple.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  private:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">domain</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/private.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cn:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/Basic/CN.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/CN.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  ad-keyword:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/Basic/common-ad-keyword.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/common-ad-keyword.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  foreign:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/Basic/foreign.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/foreign.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  telegram:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/App/social/Telegram.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/Telegram.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  lan:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    behavior:</span> <span class="string">classical</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">"https://cdn.jsdelivr.net/gh/Hackl0us/SS-Rule-Snippet@master/Rulesets/Clash/Basic/LAN.yaml"</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">./ruleset/LAN.yaml</span></span><br><span class="line"><span class="attr">    interval:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  microsoft:</span> <span class="string">&#123;type:</span> <span class="string">http,</span> <span class="attr">behavior:</span> <span class="string">classical,</span> <span class="attr">path:</span> <span class="string">./Filter/Microsoft,</span> <span class="attr">url:</span> <span class="attr">https://cdn.jsdelivr.net/gh/Semporia/Clash-X@master/Filter/Microsoft.yaml,</span> <span class="attr">interval:</span> <span class="number">3600</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>然后配置下最终规则，整个配置就算完成了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,private,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,icloud,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,apple,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,microsoft,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">DOMAIN,clash.razord.top,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">DOMAIN,yacd.haishan.me,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,apple-proxy,Proxy</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,apple-direct,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,cn,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,ad-keyword,REJECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,foreign,Proxy</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,telegram,Proxy</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RULE-SET,lan,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">GEOIP,CN,DIRECT</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">MATCH,Proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - RULE-SET,apple,DIRECT,no-resolve</span></span><br></pre></td></tr></table></figure><p>这里说下 Clash 支持的几种规则；</p><ul><li>DOMAIN-SUFFIX：域名后缀匹配</li><li>DOMAIN：域名匹配</li><li>DOMAIN-KEYWORD：域名关键字匹配</li><li>IP-CIDR：IP段匹配</li><li>SRC-IP-CIDR：源IP段匹配</li><li>GEOIP：GEOIP 数据库（国家代码）匹配</li><li>DST-PORT：目标端口匹配</li><li>SRC-PORT：源端口匹配</li><li>PROCESS-NAME：源进程名匹配</li><li>RULE-SET：Rule Provider 规则匹配</li><li>MATCH：全匹配</li></ul><p>写法上面已经有示例了，特别的情况，如果你不想让 Clash 进行 DNS 解析，可以在后面加上 no-resolve。<br>自带的两种规则是 REJECT 和 DIRECT，很好理解，广告相关的一般直接使用 REJECT，不需要代理的就使用 DIRECT，剩下的就需要指定我们配的代理组，例如本例的 Proxy。<br><code>MATCH</code>需要位于规则列表末尾，除了那些漏网之鱼。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>同样，这也是 Pro 的专有功能，除了全局、直连、规则，还增加了一个更灵活的脚本模式，来应对日益增多的 Rule 规则。但是目前用的人很少，我也没这个需求，暂不关注。<br>如果有更个性化的节点处理需求，可以尝试使用 parsers。</p><h2 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h2><p>如果 Clash 不能满足你的需求，可以尝试 <a href="https://github.com/MetaCubeX/Clash.Meta" target="_blank" rel="noopener">Clash.Meta</a> 版本，对应的 GUI 推荐 <a href="https://github.com/zzzgydi/clash-verge" target="_blank" rel="noopener">clash-verge</a>，可能会满足你的需求。</p><h2 id="参考规则"><a href="#参考规则" class="headerlink" title="参考规则"></a>参考规则</h2><p>这里推荐几个开箱即用的规则：</p><p><a href="https://github.com/DivineEngine/Profiles" target="_blank" rel="noopener">Profiles</a><br><a href="https://github.com/Loyalsoldier/clash-rules" target="_blank" rel="noopener">clash-rules</a><br><a href="https://github.com/Hackl0us/SS-Rule-Snippet" target="_blank" rel="noopener">SS-Rule-Snippet</a><br><a href="https://github.com/Hackl0us/GeoIP2-CN" target="_blank" rel="noopener">GeoIP2-CN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起因还要从去年还是前年的那次大规模封杀说起，因为种种原因 SS 原作者早已弃坑，SSR 作者也是如此，以现在的防火墙技术识别 SS 的流量特征应该不难，每次都是大规模的『关机保平安』；&lt;br&gt;我买的机场也开始提供 SS + V2ray 的方式，并且建议优先使用 V2ray，我也就顺势切换了，接下来遇到的一个问题就是 SS 客户端不支持，需要找一个替代的，最好多种协议都支持，一轮调研下来，Clash 脱颖而出（当时起码是 Star 最高的），于是就开始使用 ClashX。
    
    </summary>
    
      <category term="其他" scheme="https://sakanoy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="工具" scheme="https://sakanoy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java核心编程知识索引</title>
    <link href="https://sakanoy.com/2020/07/03/Java%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%95/"/>
    <id>https://sakanoy.com/2020/07/03/Java核心编程知识索引/</id>
    <published>2020-07-03T12:46:54.000Z</published>
    <updated>2024-11-14T17:46:09.405Z</updated>
    
    <content type="html"><![CDATA[<p>这篇索引并不会介绍过多语言层面的基础概念，侧重点主要在于 JVM 和 JUC 这两块，属于 Java 中比较进阶的知识了，我的知识也主要来自于两本书：《深入理解Java虚拟机》和《Java并发编程的艺术》以及网上搜集的资料，这两本书写的非常棒，入门是够了，通篇基本没废话，我的笔记也基本都是摘录自这两本书。<br>也正是如此，相关总结就直接放到 Github 了，不抄到这里了，这一篇主要来列一个大纲，以及做一些补充。<a id="more"></a></p><h2 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h2><p>点击可直达，基本是我自己总结的书中的重点（我觉得），当然一些太高深我理解不了的东西也跳过了，比如 JVM 的源码，C++、汇编、编译原理相关的。</p><p>而 Java 语言基础这里基本不涉及，大多数都是内建 API 和语法之类的东西，有个两三年学习经验的基本都比较熟的，不同语言之间差距也不大，复盘可参考笔记『<a href="http://dwz.date/btpG" target="_blank" rel="noopener">Java基础复习计划</a>』和我博客里搜索『Java基础』关键字，配合下面 JVM 等相关知识，会有更深入的理解。</p><p>由于目前 Java8 已经进入大众阶段，也不再单独介绍相关特性，复盘还是参考我的笔记和博客亦或者《Java8实战》这本书，之前写过相关笔记。</p><ul><li><a href="http://dwz.date/btqd" target="_blank" rel="noopener">深入理解JVM(一)</a><br>内存区域划分、GC 前置基础知识、JDK7 之前的内置 GC 解析。</li><li><a href="http://dwz.date/btqm" target="_blank" rel="noopener">深入理解JVM(二)</a><br>类文件结构、类加载过程</li><li><a href="http://dwz.date/btqq" target="_blank" rel="noopener">深入理解JVM(补全)</a><br>类文件相关补充、常量池、字节码指令、JIT 优化、并发与锁等</li><li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/Java/基础/一入Java深似海.md" target="_blank" rel="noopener">一入Java深似海</a><br>总结自小马哥的课程，对 Java 基础的深入探讨，另一种不同的角度去看待 Java。</li><li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/Java/NewFeature/Java11 Features.md" target="_blank" rel="noopener">Java11 Features</a><br>Java 8 - 11 新特性总结</li><li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/Java/基础/Java并发编程.md" target="_blank" rel="noopener">Java并发编程</a><br>《Java并发编程的艺术》笔记</li><li>深入JVM第三版补充（未完成）</li><li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/笔记/重构的艺术.md" target="_blank" rel="noopener">重构的艺术</a><br>教你如何优雅的优化你写的代码，除了《重构》另外一本比较老的书没事也可以看看《代码整洁之道》</li></ul><p>主要还是侧重 JVM、JUC、Java 基础这些东西，上面的笔记都挺长的，平均每一篇也得至少 1w+ 字，我觉得可都是精华。</p><h2 id="JVM知识点"><a href="#JVM知识点" class="headerlink" title="JVM知识点"></a>JVM知识点</h2><p>算是提纲吧，看着这个能说出来就不错了，忘记了就去相关笔记里翻吧。</p><ul><li><strong>运行时数据区域划分与职责</strong><br>方法区、程序计数器、虚拟机栈、本地方法栈、堆；HotSpot 的实现。<br>永久代与直接内存（元空间）</li><li><strong>对象访问定位</strong><br>句柄、直接指针</li><li><strong>GC基础</strong><br>判断对象死活：引用计数（循环引用）、可达性分析、GCRoots；<br>引用：强软弱虚；拓展之 ThreadLocal、直接引用；<br>方法区回收；<br>HotSpot 实现：枚举根节点 STW、安全点（抢先式中断、主动式中断）、安全区域；<br>MinorGC、MajorGC/FullGC、动态年龄；</li><li><strong>GC方案</strong><br>分代收集、标记清除、复制算法（担保机制）、标记整理；<br>收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS（标记清除、低停顿）、G1；<br>新收集器：Epsilon、ZGC、Shenandoah</li><li>JDK提供的分析工具<br>经典：jps、jinfo、jstat、jstack、jconsole、jmap、VisualVM；<br>新增：JFR、JMC、jshell</li><li><strong>类文件</strong><br>8 字节为单位二进制流、魔数、常量池（u2 自定义大小，包含字面量[表类型]和符号引用）、访问标志、字段表（字段重载）、方法表（重载）、属性表（严格顺序，可定制，其他表引用，32 位 solt 复用，u4/u2 方法长度 Code）、字节码指令（一个字节，非填充对齐，精简 int）</li><li><strong>JVM 加载机制</strong><br>加载、连接（验证、准备、解析）、初始化、使用、卸载；<br>零值、init/cinit、符号引用、直接引用、对象创建；<br>类加载器：双亲委派模型、Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader、破坏（模块化与动态性、OSGi、JDBC、SPI、JNDI）</li><li><strong>字节码执行引擎</strong><br>基于栈（可移植，紧凑、实现简单、速度慢）、基于寄存器、32 bit solt（64 位的原子性问题）、动态连接、虚方法、非虚方法、动态分派（重写覆盖）、静态分派（多态）；<br>重叠操作数栈复用；</li><li><strong>编译器（早期）优化</strong><br>词法分析、语法分析（AST）、语法糖、注解处理器（Lombok 生成）、语义分析与字节码生成、自动拆箱、循环遍历（迭代器）；<br>方案：常量折叠、final 校验、解语法糖、字节码提升/生成（字符串拼接 SB）、条件编译、泛型擦除；<br>（动态）提前编译（AOT）：JDKJaotc、GCJ 等；以及 Android 的 ART（蹂躏 Dalvik）</li><li><strong>运行时（晚期）优化</strong><br>解释器+编译器混合模式、逃生门（逆优化）、Client Compiler（c1）、Server Compiler（c2）、分层编译（3 层）、JIT 基于方法；<br>热点代码：方法（方法调用计数器）、循环（回边计数器，跑分）、基于采样热点探测（除前两种的其他）、基于计数热点探测、热度衰减、栈上替换（OSR）编译；<br>c1：简单的三段式编译，速度快，优化例如：方法内联、消除访问冗余、复写传播、无用代码消除。<br>c2：JIT + 监控，激进优化+逃生门，公共子表达式消除、数组边界检查消除、方法内联、逃逸分析（方法、线程逃逸，栈上分配、同步消除、标量替换）</li><li><strong>锁优化</strong><br>适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁、锁升级（锁膨胀）</li></ul><p>在《深入理解JVM》中也提到过一些 JUC 的知识，不过仅仅是入门，这里就不列了放到 JUC 条目中。</p><hr><p>选择 GC 的指导原则：</p><ul><li>如果应⽤属于⼩规模数据应⽤（内存资源⼤概在 100 MB 左右）的话，那么串⾏收集器是⼀种不错的选择（-XX:+UseSerialGC）</li><li>如果应⽤运⾏在单处理器并对停顿时间不敏感的话，那么它可以考虑串⾏收集器（XX:+UseSerialGC）</li><li>如果应⽤属于性能敏感但停顿时间要求不⾼（如停顿⼀秒以上）的话，那么它可以选择并⾏收集 器（-XX:+UseParallelGC）</li><li>如果应⽤认为响应时间⽐吞吐量和停顿时间更为重要的话，那么它可以考虑 CMS 或 G1 收集器</li></ul><p>当应⽤在单处理器中运⾏时，Parallel Collector 不会⽐ Serial Collector 表现更好，因为并⾏ 执⾏反⽽需要额外的开销（如同步和线程切换等）</p><p>当应⽤在双处理器中运⾏时，即使 Heap 达到中型或⼤型的空间，Serial Collector 可能是最 合适的选择。</p><p>Parallel Collector ⽬标调整：</p><ul><li>最⼤垃圾收集停顿时间（Pause Times），默认无限制</li><li>吞吐量（Throughput），决定于垃圾收集与其他应⽤执⾏时间的占⽐ 通过 JVM 参数 <code>-XX:GCTimeRatio=&lt;N&gt;</code> 调整 GC 时间与⾮ GC 时间的⽐重，GC 停顿时间等于 1 / N+1 N 默认值为 99，意味着 GC 时间占 1/100 的应⽤执⾏时间</li><li>内存⾜迹（Footprint），指定各空间的大小。</li></ul><p>JVM 默认的优先级顺序就是如上，Parallel Collector 每次垃圾收集过后，收集器将会保存并更新相关的统计信息，如平均的停顿时间。</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p>这里暂时先说一下比较容易忽视的知识点或者骚操作，那些面试常客，基本的就略过了。</p><ul><li>语言基础<br>Java 访问修饰符是否四种？（JDK9 前后）、异常打印建议限制堆栈的深度；<br>Java 是否是纯面向对象的？（原生类型）<br>String 是否是不可变？（反射）、评价 Clone 方法（设计缺陷）、集合的线程安全（View）；<br>可以在 final 修饰类中定义抽象方法？（枚举、字节码提升）；<br>取余转为位运算（限制条件）、函数式编程、ClassLoader 加载（异常）、GC选择</li><li>集合框架<br>ConcurrentHashMap 或者说线程安全的 Map，为什么不允许 null 元素？（消歧义）；<br>Set、List、Map、Deque、<code>Navigable*</code>、Array/Linked/Tree；<br>单例扩展：<code>Collections.singleton*</code>、空集合、转换集合接口、列举集合接口（of）；<br>集合包装（Collections）：只读（unmodifiable）、同步（synchronized）、类型安全（checked，避免泛型擦除影响）；<br>特殊集合：优先级队列 PriorityQueue，枚举 Set： EnumSet；<br>覆盖 equals 是否要覆盖 hashcode（建议），反之呢（必须），集合的比较重复逻辑（<code>hashcode &amp;&amp; (== || equals)</code>）<br>鉴定 Map：IdentityHashMap（覆盖了 hashcode）MethodHandle；<br>是否有必要覆盖 POJO 的 hashcode 和 eq？（用于 map、比较、排序建议覆盖，默认的递归层次深）；<br>自带排序：插入（7-）、快排（7+）、Tim排序（对象类型，更多的数量）</li><li>并发基础<br>ReentrantLock、ReentrantReadWriteLock、StampedLock（读多写少，读写锁升级版）；<br>线程池（默认的『无限』等待队列也不是很要紧，Tomcat、Nginx 这种会挡掉大部分）；<br>CountDownLatch、CyclicBarrier、Semaphore 、ThreadPoolExecutor 和 ScheduledExecutorService；<br>并发集合：CopyOnWrite、ConcurrentSkipList、ConcurrentHashMap、BlockingQueue、Fork/Join、CompletableFuture、Flow（JDK9）、大小计算（并发集合中 size 一般是需要计算的）、InterruptedException；<br>其他参考<a href="#并发编程">并发编程</a>的列举</li><li>Java元编程<br>JavaBeans（参考 Spring 的 ApplicationContextEvent）、Introspection、APT（Lombok、META-INF）</li><li>I/O<br>NIO2、Fluent API（Builder API、Chain API）、try-with-resources（AutoCloseable）；<br>NIO：Buffers（0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity）、Channels、Selectors、flip、rewind、Channels；<br>其他：压缩（compact）、标记（mark，mark 设置为 position）、复制（duplicate）等</li><li>其他<br>ListIterator、快速失败（fail-fast）、失败安全（fail-safe）、user.dir、<code>-XX:+PrintFlagsFinal</code></li></ul><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>这里提一句，美团技术团队的博客写的不错，个人比较推崇的 Java 国内圈俩神仙：美团技术团队和阿里中间件团队。</p><ul><li>处理器实现原子操作<br>锁缓存、锁总线、Java 中 CAS 的缺点</li><li>再谈Volatile<br>缓存一致性协议，总线嗅探、缓存行对齐（JIT 无效化）、JVM 通过 lock 指令实现</li><li>再谈Synchronized<br>偏向锁获得和撤销、轻量级锁及膨胀、优缺点与使用场景</li><li><strong>JMM</strong><br>解决主要矛盾（如何通讯、如何同步）、解决方案（共享内存和消息传递）、抽象概念；<br>三种重排、内存屏障、happens-before 规则、顺序一致性、final 域（static、Synchronized）</li><li><strong>AQS</strong><br>等待/通知经典范式（唤醒要继续判断）、等待超时模式、Lock 接口；<br>AQS 使用方式、可重写方法、模版方法（三类）、同步队列、独占式、共享式、何时阻塞、读写锁；<br>LockSupport 工具类、Condition 接口、等待队列（多对一）</li><li>JUC<br>ConcurrentHashMap 原理（Java8 前后）、ConcurrentLinkedQueue（HOPS 优化更新频率）、长度计算；<br>线程池、FutureTask</li></ul><h2 id="JVM性能监控与调优"><a href="#JVM性能监控与调优" class="headerlink" title="JVM性能监控与调优"></a>JVM性能监控与调优</h2><p>我们并不能保证写的代码都是安全、高效的，尤其是时间紧的情况下，很多时候生产环境下跑才会发现问题，这时候如果有服务器权限并且我们有能力找出问题并解决，那么也是一个非常棒的技能。<br>最常见的就是 GC （内存泄漏）和线程（死锁、死循环）相关引起的问题。</p><p>TBD</p><p>临时参考博客的<a href="https://bfchengnuo.com/2019/03/29/Java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇索引并不会介绍过多语言层面的基础概念，侧重点主要在于 JVM 和 JUC 这两块，属于 Java 中比较进阶的知识了，我的知识也主要来自于两本书：《深入理解Java虚拟机》和《Java并发编程的艺术》以及网上搜集的资料，这两本书写的非常棒，入门是够了，通篇基本没废话，我的笔记也基本都是摘录自这两本书。&lt;br&gt;也正是如此，相关总结就直接放到 Github 了，不抄到这里了，这一篇主要来列一个大纲，以及做一些补充。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Golang之并发编程</title>
    <link href="https://sakanoy.com/2020/07/02/Golang%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://sakanoy.com/2020/07/02/Golang之并发编程/</id>
    <published>2020-07-02T12:29:02.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>接上次的基础语法部分，还剩下的主要是并发相关的内容，现在补全；也略微提及了点测试相关的内容；<br>在 Go 中，并发程序主要使用的是 Go 的 goroutine 和 channel；相对传统的语言，简化了很多，调度上的调整也使程序高效了很多；没讲到的应该就是反射和 Web，这两块以后随用随学吧，目前这些东西也够了。<br>没有贴太多的代码，以及剩下的 Go 标准库使用的相关代码都放到这个仓库了： <a href="https://github.com/bfchengnuo/GoCS" target="_blank" rel="noopener">bfchengnuo/GoCS</a><a id="more"></a></p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go 语言的并发主要通过 goroutine 实现。goroutine <strong>类似于</strong>线程，属于<strong>用户态的线程</strong>，我们可以根据需要创建成千上万个 goroutine 并发工作。goroutine 是由 Go 语言的运行时（runtime）调度完成，<strong>而线程是由操作系统调度完成</strong>。<br>Go 语言还提供 channel 用于在多个 goroutine 间进行通信。goroutine 和 channel 是 Go 语言秉承的 CSP（Communicating Sequential Process）现代并发模式的重要实现基础。</p><p>传统上我们实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，还要处理好调度问题，一不小心就出问题，还难以调试；那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到 CPU 上实现并发执行呢？<br>Go 语言中的 goroutine 就是这样一种机制，goroutine 的概念类似于线程，但 goroutine 是由 Go 的运行时（runtime）调度和管理的。<strong>Go 程序会智能地将 goroutine 中的任务合理地分配给每个CPU</strong>。<br>Go 语言之所以被称为现代化的编程语言，就是因为它<strong>在语言层面已经内置了调度和上下文切换的机制</strong>。</p><p>在 Go 语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能：goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。<br>Go 语言中使用 goroutine 非常简单，<strong>只需要在调用函数的时候在前面加上 go 关键字</strong>，就可以为一个函数创建一个 goroutine。<br>一个 goroutine 必定对应一个函数，可以创建多个 goroutine 去执行相同的函数。</p><blockquote><p>主函数也是运行在一个 goroutine 中，我们称为 main goroutine；当主函数返回时，所有的 goroutine 都会被直接打断，程序退出，这也算是一种终结 goroutine 的方式。<br>另一种比较友好的方式就是使用 goroutine 之间的通信来告知其他 goroutine 自行结束。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 的并发主要依赖 goroutine 和 channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>) <span class="comment">// 计数 +1</span></span><br><span class="line">    <span class="keyword">go</span> hello(i) <span class="comment">// 值传递，copy</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有 wg 完成</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine 结束就登记 -1</span></span><br><span class="line">  fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免主线程结束其他打断 goroutine，暂时使用了 sync 的 WaitGroup 进行计数等待。</p><h3 id="可增长栈"><a href="#可增长栈" class="headerlink" title="可增长栈"></a>可增长栈</h3><p>OS 线程（操作系统线程）一般都有固定的栈内存（通常为 2MB）,一个 goroutine 的栈在其生命周期<strong>开始时</strong>只有很小的栈（典型情况下 2KB），goroutine 的栈是<strong>不固定的</strong>，他可以按需增大和缩小，goroutine 的栈大小限制<strong>可以达到 1GB</strong>，虽然极少会用到这个大。所以在 Go 语言中一次创建十万左右的 goroutine 也是可以的。</p><h3 id="GPM调度"><a href="#GPM调度" class="headerlink" title="GPM调度"></a>GPM调度</h3><p>GPM 是 Go 语言运行时（runtime）层面的实现，是 go 语言自己实现的一套调度系统。区别于操作系统调度 OS 线程。</p><ul><li>G 很好理解，就是 goroutine，里面除了存放本 goroutine 信息外 还有与所在 P 的绑定等信息。</li><li>P 管理着<strong>一组</strong> goroutine 队列，P 里面会存储<strong>当前</strong> goroutine 运行的上下文环境（函数指针，堆栈地址及地址边界），P 会对自己管理的 goroutine 队列做一些调度（比如把占用 CPU 时间较长的 goroutine 暂停、运行后续的 goroutine 等等）当自己的队列消费完了就去<strong>全局队列里</strong>取，如果全局队列里也消费完了会<strong>去其他 P 的队列里抢任务</strong>。</li><li>M（machine）是 Go 运行时（runtime）对操作系统内核线程的虚拟， <strong>M 与内核线程一般是一一映射的关系</strong>， 一个 groutine 最终是要放到 M 上执行的；</li></ul><p><strong>P 与 M 一般也是一一对应的</strong>。他们关系是： P 管理着一组 G 挂载在 M 上运行。<br>当一个 G 长久阻塞在一个 M 上时，runtime 会新建一个 M，这时 P 会把其他阻塞的 G 挂载在新建的 M 上。当耗时的 G 阻塞完成或者认为其已经死掉时，会回收旧的 M。</p><p>P 的个数是通过 <code>runtime.GOMAXPROCS</code> 设定（最大 256），Go1.5 版本之后默认为物理线程数。 在并发量大的时候会增加一些 P 和 M，但不会太多，切换太频繁的话得不偿失；这个值可以理解为<strong>有多少个系统线程同时执行 Go 代码</strong>。</p><blockquote><p>Go 运行时的调度器使用 GOMAXPROCS 参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，调度器会把 Go 代码同时调度到 8 个 OS 线程上。<br>Go 语言中可以通过 <code>runtime.GOMAXPROCS()</code> 函数设置当前程序并发时占用的 CPU 逻辑核心数。<br>Go1.5 版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的 CPU 逻辑核心数（跑满！）。</p></blockquote><p>单从线程调度讲，Go 语言相比起其他语言的优势在于 OS 线程是由 OS 内核来调度的，goroutine 则是由 Go 运行时（runtime）自己的调度器调度的，这个调度器使用一个称为 <code>m:n</code> 调度的技术（复用/调度 m 个 goroutine 到 n 个 OS 线程）。</p><blockquote><p>goroutine 的调度是在用户态下完成的，<strong>不涉及内核态与用户态之间的频繁切换</strong>，包括内存的分配与释放，都是在用户态维护着一块大的内存池，不直接调用系统的 malloc 函数（除非内存池需要改变），成本比调度 OS 线程低很多。<br>另一方面充分利用了多核的硬件资源，近似的把若干 goroutine 均分在物理线程上，再加上本身 goroutine 的超轻量，保证了 go 调度方面的性能。</p></blockquote><p>Go 中的 goroutine 与操作系统线程的区别：</p><ul><li>一个操作系统线程对应用户态多个 goroutine</li><li>go 程序可以同时使用多个操作系统线程</li><li>goroutine 和 OS 线程是多对多的关系，即 <code>m:n</code></li></ul><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。<br>Go 语言并发编程模型提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。<br>可以将 channel 看作 goroutine 之间的连接。channel 是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。<br>channel 遵循先进先出（FIFO），保证收发数据的顺序，并且 channel 具有具体的类型，一个 channel 只允许同一种类型通过；它可以进行比较，如果引用的是相同对象即为真。<br>通道有发送（send）、接收(receive）和关闭（close）三种操作。发送和接收都使用 <code>&lt;-</code> 符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义</span></span><br><span class="line">  <span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 第二个参数是缓冲区大小，可选</span></span><br><span class="line">  <span class="keyword">var</span> ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(ch1 == <span class="literal">nil</span>) <span class="comment">// 零值，必须使用 make 初始化后才能使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// send</span></span><br><span class="line">  ch2 &lt;- <span class="number">233</span></span><br><span class="line">  <span class="comment">// receive</span></span><br><span class="line">  fmt.Println(&lt;-ch2)</span><br><span class="line">  <span class="comment">// 丢弃</span></span><br><span class="line">  &lt;-ch2</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动关闭，非必须，可由 GC 感知回收</span></span><br><span class="line">  <span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭通道。通道是<strong>可以被垃圾回收机制回收的</strong>，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。<br>对一个关闭的通道来说：</p><ul><li>发送值就会导致 panic。</li><li>进行接收会一直获取值直到通道为空。</li><li>如果没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ul><p>通道分为带缓存和无缓存，或者叫缓冲，区别就是 make 的时候传没传第二个参数，这两种有点细微区别；</p><ul><li><p>无缓存通道<br>无缓冲的通道又称为阻塞的通道，因为向无缓存通道发送数据，必须要有人在接收值，否则会一直阻塞。<br>当两个 goroutine 进行无缓存通道通信时，就会导致发送接收的同步化，所有又被称为是『同步通道』；<br>通过 channel 可以将多个 goroutine 串联起来。</p></li><li><p>有缓存通道<br>可以看作里面维护了一个队列，可以使用内置的 len 函数获取通道内元素的数量，使用 cap 函数获取通道的容量，虽然我们很少会这么做。<br>其他方面与无缓存类似，只不过是通道满了以后才阻塞；</p></li></ul><p>从管道取内容的时候，为了避免关闭后取完一直是零值，我们可以使用 for-range 的方式，取完之后会自动结束；虽然使用 ok 判断也能实现，但是 range 的方式更加优雅。</p><h3 id="单方向的通道"><a href="#单方向的通道" class="headerlink" title="单方向的通道"></a>单方向的通道</h3><p>多个 goroutine 使用通道进行传值的时候，很多情况是单向的，为了避免乱传，可以使用 Go 提供的单向通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan&lt;- int  单向向通道输出</span></span><br><span class="line"><span class="comment">// x &lt;- chan int 单向从通道输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">    out &lt;- i * i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数传参及任何赋值操作中可以<strong>将双向通道转换为单向通道</strong>，但反过来是不可以的。</p><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>Go 内置了 select 关键字，可以同时响应多个通道的操作。<br>它使用类似于 switch 语句，它有一系列 case 分支和一个默认的分支。每个 case 会对应一个通道的通信（接收或发送）过程。 select 会一直等待，直到某个 case 的通信操作完成时，就会执行 case 分支对应的语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">      <span class="comment">// 0  2  4  6  8，因为大小为 1</span></span><br><span class="line">      fmt.Println(x)</span><br><span class="line">      <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">      fmt.Println(<span class="string">"send "</span>, i)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">"默认操作"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Duration(<span class="number">5</span>) * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用多路复用使代码更易读，并且有以下特性：</p><ul><li>可处理一个或多个 channel 的发送/接收操作。</li><li>如果多个 case 同时满足，select 会随机选择一个。</li><li>对于没有 case 的 <code>select{}</code> 会一直等待，可用于阻塞 main 函数。</li></ul><h2 id="并发退出"><a href="#并发退出" class="headerlink" title="并发退出"></a>并发退出</h2><p>并发退出的情况是很常见的，让主线程直接结束的方式并不优雅，那就是最好通过通信完成；但是 channel 的消息被消费后其他的『线程』就获取不到了，所以，我们采用 close channel 的方式来广播退出通知：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 通过 close chan 并发退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在其他的『线程』中使用循环来 if 这个函数即可，主线程将 done 进行 close 其它的就会接受到这个信号，从而退出。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当设计操作共享变量的时候，自然就需要用到锁，虽然建议尽量使用 channel 完成逻辑；但是锁总是不可避免的；</p><ul><li>互斥锁<br>能保证只有一个 goroutine 进入临界区，唤醒策略是随机的；<br>互斥锁一般使用 <code>sync.Mutex</code> 的 lock 和 unlock 方法；</li><li>读写互斥锁<br>适用于读多写少的场景，读是不需要加锁的；<br>即如果 goroutine 获取的是读锁，其他 goroutine 还可以获得读锁进行读取；<br>如果 goroutine 获取了写锁，其他 goroutine 都需要等待；<br>读写锁使用 <code>sync.RWMutex</code> 的 lock/unlock 是写锁，rlock/runlock 是读锁；</li></ul><p>Go 语言中可以使用 <code>sync.WaitGroup</code> 来实现并发任务的同步；需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。<br>请注意，Go 中没有可重入锁的概念，请尽量避免使用，否则会导致死锁；<br>同时也要注意可见性的问题，在多核 CPU 执行期间，互相的缓存是不可见的。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>如果初始化消耗比较大，那么将初始化延迟进行是个不错的选择，并且是一次性的，例如配置文件的读取，sync.Once 就是来做这个事情的。<br>理论上来讲，一次性初始化需要一个互斥锁和一个布尔变量来记录是否初始化<strong>完成</strong>，还是牵扯指令重排的问题，避免获取到初始化一半的情况；例如用 once 实现的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">  once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    instance = &amp;singleton&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go 默认提供的 map 是非并发安全的，所以在 sync 下提供了并发安全的 map；它开箱即用表示不用像内置的 map 一样使用 make 函数初始化就能直接使用；同时还内置了 Store、Load、LoadOrStore、Delete、Range 等操作方法（也必须使用这些方法才能保证安全）。</p><h3 id="竞争检测"><a href="#竞争检测" class="headerlink" title="竞争检测"></a>竞争检测</h3><p>但是我们不可能想的那么全面，总有一些漏网之鱼的竞争关系，这时候可以使用 Go 提供的工具来检查，只要在 build、run、test 命令后面加上 <code>-race</code> 的 flag，具体的使用方法参考：<a href="https://golang.google.cn/ref/mem" target="_blank" rel="noopener">https://golang.google.cn/ref/mem</a></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>使用锁意味着上下文的切换都资源的消耗，针对<strong>基本类型</strong>我们还可以使用原子操作来保证并发安全，原子操作是 Go 语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go 语言中原子操作由内置的标准库 sync/atomic 提供。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">func LoadInt32(addr <em>int32) (val int32) <br>func LoadInt64(addr </em>int64) (val int64) <br>func LoadUint32(addr <em>uint32) (val uint32)<br>func LoadUint64(addr </em>uint64) (val uint64)<br>func LoadUintptr(addr <em>uintptr) (val uintptr)<br>func LoadPointer(addr </em>unsafe.Pointer) (val unsafe.Pointer)</td><td style="text-align:left">读取操作</td></tr><tr><td style="text-align:left">func StoreInt32(addr <em>int32, val int32) <br>func StoreInt64(addr </em>int64, val int64) <br>func StoreUint32(addr <em>uint32, val uint32) <br>func StoreUint64(addr </em>uint64, val uint64) <br>func StoreUintptr(addr <em>uintptr, val uintptr) <br>func StorePointer(addr </em>unsafe.Pointer, val unsafe.Pointer)</td><td style="text-align:left">写入操作</td></tr><tr><td style="text-align:left">func AddInt32(addr <em>int32, delta int32) (new int32) <br>func AddInt64(addr </em>int64, delta int64) (new int64) <br>func AddUint32(addr <em>uint32, delta uint32) (new uint32) <br>func AddUint64(addr </em>uint64, delta uint64) (new uint64) <br>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td style="text-align:left">修改操作</td></tr><tr><td style="text-align:left">func SwapInt32(addr <em>int32, new int32) (old int32) <br>func SwapInt64(addr </em>int64, new int64) (old int64) <br>func SwapUint32(addr <em>uint32, new uint32) (old uint32) <br>func SwapUint64(addr </em>uint64, new uint64) (old uint64) <br>func SwapUintptr(addr <em>uintptr, new uintptr) (old uintptr) <br>func SwapPointer(addr </em>unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td style="text-align:left">交换操作</td></tr><tr><td style="text-align:left">func CompareAndSwapInt32(addr <em>int32, old, new int32) (swapped bool) <br>func CompareAndSwapInt64(addr </em>int64, old, new int64) (swapped bool) <br>func CompareAndSwapUint32(addr <em>uint32, old, new uint32) (swapped bool) <br>func CompareAndSwapUint64(addr </em>uint64, old, new uint64) (swapped bool) <br>func CompareAndSwapUintptr(addr <em>uintptr, old, new uintptr) (swapped bool) <br>func CompareAndSwapPointer(addr </em>unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td style="text-align:left">比较并交换操作</td></tr></tbody></table><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go 语言中的测试依赖 <code>go test</code> 命令。编写测试代码和编写普通的 Go 代码过程是类似的，并不需要学习新的语法、规则或工具。<br>在包目录内，所有以 <code>_test.go</code> 为后缀名的源代码文件都是 <code>go test</code> 测试的一部分，不会被 <code>go build</code> 编译到最终的可执行文件中。在测试文件中有三种类型的函数：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">格式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">测试函数</td><td style="text-align:center">函数名前缀为 Test</td><td style="text-align:center">测试程序的一些逻辑行为是否正确</td></tr><tr><td style="text-align:center">基准函数</td><td style="text-align:center">函数名前缀为 Benchmark</td><td style="text-align:center">测试函数的性能</td></tr><tr><td style="text-align:center">示例函数</td><td style="text-align:center">函数名前缀为 Example</td><td style="text-align:center">为文档提供示例文档</td></tr></tbody></table><p><code>go test</code> 命令会遍历所有的 <code>*_test.go</code> 文件中符合上述命名规则的函数，然后生成一个临时的 main 包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试函数名必须以Test开头，必须接收一个 *testing.T 类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  got := Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>)</span><br><span class="line">  want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line">  <span class="comment">// 因为 slice 不能比较直接，借助反射包中的方法比较</span></span><br><span class="line">  <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; </span><br><span class="line">    t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于测试的内容暂时不去看太多了，先能玩起来再说，再加上标准库基本就可以写东西了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Go语言圣经》<br><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/14_concurrence/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上次的基础语法部分，还剩下的主要是并发相关的内容，现在补全；也略微提及了点测试相关的内容；&lt;br&gt;在 Go 中，并发程序主要使用的是 Go 的 goroutine 和 channel；相对传统的语言，简化了很多，调度上的调整也使程序高效了很多；没讲到的应该就是反射和 Web，这两块以后随用随学吧，目前这些东西也够了。&lt;br&gt;没有贴太多的代码，以及剩下的 Go 标准库使用的相关代码都放到这个仓库了： &lt;a href=&quot;https://github.com/bfchengnuo/GoCS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bfchengnuo/GoCS&lt;/a&gt;
    
    </summary>
    
      <category term="Go" scheme="https://sakanoy.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://sakanoy.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux基础</title>
    <link href="https://sakanoy.com/2020/06/02/WebFlux%E5%9F%BA%E7%A1%80/"/>
    <id>https://sakanoy.com/2020/06/02/WebFlux基础/</id>
    <published>2020-06-02T17:03:31.000Z</published>
    <updated>2024-11-14T17:46:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>响应式（或者叫反应式）的异步非阻塞编程模式，大概率是未来的主流，函数式编程是基础（所以要求 Java8+），可以看作是观察者模式（或者说生产者消费者模式）的延伸。<br>Spring 5 中最重要改动是把反应式编程的思想应用到了框架的各个方面，Spring 5 的反应式编程以 Reactor 库为基础，之前我其实已经过了把瘾（<del>然后发现忘的差不多了，所以来复盘</del>），毕竟 Spring5 也已经出来很久了，更不要说 RxJava，不过也仅仅是尝鲜，这一篇整理下相关基础知识入个门。<br>开发人员可以使用 WebFlux 创建高性能的 Web 应用和客户端（包括其中的 HTTP、服务器推送事件和 WebSocket 支持）。<br>在 SpringBoot2 中也跟进了 WebFlux 的支持，默认使用 Netty，也可以切换 Servlet3.0+ 的容器。<a id="more"></a><br>反应式编程主要解决的是吞吐量的问题（或者说内存、线程压力），而不是速度问题，一定要搞清楚这一点，意味着使用相同的资源可以处理更加多的请求。<br>随着网络应用和微服务的不断发展，高并发、高吞吐量的特性越来越吸引人，Node、Go 显示出了强劲的竞争力，Java 需要更新自己来适应潮流，拥有了 WebFlux （或者说 Reactive Programming）就有了一战的底气。</p><p>比较尴尬的是例如 JDBC 等配套设施还没有太多的跟进，所以目前来看用的还不算多，不过这些问题迟早会解决。</p><h2 id="WebFlux-简介"><a href="#WebFlux-简介" class="headerlink" title="WebFlux 简介"></a>WebFlux 简介</h2><p>WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。<br>该模块中包含了对反应式 HTTP、服务器推送事件和 WebSocket 的客户端和服务器端的支持。对于开发人员来说，比较重要的是服务器端的开发。<br>在服务器端，WebFlux 支持两种不同的编程模型：</p><ol><li>Spring MVC 中使用的基于 Java 注解的方式；</li><li>基于 Java 8 的 lambda 表达式的函数式编程模型。</li></ol><p><strong>这两种编程模型只是在代码编写方式上存在不同。它们运行在同样的反应式底层架构之上，因此在运行时是相同的</strong>。</p><p>WebFlux 需要底层提供运行时的支持，WebFlux 可以运行在支持 Servlet 3.1 非阻塞 IO API 的 Servlet 容器上，或是其他异步运行时环境，如 Netty 和 Undertow。</p><blockquote><p>对标 JSR-315 和 JSR-340，分别对应 Servlet 规范的 3.0 和 3.1<br>3.0 提供了异步化；而 3.1 提供了非阻塞。</p></blockquote><p>最方便的构建 WebFlux 应用的方式是使用 SpringBoot 的初始化器，选择 Reactive Web 依赖。</p><p><img src="/image/dev/Spring-Reactive.jpg" alt=""></p><h2 id="Reactor简介"><a href="#Reactor简介" class="headerlink" title="Reactor简介"></a>Reactor简介</h2><p>Reactor 是一个基础库，可用它构建时效性<strong>流式数据</strong>应用，或者有<strong>低延迟</strong>和<strong>容错性</strong>要求的微/纳/皮级服务。<br>简单说，Reactor 是一个轻量级 <strong>JVM 基础库</strong>，帮助你的服务或应用高效，异步地传递消息。<br>Reactor 仅仅致力于解决异步和函数调用问题。和 Spring 天然无缝整合（毕竟 Reactor 框架是 Pivotal 公司开发的，实现了 Reactive Programming 思想）。</p><blockquote><p>“高效”是指什么?</p><ul><li>消息从 A 传递到 B 时，产生很少的<strong>内存</strong>垃圾，甚至不产生。</li><li>解决消费者处理消息的效率低于生产者时带来的<strong>溢出</strong>问题。</li><li>尽可能提供非阻塞<strong>异步流</strong>。</li></ul><p>PS：Spring 5 其最大的意义就是能将反应式编程技术（它就是常见的观察者模式的一种延伸）的普及向前推进一大步。而作为在背后支持 Spring 5 反应式编程的框架 Reactor，也相应的发布了 3.1.0 版本。</p></blockquote><p>从经验可知（主要是 rage 和 drunk 的推特），异步编程很难，而像 JVM 这类提供众多可选参数的平台则尤其困难。<br>Reactor 旨在帮助大多数用例<strong>真正非阻塞地运行</strong>。提供的 API 比 JDK 的 JUC 库低级原语更高效。Reactor 提供了下列功能的替代函数 (并<strong>建议不使用 JDK 原生语句</strong>)：</p><ul><li>阻塞等待： 如 <code>Future.get()</code></li><li>不安全的数据访问： 如 <code>ReentrantLock.lock()</code></li><li>异常冒泡： 如 <code>try…catch…finally</code></li><li>同步阻塞： 如 <code>synchronized{}</code></li><li>Wrapper 分配（GC 压力）： 如 <code>new Wrapper(event)</code></li></ul><p>当消息传递效率成为系统性能瓶颈的时候(10k msg/s，100k msg/s，1M…)，非阻塞机制就显得尤为重要。例如看下面的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutorService  threadPool = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">final</span> List&lt;T&gt; batches = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">Callable&lt;T&gt; t = <span class="keyword">new</span> Callable&lt;T&gt;() &#123; <span class="comment">// *1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(batches) &#123; <span class="comment">// *2</span></span><br><span class="line">      T result = callDatabase(msg); <span class="comment">// *3</span></span><br><span class="line">      batches.add(result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Future&lt;T&gt; f = threadPool.submit(t); <span class="comment">// *4</span></span><br><span class="line">T result = f.get() <span class="comment">// *5</span></span><br></pre></td></tr></table></figure><p>注释中标注的几点：</p><ol><li>Callable 分配：可能导致 GC 压力。</li><li>同步过程强制每个线程执行停：检查操作。</li><li>消息的消费可能比生产慢。</li><li>使用线程池（ThreadPool）将任务传递给目标线程：通过 FutureTask 方式肯定会产生 GC 压力。</li><li>阻塞直至 <code>callDatabase()</code> 回调。</li></ol><p>在这个简单的例子中，存在的显著问题有：</p><ul><li>分配对象可能产生 GC 压力，特别是当任务运行时间过长。 每次 GC 暂停都会影响全局性能。</li><li>默认的队列是无界的，任务会因为数据库调用而堆积。 积压虽然不会直接导致内存泄漏，但会带来严重副作用：GC 暂停时要扫描更多的对象；有丢失重要数据位的风险；等等 … 典型链式队列节点分配时会产生大量内存压力。</li><li>阻塞回调容易产生恶性循环。 阻塞回调会降低消息生产者的效率。在实践中，任务提交后需要等待结果返回，此时流式过程几乎演变为同步的了。 会话过程抛出的任何带数据存储的异常都会以不受控的方式被传递给生产者，否定了任何通常在线程边界附近可用的容错性。</li></ul><p>要实现完全非阻塞是很难办到的，尤其是在有着类似<strong>微服务架构</strong>这样时髦绰号的分布式系统的世界里。因此 Reactor 做了部分妥协，尝试利用最优的可用模式，使开发者觉得他们是在写异步纳米服务，而不是什么数学论文。<br>到了某个阶段，延迟是每一个系统到都要面对的实实在在的问题。为此：</p><blockquote><p>Reactor 提供的框架可以帮助减轻应用中<strong>由延迟产生的副作用</strong>，只需要增加一点点开销：</p><ul><li>使用了一些聪明的结构，通过启动预分配策略解决运行时<strong>分配问题</strong>；</li><li>通过确定信息传递主结构的<strong>边界</strong>，避免任务的无限堆叠；</li><li>采用主流的<strong>响应与事件驱动构架</strong>模式，提供包含反馈在内的<strong>非阻塞端对端流</strong>；</li><li>引入新的 <a href="http://projectreactor.io/docs/reference/#reactivestreams" target="_blank" rel="noopener">Reactive Streams</a> 标准,拒绝超过当前容量请求，从而保证限制结构的有效性；</li><li>在 IPC 上也使用了类似理念，提供对流控制友好的<strong>非阻塞 IO 驱动</strong>；</li><li>开放了帮助开发者们以<strong>零副作用</strong>方式组织他们代码的函数接口，借助这些函数来处理容错性和线程安全。</li></ul></blockquote><p>为实现异步目标，响应式技术和 Reactor 模块该如何搭配：</p><ul><li>Spring XD + Reactor-Net (Core/Stream)： 使用 Reactor 作为 Sink/Source IO 驱动。</li><li>Grails | Spring + Reactor-Stream (Core)： 用 Stream 和 Promise 做后台处理。</li><li>Spring Data + Reactor-Bus (Core)： 发射数据库事件 (保存/删除/…)。</li><li>Spring Integration Java DSL + Reactor Stream (Core)： Spring 集成的微批量信息通道。</li><li>RxJavaReactiveStreams + RxJava + Reactor-Core： 融合富结构与高效异步 IO 处理</li><li>RxJavaReactiveStreams + RxJava + Reactor-Net (Core/Stream)： 用 RxJava 做数据输入，异步 IO 驱动做传输。</li></ul><p><strong>Reactor 核心</strong>含有如下特性：</p><blockquote><ul><li><strong>通用 IO &amp; 函数式类型</strong>，一些 Java 8 接口的反向移植函数，提供者，消费者，谓词，双向消费者，双向函数</li><li>元组</li><li>资源池、暂停器、定时器</li><li>缓冲器，编解码和少量预定义的编解码器</li><li><strong>环境</strong>上下文</li><li><strong>调度者</strong>约定和几个预定义调度者</li><li>预定义<strong>响应式数据流处理者</strong></li></ul></blockquote><p>Reactor-核心自身可替代其它消息传递机制，完成时序任务调度，或者帮你将代码组织为函数块，实现 Java 8 的反向移植接口。这种拆分便于同其他的响应式库配合使用，而没耐心的开发者也不用再去费劲弄懂环形缓冲区了。</p><h2 id="反应式编程"><a href="#反应式编程" class="headerlink" title="反应式编程"></a>反应式编程</h2><p>反应式编程（Reactive Programming）这种新的编程范式越来越受到开发人员的欢迎。在 Java 社区中比较流行的是 RxJava 和 RxJava 2。Spring5 中使用的是另外一个新的反应式编程库 Reactor。</p><blockquote><p>Reactive Programming，中文称反应式编程，是一种高性能应用的编程方式。<br>其最早是由微软提出并引入到 .NET 平台中，随后 ES6 也引入了类似的技术。<br>在 Java 平台上，较早采用反应式编程技术的是 Netflix 公司开源的 RxJava 框架。现在大家比较熟知的 Hystrix 就是以 RxJava 为基础开发的。</p></blockquote><p><strong>反应式编程来源于数据流和变化的传播</strong>，举个例子：比如求值一个简单的表达式 <code>c=a+b</code>，当 a 或者 b 的值发生变化时，传统的编程范式需要对 a+b 进行重新计算来得到 c 的值。如果使用反应式编程，当 a 或者 b 的值发生变化时，c 的值会自动更新。<br>反应式编程最早由 .NET 平台上的 Reactive Extensions (Rx) 库来实现。后来迁移到 Java 平台之后就产生了著名的 RxJava 库，并产生了很多其他编程语言上的对应实现。在这些实现的基础上产生了后来的反应式流（Reactive Streams）规范。该规范定义了反应式流的相关接口，并将集成到 Java 9 中。</p><hr><p>在传统的编程范式中，我们一般通过迭代器（Iterator）模式来遍历一个序列。这种遍历方式是由调用者来控制节奏的，<strong>采用的是拉的方式</strong>：每次由调用者通过 <code>next()</code>方法来获取序列中的下一个值。<br>使用反应式流时采用的则是<strong>推的方式</strong>，即常见的发布者-订阅者模式：当发布者有新的数据产生时，这些数据会被推送到订阅者来进行处理。<br>在反应式流上可以添加各种不同的操作来对数据进行处理，形成数据处理链。这个以声明式的方式添加的处理链只在订阅者进行订阅操作时才会真正执行。</p><hr><p>反应式流中第一个重要概念是<strong>负压（backpressure）</strong>。在基本的消息推送模式中，当消息发布者产生数据的速度过快时，会使得消息订阅者的处理速度无法跟上产生的速度，从而给订阅者造成很大的压力。当压力过大时，有可能造成订阅者本身的奔溃，所产生的级联效应甚至可能造成整个系统的瘫痪。<br>负压的作用在于提供一种从订阅者到生产者的反馈渠道。<strong>订阅者</strong>可以通过 <code>request()</code> 方法来声明其一次所能处理的消息数量，而生产者就只会产生相应数量的消息，直到下一次 <code>request()</code> 方法调用。这实际上变成了推拉结合的模式。</p><h2 id="Flux和Mono"><a href="#Flux和Mono" class="headerlink" title="Flux和Mono"></a>Flux和Mono</h2><p>Flux 和 Mono 是 Reactor 中的两个基本概念（Java9 中也看到了类似的对象，可以理解为 Reactor = JDK8 Stream + JDK9 Reactive Stream）。Flux 表示的是包含 <strong>0 到 N 个元素的异步序列</strong>。在该序列中可以包含三种不同类型的消息通知：</p><ul><li>正常的包含元素的消息</li><li>序列结束的消息</li><li>序列出错的消息</li></ul><p>当消息通知产生时，订阅者中对应的方法 <code>onNext()</code>, <code>onComplete()</code> 和 <code>onError()</code> 会被调用。<br>Mono 表示的是包含 <strong>0 或者 1 个元素的异步序列</strong>。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。<br>Flux 和 Mono 之间可以进行转换。对一个 Flux 序列进行计数操作，得到的结果是一个 <code>Mono&lt;Long&gt;</code> 对象。把两个 Mono 序列合并在一起，得到的是一个 Flux 对象。</p><ul><li><code>Mono</code> 实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 0 到 1 个元素的发布者。</li><li><code>Flux</code> 同样实现了 <code>org.reactivestreams.Publisher</code> 接口，代表 0 到 N 个元素的发表者。</li><li><code>Scheduler</code> 表示背后驱动反应式流的调度器，通常由各种线程池实现。</li></ul><blockquote><p>在 Java 平台上，Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定了一个被称为 <a href="https%3A%2F%2Fgithub.com%2Freactive-streams%2Freactive-streams-jvm">Reactive Streams 项目（规范）</a>，用于制定反应式编程相关的规范以及接口。<br>主要接口有：Publisher、Subscriber、Subcription。</p><p>直接消费的 Mono 或 Flux 的方式就是调用 <code>subscribe</code> 方法。如果在 Web Flux 接口中开发，直接返回 Mono 或 Flux 即可。Web Flux 框架会为我们完成最后的 Response 输出工作。</p><p>异步并不代表并行，如果需要并行，使用 zip 方法完成。使用反应式，任何环节都需避免阻塞。对于客户端是透明的。</p></blockquote><p><strong>Reactive Streams 是规范，Reactor 实现了 Reactive Streams。Web Flux 以 Reactor 为基础，实现 Web 领域的反应式编程框架。</strong></p><h2 id="使用Reactor"><a href="#使用Reactor" class="headerlink" title="使用Reactor"></a>使用Reactor</h2><p>创建 Flux，Reactor 提供了一系列的静态方法来创建 Flux</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</span></span><br><span class="line">Flux.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （还有 fromIterable 和 fromStream）可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</span></span><br><span class="line">Flux.fromArray(<span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个不包含任何元素，只发布结束消息的序列。</span></span><br><span class="line"><span class="comment">// 此外还有 error 和 never</span></span><br><span class="line">Flux.empty().subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</span></span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含了从 0 开始递增的 Long 对象的序列。</span></span><br><span class="line"><span class="comment">// 其中包含的元素按照指定的间隔来发布。</span></span><br><span class="line"><span class="comment">// 除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</span></span><br><span class="line">Flux.interval(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS)).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 interval()方法的作用相同，只不过该方法通过毫秒数来指定时间间隔和延迟时间。</span></span><br><span class="line">Flux.intervalMillis(<span class="number">1000</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>上面的这些静态方法适合于简单的序列生成，当序列的生成需要复杂的逻辑时，则应该使用 <code>generate()</code> 或 <code>create()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generate 方式</span></span><br><span class="line">Flux.generate(sink -&gt; &#123;</span><br><span class="line">    sink.next(<span class="string">"Hello"</span>);</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.generate(ArrayList::<span class="keyword">new</span>, (list, sink) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> value = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    list.add(value);</span><br><span class="line">    sink.next(value);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">10</span>) &#123;</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create 方式</span></span><br><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sink.next(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>Mono 的创建方式与之前介绍的 Flux 比较相似。Mono 类中也包含了一些与 Flux 类中相同的静态方法。这些方法包括 just()，empty()，error() 和 never()等。除了这些方法之外，Mono 还有一些独有的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromSupplier(() -&gt; <span class="string">"Hello"</span>).subscribe(System.out::println);</span><br><span class="line"><span class="comment">// 从一个 Optional 对象或可能为 null 的对象中创建 Mono。</span></span><br><span class="line"><span class="comment">// 只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span></span><br><span class="line">Mono.justOrEmpty(Optional.of(<span class="string">"Hello"</span>)).subscribe(System.out::println);</span><br><span class="line">Mono.create(sink -&gt; sink.success(<span class="string">"Hello"</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><hr><p>和 RxJava 一样，Reactor 的强大之处在于可以在反应式流上通过声明式的方式添加多种不同的操作符。<br>例如 buffer 和 bufferTimeout 这两个操作符的作用是把当前流中的元素收集到集合中，并把集合对象作为流中的新元素。<br>还有 filter 、take、reduce 和 reduceWith、merge 和 mergeSequential、flatMap 和 flatMapSequential、消息处理、调度器相关的方法，这方面其实有很多内容，但是没细看，估计短时间内接触不到，有个印象等用的时候知道有这么个东西然后再查 API 好了。</p><h2 id="使用WebFlux"><a href="#使用WebFlux" class="headerlink" title="使用WebFlux"></a>使用WebFlux</h2><p>使用 WebFlux 与 Spring MVC 的不同在于，<strong>WebFlux 所使用的类型是与反应式编程相关的 Flux 和 Mono 等，而不是简单的对象</strong>。对于简单的 Hello World 示例来说，这两者之间并没有什么太大的差别。对于复杂的应用来说，反应式编程和负压的优势会体现出来，可以带来整体的性能的提升。</p><p>吞吐量为何会大幅提升？因为使用 WebFlux 后，容器的线程不会被阻塞，只会给业务代码一个回调函数（<code>asyncContext.complete()</code>），业务代码处理完了再通知我！这样就可以使用少量的线程处理更加高的请求，从而实现高吞吐量（结合负压不会造成过高的处理压力）。</p><p>类中的方法都以 Flux 或 Mono 对象作为返回值，这也是 WebFlux 应用的特征。Flux 类型的参数表示的是有多个对象需要处理。可以使用 <code>doOnNext()</code> 来对其中的每个对象进行处理。<br>除了服务器端实现之外，WebFlux 也提供了反应式客户端，可以访问 HTTP、SSE 和 WebSocket 服务器端。分别对应：Web 的 HTTP、SSE、WebSocket，这里不再多说。</p><p>这里不贴代码了，参考我 <a href="https://github.com/bfchengnuo/JavaReplay/tree/master/WebFlux" target="_blank" rel="noopener">Github</a> 的这个模块。</p><h2 id="服务器推送事件"><a href="#服务器推送事件" class="headerlink" title="服务器推送事件"></a>服务器推送事件</h2><p>服务器推送事件（Server-Sent Events，SSE）<strong>允许服务器端不断地推送数据到客户端</strong>。<br>相对于 WebSocket 而言，服务器推送事件只支持服务器端到客户端的<strong>单向数据传递</strong>。虽然功能较弱，但优势在于 SSE <strong>在已有的 HTTP 协议上使用简单易懂的文本格式来表示传输的数据</strong>。<br>作为 W3C 的推荐规范，SSE 在浏览器端的支持也比较广泛，除了 IE 之外的其他浏览器都提供了支持。在 IE 上也可以使用 polyfill 库来提供支持。<br>在服务器端来说，SSE 是一个不断产生新数据的流，非常适合于用反应式流来表示。在 WebFlux 中创建 SSE 的服务器端是非常简单的。只需要返回的对象的类型是 <code>Flux&lt;ServerSentEvent&gt;</code>，就会被自动按照 SSE 规范要求的格式来发送响应，或者指定 MediaType。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sse"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/randomNumbers"</span>)</span><br><span class="line">  <span class="keyword">public</span> Flux&lt;ServerSentEvent&lt;Integer&gt;&gt; randomNumbers() &#123;</span><br><span class="line">    <span class="keyword">return</span> Flux.interval(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">      .map(seq -&gt; Tuples.of(seq, ThreadLocalRandom.current().nextInt()))</span><br><span class="line">      .map(data -&gt; ServerSentEvent.&lt;Integer&gt;builder()</span><br><span class="line">           .event(<span class="string">"random"</span>)</span><br><span class="line">           .id(Long.toString(data.getT1()))</span><br><span class="line">           .data(data.getT2())</span><br><span class="line">           .build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(value = <span class="string">"/stream"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">streamAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SseController 是一个使用 SSE 的控制器的示例。其中的方法 <code>randomNumbers()</code> 表示的是每隔一秒产生一个随机数的 SSE 端点。我们可以使用类 <code>ServerSentEvent.Builder</code> 来创建 ServerSentEvent 对象。这里我们指定了事件名称 random，以及每个事件的标识符和数据。事件的标识符是一个递增的整数，而数据则是产生的随机数。</p><p>PS：我记得在我写的 SB2.x 的初尝试那篇文章中关于这个有个小例子。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 支持客户端与服务器端的<strong>双向通讯</strong>。当客户端与服务器端之间的交互方式比较复杂时，可以使用 WebSocket。<br>WebSocket 在主流的浏览器上都得到了支持。WebFlux 也对创建 WebSocket 服务器端提供了支持。在服务器端，我们需要实现接口 <code>org.springframework.web.reactive.socket.WebSocketHandler</code> 来处理 WebSocket 通讯。接口 WebSocketHandler 的方法 handle 的参数是接口 WebSocketSession 的对象，可以用来获取客户端信息、接送消息和发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(<span class="keyword">final</span> WebSocketSession session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session.send(</span><br><span class="line">      session.receive()</span><br><span class="line">      .map(msg -&gt; session.textMessage(<span class="string">"ECHO -&gt; "</span> + msg.getPayloadAsText())));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EchoHandler 对于每个接收的消息，会发送一个添加了 “ECHO -&gt; “ 前缀的响应消息。WebSocketSession 的 receive 方法的返回值是一个 <code>Flux&lt;WebSocketMessage&gt;</code> 对象，表示的是接收到的消息流。而 send 方法的参数是一个 <code>Publisher&lt;WebSocketMessage&gt;</code> 对象，表示要发送的消息流。在 handle 方法，使用 map 操作对 receive 方法得到的 <code>Flux&lt;WebSocketMessage&gt;</code> 中包含的消息继续处理，然后直接由 send 方法来发送。</p><p>在创建了 WebSocket 的处理器 EchoHandler 之后，下一步需要把它注册到 WebFlux 中。我们首先需要创建一个类 WebSocketHandlerAdapter 的对象，该对象负责把 WebSocketHandler 关联到 WebFlux 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HandlerMapping <span class="title">webSocketMapping</span><span class="params">(<span class="keyword">final</span> EchoHandler echoHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, WebSocketHandler&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"/echo"</span>, echoHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    mapping.setUrlMap(map);</span><br><span class="line">    <span class="keyword">return</span> mapping;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebSocketHandlerAdapter <span class="title">handlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 HandlerMapping 类型的 bean 把 EchoHandler 映射到路径 <code>/echo</code>。</p><p>参考代码：<a href="https://github.com/bfchengnuo/JavaReplay/tree/master/WebFlux" target="_blank" rel="noopener">Github</a></p><h2 id="函数式编程模型"><a href="#函数式编程模型" class="headerlink" title="函数式编程模型"></a>函数式编程模型</h2><p>WebFlux 还支持基于 lambda 表达式的函数式编程模型。与基于 Java 注解的编程模型相比，函数式编程模型的抽象层次更低，代码编写更灵活，可以满足一些对动态性要求更高的场景。不过在编写时的代码复杂度也较高，学习曲线也较陡。开发人员可以根据实际的需要来选择合适的编程模型。目前 Spring Boot 不支持在一个应用中同时使用两种不同的编程模式。<br>在函数式编程模型中，<strong>每个请求是由一个函数来处理的</strong>， 通过接口 <code>org.springframework.web.reactive.function.server.HandlerFunction</code> 来表示。<br>HandlerFunction 是一个函数式接口，其中只有一个方法 <code>Mono&lt;T extends ServerResponse&gt; handle(ServerRequest request)</code>，因此可以用 labmda 表达式来实现该接口。<br>接口 ServerRequest 表示的是一个 HTTP 请求。通过该接口可以<strong>获取到请求的相关信息</strong>，如请求路径、HTTP 头、查询参数和请求内容等。方法 handle 的返回值是一个 <code>Mono&lt;T extends ServerResponse&gt;</code> 对象。<br>接口 ServerResponse 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象。<br>下面是一个简单的计算器实现来展示函数式编程模型的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">add</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 + v2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">subtract</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 - v2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt;  <span class="title">multiply</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 * v2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">divide</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculate(request, (v1, v2) -&gt; v1 / v2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Mono&lt;ServerResponse&gt; <span class="title">calculate</span><span class="params">(<span class="keyword">final</span> ServerRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">final</span> BiFunction&lt;Integer, Integer, Integer&gt; calculateFunc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Tuple2&lt;Integer, Integer&gt; operands = extractOperands(request);</span><br><span class="line">    <span class="keyword">return</span> ServerResponse</span><br><span class="line">      .ok()</span><br><span class="line">      .body(Mono.just(calculateFunc.apply(operands.getT1(), operands.getT2())), Integer.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Tuple2&lt;Integer, Integer&gt; <span class="title">extractOperands</span><span class="params">(<span class="keyword">final</span> ServerRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Tuples.of(parseOperand(request, <span class="string">"v1"</span>), parseOperand(request, <span class="string">"v2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parseOperand</span><span class="params">(<span class="keyword">final</span> ServerRequest request, <span class="keyword">final</span> String param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Integer.parseInt(request.queryParam(param).orElse(<span class="string">"0"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码给出了处理不同请求的类 CalculatorHandler，其中包含的方法 add、subtract、multiply 和 divide 都是接口 HandlerFunction 的实现。这些方法分别对应加、减、乘、除四种运算。每种运算都是从 HTTP 请求中获取到两个作为操作数的整数，再把运算的结果返回。<br>在创建了处理请求的 HandlerFunction 之后，下一步是为这些 HandlerFunction <strong>提供路由信息</strong>，也就是这些 HandlerFunction 被调用的条件。这是通过函数式接口 <code>org.springframework.web.reactive.function.server.RouterFunction</code> 来完成的。接口 RouterFunction 的方法 <code>Mono&lt;HandlerFunction&lt;T extends ServerResponse&gt;&gt; route(ServerRequest request)</code> 对每个 ServerRequest，都返回对应的 0 个或 1 个 HandlerFunction 对象，以 <code>Mono&lt;HandlerFunction&gt;</code> 来表示。</p><p>当找到对应的 HandlerFunction 时，该 HandlerFunction 被调用来处理该 ServerRequest，并把得到的 ServerResponse 返回。在使用 WebFlux 的 Spring Boot 应用中，只需要创建 RouterFunction 类型的 bean，就会被自动注册来处理请求并调用相应的 HandlerFunction。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">routerFunction</span><span class="params">(<span class="keyword">final</span> CalculatorHandler calculatorHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RouterFunctions.route(</span><br><span class="line">      RequestPredicates.path(<span class="string">"/calculator"</span>),</span><br><span class="line">      request -&gt; request.queryParam(<span class="string">"operator"</span>).map(operator -&gt;</span><br><span class="line">                                                    Mono.justOrEmpty(ReflectionUtils.findMethod(</span><br><span class="line">                                                      CalculatorHandler.class,</span><br><span class="line">                                                      operator,</span><br><span class="line">                                                      ServerRequest.class))</span><br><span class="line">                                                    .flatMap(method -&gt; (Mono&lt;ServerResponse&gt;) ReflectionUtils.invokeMethod(method, calculatorHandler, request))</span><br><span class="line">                                                    .switchIfEmpty(ServerResponse.badRequest().build())</span><br><span class="line">                                                    .onErrorResume(ex -&gt; ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR).build()))</span><br><span class="line">      .orElse(ServerResponse.badRequest().build()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是相关的配置类 Config。方法 <code>RouterFunctions.route</code> 用来根据 Predicate 是否匹配来确定 HandlerFunction 是否被应用。RequestPredicates 中包含了很多静态方法来创建常用的基于不同匹配规则的 Predicate。如 <code>RequestPredicates.path</code> 用来根据 HTTP 请求的路径来进行匹配。此处我们检查请求的路径是 <code>/calculator</code>。</p><p>使用 ServerRequest 的 queryParam 方法来获取到查询参数 operator 的值，然后通过反射 API 在类 CalculatorHandler 中找到与查询参数 operator 的值名称相同的方法来确定要调用的 HandlerFunction 的实现，最后调用查找到的方法来处理该请求。如果找不到查询参数 operator 或是 operator 的值不在识别的列表中，服务器端返回 400 错误；如果反射 API 的方法调用中出现错误，服务器端返回 500 错误。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>响应式数据流</strong>作为一种新的数据流规范应用于 Java 9 及其后续版本，并被多个供应商和技术企业采纳，这一规范的定位非常清晰，旨在提供同/异步数据序列流式控制机制，并在 JVM 上首先推广。该规范由 4 个 Java 接口，1 个 TCK 和一些样例组成。</p><hr><p><strong>响应式扩展</strong>，就是通常所说的 Rx，是一组定义良好的函数式 API，大规模扩展了<strong>观察者模式</strong>。<br>Rx 模式支持响应式数据序列处理，主要的设计要点有：</p><ul><li>使用回调链分离时间/延迟：仅当数据可用时才会回调</li><li>分离线程模型：用 Observable / Stream 来处理同步或异步</li><li>控制错误链/终止：数据载荷信号以及错误与完成信号都传递给回调链</li><li>解决各种预定义 API 中多重分散-聚合和构造问题</li></ul><p>JVM 中响应式扩展的标准实现是 RxJava。它提供了强大的函数式 API，并将原始微软库中几乎全部的概念移植了过来。</p><blockquote><p>响应式数据流和响应式扩展算是最近比较新的技术了，因为牵扯到异步非阻塞技术比较难理解，但是从 Spring5 的方向来看，这是未来，至于如何学习，我还在摸索那条路比较好。</p></blockquote><hr><p>Netty 示例相关参考：<a href="https://github.com/bfchengnuo/java_learn/tree/master/ExampleCode/WebSocket_Netty" target="_blank" rel="noopener">Github</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html</a><br><a href="https://www.jianshu.com/p/7ee89f70dfe5" target="_blank" rel="noopener">https://www.jianshu.com/p/7ee89f70dfe5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式（或者叫反应式）的异步非阻塞编程模式，大概率是未来的主流，函数式编程是基础（所以要求 Java8+），可以看作是观察者模式（或者说生产者消费者模式）的延伸。&lt;br&gt;Spring 5 中最重要改动是把反应式编程的思想应用到了框架的各个方面，Spring 5 的反应式编程以 Reactor 库为基础，之前我其实已经过了把瘾（&lt;del&gt;然后发现忘的差不多了，所以来复盘&lt;/del&gt;），毕竟 Spring5 也已经出来很久了，更不要说 RxJava，不过也仅仅是尝鲜，这一篇整理下相关基础知识入个门。&lt;br&gt;开发人员可以使用 WebFlux 创建高性能的 Web 应用和客户端（包括其中的 HTTP、服务器推送事件和 WebSocket 支持）。&lt;br&gt;在 SpringBoot2 中也跟进了 WebFlux 的支持，默认使用 Netty，也可以切换 Servlet3.0+ 的容器。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://sakanoy.com/tags/Spring/"/>
    
      <category term="WebFlux" scheme="https://sakanoy.com/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>任性的语言-Golang</title>
    <link href="https://sakanoy.com/2020/05/12/%E4%BB%BB%E6%80%A7%E7%9A%84%E8%AF%AD%E8%A8%80-Golang/"/>
    <id>https://sakanoy.com/2020/05/12/任性的语言-Golang/</id>
    <published>2020-05-12T16:44:38.000Z</published>
    <updated>2024-11-14T17:46:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>Go 现在名声越来越大，很多大型互联网公司都在过渡到 Go，也不用多介绍了，我对其的印象就是：Google 出品、21世纪编程语言、<del>logo 非常萌、</del>纯编译型、对标 C（C+Python=Go）、面向并发高效计算（毕竟出生的时候已经多核时代）、万物皆异步、函数一等公民（函数式编程，CSP 并发模型）、语法简洁（没有继承、泛型、异常处理和对象的概念，但是有接口即面向接口）、效率高（更少的存储空间和更少的内存写操作）、企业级编程语言（另一个是 Java）承诺保证向后兼容、完全开源。<br>兴趣使然，简单看一下作为后来者到底解决了前人的那些痛点，取取经（我才发现原来 Python 的出生比 Java 早）。<a id="more"></a></p><p>还有个好处就是自带 GC，这一点可真是太贴心了，性能方面基本可以赶上 Java（Scala、JIT 优化后的代码），不要问为什么纯编译型语言还不如 Java，Java 慢是很久很久之前的观点了，硬要说是臃肿的第三方库（有利有弊，结果就是一个项目打个包就过百 M 了），另外 JVM 的 JIT 确实很厉害的，优化后与 C 基本无异；<strong>JIT 还帮你擦屁股（比如各种锁优化、逃逸分析、无效代码消除等等），优化人写出来的烂代码</strong>，这点 Go 是做不到的，你写成什么样就什么样了，所以你写的代码烂真的还不如 JVM 这种 runtime 的优化。<br>Golang 国内镜像站：<a href="https://golang.google.cn/" target="_blank" rel="noopener">https://golang.google.cn/</a><br>package 文档：<a href="https://golang.google.cn/pkg/" target="_blank" rel="noopener">https://golang.google.cn/pkg/</a><br>另外，Go 已成为区块链的主流开发语言。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>安装完成后使用 <code>go env</code> 可以检查环境，然后新建 GOPATH 环境变量，设置代码工作区，新版本支持多个，也可以不建，一般这个目录下会有三个文件夹，src、pkg、bin，分别对应源码、中间文件、可执行文件。<br>然后把 <code>$GOPATH/bin</code> 添加到系统环境变量中，方便直接在命令行中执行。<br>作为个人来说，src 目录下使用类似网址来区分项目即可，这里正序即可不需要像 Java 那样 com 倒序开头，文件命名使用小写，多单词使用下划线分割。<br>常用命令（其他命令用到自行搜索）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">go build</span><br><span class="line"><span class="comment"># 其他路径下编译，编译后的可执行文件保存在当前目录下</span></span><br><span class="line"><span class="comment"># go build &#123;src下的路径，到最后的文件夹&#125;</span></span><br><span class="line">go build github.com/xxx</span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">go build -o demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./xx</span><br><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">go run xx.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译、复制到 bin 下</span></span><br><span class="line">go install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉编译\跨平台编译</span></span><br><span class="line">GOOS=linux GOARCH=amd64 go build hello.go  <span class="comment"># linux 64 位</span></span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build  <span class="comment"># win 64 位</span></span><br><span class="line"></span><br><span class="line">SET CGO_ENABLED=0  <span class="comment"># 禁用 CGO，使用了 cgo 的代码是不支持跨平台编译的</span></span><br><span class="line">SET GOOS=linux  <span class="comment"># 目标平台是 linux</span></span><br><span class="line">SET GOARCH=amd64  <span class="comment"># 目标处理器架构是 amd64</span></span><br></pre></td></tr></table></figure><p>入门代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, 世界"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，package 是必须的，如果包名是 main，代表是编译为可执行文件，需要有个 main 函数作为入口。<br>函数外部无法使用语句，只能定义变量。<br>Go 语言中，有 25 个关键字，37 个保留字，可以说是非常精简了。</p><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>单独把这个命令拿出来是因为用的非常频繁，<code>go get</code> 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。<br>这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 <code>go install</code>。使用 <code>-d</code> 参数可以只下载不安装；<code>-x</code> 显示详细过程；<code>-u</code> 强制从网络更新。<br>因为 Go 语言代码托管在 Github，所以自然默认使用 git 作为版本控制工具，使用 <code>go get</code> 之前需要安装 git，虽然它支持 SVN 等其他工具和其他的类似 Github 的托管站点，但是主流一般都是 Github。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Go 语言提供了不少工具来高效率编程，如果使用 VSC 它会提示你安装这些工具，以 gofmt 来说，体现了 Go 对格式的强硬态度，这个工具是对代码进行格式化对，并且没有任何参数可以调整，这表示对编程风格的高度统一，不存在因为格式而撕逼对情况了。</p><h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>Go 中单行语句结尾不需要分号，编译器会主动把换行符转换为分号，在某些情况下不会添加，例如括号、+ 等符号，也就意味着语句太长换行的时候是有规则的，不能在普通字符后换行。<br>在方法调用等情况中，如果太长折行的话，一定是从左括号开始，否则因为自动添加分号会编译不通过，而括号作为特殊字符不会进行处理，同样为了保持风格，Go 允许最后以 <code>,</code> 结尾，逗号作为特殊符，后面也可以进行换行。<br>其他的，例如注释也有相应的规范，包注释写在第一行，多个文件的话只写一个即可，文档工具会自行处理，Go 的规范网上可以搜到很多，例如<a href="https://www.bookstack.cn/read/go-code-convention/zh-CN-commentary.md" target="_blank" rel="noopener">这篇</a>看一下即可，如果使用了 golint 等工具，不规范直接会给你提示。</p><p>对于错误或者异常，Go 语言习惯是在 if 中（<code>if err != nil</code>）处理并且直接返回（return），error 也一般是作为返回值返回，放在最后，另一个选择是 panic，相比之下用的不多。</p><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>Go 既然是静态语言，变量的声明是要确定类型的，Go 中的声明标识符分为四类：var、const、type、func，先说前两个，用代码示例来展示一下用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  age <span class="keyword">int</span></span><br><span class="line">  isOk <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c, d = <span class="string">"str"</span>, <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> desc <span class="keyword">string</span> = <span class="string">"desc"</span></span><br><span class="line"><span class="comment">// 函数变量/定义函数</span></span><br><span class="line"><span class="keyword">var</span> fun1 = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 短变量声明，只能在函数中使用</span></span><br><span class="line">  s1 := <span class="string">"Goooo"</span></span><br><span class="line">  fmt.Println(s1)</span><br><span class="line">  <span class="comment">// 字符串、数值（任何类型）、增加双引号（%q）</span></span><br><span class="line">  <span class="comment">// 另外 %b %o %x %T %p，二、八、十六进制，类型，地址&amp;</span></span><br><span class="line">  <span class="comment">// 浮点数 %f  %.2f</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s, %v, %#v"</span>, s1, s1, s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名变量</span></span><br><span class="line">x, _ = func1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明常量</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">"MMP"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// 都是 1</span></span><br><span class="line">  code1 = <span class="number">1</span></span><br><span class="line">  code2</span><br><span class="line">  code3</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  c1 = <span class="literal">iota</span>  <span class="comment">// 0</span></span><br><span class="line">  c2  <span class="comment">// 1</span></span><br><span class="line">  c3  <span class="comment">// 2</span></span><br><span class="line">  _</span><br><span class="line">  c4  <span class="comment">// 4</span></span><br><span class="line">  c5 = <span class="number">100</span>  <span class="comment">// 100</span></span><br><span class="line">  c6  <span class="comment">// 100</span></span><br><span class="line">  c7  <span class="comment">// 7</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a1, a2 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span>  <span class="comment">// 1, 2</span></span><br><span class="line">  a3, a4 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span>  <span class="comment">// 2, 3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义数量级</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _ = <span class="literal">iota</span></span><br><span class="line">  KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">  MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">  GB</span><br><span class="line">  TB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>变量的定义顺序比较『反人类』是先名字后类型，同时，变量声明后会进行默认初始化，文件也统一使用 UTF-8 编码，推荐使用驼峰命名；<br>函数中声明的变量必须使用，否则编译不通过，go 文件必须使用 package 声明包名，可以与文件夹不一致；<br>当想要忽略某个值的时候，可以使用匿名变量（<code>_</code>），匿名变量不占用命名空间，不会分配内存，所以也不存在重复声明。<br><strong>iota 是常量计数器</strong>，在 const 出现的时候重置为 0，每新增一行声明就加一，注意是从 0 开始，批量声明中使用，可以当作枚举来使用。<br>常量的命名不要使用全大些，那个有另外的用途，总之像普通变量那样使用就好了。</p><h2 id="经典数据类型"><a href="#经典数据类型" class="headerlink" title="经典数据类型"></a>经典数据类型</h2><p>这里并没有按照 Go 的分类（基础类型、复合类型、引用类型、接口类型），其中部分复杂的复合类型会单独介绍，基本数据类型方面与其他语言基本一致，也就是整数、浮点数、字符串、布尔这些，数字又分为有符号和无符号：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">uint8</td><td style="text-align:left">无符号 8 位整型 (0 到 255)</td></tr><tr><td style="text-align:center">uint16</td><td style="text-align:left">无符号 16 位整型 (0 到 65535)</td></tr><tr><td style="text-align:center">uint32</td><td style="text-align:left">无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td style="text-align:center">uint64</td><td style="text-align:left">无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td style="text-align:center">int8</td><td style="text-align:left">有符号 8 位整型 (-128 到 127)</td></tr><tr><td style="text-align:center">int16</td><td style="text-align:left">有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td style="text-align:center">int32</td><td style="text-align:left">有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td style="text-align:center">int64</td><td style="text-align:left">有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr><tr><td style="text-align:center">uint</td><td style="text-align:left">32 位操作系统上就是<code>uint32</code>，64 位操作系统上就是<code>uint64</code></td></tr><tr><td style="text-align:center">int</td><td style="text-align:left">32 位操作系统上就是<code>int32</code>，64 位操作系统上就是<code>int64</code></td></tr><tr><td style="text-align:center">uintptr</td><td style="text-align:left">无符号整型，用于存放一个指针，大小根据操作系统而定</td></tr><tr><td style="text-align:center">rune</td><td style="text-align:left">可理解为字符型（char），解决多语言问题，大小是可变的 byte</td></tr></tbody></table><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><blockquote><p>获取对象的长度的内建 <code>len()</code> 函数返回的长度可以根据不同平台的字节长度进行变化。<br>实际使用中，切片或 map 的元素数量等都可以用 <code>int</code> 来表示。<br>在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p></blockquote><p>不显式声明的情况下，默认是 int 类型，而 <code>x := int8(16)</code> 就是显式使用 int8 类型；浮点数的话默认是 float64 类型。<br>布尔类型在 Go 中是独立的，不能转换成 0 和 1。GO 中只有显式类型转换没有隐式类型转换（不包括字面量）。<br>PS：Go 中还设置了实数部分与虚数部分的复杂数据类型（复数），可能是想进军科学计算领域，一般用不到。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在 Go 中的实现是 UTF-8 编码的，可以使用反引号进行多行字符串的输入；字符串相关处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str</span><span class="params">()</span></span> &#123;</span><br><span class="line">  str := <span class="string">"Mps"</span></span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">  fmt.Println(str + <span class="string">"拼接1"</span>)</span><br><span class="line">  ss := fmt.Sprintf(<span class="string">"%s%s"</span>, str, <span class="string">",拼接2"</span>)</span><br><span class="line"></span><br><span class="line">  s1 := strings.Split(ss, <span class="string">","</span>)</span><br><span class="line">  fmt.Println(s1)</span><br><span class="line">  <span class="comment">// 遍历 - 中文</span></span><br><span class="line">  <span class="keyword">for</span> i, c := <span class="keyword">range</span> []<span class="keyword">rune</span>(str) &#123;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(c))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字符数统计</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(str))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字符串转成 byte 数组</span></span><br><span class="line">  bs := []<span class="keyword">byte</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 len 是求的 byte 的数量，对于非英文文字，例如中文在 U8 中一般是 3 个字节（也可能是 4 个），Go 中使用了一种 <strong>rune</strong> 的类型（实际为 int32）来保存非 ASCII 字符，可以理解为其他语言中的 char 类型，对应的是 Unicode，所以 rune 大小是一致的，即使是 ASCII；<br>另外，字符串是不允许修改的，底层存储使用的是 byte，非 ASCII 字符要转换成 <code>[]rune</code> 然后再进行操作，一个 rune 可以由 1 个或者多个 byte 保存。<br>使用 RuneCountInString 方法统计字符的时候，它会有一层转换或者说解码，先 byte 到 rune 之后再计算。<br>字符串相关操作 API 在 strings 包下。</p><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>nil 不属于关键字，就像其他语言中的 null 也不是关键字（你甚至可以更改 nil 的值），在 Go 中 nil 是一个预声明标识符，使用频率很高，除了其他语言的 null 用途还有其他的特点，例如 Go 中的 nil 是非常安全的，即使是 nil 也可以调用方法，只要不牵扯具体的内部变量，是完全没问题的。<br>PS：Go 的一个特点就是即使是使用 nil 值，也不会抛异常，因为它表示的是 zero value，或者说对象的默认值。</p><h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>数组定义同样也是反着的，<del>大概是特色吧一般都是反着的</del>，切片基于数组，或者看作是可以自动扩容对数组，可变长度意味着切片非常灵活，代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr3 = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">3</span>&#125; <span class="comment">// 指定索引初始化</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]&#123;<span class="number">99</span>: <span class="number">-1</span>&#125; <span class="comment">// len = 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [3]int 和 [5]int 是不同类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrEcho</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用指针，可以进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">editArr</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 其他语法 [:4] [2:] [:]</span></span><br><span class="line">  s := arr[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">// [2,3]</span></span><br><span class="line">  s2 := s[<span class="number">2</span>,<span class="number">4</span>]  <span class="comment">// [4,5] 向后扩展</span></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="number">233</span>)</span><br><span class="line">fmt.Println(<span class="string">"s / arr : "</span>, s, arr)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 定义一个切片</span></span><br><span class="line"><span class="keyword">var</span> ss []<span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 默认值 nil</span></span><br><span class="line">fmt.Println(ss == <span class="literal">nil</span>)</span><br><span class="line">ss = <span class="built_in">append</span>(ss, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(ss)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他定义方式</span></span><br><span class="line">sp2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">sp3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)     <span class="comment">// len = 10</span></span><br><span class="line">sp4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">16</span>) <span class="comment">// len = 10, cap = 16</span></span><br><span class="line">sp(sp2)</span><br><span class="line">sp(sp3)</span><br><span class="line">sp(sp4)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// sp2 拷贝到 sp3</span></span><br><span class="line">  <span class="built_in">copy</span>(sp3, sp2)</span><br><span class="line">fmt.Println(sp3)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过 append 来删除，也可以使用 copy 来删除</span></span><br><span class="line">sp3 = <span class="built_in">append</span>(sp3[:<span class="number">2</span>], sp3[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(sp3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中使用切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sp</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"len: %d, cap: %d"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<strong>数组是值类型</strong>，意味着函数传递的时候会进行完全的拷贝，而不是传递地址（引用），当然你可以使用指针来传递，但是太麻烦了，Go 中一般不会直接使用数组，而是会用切片。<br>切片在 Go 中使用 <code>[]T</code> 定义，与数组很像，只是没有固定长度，如果接触过 python，那么应该很好理解，这里的切片和 python 中的切片还是很相似的，区间都是 [x,y)，<strong>对数组切片返回的是数组的视图</strong>，也就是如果切片修改，原来的数组也会跟着修改；也正是这个原因，我们直接往函数里传递切片，就相当于传递的引用了。<br>使用下标获取超出切片大小的内容会报错，但是再次使用切片来处理却没有这个问题，可以说<strong>切片是可以向后扩展的</strong>（向前取不行），在切片的实现中，使用 ptr 来记录头部，使用一个 len 记录长度，所以使用下标是取不到的，会跟 len 做比较，但是使用切片会跟 cap 做对比，它记录了 ptr 到数组最后一个元素的长度，所以只要不是物理的越界，是可以进行切片的。<br>如果使用 append 来向切片追加数据，在不超过 cap 的情况下会覆盖原数组的内容，如果 append 后超过了 cap，那么 Go 会<strong>新创建一个数组，并由 append 返回</strong>，旧数组如果没有引用，就会被 GC。</p><p>切片的底层就是一个数组对象，由三部分组成，指针、长度和容量，长度不能超过容量（数值上，数据饱可以自动扩容），多个切片之间可能有重叠部分，因为底层可能是指向了同一个数组；切片之间不能直接比较（毕竟是间接引用），只能一个个的来，虽然效率并不高，唯一合法的比较是跟 nil，判断切片是不是空应该用 len 函数而不是使用 nil。<br>PS：上例使用了类似展开运算符的 <code>sp...</code> 语法来适配可变参数，相比其他语言同样也是倒着的；具体的扩容机制不展开说了，毕竟是隐式无法调整的，见拓展里的文章，在 1024 之前一般是 2 倍，之后是 1/4，不同类型的处理也不太一样。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 这个数据类型肯定不陌生，不过陌生的是 Go 中的定义方法。。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"k1"</span>: <span class="string">"v1"</span>,</span><br><span class="line">    <span class="string">"k2"</span>: <span class="string">"v2"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(m)</span><br><span class="line">  m[<span class="string">"k3"</span>] = <span class="string">"v3"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> val, ok := m[<span class="string">"name"</span>]; ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"存在："</span>, val, ok)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不存在"</span>, val, ok)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"k1"</span>)</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套定义也一样，就是繁琐，或者你还可以使用 make 函数来创建（<code>make(map[string]string)</code>），创建出来的是个空 Map，而 var 定义出来的是 nil；无论是那个，都是可以直接运算不会抛出异常。<br>map 也是 hash 实现，是无序的；如果需要排序需要加入到切片中，然后通过对 key 的排序来达到有序。<br>当获取的 k 不存在时，获取的是 v 类型的默认值，字符串的话就是空串了；这种情况下我们需要通过返回的第二个参数手动判断；<br>除 slice、map、func 的内建类型基本都可以作为 key，自定义的 Struct 类型只要不包含前面说的类型也可以作为 key，换句话说 key 必须是可以进行 == 比较运算的。<br>使用 key 来获取 map 的内容，最好是通过 ok 来判断一下，大部分情况下即使是空也是安全的，因为空的话会默认取零值，或者说默认值。<br>禁止对 map 进行取地址操作，因为随着内容的变化，地址也会随之变化，哈希实现就是如此。<br>当 map 是 nil 的时候，添加元素会导致 panic，但是用 make 创建的空 map 就不会有这个问题。</p><p>Go 中没有提供 set 类型，但是使用 map 的 key 特性可以做到这一点，不过也有一定的限制，因为 key 要求是可比较类型，切片就不满足这个条件，你可以定义一个函数将其转换为 string。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>编程语言我认为最核心的两块，数据类型和流程控制，流程控制基本就是指条件判断与循环，以及延伸的 switch 和 goto；因为 where 这个可以用 for 来替代，或者说 where 是 for 的语法糖，<strong>在 Go 中也没有 where</strong>，循环就是 for（三个部分都可省略，可完美替代 where）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  num := <span class="number">12</span></span><br><span class="line">  <span class="keyword">if</span> num &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Get"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n1 := <span class="number">2</span>; n1 &gt; <span class="number">1</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Go"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"for - "</span> + <span class="keyword">string</span>(i))</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      <span class="comment">// continue</span></span><br><span class="line">      <span class="comment">// return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 无限循环</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"for..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// where 用法</span></span><br><span class="line">  x := funcName() </span><br><span class="line">  <span class="keyword">for</span> x.isTrue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// range 遍历，v 不要的话可以省略，i 不要使用 _ 丢弃</span></span><br><span class="line">  str := <span class="string">"abc中文字符"</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">    <span class="comment">// fmt.Println(i, v)</span></span><br><span class="line">    fmt.Printf(<span class="string">"index: %d, val: %c\n"</span>, i, v)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch</span></span><br><span class="line">  <span class="keyword">switch</span> f := <span class="number">2</span>; f &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">"sw - 1"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">"sw - 2,3"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"sw - def"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  n := <span class="number">3</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> n &lt; <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">"sw - (&lt; 5)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法上确实不太一样，没有括号了，<strong>range 关键字跟其他语言的 foreach 类似，可以遍历可迭代的数据类型，返回两个值：坐标和具体的值</strong>，不过需要注意遍历字符串的时候 index 是按字节来的，虽然输出不会乱码，但是一个汉字会跳 3 个 index。<br>switch 也不需要手动调用 break，符合匹配后它不会向下执行的（自动 break）；另外为了可读性，还是尽量少使用 goto，虽然在跳出多层循环中 goto 很好用，但是建议使用多层 break + if 来代替。</p><blockquote><p>使用 for 进行迭代的时候，一定要注意声明域（使用 <code>:=</code> 的要注意），它记录的是循环变量的内存<strong>地址</strong>，    而不是某一时刻的值，如果需要某一时刻的值，请声明（<code>:=</code>）一个临时变量进行保存。</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数作为 Go 语言的一等公民，这个肯定是重点，在返回值上面刚接触也有点『反人类』也就是返回值写在最后，这样倒是确实有好处，如果没有返回值直接可以省略，不需要 void 了，通过代码来解释就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="keyword">return</span> a * b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="keyword">return</span> a / b</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"unsupported"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval2</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"unsupported op %s"</span>, op)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐的方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div2</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">q = a / b</span><br><span class="line">r = a % b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// q, r := div2(3, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收函数，或者直接将函数的定义写在参数上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的<strong>返回值定义在后面</strong>，同时<strong>支持多返回类型</strong>（参考 py），多返回类型可以起名，例如 div2 的方式，但是不推荐，如果不需要全部的返回值，可以使用 <code>_</code> 匿名变量来丢弃；<br>处理异常建议使用 Go 的推荐方式使用返回值（eval2），而不是直接抛出；函数只能与 nil 进行比较；<br>既然是函数式编程，必然支持高阶函数，那么函数的方法<strong>参数也可以接收函数</strong>，只需要说明函数的签名就行，不需要写函数的参数名称，只需要类型；另一种就是类似其他语言的匿名类的方式，直接把函数定义在参数上。<br>另外，Go 中的函数<strong>不支持重载</strong>，这样倒是简化了方法调度。</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>内建函数是上面说的保留字中的一部分，包括 new、make、len、cap 等函数，介绍常用的几个：</p><ul><li><p><code>new(T)</code><br>它将创建一个指定类型 T 的匿名变量，初始化为对应的零值（默认值），然后返回<strong>地址</strong>，指针类型为 <code>*T</code>；<br>它与普通的变量声明没有太大区别，它类似一个语法糖，不需要名字的匿名变量。<br>一般情况下，new 用的并不是很多，并且它不是关键字，所以你甚至可以改变它的定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(num)</span><br><span class="line">fmt.Println(*num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候要注意，new <strong>返回的是地址而不是值</strong>。</p></li><li><p><code>make([]T, len, cap)</code><br>它会创建一个指定的类型、长度、容量的切片，容量可以省略，默认与 len 相等。<br>同样，它创建的也是匿名变量，除了切片，其他类型也可以创建，例如 map <code>make(map[string]string)</code> ；<br>make 只用于 slice、map 以及 channel 的初始化，并且返回的是引用本身；为了避免 panic，这三种类型尽量使用 make 来创建。</p></li><li><p>append<br>用于向切片追加数据（可以是多个），容量饱和会自动扩容（通过复制），并返回。<br>安全起见，请尽量将它的返回值赋予原变量。</p></li><li><p><code>copy(target, source)</code><br>将一个类型复制到另一个相同的类型变量上，例如上面的 append 函数中。<br>另外，在 IO 中用的也很频繁。</p></li></ul><p>一览表：</p><table><thead><tr><th style="text-align:center">内置函数</th><th style="text-align:left">介绍</th></tr></thead><tbody><tr><td style="text-align:center">close</td><td style="text-align:left">主要用来关闭channel</td></tr><tr><td style="text-align:center">len</td><td style="text-align:left">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td style="text-align:center">new</td><td style="text-align:left">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td style="text-align:center">make</td><td style="text-align:left">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td style="text-align:center">append</td><td style="text-align:left">用来追加元素到数组、slice中</td></tr><tr><td style="text-align:center">panic和recover</td><td style="text-align:left">用来做错误处理</td></tr></tbody></table><h3 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h3><p>匿名函数因为没有名字，所以无法显式调用，所以匿名函数要么保存到一个变量，要么就立即执行，多用于回调和闭包；<br>Go 使用闭包技术实现函数值，很多人也将函数值称为闭包；<br>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unc main() &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 f 是一个函数，并且引用了外部变量 x，此时 f 就是一个闭包，在 f 有效的生命周期中，x 一直有效；<br>闭包的概念与 js、py 中基本一致。</p><h3 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h3><p>defer 语句会将其后面跟随的语句进行延迟处理；也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out:</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>正是因为这个特性，非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。<br>在 Go 语言的函数中 <code>return</code> 语句在底层并不是原子操作，它分为给返回值赋值和 RET 指令两步。而 <code>defer</code> 语句执行的时机就在返回值赋值操作后，RET 指令执行前。</p><h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>Go 没有异常机制，但是可以使用 <code>panic/recover</code> 模式来处理错误。 <code>panic</code> 可以在任何地方引发，但 <code>recover</code> 只有在 <code>defer</code> 调用的函数中有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果程序出出现了 panic 错误,可以通过 recover 恢复过来</span></span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recover in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 panic 发生时，程序会中断执行，并立即执行该 goroutine （理解为线程）中被延迟的函数（defer）</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 中的指针相比 C 已经简化了很多了，虽然进行了简化，但是在 Go 中还是非常重要的一个东西；<br>在 Go 中，指针<strong>不能参与运算</strong>，只有值传递一种方式，不用特意的去理解，跟 Java 其实也没多大区别，地址也是值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">editArr</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的交换使用返回值的方式也可以做到，这里仅仅是单纯的演示指针。<br>在 editArr 中接收的是数组的地址（指针），下面可以直接使用 arr 这个名字来进行操作，不需要在带着 <code>*</code> 这个还是非常方便的。<br>简单来说，<code>&amp;</code> 就是取地址，<code>*</code> 就是获取指针指向的变量内容，例如指向 int 类型的指针的类型就是 <code>*int</code>，如果 p 指向的是一个地址（&amp;name）那么通过指针修改变量值就需要使用 <code>*p</code>。</p><h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><p>这里本来想说面向对象的，但是 Go 它不是面向对象的语言，它只有封装，没有继承和多态，这也算是好消息吧；所以它没有 class 只有 struct，结构体是一个聚合类型，由零个或者任意多个任意类型组合的实体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">var</span> root treeNode</span><br><span class="line">fmt.Println(root)</span><br><span class="line"></span><br><span class="line">root = treeNode&#123;value: <span class="number">3</span>&#125;</span><br><span class="line">root.left = &amp;treeNode&#123;&#125;</span><br><span class="line">root.right = &amp;treeNode&#123;<span class="number">4</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">// 指针可以直接用 . 调用</span></span><br><span class="line">root.right.left = <span class="built_in">new</span>(treeNode)</span><br><span class="line">  </span><br><span class="line">  root.<span class="built_in">print</span>()</span><br><span class="line">root.setVal(<span class="number">233</span>)</span><br><span class="line">root.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNode</span><span class="params">(val <span class="keyword">int</span>)</span> *<span class="title">treeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;treeNode&#123;value: val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">value       <span class="keyword">int</span></span><br><span class="line">left, right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(node.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setVal</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">node.value = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为经常使用指针操作结构体，一般定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  pp := &amp;treeNode&#123;<span class="number">3</span>&#125;</span><br><span class="line">  <span class="comment">// 等价于</span></span><br><span class="line">  pp := <span class="built_in">new</span>(treeNode)</span><br><span class="line">  *pp = treeNode&#123;<span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中不需要有构造函数，就是指针类型也可以直接用『点』调用，使用 new 函数也可以创建一个空结构体返回地址（区别 make 是创建空间），对结构体指针可以直接使用点调用，其实是个语法糖，会自动转换为 <code>(*var).xxx</code>；</p><blockquote><p>命名类型（type）可以让我们方便的给一个特殊类型一个名字，因为 struct 的声明非常长，一般使用 type 来取一个别名。</p></blockquote><p>我们可以通过工厂函数来创建一个结构体，并且可以将地址返回给调用方用，<strong>至于对象是在堆还是栈分配，这个不需要太过在意，由编译器决定</strong>，当你返回一个地址，那么会被认为需要给其他地方用，就会在堆分配，接受 GC 的管理，反之可能就直接在栈分配。<br>需要注意的是，结构体中的方法是定义中外面的，与普通函数相比，多了一个接受者参数，放在最前面；本质上与普通函数并没有什么区别；也正是这样，在修改的函数中，因为 Go 只有值传递（变量拷贝），所以<strong>需要定义参数为指针</strong>，其他的该怎么用就怎么用。<br><strong>如果结构体比较大，为了避免复制，应该考虑优先使用指针接收</strong>；结构体通常是使用指针处理，所以定义的时候一般会直接定义成地址，如代码的最后；结构体内的定义如果都是可以比较的，那么结构体本身也是可以比较的。</p><p>定义结构体时，是按行来定义内部类型；有特殊情况，就是可以省去名字，<strong>只写类型，这样就是匿名成员</strong>，匿名成员的特点就是可以直接点出其内部的元素（或者是叶子属性）而不需要给出完整路径，有点继承的感觉，也算是一个语法糖；<br>因为匿名成员也会有一个隐式的名字，所以匿名成员类型只允许有一个；同时因为没有名字，权限也就根据子类型的定义来了。<br>在初始化的时候，匿名成员就有问题了，不能直接通过名字或者字面值直接赋值，只能通过完整的类型名来赋值，代码参考 <a href="https://github.com/bfchengnuo/GoCS/blob/master/study/basic/struct_demo.go" target="_blank" rel="noopener">Github</a>，当不同的匿名成员有相同的字段时，就需要使用完整的路径来指定。<br>结构体的内存布局是连续的，空的结构体是不占空间的。</p><h2 id="封装与扩展"><a href="#封装与扩展" class="headerlink" title="封装与扩展"></a>封装与扩展</h2><p>对于封装的一些规约，<strong>首字母大写表示是 Public 的，首字母小写表示 Private</strong>，命名都是采用驼峰。<br>每一个目录只有一个包（package）其中 main 包比较特殊，它是程序的执行入口；<br>为结构体定义的方法必须放在同一个包内，可以是不同的文件；跨包引用的时候用 包名.结构体 这样来调用，当然需要使用 import 关键字来进行导入。<br>不过既然限制结构体方法定义必须同一个包，那么扩展别人的库就有点难受来，因为 Go 没有继承，解决方案是使用别名或者使用组合的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 调用扩展的结构体</span></span><br><span class="line">extRoot := myTreeNode&#123;&amp;root&#125;</span><br><span class="line">extRoot.echo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合的方式进行扩展 treeNode</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">node *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">echo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> myNode == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">left := myTreeNode&#123;myNode.node.left&#125;</span><br><span class="line">right := myTreeNode&#123;myNode.node.right&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"扩展..."</span>)</span><br><span class="line">left.node.<span class="built_in">print</span>()</span><br><span class="line">myNode.node.<span class="built_in">print</span>()</span><br><span class="line">right.node.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合就是设计模式中的组合方式，以上代码要对比结构体中的 treeNode 定义来看；<br>而另一种别名就是使用 type 关键字 + 函数指针的方式来通过改变原始对象达到目的，省略相关代码。<br>封装后也可以像 Java 一样提供 getter 和 setter，Go 中的习惯是 getter 方法会直接省略前面的 get；Go 的编程风格不禁止直接导出字段的行为，但是这样意味着你之后不能随意的删除，为了兼容。</p><p>import 关键字默认会从标准库（GOROOT）和 GOPATH 下面寻找依赖，所以导入之前要确认是否存在；定义包名要尽量短小，因为给别人用的时候需要使用包名来确定范围，参考 fmt。<br>导入的包就必须要使用，如果不用编译会失败，这也体现出为了性能，真的是任性。</p><p>因为一个 package 可以有多个文件，默认按照文件名排序后依次初始化，因为函数外不允许进行逻辑计算，还可以在其中定义<strong>一个或多个</strong> init 函数用来做逻辑初始化（类似其他语言的构造），它与普通的函数没有多大区别，仅仅是会在加载时自动调用，多个的话就按照定义的顺序来，并且 init 函数无法被手动调用和引用。<br>还有就是 main 包总是在最后被加载。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go 中既想要 python、c++ 中的灵活性（只需要有这个方法，就能调用），又想要 java 中的类型检查（不需要等到运行或者编译时才能确定是否具有相应的方法）；<br>传统语言中的具体逻辑是由实现者来定义的，Go 中也反过来来，接口由使用者来定义，并且实现是隐式的，你只要有相应的方法就可以；同时，Go 是面向接口编程，Go 中的接口是一种类型，一种抽象的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用者</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 接口中默认就是 func 声明</span></span><br><span class="line">Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Get(<span class="string">"https://bfchengnuo.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fake := mock.Retriever&#123;<span class="string">"Mps....."</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(down(fake))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现者</span></span><br><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line">Content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的定义是跟使用者一起的，而实现看起来跟一般的结构体并没有什么不同，所以说是隐式的；<br>接口可以简单看作是一组方法的集合，是<code>duck-type programming</code>的一种体现，接口本来就是用来抽象的，看到一个接口，我们并不知道它具体是啥，但是知道它能干啥，这跟 Java 中的概念差不多；<br><strong>按照规范，接口的名称一般会以 er 结尾，参数名、返回值名可以省略，只写类型。</strong><br>值接收者实现的接口，具体的结构体可以是值类型也可以是指针，Go 会自动处理；而如果是指针接收者的实现，那么只能传入指针类型；不管选择那一种，都是实现者来决定的。<br>同样，一个类型可以实现多个接口，接口也可以进行嵌套。同时还存在空接口的类型，使用空接口可以实现接收任意类型的函数参数；空接口作为 map 的值就可以实现保存任意值的字典。</p><p>如果使用接口参数，尤其是空接口，我们根本不知道具体是什么类型，类型断言就是解决这个问题的，类型断言用法：<code>x.(T)</code>，空接口使用的非常广泛；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">"Hello 沙河"</span></span><br><span class="line">v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要多次断言，可以使用 switch 写法会舒服一点。<br>只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><h2 id="类型-type"><a href="#类型-type" class="headerlink" title="类型-type"></a>类型-type</h2><p>在任何语言中，都会有这样的情况：一些变量有着相同的内部结构，但是表示的却是完全不同的概念，例如 int 可以表示循环的控制变量，也可以表示时间戳；而 type 就是用来分割不同的概念类型；<br>使用方法为：<code>type 类型名字 底层类型</code><br>声明语句一般出现在包一级，如果使用大写字母开头，表示包外也可以访问。<br>这样声明后，虽然两个类型可能有相同的底层数据结构，但是它们却是完全不同的数据类型，多用在结构体中；底层类型想要转换为包装的别名必须通过显式类型转换，类型转换可以使用 <code>name(x)</code> 的通用方式进行。<br>经过类型定义后，你可以给这个类型添加方法，也可以使用它原始类型的特性，例如如果底层类型是 int，你就可以直接进行基本的逻辑运算。</p><p>另外，可以定义函数类型，只要符合签名就可以被赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><p>以上也体现了一定的动态性，可以对比接口来看。</p><hr><p>在 1.9 版本出现了另一种用法，就是别名，区别于类型定义，别名只是换了个名称，本质还是原来的类型；<br>定义：<code>type TypeAlias = Type</code><br>使用上与原始类型 Type 一样，仅仅是名字不同。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>最早的时候，Go 语言所依赖的所有的第三方库都放在 GOPATH 这个目录下面，这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？<br>Go 语言从 v1.5 开始开始引入 <code>vendor</code> 模式，如果项目目录下有 vendor 目录，那么 go 工具链会优先使用 <code>vendor</code> 内的包进行编译、测试等。<br><code>godep</code> 是一个通过 vender 模式实现的 Go 语言的<strong>第三方依赖管理工具</strong>，类似的还有由<strong>社区维护</strong>准官方包管理工具 <code>dep</code>。</p><blockquote><p><code>go module</code> 是 Go1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，<code>go module</code> 将是 Go 语言默认的依赖管理工具。</p></blockquote><p>所以接下来只说 go module，要启用 <code>go module</code> 支持首先要设置环境变量 <code>GO111MODULE</code> ，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p><ol><li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li><li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li><li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li></ol><p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，<strong>以后就没有必要在 GOPATH 中创建项目了</strong>，并且还能够很好的管理项目依赖的第三方包信息。<br>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>（记录了项目所有的依赖信息）和<code>go.sum</code>（记录每个依赖库的版本和哈希值）。<br>常用命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>go mod download</td><td>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</td></tr><tr><td>go mod edit</td><td>编辑 go.mod 文件</td></tr><tr><td>go mod graph</td><td>打印模块依赖图</td></tr><tr><td>go mod init</td><td>初始化当前文件夹，创建 go.mod 文件</td></tr><tr><td>go mod tidy</td><td>增加缺少的包，删除无用的包</td></tr><tr><td>go mod vendor</td><td>将依赖复制到 vendor 目录下</td></tr><tr><td>go mod verify</td><td>校验依赖</td></tr><tr><td>go mod why</td><td>解释为什么需要依赖</td></tr></tbody></table><p>因为 Go 是谷歌的，包管理也肯定在谷歌的服务器，所以对大陆肯定不友好，所以建议设置代理：目前公开的代理服务器的地址有：</p><ul><li>goproxy.io 开源，为 Go 模块而生</li><li>goproxy.cn 由国内的七牛云提供。</li></ul><p>Windows 下设置 GOPROXY 的命令为：<code>go env -w GOPROXY=https://goproxy.cn,direct</code><br>MacOS 或 Linux 下设置 GOPROXY 的命令为：<code>export GOPROXY=https://goproxy.cn</code><br>更改完毕可以使用 <code>go env</code> 查看，使用 go module 非常简单，只需要两步命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 go.mod 文件，如果不在 GOPATH 下需要指定完整的模块路径</span></span><br><span class="line">go mod init</span><br><span class="line"><span class="comment"># 自动发现依赖</span></span><br><span class="line">go get</span><br></pre></td></tr></table></figure><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本（name@x.x），如果下载所有依赖可以使用 <code>go mod download</code> 命令。</p><h2 id="包使用"><a href="#包使用" class="headerlink" title="包使用"></a>包使用</h2><p>包的声明一般写当前文件夹名，一个文件夹下不允许有不同的 package 定义，同一个 package 的文件也不允许出现在多个文件夹下，导包的时候要写全路径（对于 GOPATH）；<br>给包设置别名：<code>import 别名 &quot;包的路径&quot;</code><br>匿名导包（不使用，但是会被编译到可执行文件中）：<code>import _ &quot;包的路径&quot;</code></p><p>更多内容请到 <a href="https://github.com/bfchengnuo/GoCS" target="_blank" rel="noopener">Github</a> 仓库查看。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://www.liwenzhou.com/posts/Go/go_menu/" target="_blank" rel="noopener">Go语言学习之路</a><br><a href="https://github.com/rubyhan1314/Golang-100-Days" target="_blank" rel="noopener">Golang-100-Days（文档，未看）</a><br><a href="https://segmentfault.com/a/1190000018690961" target="_blank" rel="noopener">新版本Golang的包管理入门教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go 现在名声越来越大，很多大型互联网公司都在过渡到 Go，也不用多介绍了，我对其的印象就是：Google 出品、21世纪编程语言、&lt;del&gt;logo 非常萌、&lt;/del&gt;纯编译型、对标 C（C+Python=Go）、面向并发高效计算（毕竟出生的时候已经多核时代）、万物皆异步、函数一等公民（函数式编程，CSP 并发模型）、语法简洁（没有继承、泛型、异常处理和对象的概念，但是有接口即面向接口）、效率高（更少的存储空间和更少的内存写操作）、企业级编程语言（另一个是 Java）承诺保证向后兼容、完全开源。&lt;br&gt;兴趣使然，简单看一下作为后来者到底解决了前人的那些痛点，取取经（我才发现原来 Python 的出生比 Java 早）。
    
    </summary>
    
      <category term="Go" scheme="https://sakanoy.com/categories/Go/"/>
    
    
      <category term="Go" scheme="https://sakanoy.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>EffectiveJava后知后觉</title>
    <link href="https://sakanoy.com/2020/04/30/EffectiveJava%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89/"/>
    <id>https://sakanoy.com/2020/04/30/EffectiveJava后知后觉/</id>
    <published>2020-04-30T19:10:45.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>这本书又叫高效 Java，书中的很多条目还是让我眼前一亮的，尤其并发和序列化，大概是因为这一块本来接触的就不多吧，但也有不少内容其实是早就知道的，所以作为我个人的记录，我并不会一条条的罗列出来，主要记录一些平时用的很少或者记得模糊的东西。<br>这本书感觉如果是对入门不久的开发者来说，是非常有必要读一下的，但是如果你经常阅读 JDK 或者 Spring 等开源框架源码的老鸟，其实大部分你都可以跳着看了，因为从它们的源码中基本就能学到大部分的技巧。<a id="more"></a></p><h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><p>对象的创建与销毁算是比较耗时的，在合适的时机创建对象在高性能的系统中是非常有必要的；频繁的 GC 也会让系统卡顿。</p><h3 id="静态工厂代替构造器"><a href="#静态工厂代替构造器" class="headerlink" title="静态工厂代替构造器"></a>静态工厂代替构造器</h3><p>一个类允许客户端获取其实例的传统方式是提供一个公共构造方法。还有一种比较好的选择就是静态工厂，相比构造器，主要的优势有：</p><ol><li>拥有名称，描述更为清晰。</li><li>可避免每次调用都创建一个新对象；可以确保是一个单例或者不可实例化的亦或者不可变的，这种类被称为实例受控的类。</li><li>可以返回原返回类型的子类型，可以用这种方式来隐藏实现类，适用于基于接口的框架。</li><li>返回对象的类可以根据输入参数的不同而不同（任何子类型都是允许的）</li><li>在编写包含该方法的类时，返回的对象的类不需要存在。<br>这种灵活的方案构成了服务提供者框架的基础，例如 JDBC。</li></ol><p>当然也是有缺点的：</p><ul><li>类一般不含有公有或者受保护的构造器，所以就不能被<strong>子类化</strong>。<br>这也鼓励开发者多使用组合而不是继承。</li><li>开发者很难找到它们。<br>不过也有一些惯用名称，举例说明：<br><strong>from</strong>：类型转换方法，它接受单个参数并返回此类型的相应实例；<br><strong>of</strong>：聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起；<br><strong>valueOf</strong>：from 和 to 更为详细的替代方式；<br><strong>instance 或 getinstance</strong>：返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值；<br><strong>create 或 newInstance</strong>：与 instance 或 getInstance 类似，除此之外该方法保证每次调用返回一个<strong>新的实例；</strong><br><strong>getType</strong>：与 getInstance 类似，但是在工厂方法处于不同的类中的时候使用（Type 是工厂方法返回的对象类型）；<br><strong>newType</strong>：与 newInstance 类似，但是在工厂方法处于不同的类中的时候使用（Type 是工厂方法返回的对象类型）；<br><strong>type</strong>：getType 和 newType 简洁的替代方式。</li></ul><p>例如下面一个 boolean 提升为包装的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要区分与工厂模式的差异，此例中与工厂模式没有什么直接联系。<br>如果你使用接口的静态方法，注意不能为私有，但是私有却是必要的，Java 9 允许私有静态方法，但静态字段和静态成员类仍然需要公开。</p><h3 id="构造方法参数过多时使用builder模式"><a href="#构造方法参数过多时使用builder模式" class="headerlink" title="构造方法参数过多时使用builder模式"></a>构造方法参数过多时使用builder模式</h3><p>静态工厂和构造器有个共同的局限性，不能很好的扩展到大量的可选参数。<br>构建器的一般套路就是让客户端利用必要的参数来调用构造器或者静态工厂得到一个 builder 对象，然后客户端在这个对象上调用各种 setter 方法设置相关参数，最后客户端调用无参的 build 方法来生成不可变的对象。<br>假设使用一个个的 setter 方法来设置，这时候对象就会出现不完整状态，单线程倒还无所谓。<br>一般来说，构建器是可以使用调用链的，这种写法非常舒服，记得在 Android 中有大量使用。</p><hr><p>当然，构建器也有它的局限性，要创建对象你得先搞出一个构建器来，创建对象需要开销啊，在非常注重性能的系统里就有点问题了。<br>构建器显得更加冗长，因此只有在很多参数的时候才使用，比如 4 个以上，如果以后有可能会增加参数那么一开始就最好使用构建器。<br>在参数众多，并且很多参数是可选的或者相同类型，那么 builder 模式是个很不错的选择。</p><h3 id="关于单例"><a href="#关于单例" class="headerlink" title="关于单例"></a>关于单例</h3><p>单例真的是相当有料啊，常见的“饿汉式”基本可以保证单例，只能用大部分情况下，最简单的，使用反射可以轻易的调用私有的构造函数，对应的防范措施就是修改构造器，让它在创建的时候检查是否已经存在，如果已存在抛出异常。<br>如果单例的对象需求为可序列化的，那么仅仅实现标记接口是不行的，这样还是可能会出现第二个；为了维护并保证单例，必须声明所有实例域都是瞬时（transient）的，并提供一个 readResolve 方法（具体实现可以是返回单例对象即可）</p><hr><p>从 1.5 之后，实现单例还可以使用枚举，这种方式虽然跟上面的公有静态方法获取没啥区别，但是更简洁；无偿的提供了序列化机制，绝对防止多次实例化，这差不多已经成为最佳的实现单例方法，虽然没广泛使用。</p><hr><p>然后说起<strong>工具类</strong>，一般都是静态方法组成的，也不需要实例化，为了防止实例化，可以把构造改为私有，但只有这样还不行，和单例不同，这样内部可以实例化，但是工具类内部也没有实例化的需求，所以在构造里<strong>直接抛一个异常</strong>是最简单的做法，只不过这样的代码看起来比较奇怪，写上注释比较好，当然它也就不可能有子类了。</p><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>当然，能重用就不要浪费资源去创建相同功能的新对象，如果对象是不可变的那么它始终可以被重用（使用单例模式）。<br>对于同时提供了静态工厂方法和构造器的<strong>不可变类</strong>，通常使用静态工厂而不是构造器，以避免创建不必要的对象，例如 <code>Boolean.valueOf(String)</code> 和 <code>Boolean(String)</code>，后者在 Java9 中已被废弃。</p><p>有些情况下看起来并不是很明细，例如 Map 中的 ketSet，返回键值的 set 集合，第一次看上去会以为每次调用都会创建一个新的 set 返回，我们可以对这个 set 进行操作；实际上，他们返回的 set 都是同一个，因为对应的是一个 Map，可以称作为这个 Map 的一个视图（适配器），所以当改变这个 set 与之关联的都会变化。<br>在使用正则匹配的时候如果多次使用也要使用 Pattern 实例，因为创建它是昂贵的。<br>PS：<strong>自动装箱是非常耗费性能的！与基本数据类型尽量不要混用。</strong></p><p>当然，小对象的构造器只做少量的工作，所以小对象的创建和回收动作是非常廉价的，通过附加对象提升程序的清晰性和简洁性是好事。 </p><h2 id="对象的公共方法"><a href="#对象的公共方法" class="headerlink" title="对象的公共方法"></a>对象的公共方法</h2><p>重写 equals 方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问 题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例只与自身相等。<br>什么时候需要重写 equals 方法呢?如果一个类包含一个逻辑相等(logical equality)的概念，此概 念有别于对象标识(object identity)，而且父类还没有重写过 equals 方法。<br>这种情况多发生在值类型的情况，例如 String、Integer 之类。如果真的需要重写，请保证下面的几个约定：</p><ul><li><strong>自反性:</strong> 对于任何非空引用 x， <code>x.equals(x)</code> 必须返回 true。<br>即：一个对象必须与自身相等</li><li><strong>对称性:</strong> 对于任何非空引用 x 和 y，如果且仅当 <code>y.equals(x)</code> 返回 true 时 <code>x.equals(y)</code> 必须 返回 true。<br>即：任何两个对象必须在是否相等的问题上达成一致</li><li><strong>传递性:</strong> 对于任何非空引用 x、y、z，如果 <code>x.equals(y)</code> 返回 true， <code>y.equals(z)</code> 返回 true，则 <code>x.equals(z)</code> 必须返回 true。<br>即：如果第一个对象等于第二个对象，第二个 对象等于第三个对象，那么第一个对象必须等于第三个对象</li><li><strong>一致性:</strong> 对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 <code>x.equals(y)</code> 的多次调用必须始终返回 true 或始终返回 false。<br>即：如果两个对象是相等的，除非一个(或两 个)对象被修改了， 那么它们必须始终保持相等</li><li>对于任何非空引用 x， <code>x.equals(null)</code> 必须返回 false。<br>即：所有的对象都必须不等于 null</li></ul><p>如果不遵守，程序可能就会出现各种奇奇怪怪的问题。<br>对于类型为非 float 或 double 的基本类型，使用 == 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 <code>Float.compare()</code> 方法（double 也是类似，避免使用 equals 装箱操作）；对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每 个元素都很重要，请使用其中一个重载的 Arrays.equals 方法，对于可能存在空的情况，使用 Objects 的 equals 方法也许不错。<br>equals 方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同 的属性，开销比较小的属性，或者最好是两者都满足(derived fields)</p><blockquote><p>编写和测试 equals(和 hashCode)方法很繁琐，生的代码也很普通。替代手动编写和测试这些方 法的优雅的手段是，使用谷歌 AutoValue 开源框架，该框架自动为你生成这些方法，只需在类上添加一 个注解即可。<br>虽然 IDE 也会提供相关功能，但是生成的代码很冗长，并且不能动态更新。</p></blockquote><p>然而，大多数情况下，我们并不需要去重写 eq。</p><hr><p><strong>在每个类中，在重写</strong> equals <strong>方法的时侯，一定要重写</strong> hashcode <strong>方法。</strong> 如果不这样做，你的类违反了 hashCode 的通用约定，这会阻止它在 HashMap 和 HashSet 这样的集合中正常工作，<strong>相等的对象必须具有相等的哈希码</strong>。<br>这在根据类的 equals 方法，两个不同的实例在逻辑上是相同的情况下显得很重要。例如 HashMap 就做了优化，缓存了与每一项(entry)相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。<br>哈希的生成你可能看到很多都用一个 31 这个数，因为它是一个奇数的素数，避免乘法溢出，并且它可以被 JVM 优化为位运算。<br>可以看出 equals 和 hashCode 使用了大量递归，这两个方法还是很重的。<br>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。<br>最后，<strong>不要试图从哈希码计算中排除重要的属性来提高性能</strong></p><hr><p>对于  toString 的通用约定是：建议所有的子类重写这个方法，不过在静态工具类中编写 toString 方法是没有意义的，同样枚举中也完全没有必要。</p><hr><p>虽然存在 Cloneable 这样的接口，不幸的是，它没有达到这个目的。它的主要缺点是<strong>缺少 clone 方法</strong>，而 Object 的 clone 方法是受保护的。你只能借助反射来调用，仅仅因为它实现了 Cloneable 接口，就调用对象上的 clone 方法这想法是行不通的。<br>那么这个接口的意义是，如果一个类实现了 Cloneable 接口，那么 Object 的 clone 方法将返回该对象的逐个属性 (field-by-field) 拷贝；否则会抛出异常，这确实是一个不太好的设计。<br>通常情况下，实现一个接口用来表示可以为客户做什么。但对于 Cloneable 接 口，它会修改父类上受保护方法的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();  <span class="comment">// Can't happen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的例子，在没有引用变量的情况下是可行的，但是如果涉及引用变量，就得递归调用 clone，同时它用到了协变规范；这也牵扯到我们常说的深度克隆和浅度克隆。<br>在数组上调用 clone 会返回一个数组，其运行时和编译时类型与被克隆的数组相同。这是复制数组的首选习语。事实上，数组是 clone 机制的唯一有力的用途。<br>如果 elements 属性是 final 的，则以前的解决方案将不起作用，因为克隆将被禁止向该属性分配新的值，在克隆上真的是各种问题，并且 Object 的克隆方法是不同步的，也正是这样用的并不多。<br>如果确实要用，实现 Cloneable 的所有类应该重写公共 clone 方法，而这个方法的返回类型是类本身。这个方法应该首先调用 super.clone，然后修复任何需要修复的属性。<br>对象复制更好的方法是提供一个复制构造方法或复制工厂。考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。这个规则的一个明显的例外是数组，它最好用 clone 方法复制。<br>这里给几个参考：<a href="https://github.com/bfchengnuo/MyRecord/issues/25" target="_blank" rel="noopener">Java对象的属性拷贝效率比较</a>、<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/%E5%9F%BA%E7%A1%80/%E4%B8%80%E5%85%A5Java%E6%B7%B1%E4%BC%BC%E6%B5%B7.md" target="_blank" rel="noopener">一入Java深似海</a>（评价 Java 中的 clone 方法？）</p><h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><h3 id="组合优于继承"><a href="#组合优于继承" class="headerlink" title="组合优于继承"></a>组合优于继承</h3><p>不要继承一个现有的类，而应该给你的新类增加 一个私有属性，该属性是现有类的实例引用，这种设计被称为组合(composition)，因为现有的类成为新类的组成部分。<br>如果使用继承，那么当父类有所变化时，子类也会受影响，即使子类的代码并没有任何变化。<br>这很像是装饰器模式，这里要区别与代理模式；包装类的缺点很少， 一个警告是包装类不适合在回调框架中使用，可能会存在 Self 问题（this 指向）；有些人担心转发方法调用的性能影响，以及包装对象对内存占用， 两者在实践中都没有太大的影响。<br>只有在子类真的是父类的子类型的情况下，继承才是合适的。<br>所以，从这个角度，JDK 中 Stack 类不应该继承 Vector 类，Properties 不应该继承 Hashtable，它们之间使用组合更加合适。<br>继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。</p><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>从 Java8 开始，接口可以有默认方法了，这确实解决了一些问题，但是也引入了一些新问题，跟继承类似，接口的实现者是感知不到接口中新增的默认方法，<br>例如，一个将集合同步化的工具类，在接口新增了默认方法后并不会感知，这也导致这个方法不会被同步，如果作者不及时重写默认方法，可能就会导致问题出现。<br>在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时可能会失败。<br>所以，应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的。</p><h3 id="常量接口模式"><a href="#常量接口模式" class="headerlink" title="常量接口模式"></a>常量接口模式</h3><p>所谓的常量接口模式就是定义一个接口，里面用来存储常量；<br><strong>常量接口模式是对接口的糟糕使用</strong>，对类的用户来说，类实现一个常量接口是没有意义 的；事实上，它甚至可能使他们感到困惑，如果实现了常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染，并且未来版本中如果不需要常量了，仍然需要实现接口，来保证二进制兼容。<br>JDK 中也有部分实现，这些接口应该被视为不规范的，不应该被效仿。更好的方式应该是使用一个不可实例化的类来做，抽象类也不可以，容易被误解是来做继承的。<br><strong>总之，接口只能用于定义类型。 它们不应该仅用于导出常量。</strong></p><h3 id="关于内部类"><a href="#关于内部类" class="headerlink" title="关于内部类"></a>关于内部类</h3><p>或者叫嵌套类， <strong>如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类</strong>。<br>有四种嵌套类: 静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类。<br>如果嵌套类的实例可以与其宿主类的实例隔离存在，那么嵌套类必须是静态成员类：不可能在没有宿主实例的情况下创建非静态成员类的实例。<br>静态成员类的一个常见用途是作为公共帮助类，类似：Aa.Bb.NAME，非静态成员类的一个常见用法是定义一个 Adapter，可参考 Map  中的各种视图。<br>在非静态成员类中，每个实例都隐藏的引用了自己的宿主，存储这个引用就需要占用时间和空间，更严重的可能会导致 GC 无法回收宿主对象，就是因为引用是不可见的，很难被检测到。<br>私有静态成员类的常见用法是表示由它们的宿主类表示的对象的组件，例如 Map.Entry；<br>总结一下就是：如果一个嵌套的类需要在一个方法之外可见，或者太长而不能很好地适应一个方法，使用一个成员类。<br>如果一个成员类的每个实例都需要一个对其宿主实例的引用，使其成为非静态的;；否则，使其静态。<br>假设这个类属于一个方法内部，如果你只需 要从一个地方创建实例，并且存在一个预置类型来说明这个类的特征，那么把它作为一个匿名类；否则，把它变成局部类。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型已经都用的很熟练了，编译时会自动强制转换，相当于运行时擦除，注意这里编译后的字节码还是保存着泛型的信息的，还有就是泛型不可以使用原始类型（没有任何类型参数的泛型类型的名称，简单说就是不用泛型，或者使用 ？通配符的情况），这样编译器没办法帮你检查错误。<br>如果跟数组对比，会发现即有相似又有差异，最大的区别为数组是支持协变的，例如 String 数组可以赋值给 Object 数组，但是泛型不可能，也正是因为这个差异，导致不能使用泛型数组（尽管很少有用，创建无限定通配符类型的数组是合法的），所以作为替代方案一般我们都使用集合来替代，虽然牺牲了一些性能，但是安全。<br>泛型这个东西解释起来不难，但是运用到你写的代码中很难，说白了就是一个设计问题。<br>参数化不难，但是泛型化真的需要一定的水平。</p><p>编译器可能无法证明你的代码是安全的，所以会给你发出警告，但是你可以证明，这种情况下你可以使用 @SuppressWarnings 注解来进行标注，并使用注释来说明原因。<br>使用 SuppressWarnings 的时候一定要小心，做到最小范围化，否则可能就出现吞掉其他警告的可能。</p><p>泛型的另一个难点是限定通配符的使用：</p><ul><li>上限（<code>&lt;? extends E&gt;</code>）<br>说明传入的可以是 E 或者 E 的子类</li><li>下限（<code>&lt;? super E&gt;</code>）<br>说明传入的值可以是 E 或者 E 的父类</li></ul><p>这个的用法其实有点误导，感觉有点别扭；<br>另外需要注意的一点，可变参数也不可以和泛型同用，因为可变参数的本质就是数组，泛型数组是不可以用的。<br>不过可变参数的情况下还是有点区别，它不会直接像数组那样给你一个错误，而是给你一个警告，这是因为像 <code>T...</code> 这样的用法是安全的，但是 <code>List&lt;T&gt;...</code> 这种就是不安全的，或者可以理解为如果仅仅是单纯的传递参数是安全的，总而言之，可变参数和泛型不能很好地交互。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>建议使用枚举类型来代替整型常量，使用枚举确实有很多好处，但是以我的观察，还是用 int 常量的多，我猜可能是因为这种入库的时候方便，如果 Entry 使用枚举定义，可能会有点复杂，并且与前端的约定也一般是 int 标识，还要处理序列化相关，当然如果不涉及入库操作，枚举肯定是首选。<br>同时，枚举确实是非常灵活的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">  PLUS, MINUS, TIMES, DIVIDE;</span><br><span class="line">  <span class="comment">// Do the arithmetic operation represented by this constant</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> PLUS:   <span class="keyword">return</span> x + y;</span><br><span class="line">      <span class="keyword">case</span> MINUS:  <span class="keyword">return</span> x - y;</span><br><span class="line">      <span class="keyword">case</span> TIMES:  <span class="keyword">return</span> x * y;</span><br><span class="line">      <span class="keyword">case</span> DIVIDE: <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Unknown op: "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">  PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">  Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方案是有问题的，首先我们不喜欢有异常参与，主要是展示可以这样用 switch 语法。<br>另外，永远不要从枚举的序号中得出与它相关的值; 请将其 保存在实例属性中（最好避免使 用 ordinal 方法）。</p><blockquote><p>对于 int 类型的常量取值，参考 JDK 的位运算顺序是个不错的选择，即：<br>1 &lt;&lt; 0  // 1<br>1 &lt;&lt; 1  // 2<br>1 &lt;&lt; 2  // 4<br>使用位域的好处：TBD</p></blockquote><p>枚举其实还是蛮复杂的，不过感觉我们平常用的真的很少，也许确实有一些复杂性在里面。</p><h2 id="Lambdas和Streams"><a href="#Lambdas和Streams" class="headerlink" title="Lambdas和Streams"></a>Lambdas和Streams</h2><p><strong>Lambda 优于匿名类</strong>，一行代码对于 lambda 说是理想的，三行代码是合理的最大值。 如果违反这一规定，可能会严重损害程序的可读性。<br>如果枚举类型具有难以理解的常量特定行为，无法在几行内实现，或者需要访问实例属性或方法，那么常量特定的类主体仍然是行之有效的方法。<br>虽然 Lambda 是首选，但是 Lambda 并不能完全替代匿名类，其中还要注意 this 指向的问题。</p><p><strong>方法引用优于 lambda 表达式</strong>，如果 lambda 变得太长或太复杂，它们也会给你一个结果；你可以从 lambda 中提取代码到一个新的方法中，并用对该方法的引用代替 lambda。 你可以给这个方法一个好名字，并把它文档记录下来（通常 IDE 会有智能提示）。<br>还有就是在 JDK 中就包含了很多内置函数，优先使用这些内置的，没有合适的再自己定义，大部分情况下，自带的就足够了，自己定义的时候记得用 @FunctionalInterface 标记。</p><hr><p>对于 Stream API， 该 API 提供了两个关键的抽象：流 (Stream)，表示有限或无限的数据元素序列，以及流管道 (stream pipeline)，表示对这些元素的多级计算。<br>Stream pipeline 通常是惰性 (lazily) 计算求值；直到终结操作被调用后才开始计算，而为了完成终结操作而不需要的数据元素永远不会被计算出来。 这种惰性计算求值的方式，使得无限流成为可能。<br>通常情况下，流管道会按顺序运行，如果要并行，只需要调用 parallel 方法，但是并不建议这么做。<br>Stream API 具有足够的通用性，实际上任何计算都可以使用 Stream 执行，但是「可以」，并不意味着应该这样做；过度使用流会难以阅读和维护。<br>使用 Lambda 过程中，因为没有显式类型声明，所以好的命名非常重要。<br>流式处理有一个缺点是在多个阶段中一旦将值映射到其他值，原始值就丢失了。流与迭代那种方式好，要具体情况具体分析，通常来说迭代不适合并行化，也不适合计算场景。<br>纯函数的结果仅取决于其输入；它不依赖于任何可变状态，也不更新任何状态，即所谓的无任何副作用。</p><p>对于流的并行化，看似非常简单，只需要调用一下 parallel，但是编写安全高效的并发代码还是一样的困难，你可能会遇到各种奇奇怪怪的现象，并且可能没有任何错误提示。<br>所以，一定要慎用并行处理。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>关于方法的设计，例如方法名的选取、参数不要过多、优先使用接口类型等等这些都已是业界规范，除此之外<strong>与布尔型参数相比，优先使用两个元素枚举类型</strong>。<br>对于重载，也需要警惕，<strong>重载(</strong>overloaded<strong>)方法之间的选择是静态的，而重写 (</strong>overridden<strong>)方法之间的选择是动态的</strong>，这里关键是静态选择，无论你运行时实际是什么类型，都是根据你编写时候来确定走那个重载。<br>可变参数和数组是一种，不可算重载。在数组和 Object 的重载中，null 会优先匹配数组类型，因为比 Object 更具体。<br>很多时候重载不如另起一个更好的名称，例如 readInt、readLong 比使用重载更形象。<br>像自动装箱、Lambda 之类进一步增加了重载的复杂性。开发者应当确保当传递相同的参数时，所有的重载行为都是一致的。<br>在<strong>性能关键的情况下</strong>使用可变参数时要小心，每次调用可变参数方法都会导致数组分配和初始化。</p><p>尽量放回空数组或者集合，不要使用 null，编写客户端的程序员可能忘记编写特殊情况代码来处理 null 返回，如果有证据表明分配空集合会损害性能，可以通过重复返回相同的不可变空集合来避免分配，或者例如 <code>Collections.emptySet</code> 对象；<br>不论是抛出异常还是返回 null，都不合适，前者代价太高，后者需要调用者单独处理；在 Java8 中的 Optional 或许是一个比较好的方案，跟 Guava 中的用法基本一致，容器类型，包括集合、映射、Stream、数组 和 Optional，不应该封装在 Optional 中。<br>需要注意的是：返回包含已装箱基本类型的 Optional 的代价高得惊人，他们有专门的类似 OptionalInt 的包装。<br>在集合或数组中使用 Optional 的键、值或元素几乎都是不合适的。<br>除了作为返回值之外，不应该在任 何其他地方中使用 Optional，使用它也必然会带来一定的性能消耗。</p><h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><p>从 Java 7 开始，就不应该再使用 Random。在大多数情况下，选择的随机数生成器现在是 ThreadLocalRandom<strong>。</strong> 它能产生更高质量的随机数，而且速度非常快。<br>每个程序员都应该熟悉 java.lang、java.util 和 java.io 的基础知识及其子包，也就是不要重复造轮子。<br>若需要精确答案就应避免使用 float 和 double 类型，二进制无法精确表示 0.1，就像十进制无法表示 1/3，要么进行倍数换算成整数运算，要么使用 BigDecimal，不过使用 BigDecimal 的时候一定要用字符串的构造，否则也是不精确的。<br>BigDecimal 与原始算术类型相比很不方便，而且速度要慢得多；如果数值不超过 9 位小数，可以使用 int；如果不超过 18 位，可以使用 long。如果数量可能超过 18 位，则使用 BigDecimal。</p><p>警惕自动装箱的风险，在比较的时候 <code>==</code> 所带来的问题，以及包装类型默认值为 null，避免 NPE。</p><p>不要去计较效率上的一些小小的得失，在 97% 的情况下，不成熟的优化才是一切问题的根源。<br>优化方面的准则：不要优化；在你还没有绝对清晰的未优化方案之前，请不要进行优化。<br>努力编写好的程序，而不是快速的程序。<br>这并不意味着在程序完成之前可以忽略性能问题，实现上的性能问题可以日后优化，对于架构缺陷，如果不重写系统，就不可能解决限制性能的问题，因此在设计时就要考虑性能。<br>总结一下就是，不要努力写快的程序，要努力写好程序；速度自然会提高。但是在设计系统时一定要考虑性能，特别是在设 API、线路层协议和持久数据格式时。<br>当你完成了系统的构建之后，请度量它的性能。如果足够快，就完成了。如果没有，利用分析器找到问题的根源，并对系统的相关部分进行优化。<br>第一步是检查算法的选择：再多的底层优化也不能弥补算法选择的不足。根据需要重复这个过程，在每次更改之后测量性能，直到你满意为止。</p><p>在命名方面，不可实例化的实用程序类通常使用复数名词来命名（xxxxs），转换对象类型的实例方法用 to 开头，返回视图的方法用 as 开头；返回布尔类型的方法用 is 或者 has（比较少）开头；组件（包名）应该很短，通常为 8 个或更少的字符，鼓励使用有意义的缩写，例如 util 而不是 utilities。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>只有在异常情况下才能使用异常，一切其他的骚操作都是不可取的，不仅模糊了代码意思，还降低性能，不要将它们勇于普通的控制流程。<br>优先使用标准异常例如：IllegalArgumentException、IllegalStateException、UnsupportedOperationException。<br>对于底层抛出的异常，直接抛出会让人摸不着头脑，通常会在高层进行转换，方便阅读，并且最好写清楚文档。</p><h2 id="并发和序列化"><a href="#并发和序列化" class="headerlink" title="并发和序列化"></a>并发和序列化</h2><p>关于如何停止线程，stop 方法早已经废弃，主流是控制标志位的方法，但是请注意，标志位的变量一定要 volatile 保证可见性，因为 JVM 的优化（在非同步代码中可能会重排）和 Java 内存模型的关系，<strong>必须要进行 volatile 化</strong>；<br>或者使用 synchronized 进行同步读写标志位的方法，注意，是读写都需要同步，单独独立到方法中去。<br>同时，要避免过度同步，在一个被同步的区域内部，<strong>不要调用设计成要被覆盖的方法</strong>，这个类不知道该方法会做什么事情，也无法控制它，根据外来方法的作用，从同步区域中调用它会导致异常、死锁或者数据损坏（Effective Java 中的例子很经典）。<br><strong>应该将外来代码移出同步区</strong>，必要情况可以使用快照方式来避免 CME 等异常，例如使用 JUC 的 CopyOnWriteArrayList。<br>当你不确定的时候，就不要同步类，而应该建立文档，注明它不是线程安全的，让调用者从外部同步；如果你在内部同步了类，就可以使用不同的方法来实现高并发性，例如分拆锁、分离锁和非阻塞并发控制。<br>不建议使用困难的 wait 和 notify，也正是因为正确地使用 wait 和 notify 比较困难，就应该用更高级的并发工具来代替。<br>最常用的同步器是 CountDownLatch 和 Semaphore，较不常用的是 CyclicBarrier 和 Exchanger ，功能最强大的同步器是 Phaser。<br>Lock <strong>字段应该始终声明为</strong> final，对于延迟初始化，除非需要，否则不要这样做。</p><hr><p>关于序列化，请优先选择 Java 序列化的替代方案，序列化的一个根本问题是它的可攻击范围太大，且难以保护，而且问题还在不断增多；当你反序列化一个你不信任的字节流时，你就会受到攻击。避免序列化利用的最好方法是永远不要反序列化任何东西。<br>反序列化真的非常危险，你不应该接受来自不可信来源的 RMI 流量，但同时它确实又是必须的，或者说广泛使用的，比如 RMI（远程方法调用）、JMX（Java 管理扩展）和 JMS（Java 消息传递系统）。<br>设计不良的序列化形式，可能会造成严重后果；序列化是一种用于创建对象的超语言机制，或者说『隐藏的构造函数』，readObject 方法实际上相当于另外一个<strong>公有的构造器</strong>，或者说是一个「用字节流作为唯一参数」的构造器，并且这个字节流可以伪造；如无必要不要实现 Serializable。<br>为了防止字节流的伪造，建议重写 readObject 方法，在调用 defaultReadObject 之后进行手动校验，但这也只能防止部分攻击；自定义序列化规则的时候注意 transient 的运用，反序列化的时候进行手动恢复。<br>当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果那个字段包含了这样的对象引用，就必须做 保护性拷贝，这是非常重要的。<br>如果单例对象要序列化，请在 readObject 忽略任何序列化相关的逻辑，因为默认无论你做如何防范，它总会返回一个新对象。<br>readResolve 的可访问性 (accessibility) 也十分重要，单例的防攻击可以使用枚举类限制。</p><p>PS：领先的跨平台结构化数据表示是 JSON 和 Protocol Buers，也称为 protobuf（二进制，效率更高）。<br>如果没有显式声明 serialVersionUID，系统会自动使用 SHA-1 进行生成。<br>建议是无论选择哪种序列化形式，都要在编写的每个可序列化类中声明显式的序列版本 UID，目的是为了版本兼容。<br>建议使用序列化代理模式（为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的逻辑状态。这个嵌套类被称为序列化代理），序列化代理方式可以阻止伪字节流的攻击以及内部字段的盗用攻击，但是也有一定的局限性，例如性能方面的损耗。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果 instanceof 的第一个操作数是 null，那么不管第二个操作数是那种类型，都返回 false；</p><p>函数式方法：每次执行返回一个新的实例，而不是修改这个实例。要善用不可变对象；缺点主要是每个不同的值都需要创建一个单独的对象，创建过程可能代价很高。</p><p>除非有充分的理由使类成为可变类，否则类应该是不可变的，唯一的缺点是在某些情况下可能会出现性能问题。</p><p>序列化攻击。</p><p>Java7 开始有了下划线语法，对于底数为 10 的数字，无论是整型还是浮点型的，都应该用下划线将数字分成三个数字组，表示一千的正负幂。</p><p>Java8 开始支持可重复注解，使用 @Repeatable；</p><p>标记接口类型的存在允许在编译时捕获错误，如果使用标记注解，则直到运行时才能捕获错误。<br>标记接口对于标记注解的另一个优点是可以更精确地定位目标；</p><p>优先使用基本类型而不是基本类型的包装类。</p><p>在 Java 7 中添加的 <code>Objects.requireNonNull</code> 方 法灵活方便，因此没有理由再手动执行空值检查。</p><p>性能监控方面，JDK Micro Benchmark Framework：JMH</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书又叫高效 Java，书中的很多条目还是让我眼前一亮的，尤其并发和序列化，大概是因为这一块本来接触的就不多吧，但也有不少内容其实是早就知道的，所以作为我个人的记录，我并不会一条条的罗列出来，主要记录一些平时用的很少或者记得模糊的东西。&lt;br&gt;这本书感觉如果是对入门不久的开发者来说，是非常有必要读一下的，但是如果你经常阅读 JDK 或者 Spring 等开源框架源码的老鸟，其实大部分你都可以跳着看了，因为从它们的源码中基本就能学到大部分的技巧。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础语法</title>
    <link href="https://sakanoy.com/2020/04/25/TypeScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://sakanoy.com/2020/04/25/TypeScript基础语法/</id>
    <published>2020-04-25T17:32:44.000Z</published>
    <updated>2024-11-14T17:46:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript 是 JavaScript 的一个超集，或者说 TS 是基于 JS 的，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上，它可以编译成纯 JavaScript；编译出来的 JavaScript 可以运行在任何浏览器上（不能直接运行 TS）。<br>我对其简单的理解就是强类型的 JS，强类型可以给我们带来静态语言的一些好处，比如可读性和可维护性，也更加适合 IDE 做语法分析和代码提示，同时它也有强大的类型推断，缺点就是学习成本和开发成本（挺明显的）。<a id="more"></a><br>这样看来 TS 对写后端项目可是极其友好，学 TS 也是只看与 JS 的不同点即可，对于 JS 和 Java 基础不错的人，在很多方面真的都是似曾相识，理解起来简单很多。<br>现在的前端项目使用 TS 的越来越多，不管怎么样，还是了解一下为好。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要 Node 的环境，并且 Node 无法直接运行 TS 文件，所以使用下面的命令安装 ts 工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br><span class="line"><span class="comment"># 安装便捷的 node 运行工具</span></span><br><span class="line">npm install ts-node -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控文件变化，自动编译</span></span><br><span class="line">tsc -w</span><br></pre></td></tr></table></figure><p>然后就可以使用 tsc、ts-node 这些命令了。</p><h2 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h2><p>静态类型带来的好处不光是强约束，还有代码提示，因为类型固定，所以此类型的方法也都明确知道了，通过代码来说明：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础类型</span></span><br><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> tag: <span class="built_in">string</span> = <span class="string">'tt'</span>;</span><br><span class="line"><span class="keyword">let</span> temp: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">let</span> tempArr: (<span class="built_in">number</span> | <span class="built_in">string</span>)[];</span><br><span class="line"><span class="comment">// 元组</span></span><br><span class="line"><span class="keyword">const</span> tupleArr: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Student &#123;&#125;</span><br><span class="line"><span class="comment">// 对象类型，定义也可以独立出去，例如 student</span></span><br><span class="line"><span class="keyword">const</span> Person: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'mps'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> stu: Student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型的两种定义</span></span><br><span class="line"><span class="keyword">const</span> fun: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可省略返回值类型使用自动推断</span></span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动约束返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum2</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解构语法赋值约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum3</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    &#123; x, y &#125;: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像类似 <code>const num: number</code> 的定义叫做类型注解，也就是我们告诉 TS 它是什么类型；如果直接不写类型直接写值，那么会自动推断出类型来，当无法推断的时候，只能使用类型注解的方式了。<br>特殊的，如果返回值空，使用关键字 void 标注，最好还是标注一下，虽然有自动推断；其他特殊的有 never 表示永远不会执行到最后，例如抛出异常或者无限循环之类。<br>对于元组类型，可以理解为固定长度，固定顺序的数组，需要你精确控制各个类型的顺序，例如读取 CSV 的时候。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>概念不多说，跟静态语言里的基本一致，也是抽取共性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  desc?: <span class="built_in">string</span>;</span><br><span class="line">  alert?(): <span class="built_in">void</span>;</span><br><span class="line">  alert2?: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  readonly name?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 允许其他类型</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: Point = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口函数类型</span></span><br><span class="line"><span class="keyword">interface</span> echoFun &#123;</span><br><span class="line">  (desc: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str: echoFun = <span class="function">(<span class="params">desc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> desc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口函数『重载』</span></span><br><span class="line"><span class="keyword">interface</span> Fun &#123;</span><br><span class="line">  (): <span class="built_in">string</span>;</span><br><span class="line">  (param: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口非常灵活，能用接口就用接口，实在做不了再考虑类型别名之类。<br>其他的都差不多，都是给 class 实现用的，可以多实现，接口也可以继承。<br>这里补充一下，当你使用结构赋值直接传递的时候 TS 是强校验，就是说多一个少一个都不行；但是你通过对象引用来传递的时候，就不会那么强了，只要不少就行，可以多；亦或者定义中允许其他类型，例如上面的接口。<br>在 TS 编译过程中，接口会被消除，也就是接口只是在 TS 开发阶段帮助我们的工具。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。<br>类在面向对象语言中非常常见，用来封装的好工具，继承、重写等概念之类的不多说，熟悉静态语言的都很熟了，在这里也都基本一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">public</span> desc: <span class="built_in">string</span> = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">static</span> isAnimal(a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">instanceof</span> Animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">public</span> tag: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(name: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Kitty'</span>, <span class="string">'tag'</span>); <span class="comment">// setter: Kitty</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>; <span class="comment">// setter: Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(a.tag); <span class="comment">// tag</span></span><br><span class="line">Animal.isAnimal(a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式，这里使用普通的延迟加载也可以</span></span><br><span class="line"><span class="keyword">class</span> Demo &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> Demo();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 Java，getter 和 setter 方法定义有些许不同，调用的时候也不需要按照方法的形式，不过总体来说基本一致。<br>静态方法可以直接调用，也可以通过实例调用，这一点上一致；可以定义抽象类，可以使用 public、private 和 protected 访问修饰符，不写的话默认是 public；并且可以通过 readonly 关键字定义只读属性。<br>在构造方法中通过类似 <code>public/private tag: string</code> 的语法可以快速定义类似上例中 name 的属性，也就是省去了定义和赋值的代码。<br>在 ES7 中，还加入了实例属性和静态属性，真是越来越熟悉了。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>在定义比较复杂的类型声明时，可以使用类型别名抽取，常用于联合类型（叠加）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Teacher = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t: Teacher= &#123;</span><br><span class="line">  name: <span class="string">'mps'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Stu &#123;</span><br><span class="line">  name: <span class="built_in">string</span> = <span class="string">'mps'</span>;</span><br><span class="line">  clazz: <span class="built_in">string</span> = <span class="string">'one'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 联合类型的转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">data: Stu | Teacher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一种方式</span></span><br><span class="line">  <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Stu) &#123;</span><br><span class="line">    (data <span class="keyword">as</span> Stu).clazz;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二种方式，不需要 as 强转</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'age'</span> <span class="keyword">in</span> data) &#123;</span><br><span class="line">    data.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="string">'123'</span> <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型保护</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span>, y: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> x == <span class="string">'string'</span> || <span class="keyword">typeof</span> y == <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名与接口的一个区别也就是类型别名可以做联合类型，另外例如上面的将 name 设置为 string 的别名，接口就做不到，这也很符合别名这个概念。</p><h2 id="枚举和泛型"><a href="#枚举和泛型" class="headerlink" title="枚举和泛型"></a>枚举和泛型</h2><p>枚举概念上与 Java 中类似，不过幸好远远没有 Java 中那么复杂；也终于看到了泛型，熟悉 Java 的我使用起来没有什么障碍：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123;</span><br><span class="line">  ONE,</span><br><span class="line">  TWO = <span class="number">3</span>,</span><br><span class="line">  THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 3 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Status.ONE)</span><br><span class="line"><span class="built_in">console</span>.log(Status.TWO)</span><br><span class="line"><span class="built_in">console</span>.log(Status.THREE)</span><br><span class="line"><span class="comment">// 反查</span></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span>&lt;<span class="title">E</span>, <span class="title">T</span>&gt;(<span class="params">data: E</span>): <span class="title">E</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型中的 keyof 用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen2</span>&lt;<span class="title">E</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Teacher</span>&gt;(<span class="params">data: Teacher, key: E</span>): <span class="title">Teacher</span>[<span class="title">E</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举里的项默认就是连续数字，默认从 0 开始，如果你手动赋值，之前的从 0 开始，之后就按你赋值的数依次加一；当然你也可以手动设置为字符串类型。<br>TS 中的泛型类型推断要强得多，很多情况虽然可以不写，但是建议写上清晰一点；也可以使用 extends 和 supper 关键字，甚至可以这样写：<code>T extends number | string</code>，灵活性是更多一些。<br>尤其注意 TS 中泛型的 keyof 用法，这相对来说是个新语法，就是展开对象的 key。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>使用之前需要在配置文件中开启 experimentalDecorators，这是 ES7 的东西，好用是好用。<br>首先，装饰器本身也是一个函数，毕竟 JS 中函数是一等公民；装饰器的参数是一个（作用在）构造函数，通过 @ 来调用，示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 表示是构造函数，可简单理解为传入一个有构造的对象（类）返回一个装饰后的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">new</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt; <span class="title">any</span>&gt;(<span class="params">constructor: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">    echo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'decorator'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator2</span>(<span class="params">flag: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> testDecorator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDecorator3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> testDecorator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDecorator</span></span><br><span class="line"><span class="meta">@testDecorator</span>2(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数的方式装饰，避免调用不到装饰新增的方法</span></span><br><span class="line"><span class="keyword">const</span> Test2 = testDecorator3()(</span><br><span class="line">  <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tt = <span class="keyword">new</span> Test(<span class="string">'mps'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tt2 = <span class="keyword">new</span> Test2(<span class="string">'mps'</span>);</span><br><span class="line">tt2.echo();</span><br></pre></td></tr></table></figure><p>执行时机为类『加载』，同时只会执行一次，无论你 new 没 new 都会执行；一个类可以使用多个装饰器，顺序按照定义的顺序。<br>上面介绍的是类装饰器，同样的，也有方法装饰器，作用在类的 prototype（如果是静态方法就是构造函数）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法装饰器，target 表示类的 prototype，静态方法为构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echoDecorator</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 禁止修改方法，通过 PropertyDescriptor 控制方法行为</span></span><br><span class="line">  desc.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 异常处理</span></span><br><span class="line">  <span class="keyword">const</span> fn = desc.value;</span><br><span class="line">  desc.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MethodDemo &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@echoDecorator</span></span><br><span class="line">  echo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法参数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDecorator</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @catchDecorator('msg')</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchDecorator</span>(<span class="params">msg: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">const</span> fn = desc.value;</span><br><span class="line">    desc.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方法装饰器的调用时机，跟类一样，在定义的时候就完成了，不需要等到实例化的时候。<br>特别的，在 setter 和 getter 方法上，只允许一个有装饰器。<br>属性的装饰器跟方法装饰器基本一致，只是不再有 PropertyDescriptor 这个参数了，在装饰器里修改也是改的原型上的值，并不能修改实例的值。<br>而参数装饰器就是多个一个参数位置的参数，其他的基本一致， 我感觉跟注解挺像的。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>假设在 Web 中运用 TS 编译后的文件，如果就最基本的写法，很多类、函数之类的都会变成全局变量，这肯定是混乱糟糕的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> Tese &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> Demo &#123;</span><br><span class="line">    tag: <span class="built_in">string</span> = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 子命名空间</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Sub &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///&lt;reference path='' /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Main &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tese.Demo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用 export 导出，默认是调用不到的，当命名空间互相引用的时候，建议是写清楚注释，虽然这并不是必须的。<br>但是可以看出这种方式并不优雅，为了可读性，建议使用 ES6 的模块化语法，这样就不需要使用 namespace 关键字了。<br>在 Web 场景下使用 ES6 的模块化打包为一个 JS 文件，可能需要使用 amd 标准，但是浏览器不支持，有需要引入其他的支持库，语法也很繁琐，正是如此 Webpack、parcel 之类的打包工具才崛起了。<br>在不同的文件中如果存在相同的命名空间，那么 TS 会做融合处理，也就是取并集。</p><h2 id="附：配置文件"><a href="#附：配置文件" class="headerlink" title="附：配置文件"></a>附：配置文件</h2><p>使用 <code>tsc --init</code> 会在当前目录生成 TS 的编译配置文件，当运行 tsc 的时候自动读取，示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    "target": "es5" /* target用于指定编译之后的版本目标: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */,</span><br><span class="line">    "module": "commonjs" /* 用来指定要使用的模块标准: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */,</span><br><span class="line">    "lib": ["es6", "dom"] /* lib用于指定要包含在编译中的库文件 */,</span><br><span class="line">    "allowJs": true,                       /* allowJs设置的值为true或false，用来指定是否允许编译js文件，默认是false，即不编译js文件 */</span><br><span class="line">    "checkJs": true,                       /* checkJs的值为true或false，用来指定是否检查和报告js文件中的错误，默认是false */</span><br><span class="line">    "jsx": "preserve",                     /* 指定jsx代码用于的开发环境: 'preserve', 'react-native', or 'react'. */</span><br><span class="line">    "declaration": true,                   /* declaration的值为true或false，用来指定是否在编译的时候生成相应的".d.ts"声明文件。如果设为true，编译每个ts文件之后会生成一个js文件和一个声明文件。但是declaration和allowJs不能同时设为true */</span><br><span class="line">    "declarationMap": true,                /* 值为true或false，指定是否为声明文件.d.ts生成map文件 */</span><br><span class="line">    "sourceMap": true,                     /* sourceMap的值为true或false，用来指定编译时是否生成.map文件 */</span><br><span class="line">    "outFile": "./",                       /* outFile用于指定将输出文件合并为一个文件，它的值为一个文件路径名。比如设置为"./dist/main.js"，则输出的文件为一个main.js文件。但是要注意，只有设置module的值为amd和system模块时才支持这个配置 */</span><br><span class="line">    "outDir": "./",                        /* outDir用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹 */</span><br><span class="line">    "rootDir": "./",                       /* 用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现以rootDir的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译 */</span><br><span class="line">    "composite": true,                     /* 是否编译构建引用项目  */</span><br><span class="line">    "incremental": true,                   /* Enable incremental compilation */</span><br><span class="line">    "tsBuildInfoFile": "./",               /* Specify file to store incremental compilation information */</span><br><span class="line">    "removeComments": true,                /* removeComments的值为true或false，用于指定是否将编译后的文件中的注释删掉，设为true的话即删掉注释，默认为false */</span><br><span class="line">    "noEmit": true,                        /* 不生成编译文件，这个一般比较少用 */</span><br><span class="line">    "importHelpers": true,                 /* importHelpers的值为true或false，指定是否引入tslib里的辅助工具函数，默认为false */</span><br><span class="line">    "downlevelIteration": true,            /* 当target为'ES5' or 'ES3'时，为'for-of', spread, and destructuring'中的迭代器提供完全支持 */</span><br><span class="line">    "isolatedModules": true,               /* isolatedModules的值为true或false，指定是否将每个文件作为单独的模块，默认为true，它不可以和declaration同时设定 */</span><br><span class="line"></span><br><span class="line">    /* Strict Type-Checking Options */</span><br><span class="line">    "strict": true /* strict的值为true或false，用于指定是否启动所有类型检查，如果设为true则会同时开启下面这几个严格类型检查，默认为false */,</span><br><span class="line">    "noImplicitAny": true,                 /* noImplicitAny的值为true或false，如果我们没有为一些值设置明确的类型，编译器会默认认为这个值为any，如果noImplicitAny的值为true的话。则没有明确的类型会报错。默认值为false */</span><br><span class="line">    "strictNullChecks": true,              /* strictNullChecks为true时，null和undefined值不能赋给非这两种类型的值，别的类型也不能赋给他们，除了any类型。还有个例外就是undefined可以赋值给void类型 */</span><br><span class="line">    "strictFunctionTypes": true,           /* strictFunctionTypes的值为true或false，用于指定是否使用函数参数双向协变检查 */</span><br><span class="line">    "strictBindCallApply": true,           /* 设为true后会对bind、call和apply绑定的方法的参数的检测是严格检测的 */</span><br><span class="line">    "strictPropertyInitialization": true,  /* 设为true后会检查类的非undefined属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启strictNullChecks，默认为false */</span><br><span class="line">    "noImplicitThis": true,                /* 当this表达式的值为any类型的时候，生成一个错误 */</span><br><span class="line">    "alwaysStrict": true,                  /* alwaysStrict的值为true或false，指定始终以严格模式检查每个模块，并且在编译之后的js文件中加入"use strict"字符串，用来告诉浏览器该js为严格模式 */</span><br><span class="line"></span><br><span class="line">    /* Additional Checks */</span><br><span class="line">    "noUnusedLocals": true,                /* 用于检查是否有定义了但是没有使用的变量，对于这一点的检测，使用eslint可以在你书写代码的时候做提示，你可以配合使用。它的默认值为false */</span><br><span class="line">    "noUnusedParameters": true,            /* 用于检查是否有在函数体中没有使用的参数，这个也可以配合eslint来做检查，默认为false */</span><br><span class="line">    "noImplicitReturns": true,             /* 用于检查函数是否有返回值，设为true后，如果函数没有返回值则会提示，默认为false */</span><br><span class="line">    "noFallthroughCasesInSwitch": true,    /* 用于检查switch中是否有case没有使用break跳出switch，默认为false */</span><br><span class="line"></span><br><span class="line">    /* Module Resolution Options */</span><br><span class="line">    "moduleResolution": "node",            /* 用于选择模块解析策略，有'node'和'classic'两种类型' */</span><br><span class="line">    "baseUrl": "./",                       /* baseUrl用于设置解析非相对模块名称的基本目录，相对模块不会受baseUrl的影响 */</span><br><span class="line">    "paths": &#123;&#125;,                           /* 用于设置模块名称到基于baseUrl的路径映射 */</span><br><span class="line">    "rootDirs": [],                        /* rootDirs可以指定一个路径列表，在构建时编译器会将这个路径列表中的路径的内容都放到一个文件夹中 */</span><br><span class="line">    "typeRoots": [],                       /* typeRoots用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载 */</span><br><span class="line">    "types": [],                           /* types用来指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载进来 */</span><br><span class="line">    "allowSyntheticDefaultImports": true,  /* 用来指定允许从没有默认导出的模块中默认导入 */</span><br><span class="line">    "esModuleInterop": true /* 通过为导入内容创建命名空间，实现CommonJS和ES模块之间的互操作性 */,</span><br><span class="line">    "preserveSymlinks": true,              /* 不把符号链接解析为其真实路径，具体可以了解下webpack和nodejs的symlink相关知识 */</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    "sourceRoot": "",                      /* sourceRoot用于指定调试器应该找到TypeScript文件而不是源文件位置，这个值会被写进.map文件里 */</span><br><span class="line">    "mapRoot": "",                         /* mapRoot用于指定调试器找到映射文件而非生成文件的位置，指定map文件的根路径，该选项会影响.map文件中的sources属性 */</span><br><span class="line">    "inlineSourceMap": true,               /* 指定是否将map文件的内容和js文件编译在同一个js文件中，如果设为true，则map的内容会以//# sourceMappingURL=然后拼接base64字符串的形式插入在js文件底部 */</span><br><span class="line">    "inlineSources": true,                 /* 用于指定是否进一步将.ts文件的内容也包含到输入文件中 */</span><br><span class="line"></span><br><span class="line">    /* Experimental Options */</span><br><span class="line">    "experimentalDecorators": true /* 用于指定是否启用实验性的装饰器特性 */</span><br><span class="line">    "emitDecoratorMetadata": true,         /* 用于指定是否为装饰器提供元数据支持，关于元数据，也是ES6的新标准，可以通过Reflect提供的静态方法获取元数据，如果需要使用Reflect的一些方法，需要引入ES2015.Reflect这个库 */</span><br><span class="line">  &#125;</span><br><span class="line">  "files": [], // files可以配置一个数组列表，里面包含指定文件的相对或绝对路径，编译器在编译的时候只会编译包含在files中列出的文件，如果不指定，则取决于有没有设置include选项，如果没有include选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用* ? **/ 等通配符</span><br><span class="line">"include": [],  // include也可以指定要编译的路径列表，但是和files的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符，比如"./src"即表示要编译src文件夹下的所有文件以及子文件夹的文件</span><br><span class="line">"exclude": [],  // exclude表示要排除的、不编译的文件，它也可以指定一个列表，规则和include一样，可以是文件或文件夹，可以是相对路径或绝对路径，可以使用通配符</span><br><span class="line">"extends": "",   // extends可以通过指定一个其他的tsconfig.json文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置。TS在3.2版本开始，支持继承一个来自Node.js包的tsconfig.json配置文件</span><br><span class="line">"compileOnSave": true,  // compileOnSave的值是true或false，如果设为true，在我们编辑了项目中的文件保存的时候，编辑器会根据tsconfig.json中的配置重新生成文件，不过这个要编辑器支持</span><br><span class="line">"references": [],  // 一个对象数组，指定要引用的项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在官方的<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">文档</a>中，各个配置项有详细的说明。如果你使用 ts-node 工具，也会使用这个编译配置文件的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们约定使用 TypeScript 编写的文件以 <code>.ts</code> 为后缀，用 TypeScript 编写 React 时，以 <code>.tsx</code> 为后缀。</p><p>在 TS 中不能直接 import JS 库，如果需要，要额外安装对应的翻译库，这个 VSC 之类的 IDE 都有提示，会转换到一个 <code>.d.ts</code> 中间文件；这个文件仅仅是用 <code>declare var</code> 语法将对应库的 JS 语法合理化，也就是为了避免 IDE 的错误提示，即使不用也可以使用 parcel 之类正确的打包。</p><p>相比 Webpack，parcel 更快，也无需配置即可使用，做 demo 是很适合用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript 是 JavaScript 的一个超集，或者说 TS 是基于 JS 的，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上，它可以编译成纯 JavaScript；编译出来的 JavaScript 可以运行在任何浏览器上（不能直接运行 TS）。&lt;br&gt;我对其简单的理解就是强类型的 JS，强类型可以给我们带来静态语言的一些好处，比如可读性和可维护性，也更加适合 IDE 做语法分析和代码提示，同时它也有强大的类型推断，缺点就是学习成本和开发成本（挺明显的）。
    
    </summary>
    
      <category term="Web" scheme="https://sakanoy.com/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://sakanoy.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot编程思想之不求甚解</title>
    <link href="https://sakanoy.com/2020/04/18/SpringBoot%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B9%8B%E4%B8%8D%E6%B1%82%E7%94%9A%E8%A7%A3/"/>
    <id>https://sakanoy.com/2020/04/18/SpringBoot编程思想之不求甚解/</id>
    <published>2020-04-18T13:40:50.000Z</published>
    <updated>2024-11-14T17:46:09.409Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 领域，SpringBoot 是目前最流行的微服务框架，将使用门槛大幅度的降低，达到开箱即用；那么这也必然使 SB 成为了一个黑盒，如果需要深度定制或者了解内部原理变得有点复杂，希望通过阅读本系列书籍来解开这个黑盒。<br>最重要的部分就是 SB 的主要特性部分，自动装配和自动配置方面的理解；从 SB2.x 开始架构逐步稳定，现在可以尝试大规模使用了。<br>微服务架构作为一种细粒度的 SOA，无论那种表达方式，只不过是名词之争，架构设计的好坏不在于理论和技术，而在于实施者对业务的理解和专业水平。<a id="more"></a><br>想了一下，直接写到这一篇里了，不再分篇，超长文预警。</p><h2 id="初探SpringBoot"><a href="#初探SpringBoot" class="headerlink" title="初探SpringBoot"></a>初探SpringBoot</h2><p>对于简单的使用没什么可说的，SB 是出了名的简单，这是对于使用来说，也有句话越简单的东西越复杂，关于基本的使用参考官方文档和 API 文档基本就可以了，我之前也写过两篇使用内容为主的：<a href="https://bfchengnuo.com/2017/10/15/SpringBoot%E5%88%9D%E5%B0%9D%E8%AF%95/" target="_blank" rel="noopener">SpringBoot初尝试</a>、<a href="https://bfchengnuo.com/2018/08/26/SpringBoot%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">SpringBoot进阶</a><br>上面的两篇可能与本篇有重叠，但是总应该是互补的，侧重点不同。还可以参考我的一篇笔记<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Spring%E5%AE%B6%E6%97%8F/SB_depth.md" target="_blank" rel="noopener">深入SB</a><br>还有一篇未完成的 <a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/TODO/Spring%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0.md" target="_blank" rel="noopener">Spring核心编程概述</a> 待填坑。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">官方</a>列举了六大特性：</p><ol><li>创建独立的 Spring 应用</li><li>嵌入 Tomcat, Jetty 或者 Undertow 等 Web 容器（不需要部署 War 文件）</li><li>提供固化的 starter 依赖，简化构建配置</li><li>当条件满足时，自动装配 Spring 或者第三方类库</li><li>提供运维特性，例如指标信息、健康检查、外部化配置</li><li>绝无代码生成，不需要 XML 配置</li></ol><h3 id="独立的Spring应用"><a href="#独立的Spring应用" class="headerlink" title="独立的Spring应用"></a>独立的Spring应用</h3><p>SpringBoot 除了构建我们熟悉的 Web 应用，在非 Web 应用上也是非常好用的，例如服务提供、调度任务、消息处理等场景。<br>并且，在 Web 应用方面，除了传统的 Servlet 容器，2.x 版本实现了 Reactive Web 容器，也就是 Spring5.x 的 WebFlux。</p><p>按照一般的思路用 SB 构建的应用我们应该叫 SB 应用，然而实际上是 Spring 应用，因为在 SB 的构建过程中，主要的驱动核心是靠 SpringApplication 完成的，所以可以称为 Spring 应用。</p><blockquote><p>Spring Web 时代是利用 ServletContext 生命周期构建 Web Root Spring 应用上下文（ContextLoaderListener）；<br>结合 Servlet 生命周期构建 DispatcherServlet 的 Spring 应用上下文。</p></blockquote><p>所以，在 Spring Web 时代都是被动的回调执行，没有完整的应用主导权，这在使用了嵌入式容器后才改善。</p><h3 id="可执行JAR"><a href="#可执行JAR" class="headerlink" title="可执行JAR"></a>可执行JAR</h3><p>用 SB 构建的应用我们可以非常方便的使用 <code>java -jar</code> 来运行，但是默认的 Maven 打包出来是不支持的，这是因为使用了一个 Maven 插件：spring-boot-maven-plugin，并且一般情况不需要指定版本，因为父工程已经配置好了。<br>可执行 JAR 又被称为 fat jars。<br>PS：开发环境使用 <code>mvn spring-boot:run</code> 命令运行也是同样效果。</p><p>我们知道 jar 文件其实就是一个 zip 包，解压可执行 jar 文件会得到一些目录和文件：</p><ul><li>BOOT-INF/classes<br>存放应用编译后的 class 文件</li><li>BOOT-INF/lib<br>存放依赖的 jar 包</li><li>META-INF/<br>存放相关元信息，例如 MANIFEST.MF</li><li>org/<br>存放 SB 相关 Class 文件</li></ul><p>接下来就是分析为什么这个 jar 可以直接运行了，依赖于 spring-boot-loader；<br>根据 Java 规范，如果使用 -jar 运行，引导配置必须放在 MANIFEST.MF 文件中，它必须在 META-INF 目录下；所以你查看这个文件基本就能了解了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher  # Main 函数</span><br><span class="line">Start-Class: com.example.demo.DemoApplication  # 启动类</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/         # 编译之后的 class 文件目录</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/                 # 当前工程依赖的 jar 包目录</span><br><span class="line">Build-Jdk-Spec: 1.8                            # 指定的 JDK 版本</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE             # SpringBoot 版本</span><br></pre></td></tr></table></figure><p>这里主要看 JarLauncher 这个类，相应的，打出来的可执行 war 包就是 WarLauncher；知道了核心类，那么我们就又了另一种启动方式，把 jar 包解压，在解压后的目录可以直接执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>这样也是可以正常启动 Spring 应用，可以得出 JarLauncher 装载执行了我们的启动类，如果你尝试直接运行启动类，很遗憾是不行的，原因是 lib 依赖库的原因。<br>具体的原因可以查看 JarLauncher 的源码，很简单就不说了（深层次的例如对于 URL 协议的处理就很难理解），里面进行了处理所以才能 jar 或者解压后运行。<br>一句话概括就是：<strong>JarLauncher 实际上是同进程内调用 Start-Class 的 main 方法，并在启动前准备好 CP（classpath）</strong>，war 包亦是如此，不过目录会有所差别，毕竟要兼容 servlet 容器（仅关注 WEB-INF/classes、lib）运行，根据容器的特性就可以做到忽略非规范目录的冲突的包，当然 WebFluex 不行。</p><h3 id="嵌入式Web容器"><a href="#嵌入式Web容器" class="headerlink" title="嵌入式Web容器"></a>嵌入式Web容器</h3><p>从 2.x 开始，Netty 也作为容器加入，不同容器无法共存，Undertow 作为 JBoss 社区推出的新一代兼容 Servlet3.1+ 的容器，用的还是不太广泛。<br>目前最新版本支持 HTTP/2 和 servlet4.0，核心 jar 体积只有 2.2MB，4.0 规范对应 Tomcat 和 Jetty 9.x，Undertow 2.x。<br>因为 SpringFlux 基于 Reactor 框架实现，因此 Netty 容器属于 Reactor 和 Netty 的整合实现；<br>其他的三种容器<strong>也能作为 Reactive Web Server</strong>，默认是 Netty，毕竟 <strong>Servlet3.1+ 也支持 Reactive 异步非阻塞的特性</strong>。<br>另外需要说明的是，嵌入式容器并不是 SB 首创，各个容器早就支持，SB 不过是将整合做到了极致。</p><blockquote><p>Apache Tomcat 官方很早就提供了相应的可执行 jar 的构建插件，但是运行时还是通过解压到临时目录的方式实现；<br>对于 SB，它使用了零压缩模式，所以可以不解压直接读取运行，也正是这个所以重写 JAR 协议的 URL 实现。</p><p>同样，Jetty 天然的可插拔 API 对嵌入式容器开发更加友好，也是 Google 的 GAE 弃用 Tomcat 转为 Jetty 的一个原因；不仅想如果当时有 SB 这种框架或许迁移难度会大幅下降。</p></blockquote><p>在嵌入式 Reactive Web 容器方面，Undertow 用的还是蛮多的，它也对这两种情况各有一个实现。当依赖中存在 WebFlex 的时候，容器的 Starter 就自动装配为 Reactive 容器了。</p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>关于这点，一开始让我们感觉很神奇，文档也是轻描淡写『@EnableAutoConfiguration 和 @SpringBootApplication <strong>两者选其一</strong>标注在 @Configuration 类上』，但是它没说明这个 @Configuration 是如何装配的。<br>对于 Spring，我们熟悉常见的三种装配方式：</p><ul><li><code>&lt;context:component-scan&gt;</code> 标签</li><li>@Import</li><li>@ComponentScan</li></ul><p>以上三种手段均需要 Spring 上下文引导，前一个可以使用 ClassPathXmlApplicationContext 加载，后者就需要 AnnotationConfigApplicationContext 加载；<br>对于 SB 很显然是通过 SpringApplication 实现的，那么我们可以认为，主启动类承担了 @Configuration 的角色。</p><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>这个注解肯定不陌生，它是很有料的，如果你点进去看源码，相关的分析其实在『<a href="https://bfchengnuo.com/2018/08/26/SpringBoot%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">Spring进阶</a>』中已经说的差不多了，这里不再重复，简单说它相当于开启自动装配、标注配置类、开启包扫描；在包扫描上，它排除了一些特定类型，例如同时标注配置类和开启自动装配的，这就避免了使用多次时的冲突问题。<br>PS：配置类源于 @Component 的派生，Spring 称为『模式注解』。</p><p>另外，在这个注解中，使用了大量的 @AliasFor 别名，这属于 JDK 的知识了，只是提醒一下。</p><p>@SpringBootApplication 也并不是一定要标注在引导类上，只要保证 run 方法传递的是标注这个注解的类即可，这一点的原因在进阶文章里也提到过。<br>具体的将也不是非 @SpringBootApplication 不可，官方的说法 @EnableAutoConfiguration 也是没问题的（即使它不是 @Configuration），这里去看进阶篇就足够了，点到为止，之后还会深入分析，这里还不到时候。</p><hr><p>作为 @Configuration 的派生类，也继承了 CGLIB 提生的特性，官方文档中有说明，传统的 @Bean 属于轻量模式（Lite）在 @Configuration 或者 @Component 下的 @Bean 就属于完全模式（Full），会执行 CGLIB 提升。</p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>这个注解如果你看的话跟 @Configuration 没什么不同，但是在 SB 中，官方建议多使用 @SpringBootConfiguration，在做注解元数据解析的时候会有帮助。</p><h3 id="创建自动配置类"><a href="#创建自动配置类" class="headerlink" title="创建自动配置类"></a>创建自动配置类</h3><p>编写自动配置类也是有固定套路的，一般创建名为 xxxAutoConfiguration 的配置类，这个类一般被标注了 @Configuration 和 @Import 注解；<br>对于 @Import 注解，你可以选择导入一个配置类或者 ConfigurationSelector 的实现类。<br>接下来，就是配置执行入口，也就是在 <code>META-INF/spring.factories</code> 文件中配置这个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.bfchengnuo.demo.xxxAutoConfiguration</span><br></pre></td></tr></table></figure><p>因为都是注解，解析注解带来的时间成本肯定会影响应用的启动速度，所以在 Spring5.x 的时候加入了 @Indexed 注解，在<strong>编译</strong>的时候就会向 @Component 和其派生注解增加索引，从而减少运行时的消耗。</p><h3 id="Production-Ready特性"><a href="#Production-Ready特性" class="headerlink" title="Production-Ready特性"></a>Production-Ready特性</h3><p>也就是为生产准备的特性，例如指标、健康检查、外部化配置。<br>它是 DevOps 的立足点，当然这个词具体的定义就是仁者见仁智者见智了。<br>对于 SpringBootActuator 国内大部分都不重视，其实还是很有用的，它用于监控和管理 Spring 应用，可以通过 HTTP Endpoint 或者 JMX Bean 与其交互。<br>这里就不继续展开了，内容还是蛮多的，如果以后逐步都用起来了，估计还会单独写吧，个人感觉还是很有前途的。</p><p>下面说说外部化配置，在 SB 中有三种用途：</p><ol><li>Bean 的 @Value 注入</li><li>Spring Environment 读取</li><li>@ConfigurationProperties 的读取</li></ol><p>上面说的是消费方，那么生产源呢，在<a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">官方文档</a>中描述了 17 种 PropertySource 的顺序，然而我们平常用的并不多，也就是用用命令行指定来替代 application.yml 中的属性。<br>因为 SB 的规约大于配置思想，让我们省去了大量的配置。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>纵观 Spring 的一路演变，就是注解驱动之路，在 3.1 之后可谓大变化，增加了 @EnableXXX 模式，包扫描和 ConfigurationSelector（ImportSelector）；到了 4.x 有了 Condition 条件注解，接下来会更加详细的探讨。<br>SB 的特性让其称为微服务的基础组件，也是 SC 的基础设施，或者将 SB 称为微服务的中间件，也是 SB 的出现让 Spring 社区焕发了第二春，简单再说 SC，对于分布式系统要解决的问题有：</p><ul><li>分布式配置</li><li>服务注册和发现</li><li>路由</li><li>服务调用</li><li>负载均衡</li><li>熔断机制</li><li>分布式消息</li></ul><p>Spring 官方最大的优势就是 API 设计能力，也可以说是抽象能力，云平台的现在，Java 已经派生语系处于垄断地位，SC 也慢慢成长（虽然 Netflix 进入维护模式，不过 Alibaba 崛起了）SpringCloudStream 也可以了解一下。</p><h2 id="走向自动装配"><a href="#走向自动装配" class="headerlink" title="走向自动装配"></a>走向自动装配</h2><p>前面的自动装配只是简单的提了一下相当于是结果，这一部分讲述自动装配的发展过程以及其中涉及的一些编程模式。</p><h3 id="注解驱动的发展"><a href="#注解驱动的发展" class="headerlink" title="注解驱动的发展"></a>注解驱动的发展</h3><p>在 Spring2.5 的时候我们常用的 @Autowired、@Component、@Order、@Service、@Qualifier、SpringMVC 相关注解才被加入，之前基本还是 XML 的天下，即使这个版本提供了大量的注解，但是还是离不开 <code>&lt;context:component-scan&gt;</code> 和 <code>&lt;context:annotation-config&gt;</code> 的噩梦。</p><blockquote><p>对于 @Qualifier 这个注解，还有一种『逻辑类型』限定的使用（不带参数，用来缩小匹配范围），例如在 SC 的 @LoadBalanced 中就如此使用。<br>即，你在 @Bean 的时候顺带加一个 @Qualifier，那么在 @Autowired 的时候也加一个 @Qualifier 它会自动找之前定义的时候也有 @Qualifier 的对象，就算有其他的相同的类型的 Bean 也会被过滤，并且这种方式不需要写值。<br>另外，Spring 还有一种缺省机制，也可以说容错机制，在没用 @Qualifier 注解下，即缺省情况下使用 Bean 标识符（方法名、字段名）注入。</p></blockquote><p>到了 3.x 时代，进入了注解驱动的黄金时代，井喷式增长，当然也跟 Java5 的特性有关，通过派生性，有了 @Configuration 这类注解，@Import 也出现了，并且提供 @ImportResource 来解决 XML 遗留问题。<br>通过加入 @Bean 等一些列注解对标 XML 配置，决心替代 XML 了。那么最后的问题，谁来引导 SpringContextConfiguration 呢，不可能通过包扫描标签，那样又是依赖 XML，所以有了 AnnotationConfigApplicationContext，用这个来注册 @Configuration，并且通过前面的 @ImportResource 导入遗留的 XML 配置，虽然这种方式看起来有点别扭。<br>终于，在 3.1 的时候引入 @ComponentScan 替换了包扫描标签，全面进入注解驱动时代；<br>同时，也出现了 @Profile 这类条件化定义 Bean 能力的注解，虽然功能很弱；Web 方面也是突飞猛进，@RequestBody 之类的注解也都出现；<br>并且 3.x 时代还新增了 Environment 之类的 API 接口，@PropertySource 的出现为外部化配置奠定了基础，其他的还有很多，例如缓存的抽象、异步的支持（@Schedule、异步 Web 处理）、校验注解（JSR-303）、@Enable 模块驱动（@EnableWebMvc 等）。<br>所以，3.x 真的是黄金时代，看着都兴奋。</p><hr><p>接下来的 4.x 进入完善时代，上面说过 @Profile 很鸡肋，所以加入了 @Conditional，通过编程的方式来解决 @Profile 灵活性不足的问题，SB 中的 @ConditionalOn* 就是这个的派生。<br>尽管不是强制使用 Java8，但也巧妙的兼容了新的时间 API、@Repeatable 和参数名称发现；也正是有了 @Repeatable 所以 @PropertySource 提升为了可重复标注的注解（Java8 之前可以配合 @PropertySources 使用），@ComponentScan 也是同理；<br>同时，4.2 新增了 @EventListener 作为 ApplicationListener 的另一个选择，@AliasFor 注解也解除了之前派生的一些限制（@GetMapping 一类注解就使用了这个特性），加入 @CrossOrigin 作为 CorsRegistration 的替换方案。<br>其他的一些例如依赖查找 @Lookup 处在比较边缘化的地位，不需要太多了解。</p><hr><p>最后，也就是现在的 5.x 版本，新增的 @Indexed 用来构建索引，加快包扫描，但是存在一定的缺陷，要避免模式注解忽略的问题（例如项目引入两个 jar，一个使用了一个没使用，并且包名相同，那么你在项目里只能扫到使用了 @Indexed 的 Bean，因为没使用的不会存在于 <code>META-INT/spring.components</code> 索引文件中，存在这个文件 Spring 就不会扫描包，只会寻找索引文件对应的 CandidateComponentsIndex 对象）；感兴趣的可以研究一下。<br>同时引入了 JSR-305 适配注解 @NonNull 之类（Spring 中已经大量使用），为 Java 和 Kotlin 之间提供技术杠杆。</p><h3 id="注解编程模型"><a href="#注解编程模型" class="headerlink" title="注解编程模型"></a>注解编程模型</h3><p>Java 语言规范规定，注解不能继承，没有派生子类的功能，所以 Spring 采用了元标注（注解上标注注解）的方式来实现『派生』；<br>需要注意，直到 Spring4.x 才实现了多层次派生性，之前都是深度有限，4.x 版本中的 AnnotationAttributesReadingVisitor 使用了递归方式查找元注解，这个问题才得以解决，不过 SB 最低版本都是依赖 4.x+，所以不用担心。<br>其他的，为了方便使用还添加了很多组合注解，例如 @TransactionalService 就是 @Transactional 和 @Service 的组合；那么如何感知是个问题，常规的思路肯定是反射手段解析元信息，但是 Spring 并没有这么做，使用的是抽象出 AnnotationMetadata 这个接口。<br>为了提高效率，Spring 的类加载机制是通过 ASM 实现的，例如 ClassReader，相对于 ClassLoader 体系，它直接操作字节码，也便于进行字节码提升；这方面的内容很复杂，是一个大的体系，这里不再详细说明。</p><blockquote><p>AnnotationMetadata 有两个实现类：AnnotationMetadataReadingVisitor 和 StandardAnnotationMetadata；<br>前者使用 ASM 方式读取，涉及 AnnotationMetadata 和 ClassMetadata 等对象，丰富性肯定不如 Java 反射 API；<br>后者使用 Java 反射进行读取，用的也很多。</p></blockquote><p>那么 Spring 为什么要两套实现？<br>除了效率的差距，还有一个是场景，如果使用 Java 反射 API，必然需要一个大前提，就是<strong>反射的 Class 必须被 ClassLoader 装载</strong>，但是在 Spring 的包扫描阶段，显然是不可能的，所以使用 ASM 的方式；之后装载之后就可以使用 Java API 了。<br>如果需要进行反射相关操作，不妨试试 Spring 提供的反射工具类：ReflectionUtils；类似的 AnnotationUtils、AnnotatedElementUtils 的工具类 Spring 中也大量使用。<br>同时，在使用元注解的时候要留意属性覆盖的情况，细分可以是显性覆盖（@AliasFor）和隐性覆盖；其中也有一些规则，这里不细说了。</p><h3 id="注解驱动设计模式"><a href="#注解驱动设计模式" class="headerlink" title="注解驱动设计模式"></a>注解驱动设计模式</h3><p>从 @Enable 模式开始说起（模块装配），Spring 中就存在很多，例如 Web Mvc、缓存、JMX、Async 模块等，这都是来自 Spring，并不是 SB 的特性，当然在 SB 和 SC 中也有新增，例如开启自动装配。<br>这个模式简化了装配模式，做到了按需装配，但是缺点是必须手动开启。<br>而想要自定义 @Enable 也很简单，你可以随便拿一个来参考，主要就是利用 @Import 和 @Configuration，当然你也可以试试接口编程的 ImportSelector 接口，其他的 ImportBeanDefinitionRegistrar 用的相对少一点。<br>而原理，主要还是对这些注解的解析，因为这又是一个大的体系，在这也不想多说，简单提一提：</p><blockquote><p>无论是 XML 还是注解驱动的场景，均是通过 AnnotationConfigUtils 的 registerAnnotationConfigProcessors 方法进行装载 ConfigurationClassPostProcessor 类，这个类是最高优先级的 BeanFactoryPostProcessor 实现。</p></blockquote><p>解析 Spring BeanDefinition 的注解元信息最重要的组件是 ConfigurationClassParser，它的两个重载分为不同的实现，就是前面说过的 AnnotationMetadataReadingVisitor 和 StandardAnnotationMetadata；<br>这里也会进行递归调用解析，还记得前面说的轻量模式和完全模式么，就是根据这个来区分进行 CGLIB 提升。</p><h4 id="SpringWeb自动装配"><a href="#SpringWeb自动装配" class="headerlink" title="SpringWeb自动装配"></a>SpringWeb自动装配</h4><p>在 Spring 中除了模块装配，在 3.1 之后，也支持自动装配，仅限于 Web 场景；新引入的 WebApplicationInitializer 构建在 Servlet 3.0  的 ServletContainerInitializer 上，支持编程方式替代传统 web.xml。<br>在 SpringSecurity 也有类似的实现 AbstractSecurityWebApplicationInitializer。</p><p>实现原理还是依赖 Servlet 3.0 的特性，大部分开发人员对 Servlet 规范还是陌生的，新规范带来的运行时插拔可是极大的灵活性（拓展知识 SPI），也不能说新了，毕竟很多年了，现在 4.0 的异步技术又有多少人关注呢。<br>关于这一块的内容，如果感兴趣去稍微看下源码，其实还挺有意思的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractDispatcherServletInitializer</span><br><span class="line">  |-AbstractAnnotationConfigDispatcherServletInitializer</span><br><span class="line">    |-AbstractContextLoaderInitializer</span><br></pre></td></tr></table></figure><p>在 Web Mvc 中，DispatcherServlet 有专属的 WebApplicationContext，它继承了来自 Root WebApplicationContext 的所有 Bean，也就是我们常说的父子容器。<br>无论哪一个容器，都是基于注解驱动的 Web 应用上下文实现的，一般情况我们选择最具体的就好。</p><h4 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h4><p>说的就是 @Profile 和 @Conditional，对于 Profile 只支持简单的 <code>@Profile({&quot;dev&quot;, &quot;prod&quot;})</code>、<code>@Profile(&quot;!dev&quot;)</code> 这种形式，具体的处理原理不多说了，还是分析注解元数据那一套。<br>由于 Profile 太过于局限性，现在基本都是 @Conditional 的天下，实现起来也不复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(&#123;ProfileCondition.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个源码，还有什么疑问，肯定是 @Conditional 的天下了。<br>当多个 Conditional 并存时，会使用 @Order 排序，需要注意一下；ConditionEvaluator 的评估有两个阶段，Bean 注册阶段和 Configuration Class 解析阶段。</p><h3 id="SB自动装配"><a href="#SB自动装配" class="headerlink" title="SB自动装配"></a>SB自动装配</h3><p>在 SB 中的自动装配相比上面所说，一个区别就是应用依赖的 Jar 存在变化的可能，因为所在包的路径不确定，所以很多手段都不太合适，或许会想到使用 @ComponentScan 来全局扫描，但是官方文档中明确表示不鼓励这样扫描默认包，因为它会读取所有 Jar 中的类。<br>SB 的自动装配是非侵占性的，对于失效自动装配有两种方式：代码配置（@EnableAutoConfiguration 的 exclude）和外部化配置（<code>spring.autoconfigure.exclude</code>），为了避免侵入性，外部化是优先选择。<br>如果你想看 SB 自动装配的原理，可以进入注解发现是通过 AutoConfigurationImportSelector 来实现的，读一下这个的源码就能猜个差不多，从字面意思：</p><ol><li>加载自动装配的元信息<br>至于为什么需要加载元信息，因为 @Conditional 之类的注解处理时机较晚，所以根据元信息来匹配就减少了自动装配的时间，参考：spring-autoconfigure-metadata.properties</li><li>获取 @EnableAutoConfiguration 标注类的元信息</li><li>获取自动装配的候选类名集合<br>使用 SpringFactoriesLoader 进行读取，采用 Spring 工厂机制的加载器，简单说就是读取 spring.factories 中的配置，合并成一个 Map。</li><li>移除重复对象<br>利用的是 Set 集合去重：<code>return new ArrayList&lt;&gt;(new LinkedHashSet&lt;&gt;(list));</code></li><li>移除我们自己配的『失效自动装配』</li><li>再根据 autoConfigurationMetadata 过滤<br>过滤 spring.factories 中那些当前 ClassLoader 不存在的 Class，可以说是检查是否合法</li><li>触发自动装配导入事件</li></ol><p>SpringFactoriesLoader 在 SB 中大量的使用，这一块的内容确实不少，如果是做基础架构的，还是要深入了解，我这种打酱油的就先点到为止。<br>关于事件，这里贴一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖于 spring.factories 配置文件：</span></span><br><span class="line"><span class="comment">// org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span></span><br><span class="line"><span class="comment">//   thinking.in.spring.boot.samples.auto.configuration.listener.DefaultAutoConfigurationImportListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAutoConfigurationImportListener</span> <span class="keyword">implements</span> <span class="title">AutoConfigurationImportListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAutoConfigurationImportEvent</span><span class="params">(AutoConfigurationImportEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前 ClassLoader</span></span><br><span class="line">    ClassLoader classLoader = event.getClass().getClassLoader();</span><br><span class="line">    <span class="comment">// 候选的自动装配类名单</span></span><br><span class="line">    List&lt;String&gt; candidates =</span><br><span class="line">      SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader);</span><br><span class="line">    <span class="comment">// 实际的自动装配类名单</span></span><br><span class="line">    List&lt;String&gt; configurations = event.getCandidateConfigurations();</span><br><span class="line">    <span class="comment">// 排除的自动装配类名单</span></span><br><span class="line">    Set&lt;String&gt; exclusions = event.getExclusions();</span><br><span class="line">    <span class="comment">// 输出各自数量</span></span><br><span class="line">    System.out.printf(<span class="string">"自动装配类名单 - 候选数量：%d，实际数量：%d，排除数量：%s\n"</span>,</span><br><span class="line">                      candidates.size(), configurations.size(), exclusions.size());</span><br><span class="line">    <span class="comment">// 输出实际和排除的自动装配类名单</span></span><br><span class="line">    System.out.println(<span class="string">"实际的自动装配类名单："</span>);</span><br><span class="line">    event.getCandidateConfigurations().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"排除的自动装配类名单："</span>);</span><br><span class="line">    event.getExclusions().forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SB 的事件分发相关在后面会说，事件的分发是一个非常重点的内容。</p><p>从生命周期来说，因为 AutoConfigurationImportSelector 实现了 DeferredImportSelector，从名字看这是延迟的（会有一个待处理队列），它在 @Configuration Bean 处理完毕后才会运作，Order 来看也是优先级接近最低的。<br>拓展阅读：ConfigurationClassParser（实际执行 ImportSelector 的地方）</p><p>在顺序方面，可选择的有两种，固定和相对，例如 @AutoConfigureOrder 和 @AutoConfigureBefore，他们两个之间的顺序是先固定然后再根据相对顺序调整。<br>PS：尽量使用 name 属性，别用 value，还是因为 SB 升级导致的破坏性 API 变更，每次升级或多或少都有些。</p><p>关于自动装配的 BasePackages 参考嵌套类：AutoConfigurationPackages.Registrar，为了避免重复导入，会根据名字判断 IoC 有没有，也就是它只会注册一次。<br>因为方法执行在 Bean 初始化阶段，其 BeanDefinition 还有调整的机会，所以可以追加，借此达到夸大搜索范围的目的。</p><h3 id="自定义SB自动装配"><a href="#自定义SB自动装配" class="headerlink" title="自定义SB自动装配"></a>自定义SB自动装配</h3><p>从 spring.factories 这种加载机制可以看出与 SPI 非常像，那么接下来正式开始，首先从命名来看，遵循 SB 的套路使用 *AutoConfiguration 这样的规则，也要看一下他们的包结构，模仿着写；<br>Spring 官方建议自动装配的代码写在 autoconfigure 模块下，starter 模块依赖该模块，并且附加其他需要的依赖，当然官方并没有坚持要分包（jar），开发者完全可以合并到一个模块（jar）。</p><p>Starter 的命名，官方建议是使用 <code>${module}-spring-boot-starter</code> 的命名模式（或者拆分出一个 autoconfigure 模块），使用 spring-boot-configuration-processor 可以帮助 @ConfigurationProperties Bean 生成 IDE 辅助信息。<br>PS：在设置 Key 命名空间的时候，注意不要跟官方冲突，要不然，可能会有奇奇怪怪的问题。</p><p>总体来说跟『创建自动配置类』差不多，毕竟那是基础，编写完自动配置类后将其加入 spring.factories 文件，然后就可以构建 Starter，其中你所依赖的 SB 相关依赖都要设置为 <code>&lt;optional&gt;true&lt;/optional&gt;</code> 不要传递依赖，因为用户使用的 SB 版本可能会与之发生冲突，由于不同环境的 ClassLoader 不确定性，最终导致 Class 文件二进制不兼容的情况，可能表现为 IDE 中正常线上不正常或者反之，例如常见的 NoClassDefFoundError、NoSuchMechanismException 等。</p><blockquote><p>其中可以使用 @ConditionalOn* 之类条件注解来实现，由于 SB 的设计问题，在 2.0 时代真的是改来改去，各种破坏性升级，让人怀疑人生，一般情况为，name 属性是用于第三方库或者高低版本兼容的场景；value 属性用于物理路径非常稳定的情况，一般情况下，还是 name 用的多。</p><p>因为 ConditionEvaluator 在注册 Bean 阶段进行评估，所以 @ConditionalOnBean 和 @ConditionalOnMissingBean 的 Java doc 强烈建议开发人员仅在自动装配中使用该条件注解。<br>这一对注解主要用来判断当前的 Spring 应用上下文是否存在该 Bean，如果存在就直接 autowired，如果不存在就 new。<br>通常，它会和 OnClass 连用，先判断 CP 中是否存在，然后才有后来的容器中是否存在，还要考虑其他依赖是否装配了该 Bean，因为有个顺序问题。</p></blockquote><p>对于属性条件注解 @ConditionalOnProperty，属性来源于 Spring Environment，典型代表就是 Java 系统属性和环境变量，application.yml 也是，都属于 PropertySource。<br>剩下的 Resource 条件注解感兴趣的可以看一下，在书中进行了大量的源码分析，关键是要搞明白 ConditionEvaluator 和 ResourceLoader（ConditionEvaluator 关联的 ResourceLoader 来自 Spring 应用上下文），最终会发现 DefaultResourceLoader 实际上是 Spring 中的唯一 ResourceLoader 实现。<br>个人感觉涉及 Resource 的东西，不说难吧就是很绕，很烦人，I/O 是个折磨人的东西，涉及 Stream、各种 URL 协议之类，Handle 和 Factory。</p><p>SB 自定义的 Condition 基本都是扩展的 SpringBootCondition 而不是直接实现 Condition 接口，可以借鉴下。</p><p>示例工程：<a href="https://github.com/mercyblitz/thinking-in-spring-boot-samples/tree/master/spring-boot-2.0-samples/formatter-spring-boot-starter" target="_blank" rel="noopener">Github</a></p><h2 id="理解SpringApplication"><a href="#理解SpringApplication" class="headerlink" title="理解SpringApplication"></a>理解SpringApplication</h2><p>这一部分从 Spring 应用的生命周期来看，分为初始化阶段、运行阶段、结束阶段。也是很硬核的内容。</p><h3 id="SpringApplication初始化阶段"><a href="#SpringApplication初始化阶段" class="headerlink" title="SpringApplication初始化阶段"></a>SpringApplication初始化阶段</h3><p>初始化阶段主要分为<strong>构造阶段和配置阶段</strong>，构造阶段当然是通过构造器来完成的，不过一般情况我们都用 run 这个静态方法了，它也是走的构造。<br>无论那种，最终都需要传递一个 primarySource，也可以理解成标注了 @EnableAutoConfiguration 的类，最终会被 SpringApplication 的 primarySources 属性保存，接下来会依次执行 WebApplicationType.deduceFromClasspath、setInitializers、setListeners、deduceMainApplicationClass，可以理解为：</p><ul><li>推断 Web 应用类型<br>在此阶段上下文还没有准备，所以使用的是检查当前 ClassLoader 下的基准 Class 的存在性来判断；<br>当 DispatcherHandler 存在，DispatcherServlet 不存在，也就是依赖 WebFlux 下，判断为 Reactive Web 应用；<br>当 Servlet 和 ConfigurableWebApplicationContext 不存在时，非 Web 应用；<br>当 Spring WebFlux 和 Spring Mvc 同时存在，按 Servlet Web 处理。</li><li>加载 Spring 应用上下文初始化器<br>该方法返回所有 spring.factories 资源配置中的 ApplicationContextInitializer实现类名单。<br>并不强制要求实现 Ordered 排序，排序后保存到 initializers 属性中；<br>PS：在调用 run 之前，允许你使用 setter 方法进行覆盖性更新。</li><li>加载 Spring 应用事件监听器</li><li>推断应用引导类</li></ul><p>构造阶段就算到此完成，接下来是配置阶段，该阶段是可选的，主要用于调整或者补充构造阶段的状态，以 SpringApplication 的 setter 方法为代表，是用于调整的相关；补充行为则以 add 方法为代表。推荐使用 SpringApplicationBuilder。<br>大多数情况开发人员无需调整 SpringApplication 的默认状态，作为拓展可以看看 SC 或者 SC Data Flow。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">  .bannerMode(Banner.Mode.CONSOLE)</span><br><span class="line">  .web(WebApplicationType.NONE)</span><br><span class="line">  .profiles(<span class="string">"dev"</span>)</span><br><span class="line">  .headless(<span class="keyword">false</span>)</span><br><span class="line">  .run(args);</span><br></pre></td></tr></table></figure><p>用的最多的也许是 Banner 相关吧。</p><blockquote><p>关于配置源，1.x 和 2.x 差别较大，2.x 中构造函数由 Object 改为 Class，所以 XML 和 packages 就无法作为参数传递，只能通过 setSources 方法传递。<br>PS：注意 sources 和 primarySources 属性。</p></blockquote><p>其中，sources 属性使用的是 LinkedHashSet 说明具有去重功能，并且有序。</p><h3 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h3><p>这个阶段属于核心过程，围绕 run 方法展开，它会进一步完善所需要的资源准备，随后启动 Spring 应用上下文，伴随 SB 和 Spring 的事件分发，形成完整的 SpringApplication 生命周期。<br>它可以再进行细分，准备、启动、启动后。</p><h4 id="上下文准备阶段"><a href="#上下文准备阶段" class="headerlink" title="上下文准备阶段"></a>上下文准备阶段</h4><p>本阶段的范围是从 run 方法开始到 refreshContext 调用之前；挑主要的说。<br>SpringApplicationRunListeners 属于组合模式的实现，内部关联了 SpringApplicationRunListener 的集合，按照字面意思，应该是 SB 运行时监听器（<del>此处应有监听方法与运行阶段对应表</del>）</p><blockquote><p>结合 SpringFactoriesLoader 机制，可以从 spring.factories 中快速定位其内建实现；<br>对于普通开发者，只需要根据 SpringFactoriesLoader 机制和 SpringApplicationRunListener 的要求就能对该接口进行扩展。</p></blockquote><p>然后，可以得出，EventPublishingRunListener 是 SB 中的唯一内建实现，可以得出，根据 SpringApplication 所关联的 ApplicationListener 实例列表，动态的添加到 SimpleApplicationEventMulticaster 中；<br>SimpleApplicationEventMulticaster 是 Spring 中实现 ApplicationEventMulticaster 接口的类，用于发布 Spring 应用事件（ApplicationEvent），所以可以看出它也充当了 SB 中事件发布者的角色。<br><del>（此处应有 SB 事件与监听方法对照表）</del><br>虽然 SB 与 Spring 事件有很大的关联性，但是他们还是有差异性的，主要体现再顺序和时机上，<a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners" target="_blank" rel="noopener">官方文档</a>中也有提及。</p><h4 id="拓展-理解Spring事件"><a href="#拓展-理解Spring事件" class="headerlink" title="拓展-理解Spring事件"></a>拓展-理解Spring事件</h4><p>Spring 事件是 Spring 应用上下文 ApplicationContext 对象触发的，SB 事件的发布者则为 SpringApplication 关联的 SimpleApplicationEventMulticaster 类型，虽然它也是来自 Spring。<br>Spring 中的事件也采用了 JDK 的观察者模式规范，不过进行了一定的扩展或者说增强。</p><p>对于如何监听具体的 ApplicationEvent 类型，在 3.0 得到改善，ApplicationListener 支持泛型监听，不再监听所有事件靠 instanceof 筛选，但是由于泛型的限制，无法同时监听不同的事件类型，如果继续使用 ApplicationEvent 做泛型，这就又回到了之前。<br>所以，3.0 中引入了 SmartApplicationListener 接口，它通过 supports* 方法来过滤监听的事件类型和事件源类型，例如 ConfigFileApplicationListener。</p><p>上面说过 SB 的事件发布者 SimpleApplicationEventMulticaster 也是来自 Spring，并且是 ApplicationEventMulticaster 接口的实现类，该接口主要承担两个职责：关联 ApplicationListener 和广播 ApplicationEvent。<br>PS：SB 的事件监听器都是经过排序了的。</p><blockquote><p>看源码的朋友们，Spring 4.0 引入的 ResolvableType 是 Spring 为了简化 Java 反射 API 提供的组件，它能够轻松的获取泛型类型等。</p><p>SimpleApplicationEventMulticaster 虽然允许事件广播时 ApplicationListener 异步监听事件，但是无论时 Spring 还是 SB 均没有使用其来提升为异步执行，由于 EventPublishingRunListener 的封装，SB 事件监听器也无法异步执行。</p></blockquote><p>关于 ApplicationEventMulticaster 与 ApplicationContext 的关系，官方文档提到过可以使用 ApplicationEventPublisher 发布 ApplicationEvent；<br>查看 ApplicationContext 可以看到它扩展了 ApplicationEventPublisher，也就是说，<strong>无论那种 Spring 应用上下文，都具备发布 ApplicationEvent 的能力</strong>。<br>PS：获取 ApplicationEventPublisher 可以通过 Aware 方式。仔细看还会发现拓展了 ResourceLoader，所以 ApplicationContext 也是 setResourceLoader 方法的常客。</p><p>我们可以简单的得出结论，ApplicationEventPublisher 的实例就是当前 ApplicationContext。<br>SimpleApplicationEventMulticaster 既是 SB 事件广播的实现，又是 Spring 事件发布的实现。<br>SimpleApplicationEventMulticaster 作为 Spring 中唯一的 ApplicationEventMulticaster 实现，无论是 Spring 还是 SB，都充当同步广播事件对象的角色，开发人员主要关注 ApplicationEvent 的类型和对应的 ApplicationListener 实现即可。<br><del>此处应有 Spring 内建事件一览表</del></p><h4 id="拓展-Spring内建事件"><a href="#拓展-Spring内建事件" class="headerlink" title="拓展-Spring内建事件"></a>拓展-Spring内建事件</h4><p>当 ConfigurableApplicationContext 的 refresh 方法执行到 finishRefresh 方法时，Spring 应用上下文就会发布 ContextRefreshedEvent （上下文就绪）事件；<br>此时应用上下文中的 Bean 已经完成初始化，并能投入使用，通常会使用 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 监听，获取所需要的 Bean，防止出现 Bean 提早初始化。</p><p>剩下的 Spring 应用上下文启停事件不多说，SC 中还用了下，SB 不常见。<br>只需要正确的理解上下文的 start、stop、close 方法之间的区别。相关类：Lifecycle；</p><p><strong>因为事件源都是用的 ApplicationContext，所以称之为 Spring 上下文事件</strong>。</p><h4 id="拓展-Spring应用上下文事件"><a href="#拓展-Spring应用上下文事件" class="headerlink" title="拓展-Spring应用上下文事件"></a>拓展-Spring应用上下文事件</h4><p>应用上下文 ApplicationContextEvent 与 Spring 事件 ApplicationEvent 的关系嘛，直接看就是继承关系（extends ApplicationEvent）；<br>对于 Spring 事件的监听，4.2 开始可以使用 @EventListener 注解，毕竟开始进军注解驱动编程。</p><blockquote><p>使用 @EventListener 的时候，注意要标注在 IoC 中的 Bean 上，并且需要 public 权限；<br>单一类型监听中，虽然规范要求不能有返回值，但是即使返回值不为 void 也可以执行；<br>在多类型监听中，需要特别处理，不能有返回值，也需要手动进行多个 ApplicationEvent 的过滤。</p><p>异步支持：需要先使用 @EnableAsync 开启，然后使用 @Async 注解。<br>可以使用 @Order 控制顺序。<br>对泛型 ApplicationEvent 支持方面，需要事件实现 ResolvableTypeProvider 接口。<br>相关源码：EventListenerMethodProcessor（生命周期相关）、DefaultEventListenerFactory（适配相关）</p></blockquote><p>因为关联了 ApplicationEventMulticaster 属性，在 close 的时候也没有进行销毁关系，所以即使在 close 后，依然可以发布 Spring 事件，但是因为关联的 ApplicationListener 已经被销毁，所以最终无法被监听。<br>广播实现也很简单，就是通过 ApplicationEvent 找到关联的 ApplicationListener 列表，异步或者同步的调用即可。<br><del>此处应当有这几种方式的对照表</del></p><h4 id="Spring事件小结"><a href="#Spring事件小结" class="headerlink" title="Spring事件小结"></a>Spring事件小结</h4><p>主要包括的是 Spring 事件、事件监听器、事件广播器，以及它们与 Spring 应用上下文的关系。<br>涉及到的事件分为 Spring 事件与 Spring 应用事件，主要以事件源区分，并且开发者可以自定义 ApplicationEvent。<br>进一步是泛型化与注解化。注解化依赖于适配器将其转换为 ApplicationListener，其中有 AOP 相关知识。<br>其中我略去了大量的源码级讲解，没办法，源码看的我头大，目前真的不想再多弄了 (/▽＼)。</p><h4 id="拓展-SB事件"><a href="#拓展-SB事件" class="headerlink" title="拓展-SB事件"></a>拓展-SB事件</h4><p>有了 Spring 的事件基础，再来看 SB 的事件就简单多了，毕竟都是一套体系，如果 SB 仅仅是复用 Spring 相关的 API 那么就更好了，他们各自为政互不干涉，对我们理解很友好。<br>但是再 1.4 之前的版本，其实内部还是很混乱的，主要因为直接复用了 SimpleApplicationEventMulticaster，可能存在重复添加的情况，核心问题在于 spring.factories 中的实例列表是否有必要关联到 Spring 应用上下文中，这就导致 ApplicationListener 也可以监听到 SB 的事件，这其实并不好。</p><p>从 1.4 之后，SB 就进行了微调，SB 事件与 Spring 事件开始独立，互不干扰，也是从这开始核心 API 开始趋于稳定。<br>具体改动可参考 EventPublishingRunListener 的 contextPrepared 方法，不再直接关联 SimpleApplicationEventMulticaster，但是实例依然会加入到 Spring 应用上下文中。<br>也正是因为 SpringApplication 使用了独立的 ApplicationEventMulticaster 对象，虽然 SpringApplication 和 ApplicationContext  都还是使用的 SimpleApplicationEventMulticaster 实例，<strong>但不再是同一个对象</strong>。<br>到这里就完成了隔离，SB 中可以监听 Spring 事件，反之不可，但是多数情况监听的还是 SB 事件。</p><p>在 SB 中，大量使用了 SmartApplicationListener，SB 中事件的事件源多用 SpringApplication。</p><h4 id="拓展-SB内建事件"><a href="#拓展-SB内建事件" class="headerlink" title="拓展-SB内建事件"></a>拓展-SB内建事件</h4><p>在 SB 中，无论你监听 SB 事件还是 Spring 事件，都是通过在 spring.factories 中配置实现的（属性为 ApplicationListener 的实现类）。<br><del>此处应当有 SB 内建事件一览表</del><br>最熟悉的可能是 ConfigFileApplicationListener 和 LoggingApplicationListener，分别负责 SB 应用配置文件的加载和日志系统的初始化（日志框架识别和日志配置文件加载等）。<br>SB 的内建事件根据 EventPublishingRunListener 的生命周期回调方法依次发布。<br>可以理解为 SB 的事件/监听机制是继承于 Spring 的事件/监听机制，例如 SpringApplicationEvent 就继承自 ApplicationEvent。</p><p>其他的类似 ApplicationArguments、ConfigurableEnvironment （对应不同的 Web 类型）就战略性略过了（Spring 应用上下文运行前准备）。</p><h4 id="上下文启动阶段"><a href="#上下文启动阶段" class="headerlink" title="上下文启动阶段"></a>上下文启动阶段</h4><p>本阶段有 refreshContext 方法实现，它首先调用 refresh，执行 ApplicationContext 的启动，然后注册 shutdownHook 线程（JVM shutdown hook 机制），实现优雅的 Spring Bean 销毁生命周期回调。<br>在 1.4 版本之后，重构了 refreshContext 方法，随着这个方法的执行，Spring 应用上下文正式进入 Spring 生命周期，SB 的核心也随之启动，例如自动装配、嵌入式容器等特性，紧接着分发 ContextRefreshedEvent 事件。</p><h4 id="上下文启动后阶段"><a href="#上下文启动后阶段" class="headerlink" title="上下文启动后阶段"></a>上下文启动后阶段</h4><p>这里主要是 afterRefresh 方法，具体的实现在 2.0 也有略微调整，主要为不再具有执行 ApplicationRunner 或者 CommandLineRunner 的能力，不过并不会影响它们的执行，只是执行时机相对延后了，最后分发 ApplicationStartedEvent 事件。</p><p>同时 ApplicationStartedEvent 的语义也有所变化，1.5 中加入了 ApplicationStartingEvent 事件，虽然 ApplicationStartedEvent 标注为 2.0 加入，其实在 1.x 就存在，2.0 对其进行了调整，关联了 ConfigurableApplicationContext 对象。<br>简单说就是，ApplicationStartingEvent 充当了之前 ApplicationStartedEvent 的角色，ApplicationStartedEvent 被延后触发。</p><h3 id="SpringApplication结束阶段"><a href="#SpringApplication结束阶段" class="headerlink" title="SpringApplication结束阶段"></a>SpringApplication结束阶段</h3><p>各个版本中此阶段的实现比较稳定，可分为正常结束和异常结束。<br>当 ApplicationReadyEvent 事件触发后 SpringApplication 的生命周期进入尾声，除非发生异常，进入异常分支，这其中在不同版本中的实现都有细微变化，不过影响不大。<br>而如果进入异常分支，基本就意味着 Spring 应用运行失败，可参考 SpringApplicationRunListener。</p><p>对于 SB 的异常处理，1.1 开始就替换为 Throwable，同时拥有故障分析器：FailureAnalysis，它会在上下文关闭之前执行错误分析并输出报告。<br>其中 FailureAnalysis 仅分析故障，报告则由 FailureAnalysisReporter 负责（也是由工厂机制加载排序，默认仅存在一个）。<br>当然你也可以自定义这两个的实现，一样配置到 spring.factories 中，1.x 与 2.x 有所不同，SC Data Flow 用户关注一下。</p><h3 id="应用退出阶段"><a href="#应用退出阶段" class="headerlink" title="应用退出阶段"></a>应用退出阶段</h3><p>这里主要是 ShutdownHook 线程，在 JVM 退出时能够确保完成 Spring 生命周期回调，进行资源释放，例如 JDBC 连接、会话状态等。<br>这里也可以细分正常退出和异常退出，还有个退出码，不知道有没有人关注，用 IDEA 的时候会打印出来，非 0 就是异常退出，相关源码：ExitCodeGenerator。<br>因为 IDEA 可以获取子进程的退出码，但是真实环境下基本不可用，除非你是用 SC Data Flow 之类。<br>异常退出由 SpringApplication 的 handleRunFailure 方法负责，由于用的不多，不多展开了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Spring IO Platform 项目是为了统一 Maven 管理的项目，2019 年后不再维护，被 spring-boot-dependencies 和 spring-boot-starter-parent 取代。</p><p>当相应的 starter 添加到 ClassPath 后，其关联的特性随应用的启动而自动装载，这种机制称为自动装配（AutomaticallyConfigure）。</p><p>使用 @HandlesTypes 来进行过滤，选择出自己关系的类型。</p><p>SB 根据 Web 类型推断来创建对应的 Spring 应用上下文，我们最常用的 Servlet 类型就是用 AnnotationConfigWebApplicationContext。<br>WebApplicationType 还可以作为 ConfigurableEnvironment 对象具体类型的条件，所以 applicationContextClass 的属性设定后还需要对 webApplicationType 设置。</p><p>在 spring.factories 中声明的资源，可能存在重复执行的情况，所以建议凡是使用 Spring 工厂加载机制的场景，建议覆盖 hashCode 和 equals。</p><p>SB 的事件监听器均由 Spring 工厂加载机制加载并初始化，它们并非 Spring Bean，<strong>因此无法享受注解驱动和 Bean 生命周期管理回调接口的『福利』</strong>，不过这并不影响他们获得 Spring Bean，因为有关联的 ConfigurableApplicationContext 对象。<br>这个要对比  ApplicationRunner 和 CommandLineRunner  看。</p><p>SB 引入 SpringApplication 大概是对 Spring 应用上下文的生命周期的补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 领域，SpringBoot 是目前最流行的微服务框架，将使用门槛大幅度的降低，达到开箱即用；那么这也必然使 SB 成为了一个黑盒，如果需要深度定制或者了解内部原理变得有点复杂，希望通过阅读本系列书籍来解开这个黑盒。&lt;br&gt;最重要的部分就是 SB 的主要特性部分，自动装配和自动配置方面的理解；从 SB2.x 开始架构逐步稳定，现在可以尝试大规模使用了。&lt;br&gt;微服务架构作为一种细粒度的 SOA，无论那种表达方式，只不过是名词之争，架构设计的好坏不在于理论和技术，而在于实施者对业务的理解和专业水平。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://sakanoy.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://sakanoy.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java中的日志框架</title>
    <link href="https://sakanoy.com/2020/04/11/Java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    <id>https://sakanoy.com/2020/04/11/Java中的日志框架/</id>
    <published>2020-04-11T09:24:52.000Z</published>
    <updated>2020-04-11T14:55:47.723Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前我简单整理过<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/%E7%B1%BB%E5%BA%93%E7%9B%B8%E5%85%B3/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.md" target="_blank" rel="noopener">相关笔记</a>，刚开始认为日志框架只是很简单的存在，然而事实上并不简单，尤其在不同的依赖中使用不同的框架下，就是一团糟；再加上 SB 的黑盒，如果用的很杂其实还是蛮糟心的，各种冲突时不时跳出来恶心你一下，借此机会重新整理一下。<a id="more"></a></p><p><img src="/image/dev/java-log.png" alt=""></p><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>我们主要讨论那些比较知名的日志框架，例如 commons-logging、log4j、slf4j、logback。<br>在探讨之前，可以先了解下为什么需要日志框架，最早的框架是怎么演变的，这里推荐一篇文章：<a href="https://mp.weixin.qq.com/s/XiCky-Z8-n4vqItJVHjDIg" target="_blank" rel="noopener">一个著名的日志系统是怎么设计出来的？</a></p><blockquote><p>在 log4j 被 Apache Foundation 收入门下之后，由于理念不合，log4j 的作者 Ceki 离开并开发了 slf4j 和 logback。</p></blockquote><p>下面就一个个的来看。</p><h3 id="CommonsLogging-JCL"><a href="#CommonsLogging-JCL" class="headerlink" title="CommonsLogging/JCL"></a>CommonsLogging/JCL</h3><p>apache-commons-logging （之前称为 JakartaCommonsLogging 即 JCL）是 Apache 提供的一个<strong>通用的日志接口</strong>，可以理解为是一个规范。<br>在 commons-logging 中，有一个 SimpleLogger 的简单实现，但是它功能很弱，所以使用 commons-logging ，通常都是配合着 log4j 来使用；</p><p><strong>commons-logging 会通过动态查找的机制，在程序运行时自动找出真正使用的日志库，并且尽可能找到一个”最合适”的日志实现类，如果判断有 Log4j 包，则使用 log4j，最悲观的情况下也总能保证提供一个日志实现 (SimpleLog)</strong></p><h3 id="Log4j和Log4j2"><a href="#Log4j和Log4j2" class="headerlink" title="Log4j和Log4j2"></a>Log4j和Log4j2</h3><p>它是 Apache 的一个开放源代码项目，实现了输出到控制台、文件、 回滚文件、发送日志邮件、输出到数据库日志表、自定义标签等全套功能，且配置比较简单。</p><blockquote><p>后来 <strong>Apache Logging</strong> 一直在关门憋大招，log4j2 在 beta 版鼓捣了几年，终于在 2014 年发布了 GA 版，不仅吸收了 logback 的先进功能，更通过优秀的锁机制、LMAX Disruptor、”无垃圾”机制等先进特性，在性能上全面超越了 log4j 和 logback。</p><p>log4j2 弃用了 properties 方式配置，采用的是 xml、json 或者 jsn 这种方式来做。</p></blockquote><p>可以说 log4j2 是与 logback 来对标的。</p><h3 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a>slf4j</h3><p>slf4J，即简单日志门面（Simple Logging Facade for Java），<strong>不是具体的日志解决方案，它只服务于各种各样的日志系统</strong>。按照官方的说法，SLF4J 是一个用于日志系统的简单 Facade，允许最终用户在<strong>部署其应用时</strong>使用其所希望的日志系统。</p><p>可以这么说，slf4j 等于 commons-logging，是各种日志实现的<strong>通用入口</strong>，会根据 classpath 中存在下面哪一个 Jar 来决定具体的日志实现库；它只是一个 API，提供一个规范。<br>因为 slf4j 用的很广泛，所以重点说说，提供一个架构图。</p><p><img src="/image/dev/slf4j.png" alt=""></p><p>SLF4J (Simple logging Facade for Java) 不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。<br>如果是在编写供内外部都可以使用的 API 或者通用类库，那么你真不会希望使用你类库的客户端必须使用你选择的日志类库。</p><blockquote><p>如果一个项目已经使用了 log4j，而你加载了一个类库，比方说 Apache ActiveMQ 它依赖于于另外一个日志类库 logback，<strong>那么你就需要把它也加载进去</strong>。<br>但如果 Apache Active MQ 使用了 SLF4J，你可以继续使用你的日志类库 (当前是 log4j) 而无需忍受加载和维护一个新的日志框架的痛苦。</p></blockquote><p>slf4j 为各类日志输出服务提供了适配库，如 slf4j-log4j12（log4j 适配器），slf4j-simple（slf4j 简单实现），slf4j-jdk14（适配 JDK 的 Logger）等。<br>一个 Java 工程下只能引入一个 slf4j 适配库，slf4j 会加载 <code>org.slf4j.impl.StaticLoggerBinder</code> 作为输出日志的实现类。这个类在每个适配库中都存在，当需要更换日志输出服务时（比如从 logback 切换回 log4j），只需要替换掉适配库即可。<br>我们简单理解为，你使用 slf4j-api 来进行开发，其他人可以通过选用不同的适配器 + 对应的具体日志类的方式来进行各种组合。</p><p>slf4j 还推出了 jcl-over-slf4j 桥接库，能够把使用 JCL 的 API 输出的日志桥接到 slf4j 上，方便那些想要使用 slf4j 作为日志门面但同时又要使用 Spring 等需要依赖 JCL 的类库的系统。</p><h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><p>logback 是由 log4j 创始人设计的又一个开源日志组件。<br>logback 当前分成三个模块：logback-core、logback- classic 和 logback-access。</p><ul><li>logback-core<br>是其它两个模块的基础模块。</li><li>logback-classic<br>它是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j。</li><li>logback-access<br>主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与 HTTP 访问相关的功能。</li></ul><p>logback 天然与 slf4j 适配，不需要额外引入<strong>适配库</strong>（毕竟是一个作者写的）<br>想在 Java 程序中使用 Logback，需要依赖三个 jar 包，分别是 slf4j-api，logback-core，logback-classic。<br>其中 slf4j-api 并不是 Logback 的一部分，是另外一个项目，但是强烈建议将 slf4j 与 Logback 结合使用。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在 Java 领域日志工具中，最早得到广泛使用的是 log4j。那么为啥有 commons-logging 的出现？上面已经介绍了 common-logging 只提供 log 的接口，其中具体的实现时动态绑定的，所以 common-logging 与 log4j 的结合比较多！</p><p>但是随之也产生了一些问题，那就是 common-logging 的动态绑定有时候也会失败，在这样的背景下 slf4j 应运而生，slf4j 与 commons-logging 一样提供 log 接口，但是 slf4j 是通过静态绑定实现。</p><blockquote><p>slf4j 唯独没有提供 log4j2 的适配库和桥接库，log4j-slf4j-impl 和 log4j-to-slf4j 都是 Apache Logging 自己开发的，看样子 Ceki 和 Apache Logging 的梁子真的很深啊……倒是 Apache 没有端架子，可能也是因为 slf4j 太火了吧</p></blockquote><p>log4j2 和 logback 各有长处，总体来说，如果对性能要求比较高的话，log4j2 相对还是较优的选择</p><h2 id="SB中的应用"><a href="#SB中的应用" class="headerlink" title="SB中的应用"></a>SB中的应用</h2><p>在 Spring 中使用的是 JCL 框架，SB 中根据 spring-boot-starter-logging 的依赖分析，可以得出：</p><ul><li>SpringBoot2.x 底层也是使用 slf4j+logback <del>或 Log4J 的</del>方式进行日志记录。</li><li>SpringBoot 引入中间替换包把其他的日志都替换成了 SLF4J。</li><li>如果我们要引入其他框架、可以把这个框架的默认日志依赖移除掉。</li></ul><p>至于 1.x 版本就不再讨论了，也可能是 JCL。<br>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p><ul><li>Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy</li><li>Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml</li><li>Log4j2：log4j2-spring.xml, log4j2.xml</li><li>JDK (Java Util Logging)：logging.properties</li></ul><p>门面框架虽然有 slf4j 和 jcl 两类，就目前肯定 slf4j 更受欢迎，那么之前用 jcl 的怎么办，例如 spring，这多亏了 jcl-over-slf4j 桥接器可以进行转换，这都不是事。</p><h3 id="使用log4j"><a href="#使用log4j" class="headerlink" title="使用log4j"></a>使用log4j</h3><p>也就是目前可以说最常见的组合 slf4j + log4j，先排除后添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以根据日志情况来确认。</p><h3 id="使用log4j2"><a href="#使用log4j2" class="headerlink" title="使用log4j2"></a>使用log4j2</h3><p>方法其实有很多种，那种好目前我也没评估，举例一种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>思路就是排除 SB 自带的日志框架，然后加入我们自己的（通过 starter 方式）</p><h2 id="经典使用"><a href="#经典使用" class="headerlink" title="经典使用"></a>经典使用</h2><p>就目前来说，用的最广泛的还是 log4j ，毕竟即使后面的框架更好，项目已经进行好几年的情况下贸然换用可能会导致很多奇怪的问题，这也造成来现在的依赖日志框架都是乱七八糟，但总体以 log4j 为主，缺点可以忍受，没有大到需要换框架的地步。</p><h3 id="log4j使用"><a href="#log4j使用" class="headerlink" title="log4j使用"></a>log4j使用</h3><p>因为 log4j 用的很多，所以重点再说说。<br>默认会读取资源目录下的 <code>log4j.properties</code> 文件，当然也可以自定义配置文件的位置。<br>配置文件的基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 配置根 Logger</span><br><span class="line">log4j.rootLogger = [level], appenderName1, appenderName2,  …</span><br><span class="line"></span><br><span class="line"># 配置日志信息输出目的地 Appender</span><br><span class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class</span><br><span class="line">  log4j.appender.appenderName.option1 = value1</span><br><span class="line">  …</span><br><span class="line">  log4j.appender.appenderName.optionN = valueN </span><br><span class="line"></span><br><span class="line"># 配置日志信息的格式（布局）</span><br><span class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class </span><br><span class="line">  log4j.appender.appenderName.layout.option1 = value1 </span><br><span class="line">  … </span><br><span class="line">  log4j.appender.appenderName.layout.optionN = valueN</span><br></pre></td></tr></table></figure><h4 id="输出级别"><a href="#输出级别" class="headerlink" title="输出级别"></a>输出级别</h4><p>关于 <strong>level</strong> 日志输出级别，共有五级：</p><table><thead><tr><th>标识</th><th>ID</th><th>描述</th></tr></thead><tbody><tr><td>FATAL</td><td>0</td><td>适用于严重错误事件</td></tr><tr><td>ERROR</td><td>3</td><td>适用于代码存在错误事件</td></tr><tr><td>WARN</td><td>4</td><td>适用于代码会有潜在错误事件</td></tr><tr><td>INFO</td><td>6</td><td>适用于代码运行期间</td></tr><tr><td>DEBUG</td><td>7</td><td>适用于代码调试期间</td></tr></tbody></table><p>除此之外还有两种状态就是 ALL： 打开所有日志；OFF：关闭所有日志；</p><h4 id="输出目的地"><a href="#输出目的地" class="headerlink" title="输出目的地"></a>输出目的地</h4><p>Appender 为日志输出目的地，Log4j 提供的 appender 有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line">org.apache.log4j.FileAppender（文件），</span><br><span class="line">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</span><br><span class="line">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br></pre></td></tr></table></figure><h4 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h4><p>Layout：日志输出格式，Log4j提供的layout有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line">org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br></pre></td></tr></table></figure><p>打印参数  Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%m  输出代码中指定的消息</span><br><span class="line">%p  输出优先级，即 DEBUG，INFO，WARN，ERROR，FATAL </span><br><span class="line">%r  输出自应用启动到输出该log信息耗费的毫秒数 </span><br><span class="line">%c  输出所属的类目，通常就是所在类的全名 </span><br><span class="line">%t  输出产生该日志事件的线程名 </span><br><span class="line">%n  输出一个回车换行符，Windows 平台为 &quot;\r\n&quot;，Unix 平台为 &quot;\n&quot; </span><br><span class="line">%d  输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，</span><br><span class="line">  比如：%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;，输出类似：2017-12-21 13:37:05 512</span><br><span class="line">%l  输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line">  举例：Testlog4.main(TestLog4.java: 10 )</span><br><span class="line">[%10p]右对齐，最小宽度10</span><br><span class="line">[%-10p]左对齐，最小宽度10</span><br></pre></td></tr></table></figure><p>SSS 其实是毫秒的意思</p><h4 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h4><p>具体项目具体对待，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">### set log levels ###  </span><br><span class="line">log4j.rootLogger = debug, stdout, D, E  </span><br><span class="line">  </span><br><span class="line">### 输出到控制台 ###  </span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.stdout.Target = System.out  </span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern =  %d&#123;ABSOLUTE&#125; %5p %c&#123; 1 &#125;:%L - %m%n  </span><br><span class="line">  </span><br><span class="line">### 输出到日志文件 ###  </span><br><span class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.D.File = logs/log.log</span><br><span class="line">log4j.appender.D.Append = true</span><br><span class="line">## 输出DEBUG级别以上的日志</span><br><span class="line">log4j.appender.D.Threshold = DEBUG</span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n  </span><br><span class="line"></span><br><span class="line">### 保存异常信息到单独文件 ###  </span><br><span class="line">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.E.File = logs/error.log</span><br><span class="line">log4j.appender.E.Append = true</span><br><span class="line">## 只输出ERROR级别以上的日志!!!</span><br><span class="line">log4j.appender.E.Threshold = ERROR</span><br><span class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %l:%c:%t:%r ] - [ %p ]  %m%</span><br></pre></td></tr></table></figure><h3 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h3><p>使用 log4j2 需要两个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件示例，就是格式变成了 XML ，和上面其实也差不多：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"error"</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 先定义所有的appender --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">appenders</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个输出控制台的配置 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- 控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这个都知道是输出日志的格式 --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Console</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- append 为TRUE表示消息增加到指定文件中，false 表示消息覆盖指定的文件内容，默认值是true --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打印出所有的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch="ACCEPT" onMismatch="DENY"意思是匹配就接受,否则直接拒绝  --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"ERROR"</span> <span class="attr">fileName</span>=<span class="string">"logs/error.log"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy.MM.dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">File</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/web.log"</span>  </span></span><br><span class="line"><span class="tag">                 <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy-MM-dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"2MB"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">loggers</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--  建立一个默认的root的logger --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFile"</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR"</span> /&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置其实都差不多，应该还是蛮好看懂的。</p><h3 id="logback-1"><a href="#logback-1" class="headerlink" title="logback"></a>logback</h3><p>这里我也不打算详细说了，贴一个配置文件示例（logback.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"mmall"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;File&gt;d:/mmalllog/mmall.log&lt;/File&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>/developer/apache-tomcat-7.0.73/logs/mmall.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/developer/apache-tomcat-7.0.73/logs/mmall.log.%d&#123;yyyy-MM-dd&#125;.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;File&gt;d:/mmalllog/error.log&lt;/File&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>/developer/apache-tomcat-7.0.73/logs/error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/devsoft/apache-tomcat-7.0.73/logs/error.log.%d&#123;yyyy-MM-dd&#125;.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;fileNamePattern&gt;d:/mmalllog/error.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.mmall"</span> <span class="attr">additivity</span>=<span class="string">"false"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"mmall"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- geelynote mybatis log 日志 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.mmall.dao"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--&lt;logger name="com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate" level="DEBUG" &gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;/logger&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--&lt;logger name="java.sql.Connection" level="DEBUG"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;/logger&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;logger name="java.sql.Statement" level="DEBUG"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;/logger&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--&lt;logger name="java.sql.PreparedStatement" level="DEBUG"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;appender-ref ref="console"/&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;/logger&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"error"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体用到再做补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前我简单整理过&lt;a href=&quot;https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/%E7%B1%BB%E5%BA%93%E7%9B%B8%E5%85%B3/Java%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关笔记&lt;/a&gt;，刚开始认为日志框架只是很简单的存在，然而事实上并不简单，尤其在不同的依赖中使用不同的框架下，就是一团糟；再加上 SB 的黑盒，如果用的很杂其实还是蛮糟心的，各种冲突时不时跳出来恶心你一下，借此机会重新整理一下。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ElasticStack从入门到放弃</title>
    <link href="https://sakanoy.com/2020/03/19/ElasticStack%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>https://sakanoy.com/2020/03/19/ElasticStack从入门到放弃/</id>
    <published>2020-03-19T11:27:44.000Z</published>
    <updated>2020-03-19T11:32:08.310Z</updated>
    
    <content type="html"><![CDATA[<p>关于 ES 的基本使用之前<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener">已经写过了</a>，然后 ELK 也许听的比较多，后来又有了一个 ELK Stack，指的就是 Elastic Stack。<br>这一套技术用在搜索需求、日志分析非常好用，也有很多用来处理 Excel 数据的，就现在都发展来看，ES 真是绕不开都技术，<del>早晚都是要学</del>，ELK 一套带走就好了。<br>毕竟这一全家桶内容很多，不打算过多深挖，很多东西都不细说了，提供关键词提点自己，用到来查到搜索方向后再 Google 具体使用就好了。<a id="more"></a><br>但是，它东西真的太多了，并且枯燥，对于不喜欢数据库的我来说，以至于最终还是不能坚持，草草了事吧。</p><ul><li>Elasticsearch<br>是一个搜索和分析引擎（数据的存储、查询、分析）</li><li>Logstash<br>是服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到诸如 Elasticsearch 等“存储库”中</li><li>Kibana<br>可以让用户在 Elasticsearch 中使用图形和图表对数据进行可视化</li><li>Beats<br>一系列轻量型的单一功能数据采集器</li></ul><p>Logstash 和 Beats 的作用就是数据的收集与整理，只不过 Beats 是为了解决用户的 “我只想对某个文件进行 tail 操作”的需求。<br>上面说过它们是采集数据的，范围很广，例如文件类的有日志、excel，数据库和 http 服务也可以，还支持自定义扩展。</p><p>ES 的服务端口默认 9300，Web 管理端口默认 9200.<br>官网文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>复习一下 ES 的基本概念，交互是靠 RESTful API，ES 中主要的就三类：</p><ul><li>文档-Document<br>最小的数据单元，内含多个字段 ，类似于数据库中的一行数据；<br>由 Json Object （字段）构成，多种数据类型（可存二进制）；<br>当然，还会存在一些元数据</li><li><del>类型-Type</del><br>索引可以定义一个或多个类型，文档必须属于一个类型，相当于数据库中的 table；<br>未来版本中因为索引调整为唯一，下面不再有多个类型，所以类型将会逐步消除。</li><li>索引-Index<br>相同属性的文档集合，<del>相当于数据库的 Database</del>；<br>再 6+ 的版本，官方已经禁止索引下创建多个类型，可以当作是 table 了。</li><li>节点-Node<br>一个 ES 的运行实例，构成集群的基本单元。<br>每一个 ES 实例可以看作就是一个 JVM 线程。</li><li>集群-Cluster<br>多个节点构成的统一体</li></ul><p>分布式中，必然还少不了分片和备份，类似 kafka 的概念了，一个索引可以分片成多个块，存放在不同的节点，这样既可以提高吞吐量，也可以方便的扩展，降低单节点的压力；备份就不多说了，分布在其他的节点上。</p><p>另外 ES 的特性还有：近实时，也就是秒级；分布式架构，方便扩展，简单说就是对 Lucene 的一个封装。</p><blockquote><p>倒排索引与分词：</p><p>在说倒排索引之前，先要知道什么是正排索引，做比喻的话，就像一本书的目录，这就是正排索引；<br>而倒排索引就是书的名词索引页。<br>具体到 ES 的话，正排索引就是根据 ID 获取文档信息；倒排索引就是根据文档的内容（关键词）定位到是那个文档 ID；</p><p>而对于分词，这个也简单，毕竟对于搜索，分词后与之建立关系才能搜索。<br>正排与倒排的关系就是 ID 到单词（或者完整信息，不分词也可）与单词到 ID 的关系（一般需要分词）。</p></blockquote><p>倒排索引主要包含两部分：</p><ol><li>单词词典（Term Dictionary）<br>记录所有文档单词和列表关联关系，一般都比较大。<br>实现一般是类似 B+ 树的结构。</li><li>倒排列表（Posting List）<br>主要有 ID （获取原始信息）、单词频率（相关性算分）、位置（搜索词的前后）、偏移构成（高亮显示）。</li></ol><p>我们从单词词典中拿到一个词，然后通过记录的偏移量快速定位到对应的倒排列表，然后就拿到了原始 ID（还会涉及相关性算分等等步骤），最后就可以返回了。<br>PS：倒排索引是按字段来进行构建的。</p><h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>说道分词，就得说分词器，组成如下：</p><ul><li>Character Filters<br>针对原始文本进行处理，比如去除 html 特殊标记符；<br>自带的有：HTML Strip、Mapping（字符串替换）、Pattern Replace（正则匹配替换）</li><li>Tokenizer<br>将原始文本按照一定规则切分为单词；<br>自带的有 Standard、letter（非字符分割）、Whitespace、path_hierarchy 等。</li><li>Token filters<br>针对 tokenizer 处理的单词就行再加工，比如转小写、删除或新增等处理；<br>自带的有 lowercase（小写转换）、stop、Synonym 等。</li></ul><p>在调用过程中就是按照上面都顺序执行，可以使用 <strong>analyze_api</strong> 来进行测试分词是否符合预期。<br>ES 自带的分词器有：</p><ul><li>Standard（默认）<br>按词切分，支持多语言，小写处理</li><li>Simple<br>按照非字母拆分，小写处理</li><li>Whitespace<br>按照空格切分</li><li>Stop<br>相比 Simple 多了 Stop Word 处理，也就是语气助词等修饰词</li><li>Keyword<br>不分词，当作一个单词输出</li><li>Pattern<br>通过正则表达式自定义分词，默认 <code>\w+</code> 即非字符符号</li><li>language<br>提供常见的 30+ 语言分词器</li></ul><p>说到中文，中文的分词是比较难的，因为中文的词之间没有明显的分隔符，并且很依赖上下文。<br>常用的中文分词器有 IK、jieba （py 流行）等。<br>另外的一些就是基于自然语言的分词系统，也就是根据上下文来切，例如 Hanlp、THULAC；如果这些分词器满足不了你，那就只能进行自定义了，就是自己写分词器的那三部分。</p><p>PS：只有查询与索引使用相同的分词器才能保证一致性，一般查询不需要指定分词器，默认就是一致的。</p><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>Mapping 相当于表结构定义，定义字段名、字段类型、倒排索引相关；获取可以使用 <code>/index/_mapping</code> API 查看。<br>更多操作看文档就行了，不多说。<br>Mapping 中的字段一旦确定，禁止直接修改，因为 Lucene 实现倒排索引后禁止修改，要改只能重新建立索引做 reindex 操作，所以要慎重。<br>虽然禁止修改，但是你新增是没有问题的，这个行为也是可以通过 dynamic 来进行控制。<br>Mapping 中还可以通过 <code>copy_to</code> 来将字段进行拼接处理；通过 index 来控制是否被索引，敏感信息可以加上这个，还省空间；对空值处理的 null_value，其他还有很多可配置的，参考官方文档。</p><p>ES 支持多字段特性 multi-fields，就是对一个字段采取不同的配置，例如拼音化。<br>我们还可以通过使用 <strong>dynamic-template</strong> 动态模板来设置 ES 自动匹配的内容为什么类型，例如默认我们不希望让它识别为 text 分词，这样会占用空间，以及用 float 保存浮点数节约存储等；它是由上到下顺序匹配。<br>类似的，也会有索引模板，便于索引的创建，使用 <code>/_template</code> API。</p><hr><p>在数据建模过程中，要注意这些配置合理化，例如：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/enabled.html" target="_blank" rel="noopener"><code>enabled</code></a><br>是否仅存储，不做搜索和聚合分析，节省空间</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-index.html" target="_blank" rel="noopener"><code>index</code></a><br>是否构建倒排索引</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-options.html" target="_blank" rel="noopener"><code>index_options</code></a><br>存储倒排索引的那些信息</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/norms.html" target="_blank" rel="noopener"><code>norms</code></a><br>如果不需要算分排序，仅用于过滤和聚合分析，可关闭</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/doc-values.html" target="_blank" rel="noopener"><code>doc_values</code></a><br>同上，要排序要分析就开，搜索过滤就没必要</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/fielddata.html" target="_blank" rel="noopener"><code>fielddata</code></a><br>是否为 text 类型启用排序和聚合分析等</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-store.html" target="_blank" rel="noopener"><code>store</code></a><br>是否存储字段值，当内容很多时为了避免影响性能会设置为 false，独立出去；配合 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html" target="_blank" rel="noopener"><code>_source</code></a> 元信息。<br>即使你使用 API 只要求返回限定字段，由于 ES 的原理，还是会拿到所有字段，只是在返回的时候给你过滤掉，所以这种治标不治本。</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/coerce.html" target="_blank" rel="noopener"><code>coerce</code></a><br>是否开启类型自动转换</li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic.html" target="_blank" rel="noopener"><code>dynamic</code></a><br>Mapping 自动更新</li></ul><p>其他的就是一些 date_detection 这种控制日期是否自动转换的配置，建模的过程也不简单，如果想设计的好。<br>枚举类型一般设置为 keyword 因为不需要分词，也不需要计算，例如 HTTP 的状态码之类</p><hr><p>类似传统数据库，在 ES 中也可以处理表关系，Nested Object 与 Parent/child ，不过对于我来说太复杂了，不多看了，我真的对数据库提不起兴趣。<br>子元素更新频繁用 Parent，查询频繁用 Nested，因为 Parent 是分开存的，但是尽量用 Nested。</p><p>最后，保存好你的 Mapping 设计文档，做好版本管理。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>ES 毕竟是一个数据库，并且是为搜索而生，主力还是在搜索 API 上，这一块太多了，之前的笔记也有常用的部分，还是以官网 API 文档为准，搜索的时候只要善用关键词，例如 AND、NOT、分组、+/- （记得 URL 编码）、区间之类会大大简化查询语句。<br>尽量不要使用通配符、正则，尤其放在最前面，文档很大的时候会拖慢速度。<br>相比传统数据库，它还多了近似度匹配的模糊查询，并且它有一个相关性算分的功能（结果排序），搜索引擎必备了；相关性算分需要算法引擎支持，目前默认的是 BM25（相比 TF/IDF 优化了词频 tf 过大的无限增长问题），可以通过 explain 来查看算分过程，算分过程是 shard 独立的，集群的需要注意。<br>另外，在涉及日期搜索中，可以直接通过字符串计算，例如 <code>now +1h</code> ，总之就是很灵活的，不要受限于 SQL。<br>text 类型的字段在搜索排序的时候不能直接用（可通过 <code>`name.keyword</code> 转换为整体进行检索），ES 中提供了 3 种分页方式，最常用的还是 from/size（快照方式 Scroll 非实时性，利用排序方式优化的 Search After 不能实现自由翻页），因为分片的原因，分页的时候并不能确定需要的记录在那个分片，只能每个分片都查一下，最后汇总后确定真正的条数。<br>所以这种分页在遇到深度分页的时候会很耗资源，也就是越往后每个分片需要处理的数据就更大，就如同 Google 也不会把结果无限分页，如果前面都不是你想要的，后面更不会了。</p><p>由于倒排索引不可修改（确实有很多好处例如速度快可压缩等），新增数据的时候重新生成与修改，这样实时性肯定就无法保证，性能开销也很大，为了解决这个问题，可以单独为新文档构建倒排索引，查询的时候同时去两份倒排索引里翻， 当然需要有个文件来存储分块信息。<br>为了达到实时性搜索，ES 做了很多优化，例如文件系统的缓存（refresh），在还未完全写入的时候就可以提供查询，当然有相应的保护机制（translog），毕竟 ES 被称为近实时的搜素。</p><p>想要存储大量数据，分片是必须的，但是分片就会遇到相关性算分不准的问题，这时候就需要用 DFS Query-then-Fetch（通过 RESTful API 指定 search-type）。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>搭建过程就免了，在集群状态可视化上，可以常识下 <strong>cerebro</strong> 这个插件。<br>集群中，分片与副本是关键，分片还有主副之分。<br>新增节点后，原有对 index 不会增加数据容量，因为分片已经固定了；同样，只有新增节点才能增加吞吐量，增加副本是没用的。<br>ES 提供了 API 来查看集群的状态，用颜色表示的话，绿色健康，黄色表示主分片分配正常，副本未正确分配，至于红色就是主分片未正确分配，会影响搜索，但是不会影响服务。<br>既然是集群，肯定是要支持故障转移来实现高可用，这就牵扯到了 Master 选举。</p><p>文档的分片有几种方法，传统的随机在多节点下查找起来非常费劲，如果采用映射表的方式维护就是个难题（海量数据下），所以根据文档具有信息实时计算是不错的选择，就是利用哈希了，也正是因此，分片确定后就不可修改。<br>这里请求数据的时候，『寻址』或者重定向是服务端做的，客户端只与服务端建立一次连接即可，即使目标数据不在这个节点，具体的方案可参考之前写的分布式集群相关，例如 Redis、ZK 都在用，至于脑裂问题也就是选举的问题，在 ZK 哪里也着重说过。</p><p>ES 的性能基本是按照性能扩展的，所以，你只要计算出了单个 shard 的指标，就能推断出所需要多少 shard。压测工具可以试试 esrally，官方还提供了一个 <strong>x-pack</strong> 插件来监控，Kibana 也有对应的可视化插件。<br>就算日志场景一个 shard 也不要超过 50G，搜索场景不要超过 15G。</p><h2 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h2><p>为了便于统计，ES 提供了很多聚合查询功能（aggs），相比 hadoop 这类 T+1 的，它是实时返回的。<br>聚合查询主要分为下面四类：</p><ul><li>Bucket<br>分桶类型，类似 SQL 中的 GROUP BY 语法</li><li>Metric<br>指标分析类型，如计算最大值、最小值、平均值等等；分为单值与多值类型（stats）</li><li>Pipeline<br>管道分析类型，基于上一级的聚合分析结果进行再分析</li><li>Matrⅸ<br>矩阵分析类型，例如热力图</li></ul><p>相比搜索，聚合还多了计算的能力，因为分片的存在，你不能要求它的计算结果是多么的精确，可以通过一些参数来调整精准度（show_term_doc_count_error 对应 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-approximate-counts" target="_blank" rel="noopener">doc_count_error_upper_bound</a>），但是相应的也要付出性能。<br>海量数据、精准度、实时性，这三个不能兼得，只能选其二，显然 ES 聚合分析（Cardinality 和 Percentile）放弃了精准度，例如 Hadoop 就放弃了实时性。</p><p>文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html</a></p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><p>按照之前的介绍，它就是个过滤器，或者说适配器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// codec.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  <span class="comment">// 标准输入</span></span><br><span class="line">  stdin &#123;</span><br><span class="line">    codec =&gt; line</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; json</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件就是这样了（支持表达式），内部原理也是使用队列，一定程度可以代替 Kafka，默认使用的是内存队列，建议使用持久队列就行，性能损耗不是太大。<br>主要涉及三类线程，读取、队列、消费，配置文件中可以对部分进行微调，这就是调优了，不多说。<br>常用的 input 插件有：stdin、file、kafka，不需要担心继续读取、更新检查、重复读取的问题，都考虑到了。<br>要想写的好，可能还需要学习 Grok 脚本。</p><h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><p>简单说可以理解为 Logstash 的轻量级版，了解过 Logstash 的应该知道配置非常复杂，也正是因为 Beats 是轻量级的，主要在数据的收集上，如果需要对数据进行复杂的处理，还是要接入 Logstash。</p><hr><p>用于日志分析的话，基本都是用 <strong>Filebeat</strong> 这个插件，配置也蛮复杂的，还好有 Modules 可以有，达到开箱即用。</p><p>如果用于指标分析，就是 <strong>Metricbeat</strong> 这个轻量级采集器配合使用了，细分可分为系统指标类（CPU 使用等）与日志类（Redis、MySQL 提供的性能指标），不管怎么说，它都是在收集处理指标数据，供分析系统的状态。<br>它相应的也有大量 Modules，系统的、Docker、Redis、MySQL 等等，用什么就装什么，相当于自动给你写好对应的配置文件了，你只需要改一下连接地址就能用。</p><p>网络数据包的分析使用 <strong>Packetbeat</strong> 插件，使用方式与上面一样，可以用来分析 DNS、HTTP、TLS、MySQL 连接等这些信息。<br>对于 Linux 系统可使用 af_packet 模式获取更好的性能。</p><p>心跳检测，确认对方是否存活，使用 <strong>Heartbeat</strong> 插件，社区也有很多质量很高的插件。</p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>为了让请求均匀分布，线上部署一般是采用一个 Coordinating Only ES Node 负责分发，这样 Kibana 只需要连接这个节点即可。<br>因为是 Web UI 终于不跟之前的那些似得那么枯燥了，也仅仅是视觉上，操作还是离不开 ES 的那些语句，要配置好界面也不是一个容易的活。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 ES 的基本使用之前&lt;a href=&quot;https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch%E5%85%A5%E9%97%A8.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;已经写过了&lt;/a&gt;，然后 ELK 也许听的比较多，后来又有了一个 ELK Stack，指的就是 Elastic Stack。&lt;br&gt;这一套技术用在搜索需求、日志分析非常好用，也有很多用来处理 Excel 数据的，就现在都发展来看，ES 真是绕不开都技术，&lt;del&gt;早晚都是要学&lt;/del&gt;，ELK 一套带走就好了。&lt;br&gt;毕竟这一全家桶内容很多，不打算过多深挖，很多东西都不细说了，提供关键词提点自己，用到来查到搜索方向后再 Google 具体使用就好了。
    
    </summary>
    
      <category term="自我提升" scheme="https://sakanoy.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="数据库" scheme="https://sakanoy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="https://sakanoy.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>React核心使用总结</title>
    <link href="https://sakanoy.com/2020/03/01/React%E6%A0%B8%E5%BF%83%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sakanoy.com/2020/03/01/React核心使用总结/</id>
    <published>2020-03-01T11:20:11.000Z</published>
    <updated>2020-03-01T11:28:24.098Z</updated>
    
    <content type="html"><![CDATA[<p>既然 Vue 都学了，难道不顺便把 React 收了么？它的大名就不需要说了，全球最火的前端框架，也是个啥都能写的货。<br>相比 Vue 它会更灵活，这就意味着它更复杂，对于主力后端的我来说，也就点到为止，那些深层次的东西就不挖的太深了，App （React Native）相关的构建也以后再说，这里主要是 Web 应用的开发。<a id="more"></a></p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>创建一个 React App 就使用专业一点的 <code>Create React App</code> 脚手架吧，安装方式官网都有写，不多说。<br>之前官方文档会让安装这个库，现在直接可以使用 npm 自带的 npx 指令（它是 npm 5.2+ 附带的 package 运行工具）来创建了。</p><p>下面来看一下创建出来的目录机构，相比 Vue，看着好像精简一点，默认使用 yarn 构建；webpack 相关的文件就不多说了，其中有用的就是 public 和 src 文件夹。<br>public 文件夹很简单，放了一些 logo，还有一个网站入口文件 index.html，这个文件也非常简单，就是一个基本骨架。<br>看文件夹名字，src 是主要战场，里面有个 index.js 是入口 js 文件，可以说是按照这个文件来一句一句执行代码。<br>可以看到里面导入了一个 serviceWorker 的模块，这个是 PWA（Progressive Web App）是做 App 适配相关的，有个有意思的特点是加载后，断网情况下可查看已经加载过的内容。</p><blockquote><p><code>PWA</code> 的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美 native 的流畅体验，将网络之长与应用之长相结合。</p><p>这 public 中的 manifest.json 文件就是来定义将此 Web App 添加快捷方式放到桌面上的图标等配置，用来尽量模拟原生 App 的体验。</p></blockquote><p>不过 PWA 毕竟不是现在的重点，这个先放一放，到 React Native 再说。</p><p>另外，public 文件夹还有另一个作用，就是项目启动后，会自动把这个文件夹作为资源服务，所以这里的 html 也就是主入口了，所以你在这里面放 json 文件，可以作为接口的模拟。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 中也是有组件的概念，就是一个个的模块，例如 App.js 就是一个模块，通过 index.js 来引入，我学习的时候使用的是最新的版本，但是资料是老的，为了兼顾老版本，尽量都写一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="comment">// js 中的这种标签写法是 JSX 语法</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// App.js</span></span><br><span class="line"><span class="xml">import React from 'react';</span></span><br><span class="line"><span class="xml">import './App.css';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">     Mps~</span><br><span class="line">      &#123;</span><br><span class="line">        this.state.list.map((item, index) =&gt; &#123;</span><br><span class="line">          return &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 较老版本默认的 App.js</span></span><br><span class="line"><span class="xml">import React, &#123; Component &#125; from 'react'; // Component 是 React 的子模块</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class App extends Component &#123;</span></span><br><span class="line"><span class="xml">  constructor(props) &#123;</span></span><br><span class="line"><span class="xml">    // 固定调用</span></span><br><span class="line"><span class="xml">    super(props);</span></span><br><span class="line"><span class="xml">    this.state = &#123;</span></span><br><span class="line"><span class="xml">      val: ''</span></span><br><span class="line"><span class="xml">    &#125;;</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    // 推荐在构造中改变 this 指向，如果用得到</span></span><br><span class="line"><span class="xml">    this.method = this.method.bind(this)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">  // render 函数返回的即最终组件内容，使用了 JSX</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return &#123;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span> MPS~ <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>ReactDOM 这个模块是用来将我们写的组件挂载到 index.html 中的，至于为什么需要引入 React，因为使用到了 JSX。</p><p>无论你使用函数还是 class 定义，在 React 中是等效的，不过看起来函数更加的简洁，并且它还可以接受一个 props 对象来传递数据；不过嘛，虽然简洁了，但也牺牲了一些特性。<br>如果是用的类定义方式，那么 props 的接收就要放到构造函数（constructor）里，效果是一样的。<br><strong>另外 props 是只读的，不可修改；另外，也不要直接修改 state 的内容，要改也是拷贝一份，然后使用 set 方法修改。</strong></p><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>为了更加方便管理，一般会将 UI 部分单独拆离出来，也就是把 render 函数单独搞出来，这样在上层的组件中 render 之间返回 <code>&lt;xxxUI /&gt;</code> 就可以了，但是 UI 中用到的变量怎么办，就是父子组件的传值了。<br>在需要传递方法给子组件执行的时候，如果方法需要传递参数，应该怎么写呢，之间加括号显然不妥，只能使用箭头函数：<br><code>onClick={() =&gt; {this.props.method(p)}}</code></p><p>像这种抽取出来的 UI 组件只有视图，那么就可以称为无状态组件，还记得脚手架给我们生成的默认文件的那个函数，那就是一个无状态组件了，它的性能更高。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>虽然 React 并不强制使用 JSX，但是基本所有的 React 都这用吧，毕竟是真的好用，目前只能说说用到的一些功能。</p><blockquote><p>JSX 语法不仅仅是可以便捷的使用 HTML 标签，自定义的标签也是可以的，例如 <code>&lt;App /&gt;</code><br>不过需要注意，自定义的标签开头必须大写，也就是你 import 导入的时候命名就得符合这个规则。</p></blockquote><p>JSX 规定返回的内容必须包裹这一个标签内，但是这样就会多了一层结构，对样式可能不友好，类似的，它也有相应的特殊标签来规避：Fragment</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;input value=&#123;<span class="keyword">this</span>.state.val&#125; </span><br><span class="line">        ref=&#123;(input) =&gt; &#123;<span class="keyword">this</span>.input = input&#125;&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">handleChange(e) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 必须通过 set 函数 dom 才会刷新</span></span><br><span class="line"><span class="regexp">  this.setState(&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ e.target = this.input</span></span><br><span class="line"><span class="regexp">    val: e.target.value,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 展开运算符，添加新元素</span></span><br><span class="line"><span class="regexp">    list: [...this.state.list, newVal]</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看出，它其实也是一个组件，只不过是 React 自带的，如果嫌麻烦，可以在 import 的时候就把它导进来。<br>上面的例子中，使用到了 ref 语法，虽然它能简化 e.target 这种写法，但是不推荐使用。<br>JSX 的差值表达式是使用一个大括号来定义的，包括触发事件（驼峰格式）的函数引用，注意 this 的作用域，然后下面是一些 JSX 的语法补充。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释，利用 &#123;&#125; 里面是 JS 表达式的原理，仅开发可见</span></span><br><span class="line">&#123;<span class="comment">/* xxxx */</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// xxxxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式，避免与类定义混淆，使用 className</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./demo.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1 className=<span class="string">'xxx'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用转义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMarkup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">__html</span>: <span class="string">'First &amp;middot; Second'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span>;</span></span><br><span class="line">  // return &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: 'First &amp;middot; Second'&#125;&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在禁用转义中使用了双花括号，这里第二个花括号已经是 JS 的对象了，所以，并没有太大含义。<br>由于语言的歧义，除了 class 用 className 代替，在 label 中的 for 要用 htmlFor 来替代。</p><hr><p>即使你不使用 JSX 语法，React 提供来一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. </span></span><br><span class="line">React.createElement(<span class="string">'div'</span>, &#123;&#125;, <span class="string">'show'</span>);</span><br></pre></td></tr></table></figure><p>它与 JSX 的效果是一样的，也可以说 JSX 就是它的简写版本。</p><h2 id="组件之间传值"><a href="#组件之间传值" class="headerlink" title="组件之间传值"></a>组件之间传值</h2><p>页面都是有一个个的组件组成的，那就肯定避免不了传值问题，父组件向子组件传值相对很简单，直接通过标签的自定义属性即可，子组件只需要使用 <code>this.props.attrName</code> 就可以获取到，但是是<strong>只读</strong>的。<br>很多时候，我们需要在子组件中修改父组件的一些数据，当然这肯定是不能允许直接改的，一般是通过调用父组件的一个方法来实现数值的修改。<br>虽然子组件调用父组件的函数直接想不好搞，但是可以曲线救国，把父组件的方法直接传给子组件不就得了，子组件拿到了就可以在子组件的函数里直接调用；在传递的时候记得父组件里使用 bind 改变一下 this 指向。</p><p>单向数据流保证了数据的安全稳定，否则都不好定位是谁改了然后又导致了什么。</p><h3 id="类型校验"><a href="#类型校验" class="headerlink" title="类型校验"></a>类型校验</h3><p>因为不管是什么类型都可以往子组件传递，甚至方法，为了避免出错，还是校验一下比较好，方法就是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="comment">// 前面省略了</span></span><br><span class="line"></span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  n1: propTypes.string.isRequired,</span><br><span class="line">  n2: propTypes.func,</span><br><span class="line">  n3: propTypes.number,</span><br><span class="line">  n4: propTypes.array,</span><br><span class="line">  n5: propTypes.bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.defaultProps = &#123;</span><br><span class="line">  n1: <span class="string">'null'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>如果类型不对会给你一个警告，虽然并不影响程序的运行。<br>更多高级的用法例如或者并且等判断参考官方文档：<a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html</a></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>父子组件传值还算是简单，当项目复杂起来，不可能只是父子之间的传值，如果还用现在的方法就会很复杂，所以需要引入 Redux 来完成不同组件之间的传值。<br>原理也很简单，把数据统一放到一个 Store 对象中统一存储，然后需要的组件去监控这里面某个变量的值，当发生变化时，做出相应的改变。</p><p><img src="/image/dev/redux.png" alt="img"></p><p>上图就是 Redux 的数据流，也是按照单向数据流设计，组件必须通过 Action 才可以操作 Store 的数据。<br>第一步，创建一个 Store，例如 <code>./store/index.js &amp; reducer.js</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 Redux Dev 插件可用，需要在这配置</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;&#125;  <span class="comment">// 具体存储</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  <span class="comment">// state = 上一次的 state 数据</span></span><br><span class="line">  <span class="comment">// 要根据 action 的内容来更新 state，switch....case</span></span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">  todos: [</span><br><span class="line">    ...state.todos,</span><br><span class="line">    &#123;</span><br><span class="line">      text: action.text,</span><br><span class="line">      completed: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>仓库创建好了，下面就可以使用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;  <span class="comment">// ./store/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    store.getState();</span><br><span class="line">    <span class="comment">// store 数据发生改变后执行</span></span><br><span class="line">    store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  change(newVal) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">'change_value'</span>,</span><br><span class="line">    value: <span class="string">'newVal'</span></span><br><span class="line">    &#125;;</span><br><span class="line">    store.dispatch(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免 Action#type 手误写错，可以专门起一个 js 文件来定义，类似枚举。同理，Action 方法也是类似。<br>由于 reducer 中的 state 不能直接修改，每次根据 action 更新时需要拷贝一个，一不小心就容易漏掉，这个时候就可以使用 <strong>immutable-js</strong> 这个库来做，生成不可变对象，经过它的转换，就可以通过使用 get 方法获取或者 set 方法重新生成一个不可变对象。<br>为了统一样式，可以使用 <strong>redux-immutable</strong> 库来进行处理。</p><p>PS：Redux = Reducer + Flux</p><h3 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h3><p>通过 <strong>React-redux</strong> 可以让我们更方便的使用 Redux，官方主页是这样写的：Official React bindings for Redux</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  rootElement</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这里使用 Provider 组件将 store 进行了传递，这样 Provider 下的所有子组件都能共享了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class App ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 store（state）的数据映射到 props</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state <span class="regexp">/*, ownProps*/</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将要调用 dispatch 的方法映射</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    change(e) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;&#125;;</span><br><span class="line">      dispatch(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(App)</span><br></pre></td></tr></table></figure><p>子组件获取 store 使用的是 connect 这个函数，在 export 的时候使用。<br>connect 函数需要传入两个参数，也就是如何做连接，就是做了两个映射，这样都省的订阅了，store 变化数据就实时刷新了。<br>并且，这样组件基本不包含任何的逻辑代码了，可以做成无状态组件了；也可以这么理解，connect 函数将 UI 组件和逻辑部分进行了拼装，返回了容器组件。</p><h2 id="State与Props"><a href="#State与Props" class="headerlink" title="State与Props"></a>State与Props</h2><p>当 State 或者 Props 发生改变时，render 函数就会执行，这样 Dom 就会被重新渲染。</p><p>在前面组件里我们说的是改变数据必须用 set 函数，使用的是传统的传入一个对象（）利用 K-V 的形式来进行更新；不过还有性能更好的方法就是异步函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> val = e.target.value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: val&#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个 return，箭头函数还可以简写</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=&gt;</span>(&#123;<span class="attr">value</span>: val&#125;))</span><br></pre></td></tr></table></figure><p>不过因为异步，在使用的时候，数值尽量固定化，也是因为异步，所以它还会有第二个参数，是回调，根据需要使用。<br>在 setState 使用异步函数的时候，函数其实会传给你一个 prevState 参数，它就是原来的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">value</span>: prevState.value + newVal&#125;))</span><br><span class="line"><span class="comment">// ES6 语法简写</span></span><br><span class="line">&#123;<span class="attr">val</span>: val&#125; == &#123;val&#125;</span><br></pre></td></tr></table></figure><p>至于 setState 为什么建议使用异步，因为这样如果有多个修改并且间隔很短，React 就可以合并成一个操作，避免连续多次的虚拟 DOM 比对与渲染。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>不管是 React 还是 Vue，都是使用虚拟 DOM 来控制页面的渲染（刷新），原因就是 JS 渲染一次真实的 DOM 需要调用浏览器 API，性能损耗过高，如果频繁渲染，体验肯定不好。<br>对于这一问题，有几个方案，现在采用的基本都是虚拟 DOM</p><ul><li>数据改变，重新生成新的 DOM，替换老的 DOM</li><li>数据改变，重新生成新的 DOM，与老的 DOM 比对，只替换差异部分</li><li>加载时构建虚拟 DOM，数据改变，虚拟 DOM 随之改变，对比之前老的虚拟 DOM，确定差异部分，操作 DOM 更新差异。</li></ul><p>这里的这个虚拟 DOM 可以理解为就是个 JS 对象，用这个 JS 对象来描述真实的 DOM，正是因为是 JS 对象，所以速度很快，性能就大幅提高了。<br>在 React 中，真实的 DOM 是按照虚拟 DOM 来渲染的，也正是因为虚拟 DOM 的存在，所以 React Native 得以存在，虚拟 DOM 渲染为真实 DOM 就是浏览器，渲染为原生 App 组件，这就成移动端的应用了。</p><p>虚拟 DOM 的比对 Diff 使用的是同层比对，从上往下，只要发现一层中的某个节点不一样，此节点下面所有的结构都会被重新渲染，虽然下面可能都没有变，但是这样的比对速度会更快。<br>之所以要设置 Key 值也是为了提高比对速度，当 key 是唯一的时候，那么就是 key 与 DOM 一对一的对应关系，当发现某个节点的 key 没有变时，可以直接复用了（<del>先根据 key 拿到对应的节点的信息，然后校验是否一致，如果不一致说明 key 是不稳定的，这种缓存就没法用了</del>），所以，用 index 当作 key 很不妥。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>对于这类描述生命周期的内容，没有什么比图更直观了：</p><p><img src="/image/dev/lifecycle1.png" alt="img"></p><p><img src="/image/dev/lifecycle2.png" alt="img"></p><p>这两幅图基本已经描述的够清楚了（虽然版本有点老），还有一个是官方的图：<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a><br>根据官方图，getDerivedStateFromProps 这个方法中 16.4 发生了变化，需要特别注意。<br>以及 componentWillReceiveProps 与 componentWillUpdate、componentWillMount 已经被标注为过时。</p><p>在 React  中所有的组件都要继承 Component，大部分的生命周期函数中 Component 中都有默认实现，唯独 render 没有，所以这就是为什么你必须写 render 函数的原因（函数式写法有点特别）。<br>因为当父组件的 render 被执行时，子组件的 render 也会被执行，即使这时候 props 并没有变化，这样就会带来不必要的性能开销，所以可以使用 <code>shouldComponentUpdate</code> 这个生命周期函数来优化（或者继承 PureComponent，它默认实现了这个方法，不过为了避免 bug，需要配合 immutable-js 使用）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextProps.xxx !== <span class="keyword">this</span>.props.xxx;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    axios.get(<span class="string">'/index'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.data.ret &amp;&amp; res.data.data) &#123;</span><br><span class="line">        <span class="comment">// something</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况，我们发送 Ajax 请求的过程要放到 componentDidMount 中。<br>建议使用 axios 当然需要安装（<code>yarn add axios</code>）</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>关于页面的路由，这里就使用 react-router-dom 这个模块来完成，文档参考<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">这里</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter, Route&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.loginStatus) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">'/'</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ResetStyle/&gt;</span><br><span class="line">      &lt;GlobalStyle/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Route path='/' exact component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route path='/detail/:id' exact render=&#123;() =&gt; &lt;div&gt;detail&lt;/div&gt;&#125;&gt;&lt;/Route&gt;</span><br><span class="line">      &lt;/BrowserRouter&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App;</span></span><br></pre></td></tr></table></figure><p>简单说就是根据请求路径的不同来决定显示的内容，使用 exact 来进行完全匹配。<br>老的版本可能不允许你 Provider 或者 BrowserRouter 有多个元素，那时候用 div 裹一下就好。</p><p>另外，它还提供了一个 Link 模块，可以用来替代 a 标签，做单页面应用，避免加载过多的 HTML。<br>在进行匹配的时候，可以使用类似 <code>/:id</code> 来匹配变量，然后在组件里通过 <code>this.props.match.params.id</code> 获取，这就是动态路由了。<br>另外一种是匹配 ？传值，一样的，只不过不需要写 <code>/:id</code> 了，如果有 <code>?id=xx</code> 会自动进行填充，获取方法不太一样，要自己手动处理字符串 <code>this.props.location.search</code> 并不是很推荐。</p><h2 id="Redux-thunk"><a href="#Redux-thunk" class="headerlink" title="Redux-thunk"></a>Redux-thunk</h2><p><strong>Redux-thunk</strong> 是 Redux 的一个中间件，用来『整理』Action 中的 Ajax 请求等处理，说明文档可以参考 <a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">Github 的主页</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: this API requires redux@&gt;=3.1.0</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure><p>使用多个中间件，例如 Redux Dev Tools 具体方法参考 <a href="https://github.com/zalmoxisus/redux-devtools-extension#12-advanced-store-setup" target="_blank" rel="noopener">Github 的文档</a>。<br>使用 Redux-thunk 后在 action 中就不一定非要是 js 的对象了，可以返回一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initAction = <span class="function">(<span class="params">newVal</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: <span class="string">'change_value'</span>,</span><br><span class="line">  value: newVal</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getAction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(<span class="string">'/do'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      dispatch(initAction(res.data));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> action = getAction();</span><br><span class="line">  <span class="comment">// 可以接受一个函数了</span></span><br><span class="line">  store.dispatch(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方展示的也是封装后的 Action 写法，还是建议把 Action 封装到一个 js 文件，统一管理。<br>看起来好像比之前麻烦了，不过以经验来看，当项目越来越大后，这种方式更加容易管理和测试。</p><h2 id="Redux-saga"><a href="#Redux-saga" class="headerlink" title="Redux-saga"></a>Redux-saga</h2><p>与 Redux-thunk 类似，Redux-saga 也是一个类似的 Redux 中间件，做异步代码拆分的，他们两个可以互相替代，使用方法也可以参考一下 <a href="https://github.com/redux-saga/redux-saga#mainjs" target="_blank" rel="noopener">Github 的文档</a>。<br>它使用单独的 JS 文件来管理 Ajax 请求，然后 run 一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sagas.js example</span></span><br><span class="line"><span class="keyword">import</span> &#123; put, takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下内容怕出错可以放到 try...catch 里</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> axios.get(<span class="string">'/do'</span>);</span><br><span class="line">  <span class="keyword">const</span> action = initAction(res.data);</span><br><span class="line">  <span class="comment">// 执行完成后传给 reducer</span></span><br><span class="line">  <span class="keyword">yield</span> put(action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">mySaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ES6 Generator 函数</span></span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">"ACTION_TYPE_NAME"</span>, fetchUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mySaga;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="comment">// action 只是包含一个 type 类型的对象即可</span></span><br><span class="line">  <span class="keyword">const</span> action = getAction();</span><br><span class="line">  store.dispatch(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说当你 dispatch 时，mySaga 也会收到你的 action，然后如果类型匹配，就会执行对应的函数，例如  fetchUser。<br>可以看出 Redux-saga 是更加复杂的，相应的功能也更强大，上面也是最基本的使用。</p><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><p>默认情况下，会把项目的所有 JS 打包成一个 JS，这样页面只需要加载一次 JS，但是，如果逻辑很多，第一次加载肯定很慢，对于大项目，更期望只加载用到的 JS，使用的是 <strong>react-loadable</strong> 这个组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadable.js</span></span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</span><br><span class="line">  <span class="comment">// 当前的 index.js 做异步</span></span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./'</span>),</span><br><span class="line">  loading () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">LoadableComponent</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上是基于官方示例做的简单修改，下面是使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Detail from './pages/detail' 之前</span></span><br><span class="line"><span class="keyword">import</span> Detail <span class="keyword">from</span> <span class="string">'./pages/detail/loadable'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ResetStyle/&gt;</span><br><span class="line">      &lt;GlobalStyle/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Route path=<span class="string">'/detail/:id'</span> exact component=&#123;Detail&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由的情况下，需要对组件特殊处理</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapState, mapDispatch)(withRouter(Detail));</span><br></pre></td></tr></table></figure><p>可以看出，只需要把 import 语句改成引入编写的 loadable 文件即可，但是，如何使用了 BrowserRouter 路由，这样就会有问题，所以在 export 的时候需要使用 withRouter 包裹一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下一般的模块开发套路，首先创建组件，如果需要较多的数据就要创建独立的 Store，然后使用 <strong>Redux + React-redux</strong> 来进行管理，子组件在 export 的时候使用 connect 函数连接 store。<br>样式的编写可以采用 <strong>styled-components</strong>，这样数据全部来自相关的 store，使用 mapStateToProps 来映射到 props 中，相关的事件通过 mapDispatchToProps 映射到 props 中，这样改变数据就使用相应的 action 即可。<br>为了将逻辑写在 action 中，例如异步请求，使用了 <strong>Redux-thunk 或者 Redux-saga</strong> 来将 action 变为一个函数，将数据处理好后直接调用 dispatch 即可，为了方便 action 管理，将所有 action 的创建抽取到 <em>actionCreators.js</em> 文件中，相应的，常量也应该抽取到一个单独的文件，便于 <em>actionCreators.js 和 reducer.js</em> 的使用。<br>存储为了不必要的麻烦，使用 <strong>immutable-js</strong> 将其变为不可变对象，为了风格的统一使用 <strong>redux-immutable</strong> 将 store 的 state 也变为不可变对象。<br>这样下来，store 文件夹里就有了不少文件，为了方便导入，可以建一个 <em>index.js</em> 做聚合。<br>每一个模块都应该有自己的 store 数据仓储，所以把相关联的 store 文件夹放真自己的模块下，在主仓储使用 combineReducers 函数来组合。</p><p>因为数据变化 <code>render()</code> 就会执行，子组件也会重新渲染，即使子组件需要的数据没有变化，为了优化这个问题导致的页面重新渲染，除了在 shouldComponentUpdate 中判断外，React 自然也想到了这一点，所以它还有一个 <strong>PureComponent</strong>，只要继承它，就自动帮你实现了 shouldComponentUpdate 的内容，不过需要也使用 immutable-js，否则可能会有 bug。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于动画，这个我是真的不想看，CSS 看着就头疼，想做的看下 <strong>react-transition-group</strong> 这个库吧。<br>关于 UI 设计，可以看看 Ant Design 这个库。</p><p>正常情况下，如果你在 JS 中导入了 CSS，那么这个 CSS 是全局生效的，所以并不推荐这样使用，例如可以使用 <code>styled-components</code> 来管理，它使用 JS 来编写样式，这样在 WebStorm 不识别，可以安装他们的一个插件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然 Vue 都学了，难道不顺便把 React 收了么？它的大名就不需要说了，全球最火的前端框架，也是个啥都能写的货。&lt;br&gt;相比 Vue 它会更灵活，这就意味着它更复杂，对于主力后端的我来说，也就点到为止，那些深层次的东西就不挖的太深了，App （React Native）相关的构建也以后再说，这里主要是 Web 应用的开发。
    
    </summary>
    
      <category term="Web" scheme="https://sakanoy.com/categories/Web/"/>
    
    
      <category term="前端" scheme="https://sakanoy.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS布局之Flex布局</title>
    <link href="https://sakanoy.com/2019/11/26/CSS%E5%B8%83%E5%B1%80%E4%B9%8BFlex%E5%B8%83%E5%B1%80/"/>
    <id>https://sakanoy.com/2019/11/26/CSS布局之Flex布局/</id>
    <published>2019-11-26T20:16:55.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>某天在网上看到了一篇帖子有感而发，作为后端还是挺喜欢 JS 的，毕竟动态语言确实爽，不过 CSS 我就….心累，真的玩不起，我们称之为玄学。<br>当我还以为盒子模型是主流时，评论区大呼 Flex 布局真香，而我就一脸懵逼了，CSS3 一直不怨触碰，但如果主流布局方式变了，那肯定是要学习一下的（当然还有一种是  grid  这个看着比较复杂，<del>之后再说</del>）。<a id="more"></a></p><h2 id="Flex布局简介"><a href="#Flex布局简介" class="headerlink" title="Flex布局简介"></a>Flex布局简介</h2><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br>2009 年，W3C 提出了一种新的方案—- Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，<strong>它已经得到了所有浏览器的支持</strong>，这意味着，现在就能很安全地使用这项功能。<br> Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任何一个容器都可以指定为 Flex 布局。 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 行内元素也可以使用 Flex 布局。*/</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Webkit 内核的浏览器，必须加上 -webkit 前缀。 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</strong></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 </p><p> <img src="/image/Flex.png" alt="基本布局"> </p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 <code>main start</code>，结束位置叫做 <code>main end</code>；交叉轴的开始位置叫做 <code>cross start</code>，结束位置叫做 <code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做 <code>main size</code>，占据的交叉轴空间叫做 <code>cross size</code>。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下6个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><p>第一次看到这些还是很陌生的，毕竟之前没接触过 Flex 布局，虽然它早就已经有了，下面就详细解释下这些属性。</p><h3 id="flex-direction-主轴方向"><a href="#flex-direction-主轴方向" class="headerlink" title="flex-direction(主轴方向)"></a>flex-direction(主轴方向)</h3><p><code>flex-direction</code> 属性决定主轴的方向（即项目的排列方向），它可能有 4 个值：</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p>无论是横向还是纵向，默认都是紧凑着来（顶格），也就是如果想要它居中排列，还需要另外的设置。</p><h3 id="flex-wrap-如何换行"><a href="#flex-wrap-如何换行" class="headerlink" title="flex-wrap(如何换行)"></a>flex-wrap(如何换行)</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code> 属性定义，如果一条轴线排不下，如何换行， 它可能取三个值：</p><ul><li><code>nowrap</code>（默认）：不换行。 </li><li><code>wrap</code>：换行，第一行在上方。 </li><li><code>wrap-reverse</code>：换行，第一行在下方。 </li></ul><p>简单说就是定义是否换行，和换行的方向，第一行在下面还是上面的问题。</p><h3 id="flex-flow-聚合属性"><a href="#flex-flow-聚合属性" class="headerlink" title="flex-flow(聚合属性)"></a>flex-flow(聚合属性)</h3><p><code>flex-flow</code> 属性是 <code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式，默认值为 <code>row nowrap</code>。<br>就是把前面两个属性值写在一起了，CSS 中很常见，下一个！</p><h3 id="justify-content-主轴对齐方式"><a href="#justify-content-主轴对齐方式" class="headerlink" title="justify-content(主轴对齐方式)"></a>justify-content(主轴对齐方式)</h3><p><code>justify-content</code>  属性定义了项目在主轴上的对齐方式。  它可能取 5 个值，<strong>具体对齐方式与轴的方向有关</strong>。下面假设主轴为从左到右。 </p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p>如果主轴是从上到下，那么就不是左右对齐的问题了，就是上下了，属性也没用使用 left 和 right 这类词，而是 start 和 end，配合之前的 Flex 基本模型，还是非常好理解的；同时，也是垂直居中的一种方案。</p><h3 id="align-items-交叉轴对齐方式"><a href="#align-items-交叉轴对齐方式" class="headerlink" title="align-items(交叉轴对齐方式)"></a>align-items(交叉轴对齐方式)</h3><p><code>align-items</code> 属性定义项目在交叉轴（默认主轴左右，交叉轴上下）上如何对齐。  它可能取 5 个值。具体的对齐方式<strong>与交叉轴的方向有关</strong>，下面假设交叉轴从上到下。 </p><ul><li><code>flex-start</code>：交叉轴的起点对齐，即所有项目靠上。</li><li><code>flex-end</code>：交叉轴的终点对齐，即所有项目靠下。</li><li><code>center</code>：交叉轴的中点对齐，即所有项目排列在中间，垂直居中。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li></ul><p>这个属性也是垂直居中的一种方案，它决定了项目在容器中垂直方向上的位置（默认情况下）</p><h3 id="align-content-多根轴线对齐方式"><a href="#align-content-多根轴线对齐方式" class="headerlink" title="align-content(多根轴线对齐方式)"></a>align-content(多根轴线对齐方式)</h3><p><code>align-content</code> 属性定义了<strong>多根轴线</strong>的对齐方式。如果项目只有一根轴线，该属性不起作用，该属性可能取 6 个值：</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><p>这个属性看似跟 align-items 没啥区别，区别就仅仅是 <strong>align-content 当项目只有一根轴线，该属性不起作用</strong>；<br>也就是说，align-items 它是用来让每一个<strong>单行的</strong>容器居中而不是让整个容器居中；align-content 属性<strong>只适用于多行的 flex 容器</strong>，并且会把多行作为一个整体，它们之间没有间隙。<br>简单讲，关键还是看是不是多行。</p><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>以上的六个属性全部是用在容器上的，相应的项目也有六个可配属性：</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><p>同样下面详细解释一下这几个属性</p><h3 id="order-项目排序"><a href="#order-项目排序" class="headerlink" title="order(项目排序)"></a>order(项目排序)</h3><p><code>order</code> 属性定义项目的排列顺序。<strong>数值越小，排列越靠前</strong>，默认为 0。 </p><h3 id="flex-grow-放大比例"><a href="#flex-grow-放大比例" class="headerlink" title="flex-grow(放大比例)"></a>flex-grow(放大比例)</h3><p><code>flex-grow</code> 属性定义项目的放大比例，默认为 <code>0</code>，即如果存在剩余空间，也不放大。<br>如果所有项目的 <code>flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code>flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink-缩放比例"><a href="#flex-shrink-缩放比例" class="headerlink" title="flex-shrink(缩放比例)"></a>flex-shrink(缩放比例)</h3><p><code>flex-shrink</code> 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。<br>如果所有项目的 <code>flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 <code>flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，<strong>前者不缩小</strong>。负值对该属性无效。</p><h3 id="flex-basis-占位大小"><a href="#flex-basis-占位大小" class="headerlink" title="flex-basis(占位大小)"></a>flex-basis(占位大小)</h3><p><code>flex-basis</code> 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。<strong>浏览器根据这个属性，计算主轴是否有多余空间</strong>。它的默认值为 <code>auto</code>，即项目的本来大小。<br>它可以设为跟 <code>width</code> 或 <code>height</code> 属性一样的值（比如 350px），则项目将占据固定空间。</p><h3 id="flex-聚合属性"><a href="#flex-聚合属性" class="headerlink" title="flex(聚合属性)"></a>flex(聚合属性)</h3><p><code>flex</code> 属性是 <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code> 的简写，默认值为 <code>0 1 auto</code>。后两个属性可选。<br>该属性有两个快捷值：auto (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self-独立对齐方式"><a href="#align-self-独立对齐方式" class="headerlink" title="align-self(独立对齐方式)"></a>align-self(独立对齐方式)</h3><p><code>align-self</code> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 <code>align-items</code> 属性。默认值为 <code>auto</code>，表示继承父元素的 <code>align-items</code> 属性，如果没有父元素，则等同于 <code>stretch</code>。<br>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br>示例：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某天在网上看到了一篇帖子有感而发，作为后端还是挺喜欢 JS 的，毕竟动态语言确实爽，不过 CSS 我就….心累，真的玩不起，我们称之为玄学。&lt;br&gt;当我还以为盒子模型是主流时，评论区大呼 Flex 布局真香，而我就一脸懵逼了，CSS3 一直不怨触碰，但如果主流布局方式变了，那肯定是要学习一下的（当然还有一种是  grid  这个看着比较复杂，&lt;del&gt;之后再说&lt;/del&gt;）。
    
    </summary>
    
      <category term="Web" scheme="https://sakanoy.com/categories/Web/"/>
    
    
      <category term="CSS" scheme="https://sakanoy.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity笔记</title>
    <link href="https://sakanoy.com/2019/11/24/SpringSecurity%E7%AC%94%E8%AE%B0/"/>
    <id>https://sakanoy.com/2019/11/24/SpringSecurity笔记/</id>
    <published>2019-11-24T08:06:36.000Z</published>
    <updated>2019-11-23T13:38:51.877Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关，SSO 相关的提了一下，看完之后不是问题。<a id="more"></a></p><p>这篇笔记基于慕课上的一门课，个人认为还是不错的，反反复复看了好几遍，先跟着写了一遍，当然不是完全的照抄，对基础框架做了一点升级和自己的一些处理，之后发现内容太多，决定从头再来一遍，并且整理成这篇笔记。</p><h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>这一次我使用的版本是 SB2.x，集成 SpringSecurity 就不需要多说了，一个 starter 搞定，然后它的默认配置会将所有的接口保护起来，使用 http basic 来认证。</p><blockquote><p>需要注意的是：<code>security.basic.enabled</code> 在 SB2.x 被废弃，如果需要禁用 SpringSecurity 请使用 exclude 的方式进行排除，例如:<br><code>@SpringBootApplication(exclude = {SecurityAutoConfiguration.class, ManagementWebSecurityAutoConfiguration.class})</code></p></blockquote><p>接下来就是如何配置了，首先我们可以新建一个 java config 类，继承 WebSecurityConfigurerAdapter 这个适配器类，然后覆盖它的方法，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPasswordAuthenticationConfig</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 使用表单登陆</span></span><br><span class="line">  http.formLogin()</span><br><span class="line">    <span class="comment">// 跳转认证的页面(默认 /login)</span></span><br><span class="line">    .loginPage(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL)</span><br><span class="line">    <span class="comment">// 进行认证的请求地址（UsernamePasswordAuthenticationFilter）</span></span><br><span class="line">    .loginProcessingUrl(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM)</span><br><span class="line">    <span class="comment">// 自定义登陆成功、失败后的处理逻辑</span></span><br><span class="line">    .successHandler(authenticationSuccessHandler)</span><br><span class="line">    .failureHandler(authenticationFailureHandler)</span><br><span class="line">    .and()</span><br><span class="line">    <span class="comment">// 设置授权要求</span></span><br><span class="line">    .authorizeRequests()</span><br><span class="line">    .antMatchers(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL, <span class="string">"/user/register"</span>)</span><br><span class="line">    <span class="comment">// 以上匹配不需要认证</span></span><br><span class="line">    .permitAll()</span><br><span class="line">    <span class="comment">// 其他请求需要进行认证</span></span><br><span class="line">    .anyRequest()</span><br><span class="line">    .authenticated()</span><br><span class="line">    .and()</span><br><span class="line">    .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们来说一下 SpringSecurity 的原理，其实也不难猜，肯定是通过 Filter 实现的，它也确实是通过一组 Filter 链来做的，首先来看一下这个图：</p><p><img src="/image/SpringSecurity基本原理.png" alt="SpringSecurity基本原理"></p><p>很显然，UsernamePasswordAuthenticationFilter 这个过滤器就是来处理表单登陆的相关请求，BasicAuthenticationFilter 那就是来处理 http basic 登陆的相关请求；例如你使用表单提交，UsernamePasswordAuthenticationFilter 会从请求中拿到用户名密码，然后去做登陆校验，如果成功则标记为已认证（通过一个过滤器链的共享变量）；如果拿不到用户名密码就放行，进入到下一个过滤器再做其他方式的登陆校验。<br>过滤链的最后一环是 FilterSecurityInterceptor，它通过那个标志位来判断前面是否已经通过了身份认证，然后根据我们 config 中配置的规则，来控制允不允许访问；如果不过，它会根据不同的原因来抛出不同的异常。<br>那么，在 FilterSecurityInterceptor 前面的 ExceptionTranslationFilter 就是来接受它抛出的异常，然后根据不同类型的异常做出不同的处理，例如未登录的异常会根据前面的配置来引导用户进行登陆。<br>PS：其中，绿色部分是我们可以控制是否开启的。</p><h3 id="自定义用户认证"><a href="#自定义用户认证" class="headerlink" title="自定义用户认证"></a>自定义用户认证</h3><p>拿到用户名密码后，如何判断是否是合法用户呢，这个需求每一个业务系统可能都不一样，所以肯定是可以自定义的，这个过程被抽象成了一个接口叫做 <strong>UserDetailsService</strong>，我们新建一个类，然后实现这个接口（只有一个需要实现的方法 loadUserByUsername），在这个方法中，我们可以拿到请求中的用户名，根据这个用户名如何获取用户信息就全靠我们自己了，使用 Mybatis 的 mapper 或者 JPA，最终只要返回一个 UserDetails 对象即可。<br>说起 UserDetails 对象，我们既可以用 SpringSecurity 的默认实现 User，也可以继承 User 后进行增强，以默认的 User 对象来说，它有几个构造方法，满足我们日常的账号是否禁用、是否锁定、是否过期等等需求。<br>它的判断逻辑也非常简单，你根据用户输入的用户名获取 UserDetails 对象并且返回，SpringSecurity 拿着你返回的这个对象中的秘密与用户输入的密码进行比对，如果错误则抛出用户名或密码错误的异常，如果这个对象的是否锁定为 true，则抛出用户已锁定的异常。<br>最后的一个参数是权限，这个放在后面的鉴权里面说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span>, <span class="title">SocialUserDetailsService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// BCryptPasswordEncoder 每次生成的会不一样，应该在注册的时候保存，这里直接拿数据库保存的</span></span><br><span class="line">    String pwd = passwordEncoder.encode(<span class="string">"123123"</span>);</span><br><span class="line">    System.out.println(<span class="string">"PWD："</span> + pwd);</span><br><span class="line">    <span class="comment">// 简单实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(username, pwd,</span><br><span class="line">                    AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin,ROLE_USER"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于密码的处理，这里使用了 BCryptPasswordEncoder，一般情况下，我们数据库中不可能存储明文密码，SpringSecurity 自然也考虑到了，所以它搞出来了个 PasswordEncoder 接口，这个接口主要定义了两个方法，一个是来处理原始密码的 encode，一个是来比较密码的 matches，你可以自己实现，也可以用它提供的几种，例如 BCryptPasswordEncoder。</p><blockquote><p>这里稍微说下 BCryptPasswordEncoder，它根据 hash + salt 的方式生成密码，特点是即使是相同的密码，每次经过它编码后秘文是不一样的！但是他们 matches 后的结果会是 true，提高了安全性。</p></blockquote><h3 id="自定义认证界面"><a href="#自定义认证界面" class="headerlink" title="自定义认证界面"></a>自定义认证界面</h3><p>我们最常用的就是表单认证，至于前端样式，肯定是各不相同，下面就来说如何自定义。<br>然而最开始的配置里已经剧透了，就是通过 <code>http.loginPage()</code> 来指定登陆的 URL，然后你写你的 html 前端就行了，如果要兼容其他客户端例如 App，你可以写一个 Controller 来判断是不是请求的 html，来确定是返回 html 还是 json；最后只需要记得别忘了把这个地址放到白名单中就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SE 在认证时会将原请求缓存进 requestCache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RequestCache requestCache = <span class="keyword">new</span> HttpSessionRequestCache();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RedirectStrategy redirectStrategy = <span class="keyword">new</span> DefaultRedirectStrategy();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当需要身份认证时，执行此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果是浏览器请求，重定向到认证页面；如果是其他返回 401 状态码提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(SecurityConstants.DEFAULT_UN_AUTHENTICATION_URL)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(code = HttpStatus.UNAUTHORIZED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleResponse <span class="title">reqAuth</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  SavedRequest savedRequest = requestCache.getRequest(request, response);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (savedRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String redirectUrl = savedRequest.getRedirectUrl();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.endsWithIgnoreCase(redirectUrl, <span class="string">".html"</span>)) &#123;</span><br><span class="line">      redirectStrategy.sendRedirect(request, response, securityProperties.getBrowser().getLoginPage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleResponse(<span class="string">"访问的服务需要授权"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户访问需要授权的接口时，如果检测到未登录，就会重定向到我们配置的登陆页面（浏览器），同时会将 URL 存起来，便于通过认证后再跳转回去，我们通过 RequestCache 这个工具就能拿到 SpringSecurity 存起来的 URL。</p><p>然后通过 <code>http.loginProcessingUrl()</code> 来指定表单的提交地址，也就是真正的后台处理登陆请求的地址，后面就是 UsernamePasswordAuthenticationFilter 那一套了。</p><h3 id="自定义成功和失败Handler"><a href="#自定义成功和失败Handler" class="headerlink" title="自定义成功和失败Handler"></a>自定义成功和失败Handler</h3><p>如何配置前面已经剧透了，想要自定义认证成功或者失败后的逻辑，只需要定义相关的 Handler 即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义登陆失败后处理逻辑</span></span><br><span class="line"><span class="comment"> * 可以实现 &#123;<span class="doctag">@link</span> AuthenticationFailureHandler&#125; 进行自定义；</span></span><br><span class="line"><span class="comment"> * 默认实现： &#123;<span class="doctag">@link</span> SimpleUrlAuthenticationFailureHandler&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by 冰封承諾Andy on 2019/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationFailureHandler</span> <span class="keyword">extends</span> <span class="title">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义登陆成功后的行为，默认为跳转回原来的地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也可以选择实现 &#123;<span class="doctag">@link</span> AuthenticationSuccessHandler&#125; 的方式来定制;</span></span><br><span class="line"><span class="comment"> * 默认规则为 &#123;<span class="doctag">@link</span> SavedRequestAwareAuthenticationSuccessHandler&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Created by 冰封承諾Andy on 2019/7/22.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> SecurityProperties securityProperties;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> RequestCache requestCache = <span class="keyword">new</span> HttpSessionRequestCache();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      HttpServletResponse httpServletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    SavedRequest savedRequest = requestCache.getRequest(httpServletRequest, httpServletResponse);</span><br><span class="line">    String redirectUrl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (savedRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      redirectUrl = savedRequest.getRedirectUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当访问非 html 并且设置为 JSON 类型是返回 JSON 格式用户信息</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.endsWithIgnoreCase(redirectUrl, <span class="string">".html"</span>)</span><br><span class="line">        &amp;&amp; LoginResponseType.JSON.equals(securityProperties.getBrowser().getLoginType())) &#123;</span><br><span class="line">      httpServletResponse.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">      httpServletResponse.getWriter().write(objectMapper.writeValueAsString(authentication));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 跳转回原来的 URL</span></span><br><span class="line">      <span class="keyword">super</span>.onAuthenticationSuccess(httpServletRequest, httpServletResponse, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，Authentication 对象封装了认证相关的信息，包括我们自定义的 UserDetails 对象，密码相关的敏感信息如果返回到前端会自动进行过滤。</p><h3 id="基于表单的认证流程"><a href="#基于表单的认证流程" class="headerlink" title="基于表单的认证流程"></a>基于表单的认证流程</h3><p>表单方式应该是我们用的最多的，所以就来看看它的处理过程，照例上一张图：</p><p><img src="/image/表单认证原理.png" alt="表单认证原理"></p><p>当认证请求进入 UsernamePasswordAuthenticationFilter 这个过滤器后，它会从请求取出用户名和密码信息，封装到一个 UsernamePasswordAuthenticationToken（未认证状态） 中，接下来就到了 AuthenticationManager，它本身不包含认证的逻辑，但它会从一堆 AuthenticationProvider 中选出一个最合适的来进行认证（校验），至于挑选的过程主要是根据 Authentication 的类型进行匹配；<br>在这些 AuthenticationProvider 中，有一个 supports 方法，它会验证是否支持当前的 AuthenticationToken，如果支持，就进行后面的认证了（会调用我们 UserDetailsService 中的 loadUserByUsername 方法），不支持就跳过，进行下一次循环；<br>认证过程会通过 UserDetailsService 来获取用户信息（UserDetails），然后进行比较和校验，如果顺利，就会把 UsernamePasswordAuthenticationToken 做一个”已认证”的标记，然后将信息保存到 session，最后的一个步骤会调用我们设置的 Handler，失败的处理流程也是类似。</p><p>那么关于请求直接信息共享，还记得在过滤器链最前端有一个 SecurityContextPersistenceFilter，它的作用简单说就是当请求进来的时候检查 session 是否有 Authentication 信息，如果有就将它取出来放到一个 ThreadLocal 里；<br>当请求完成响应时，它检查 ThreadLocal 是否有认证信息，如果有就放到 session 中去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登陆的用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以通过 SecurityContextHolder.getContext().getAuthentication() 来进行获取</span></span><br><span class="line"><span class="comment"> * 有条件可以直接注入 Authentication 的方式来获取；</span></span><br><span class="line"><span class="comment"> * 或者使用 <span class="doctag">@AuthenticationPrincipal</span> 注解选择性的获取部分信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SecurityContextHolder 可以简单理解为一个 ThreadLocal，通过最前端的 &#123;<span class="doctag">@link</span> org.springframework.security.web.context.SecurityContextPersistenceFilter&#125; 过滤器，</span></span><br><span class="line"><span class="comment"> * 在每次请求到达时检查 session 是否有登陆信息，有则放到 SecurityContextHolder 中;</span></span><br><span class="line"><span class="comment"> * 在请求返回时，检查是否存在 SecurityContextHolder，如果存在则放到 session 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/me"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication,</span></span></span><br><span class="line"><span class="function"><span class="params">                             @AuthenticationPrincipal UserDetails user)</span> </span>&#123;</span><br><span class="line">  Authentication authentication1 = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">  <span class="comment">// 获取的就是 UserService 中的对象</span></span><br><span class="line">  <span class="comment">// User user =  (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span></span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体到代码，就是通过 SecurityContextHolder 这个类可以随时随地获取认证信息。</p><hr><p>当然，还可以加一些自定义的过滤器，例如来做验证码的校验，示例参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/validate/code/ValidateCodeFilter.java" target="_blank" rel="noopener">Github</a>，往过滤链中添加我们自己的过滤器最简单的方案就是直接在文章开始的配置类调用 http 的 addFilterBefore 方法。<br>现在流行的还有短信验证码，与普通的图形验证码最大的区别就是，使用短信验证码验证通过后是直接认证通过了，而不是单单一个验证码的校验，也可以说它其实是一种登陆方式。</p><h3 id="记住我功能"><a href="#记住我功能" class="headerlink" title="记住我功能"></a>记住我功能</h3><p>这个也是 Web 应用中常见的一个功能，也有不同的实现方式，在 Spring Security 中的方案是基于 Token 和数据库的，整理成流程图就是这样：</p><p><img src="/image/记住我原理.png" alt="记住我原理"></p><p>这个 RememberMeAuthenticationFilter 过滤器的位置处在靠后的位置，当前面的认证都无效时再进行“记住我”认证，表单中的 checkbox 控件固定名称是：<strong>remember-me</strong>。<br>主要的 Java 配置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 基于 JDBC 的 “记住我” 实现</span></span><br><span class="line">  JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">  jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">  <span class="comment">// 自动执行建表语句</span></span><br><span class="line">  <span class="comment">// jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http.</span><br><span class="line">    <span class="comment">// 记住我 配置</span></span><br><span class="line">    .rememberMe()</span><br><span class="line">    .tokenRepository(persistentTokenRepository())</span><br><span class="line">    .tokenValiditySeconds(securityProperties.getBrowser().getRememberMeSeconds())</span><br><span class="line">    <span class="comment">// 自定义密码处理</span></span><br><span class="line">    .userDetailsService(userDetailsService)</span><br><span class="line">    .and()</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是基于数据库，那么肯定会需要有一张表，你可以让他自己创建，或者进入到 JdbcTokenRepositoryImpl 的源码中，把里面定义的 SQL 手动执行一下。</p><h3 id="自定义认证方式"><a href="#自定义认证方式" class="headerlink" title="自定义认证方式"></a>自定义认证方式</h3><p>当了解完默认表单登陆的逻辑后，自定义其他登陆方式也就不那么难了，这里就以短信验证码登陆为例，用的也是蛮多的；首先是要明确的是，短信登陆与表单登陆是完全不同的一种方式，所以不可能在表单认证的 Filter 中搞，肯定是要自己搞一套，那么也就是需要一个拦截短信验证码的 Filter，以及一个进行校验的 Provider，然后校验通过把标识设置为 true 就好了，其他的跟表单方式基本一致。<br>那么接下来就稍微整理下需要重写的主要类：</p><ul><li>封装用户信息的 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationToken.java" target="_blank" rel="noopener">SmsCodeAuthenticationToken</a> 参考 UsernamePasswordAuthenticationToken，去掉了密码部分，因为短信登陆不需要。</li><li>拦截 SMS 请求的过滤器 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationFilter.java" target="_blank" rel="noopener">SmsCodeAuthenticationFilter</a>，它负责从请求取出相关信息封装 SmsCodeAuthenticationToken 等必要的对象。</li><li>具体的处理实现 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/authentication/mobile/SmsCodeAuthenticationProvider.java" target="_blank" rel="noopener">SmsCodeAuthenticationProvider</a>，还记得之前说过 AuthenticationManager 会调用它的 supports 方法来根据 Token 对象的类型匹配是不是用它做认证。</li><li>具体做验证的统一 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/validate/code/ValidateCodeFilter.java" target="_blank" rel="noopener">ValidateCodeFilter</a>，处在最前端，仅负责校验验证码。</li></ul><p>简单来说执行步骤是：SmsFilter –&gt; AuthenticationToken –&gt; AuthenticationManager –&gt; AuthenticationProvider –&gt; UserDetailsService –&gt; UserDetails –&gt; 获得 Authentication 已认证信息。<br>既然所需要的类都准备好了，下一步就是将他们配置到 Spring 的环境中，可以定义以下配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsCodeAuthenticationSecurityConfig</span> <span class="keyword">extends</span> <span class="title">SecurityConfigurerAdapter</span>&lt;<span class="title">DefaultSecurityFilterChain</span>, <span class="title">HttpSecurity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="meta">@Qualifier</span>(<span class="string">"myUserDetailsService"</span>)</span><br><span class="line">  <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 Filter 类似 ValidateCodeFilter，主类</span></span><br><span class="line">    SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = <span class="keyword">new</span> SmsCodeAuthenticationFilter();</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationManager(httpSecurity.getSharedObject(AuthenticationManager.class));</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(authenticationSuccessHandler);</span><br><span class="line">    smsCodeAuthenticationFilter.setAuthenticationFailureHandler(authenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">    SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = <span class="keyword">new</span> SmsCodeAuthenticationProvider();</span><br><span class="line">    smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加配置，加入到认证之后</span></span><br><span class="line">    httpSecurity.authenticationProvider(smsCodeAuthenticationProvider)</span><br><span class="line">      .addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以在文章最开始的那个配置类中，调用 <code>http.apply()</code> 方法让其生效即可。<br>至此，我们再重新梳理一下流程，首先请求进入 ValidateCodeFilter 进行校验验证码（当然它也可以同时负责校验图形验证码），通过之后就继续过滤链，被 SmsCodeAuthenticationFilter 匹配捕获，然后封装 Token 信息，后面就是 Provider 拿着这些信息去 UserDetailsService 将用户信息获取出来，然后置为“已认证”状态了。</p><h2 id="OAuth协议"><a href="#OAuth协议" class="headerlink" title="OAuth协议"></a>OAuth协议</h2><p>这里简单回顾一下 OAuth 协议，之前我就写过，<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AD%98%E6%A1%A3/OAuth.md" target="_blank" rel="noopener">连接在这里</a>，虽然写的也是很简单就是了，这里再重新温习一下，OAuth 协议主要包含角色：</p><ul><li>服务提供商（Provider）<ul><li>认证服务器（Authorization Server）</li><li>资源服务器（Resource Server）</li></ul></li><li>资源所有者（Resource Owner）</li><li>客户端（Client）</li></ul><p>接下来说说运作的基本流程：<br>资源所有者（也就是用户）去访问某个应用的服务（暂且称为客户端吧），然后需要获取其他应用（服务提供商）中的此用户数据，所以客户端会向用户请求授权，用户同意后，服务提供商会发放一个有有效期的令牌给客户端（用户同意操作在服务提供商完成）； 之后客户端可以拿着这个令牌去资源服务器获取资源，资源服务器会验证这个令牌的合法性，通过即可返回需要的资源。<br>具体例子的话，可以想象任何网站的微信、微博登录功能，其中客户端指的就是你访问的那个网站，服务提供商就是微信或者微博，点击后是不是需要跳转到微信扫码或者微博授权页的那个地址呢。</p><p>其中，最重要的就是用户同意这个步骤了，至于同意后如何获取令牌，一般我们采用的也就是<strong>授权码模式</strong>（Authorization Code）和<strong>客户端模式</strong>（Client Credentials），其中授权码模式最为广泛（更加安全，因为不用将密码暴露给第三方）。</p><p>授权码模式的流程（其实跟上面那个基本是一致的，上面就是以授权码模式为例的）：<br>需要授权时，客户端会将用户导向服务提供商的认证服务器，用户需要<strong>在认证服务器上完成同意授权</strong>，然后认证服务器会返回一个授权码，一般是将这个授权码返回到客户端的后台，然后客户端的后台根据这个授权码再去认证服务器换取令牌； 这样令牌就拿到了，整个过程需要两步，认证服务器也能通过导向的连接携带的参数来确定是那个客户端需要授权； 这样不直接返回令牌而是授权码大大加强来应用间的安全性。</p><h2 id="SpringSocial"><a href="#SpringSocial" class="headerlink" title="SpringSocial"></a>SpringSocial</h2><blockquote><p>因为 social 项目调整，目前被标记为 <strong>in the Attic</strong>，在 Spring2.x 版本中，将相关源码进行了去除，如果使用到了相关到类，只能手动补全.<br>参见：<a href="https://www.jianshu.com/p/e6de152a0b4e" target="_blank" rel="noopener">https://www.jianshu.com/p/e6de152a0b4e</a></p></blockquote><p>基本原理： social 封装了绝大部分的 OAuth 协议步骤，会在过滤器链加入 Social 自己的过滤器，通过这个过滤器来简化我们的 OAuth 流程，其中根据令牌获取用户信息的实现各不相同只能由用户来提供，其中涉及的 URL 以及必要的参数也要由用户提供；，基本的组成部分可以概括为：</p><ul><li>ServiceProvider：服务提供商的一个抽象<br>必须继承 AbstractOAuth2ApiBinding 类； 它包含 OAuth2Template 这个默认实现和 Api（AbstractOAuth2ApiBinding）<br>因为每一个服务提供商定义的接口或者数据对象都可能不同，所以针对每一个服务提供商都应该提供一个抽象与之对应，这个当然就需要用户自己实现。<br>示例：<a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/qq/api/QQImpl.java" target="_blank" rel="noopener">QQImpl</a>、<a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/qq/connect/QQServiceProvider.java" target="_blank" rel="noopener">QQServiceProvider</a></li><li>ConnectionFactory<br>提供的默认实现包含 ServiceProvider 和 ApiAdapter（负责将服务提供商个性化的格式转换为 social 通用的格式）</li><li>Connection</li><li>UsersConnectionRepository<br>最常用的就是 JDBC 的实现了，需要自己加入到 Spring 容器中，作用就是对数据库中 UsersConnection 表的 CRUD 操作 。</li></ul><p>最终的目的就是获得某用户的 Connection，然后联合数据库来获取相关的信息； 想要得到 Connection 就需要 ConnectionFactory，而创建工厂需要 ServiceProvider 和 ApiAdapter； 其中有一些是 social 给我们提供了的，剩下的就需要我们自己实现了。</p><p>说到入口，因为 Social 是通过一个 SocialAuthenticationFilter 过滤器来进行操作的，在这个过滤器中默认拦截的是 <code>/auth/{providerId}</code> 请求，用户同意授权后也会再跳转回这个地址，不过是带着授权码 code 回来的，而这个过滤器就是通过是否携带授权码来区分是哪一个步骤的；<br>当检测到是有 code 的时候，就会去自动的触发换取 token 的机制，如果失败默认的失败路径是 <code>/signin</code>，如果成功解析，它就会拿着获取到的 id 去数据库查相关信息，如果没有查到就跳转到 <code>/signup</code> 默认的注册请求，国内很多网站这里会让你绑定一个手机号（注册逻辑）或者绑定已有账号，但是你也可以让其自动注册然后自动登录（UsersConnectionRepository 会判断 ConnectionSignUp 是否为空，如果不为空会调用这个接口来获取一个 id，从而避免跳转），当然这些配置我们可以配，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/SocialConfig.java" target="_blank" rel="noopener">SocialConfig</a>。<br>并且我们通过配置 ProviderSignInUtils 工具类，可以在自定义的注册或者绑定逻辑里拿到 Social 获取到的第三方用户信息，因为在跳转之前 SocialAuthenticationFilter 会将信息保存到 session 中，这个工具也已经封装了注册（绑定）的方法。<br>简略流程可以参考：</p><p><img src="/image/social流程.png" alt="social流程"></p><p>本质与 SpringSecurity 没啥区别，都是获取用户信息，校验，最后置为“已认证”状态放到 Context 中，区别的就是获取用户信息与校验的不同。（蓝色的是 Social 提供的，橘色的是我们自己实现的）</p><h3 id="绑定与解绑"><a href="#绑定与解绑" class="headerlink" title="绑定与解绑"></a>绑定与解绑</h3><p>首先，要获取到当前用户的绑定情况，然后再判断是否进行绑定或者解绑；<br>它默认提供了一个 地址，用来获取登陆用户的绑定信息，最终会跳转到一个叫 <code>connect/status</code> 的视图，一般情况都是会自定义这个视图的，拼装后返回符合我们期望的数据结构，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/view/CustomizeConnectionStatusView.java" target="_blank" rel="noopener">CustomizeConnectionStatusView</a></p><p>绑定与解绑 Social 也基本都替我们写好了，只需要在登陆状态下 POST 方式访问 <code>/connect/{providerId}</code> 就可以了，对应的它最后也会跳转到一个 <code>/connect/{providerId}Connected</code> 的视图，这个还是要自定义的，参考 <a href="https://github.com/LoliconSky/SecurityExample/blob/master/security-core/src/main/java/com/bfchengnuo/security/core/social/view/CustomizeConnectView.java" target="_blank" rel="noopener">CustomizeConnectView</a>。<br>解绑与绑定一致，只是请求方式换成了 DELETE，返回的视图名是 <code>/connect/{providerId}Connect</code></p><p>PS：集成 Social 后，UserDetailsService 记得实现 SocialUserDetailsService 接口，然后返回一个 SocialUserDetails，这个里面才有 id 关于 OAuth 的那些信息。</p><h2 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h2><p>无论你用哪一种方式登陆，最终登陆成功后的用户信息默认是存在服务器的 session 中的，紧接着就会有超时或者说过期的问题，在集群环境下单机 session 更是一个问题。<br>通常，在 SB  的配置文件中，可以设置超时时间，最低为 1 分钟，在 SecurityConfig 配置类中也可以进行一定的配置，比如失效后的跳转逻辑、在线数量、并发逻辑等。</p><p>要解决集群 session 的问题，只要把 session 不放在单独的服务器就行了，例如可以统一放在 Redis，SpringSession 可以简化这套流程的开发，只需要在配置文件中配置 <code>spring.session.store-type</code> 就可以了，基本上是透明的，非侵入，并且配置的 session 管理项也都是有效的。<br>因为 session 读取会非常频繁，还具有时效性，所以放在 Redis 里是比较合适的。</p><h2 id="SpringSecurityOAuth"><a href="#SpringSecurityOAuth" class="headerlink" title="SpringSecurityOAuth"></a>SpringSecurityOAuth</h2><p>对于浏览器这种客户端，使用 Cookie-Session 的机制还算是方便，但是对于 App 这一类的客户端，再使用 Cookie-Session 的这种机制做认证就显得十分麻烦，难道每次都要手动保存和添加 cookie 到请求头？当然还有很多一些其他因素，这促使我们使用一种简单方便并且安全的机制来做认证，解决 HTTP 无状态的问题，然后 OAuth 就来了，简单说就是使用令牌来做认证。</p><p><img src="/image/SpringSecurityOAuth.png" alt="SpringSecurityOAuth"></p><p>OAuth 协议应该有所了解了，SpringSecurityOAuth 相当于简化了我们作为服务提供商的功能开发，服务提供商一般由认证服务器和资源服务器组成，这个前面说过，其中认证服务器最常见的是那四种授权模式，这个 Spring 已经帮我们实现了。</p><p>而资源服务器的角色，就是保护我们的资源（接口），他们两个物理上可以是一台机器，资源服务器简单说就是通过一个 Filter 来进行令牌的校验，跟前面所说的 SpringSecurity 原理差不多。</p><p>当然，自带的四种授权模式未必能满足我们，例如手机验证码登陆的需求，我们可以进行自定义授权模式，包括存储逻辑与令牌的生成也可以进行个性化。</p><h3 id="认证服务器"><a href="#认证服务器" class="headerlink" title="认证服务器"></a>认证服务器</h3><p>在 SpringSecurityOAuth 的加持下，实现一个认证服务器非常简单，只需要在 Java 配置类上增加一个 <code>@EnableAuthorizationServer</code> 注解即可。<br>加入这个注解后，Spring 就会把四种基本的授权模式与 Token 的存储逻辑（默认内存存储）进行自动装配，直接就可以用了，下面以最常用的授权码模式与密码模式来简单说明。</p><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式的流程不在多说，上面已经讲过了，默认情况下开启注解会发现有这样两个地址映射：</p><ul><li><code>/oauth/authorize</code><br>这一个就是默认提供的让用户确认授权的页面，类似你用第三方登录跳到的那个页面，让用户选择哪个账户、什么权限。<br>访问这个地址是需要一些参数的，在 OAuth2 协议的官方文档有明确规定。<br>PS：要想使用此功能，你系统的用户要有 <code>ROLE_USER</code> 权限，记得在你的 UserDetailsService 中进行配置。</li><li><code>/oauth/token</code><br>这个就是用来换取 accessToken 的接口，如果使用授权码模式，就是用上一步得到的 code 来换取 accessToken。<br>发送 POST 请求的时候记得要带你申请的 appid 之类的信息，一般通过请求头带 authorization 类型为 Base 的方式编码。</li></ul><p>拿到 accessToken 之后就可以去资源服务器获取信息了，只需要在头带上 authorization，这里类型默认用 bearer，值就是 accessToken。<br>它适合给第三方应用做授权，能避免第三方应用接触到我们应用用户的账号密码的风险。</p><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式比授权码模式要更简单，省去了获取 code 的步骤，这种方式用在同一家应用之间是没问题的，就算授权过程需要提供账户密码，但是因为都是自家的应用，还好，就相当于使用账号密码登录了。<br>过程也没啥说的，参考授权码模式的第二步，仅仅是参数的变化，参数在 OAuth2 规范有明确定义。</p><h4 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h4><p>无论使用哪种方式授权，最终获得的 accessToken 是一样的，Spring 会判断这个用户的 accessToken 是否过期，如果没过期，无论用哪种方式授权，得到的 accessToken 都是一致的。<br>当然，服务器除了返回 accessToken 过期时间等必要信息，还会有一个刷新的 token，使用这个可以进行刷新 accessToken，使 accessToken 到期时用户可以无感知的“续期”令牌。</p><h3 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>资源服务器也是类似，一个 <code>@EnableResourceServer</code> 注解即可搞定，并且可以与认证服务器的注解写在一起，毕竟他们不需要物理上隔离，只是逻辑上的概念。<br>按照前面所说，它其实是加了一个 Filter，坚持请求头的 authorization 的 bearer 是否合法。<br>认证过程就区别于传统的 Session 方式了，更加自由一些。</p><h3 id="流程解读"><a href="#流程解读" class="headerlink" title="流程解读"></a>流程解读</h3><p>大体的流程可以参考下面这张图：</p><p><img src="/image/SpringSecurityOAuth原理.png" alt="SpringSecurityOAuth原理"></p><p>其中绿色为类，蓝色为接口（括号里为默认实现）。</p><ul><li><strong>ClientDetailsService</strong><br>用来根据你传递的 client-id 信息读取客户端信息，内容会封装在 ClientDetails 实体。</li><li><strong>TokenRequest</strong><br>它封装了第三方应用请求信息，就是 OAuth 协议中规定的那些请求参数都在这里面。<br>同时，Spring 会把 ClientDetails 放进来。</li><li><strong>TokenGranter</strong><br>它背后就是那四种标准的授权模式实现了（外加一种刷新令牌的实现），它会根据 TokenRequest 中的类型来选一个具体实现，然后执行授权。<br>不管是哪一种授权，最后都会生成一个 OAuth2Request （TokenRequest 和 ClientDetails 的整合体）和 Authentication（包含授权用户的一些信息，那个用户在做授权，由 UserDetailsService 获得），他们两个最后会合并到 OAuth2Authentication 中去。</li><li><strong>AuthorizationServerTokenServices</strong><br>这就是具体生成令牌的接口了，它根据 OAuth2Authentication 的信息就可以生成、存储令牌，并且允许通过 Enhancer 对令牌进行改造。</li></ul><p>在授权码的方式中，权限是由用户最终决定的，你想获取用户的全部信息，用户未必会全部给你，当然需要支持用户勾选的情况下，所以在 TokenEndpoint 过程中，如果是授权码模式的第一阶段会把 Scope 置空，由第二步的用户来进行填充。<br>创建令牌的过程中，会先检查当前用户是否已经创建过令牌、令牌是否过期、是否有刷新令牌，都没有后才会执行创建逻辑，创建的最后一步会判断你是否定义了增强类，如果有就按照你的逻辑来对令牌进行自定义。</p><h3 id="自定义登陆"><a href="#自定义登陆" class="headerlink" title="自定义登陆"></a>自定义登陆</h3><p>自带的标准的四种方式并不一定会满足我们的业务需求，就像之前的短信验证码登陆，这里同样也需要自己实现。<br>根据流程图可以知道，只需要调用 AuthorizationServerTokenServices 就可以产生令牌了，而构建它需要 OAuth2Authentication 对象，也就是 OAuth2Request 和 Authentication。<br>然后在 SpringSecurity 中我们知道有个 handle 处理逻辑，只需要在成功的 handle 中调用一下这个 service 就可以了，并且 Authentication 对象是直接有现成的，那就只剩下 OAuth2Request 对象，而它可以从请求中提取数据拼装。<br>示例可参考 MyAuthenticationSuccessHandler，经过它改造后，使用普通的表单登陆地址，只需要填入用户名和密码就可以拿到 assessToken 了。</p><p>对于 App 短信登陆，要解决的就是去 session 后验证码的校验，App 肯定不会携带 cookie 这一类用来标识，也就是服务器端不可能存在传统的 session 中进行验证；可以将验证码存在 Redis，以一个机器 id 作为 key 或者手机号作为 key，用户登陆的时候需要在请求头或者请求参数携带这个标识，用于校验，这也就要重写 SMS 验证码的校验逻辑。</p><p>对于 App 中的第三方登录，一般都是有专门的 SDK，最终用户同意后会拿到一个 openid ，而我们的系统需要提供一个接口，使用 openid 来换取 AssessToken，这样就算是登录了。<br>当然也不一定第三方应用会给 openid，也可能会给一个授权码，需要服务器后台拿着授权码去换 token，这样的情况也需要单独处理，即在 App 的后端，要通过后处理器来处理授权码模式的请求，跟成功的 handle 一样，最后返回个 assessToken 就好了。</p><h3 id="使用JWT"><a href="#使用JWT" class="headerlink" title="使用JWT"></a>使用JWT</h3><p>首先简单说一下 JWT 的特点：</p><ul><li>自包含</li><li>密签（签名，并不是加密）</li><li>可扩展</li></ul><p>因为这些特点，它肯定也是比默认的 UUID 长不少，携带的信息越多自然就越长，我的话还是习惯用简洁一点的 UUID，虽然它并不能代表什么信息。<br>要想使用 JWT，比较好的一种方案就是通过 TokenStore 将它默认的 UUID 进行转换和存储，示例参考 TokenStoreConfig 这个类。</p><p>SpringSecurity 默认是支持 SSO 的，不过这部分我没去细细研究，客户端只需要使用 @EnableOAuth2Sso 注解和一点配置就可以了，自动授权的相关类见 WhitelabelApprovalEndpoint，具体的示例参考见：<a href="https://github.com/jojozhai/security" target="_blank" rel="noopener">https://github.com/jojozhai/security</a></p><h2 id="SpringSecurity授权"><a href="#SpringSecurity授权" class="headerlink" title="SpringSecurity授权"></a>SpringSecurity授权</h2><p>简单说，就是控制你能干什么，不能干什么；在 SpringSecurity 中最简单的一种配置就是之前继承的 AbstractChannelSecurityConfig 类中的那个 http 对象，继续往下写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  http.authorizeRequests()</span><br><span class="line">    .antMatchers(HttpMethod.POST, <span class="string">"/user/*"</span>)</span><br><span class="line">    .hasRole(<span class="string">"Admin"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就需要你在 UserDetailsService 中赋予 “ROLE<em>Admin” 权限后才能访问此 URL，记得加 `ROLE</em>` 前缀。</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>这里还是简单看一下它的执行过程，相信这张图还是很有印象的：</p><p><img src="/image/SE授权.png" alt="SE授权"></p><p>这次的焦点是在 AnonymousAuthenticationFilter，处于那一堆身份认证的最后一个，它的作用也很简单，当检测到到达这个过滤器时 Authentication 还是空的话，也就是前面那些都没有匹配到，就会创建一个 AnonymousAuthenticationToken，也就是代表匿名用户了（放进去的用户信息为 anonymousUser - ROLE_ANONYMOUS）。<br>最终，由 FilterSecurityInterceptor （是个过滤器）来判断用户是否有足够的权限请求的资源，具体的执行逻辑会委托给 AccessDecisionManager，它有一个抽象实现 AbstractAccessDecisionManager 和几个具体实现：</p><ul><li>AffirmativeBased（默认），只要一个否定就否定</li><li>ConsensusBased，少数服从多数</li><li>UnanimousBased，只要有一个成功，即算作成功</li></ul><p>简单说，它就是来统计投票的，具体投票是一堆 AccessDecisionVoter 对象（现在主要有 WebExpressionVoter 承担了，因为 3 之后的版本有了 Spring 表达式），根据选票与选择的 AccessDecisionManager，最终决定是否放行。<br>如果投票不通过就会抛出一个异常，被前面的过滤器捕获，然后进行相应的处理。</p><h3 id="权限表达式"><a href="#权限表达式" class="headerlink" title="权限表达式"></a>权限表达式</h3><p>最终由 AccessDecisionVoter 评估的就是权限表达式，到达 AccessDecisionVoter 之前 Spring 会将权限信息转换成权限表达式的类型，之前在代码中写的 <code>permitAll()</code> 就是一个权限表达式，相信列表请参考<a href="http://www.mossle.com/docs/springsecurity3/html/el-access.html" target="_blank" rel="noopener">这里</a>，当然也可以使用多个，但是就需要手动写表达式了，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.access(<span class="string">"hasRole('admin') and hasIpAddress('192.168.1.0/24')"</span>);</span><br></pre></td></tr></table></figure><p>当然也能使用自己写的方法来进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">config</span><span class="params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;</span><br><span class="line">  config</span><br><span class="line">    .antMatchers(HttpMethod.GET, <span class="string">"/fonts/**"</span>).permitAll()</span><br><span class="line">    .antMatchers(HttpMethod.GET, </span><br><span class="line">                 <span class="string">"/**/*.html"</span>,</span><br><span class="line">                 <span class="string">"/resource"</span>).authenticated()</span><br><span class="line">    .anyRequest()</span><br><span class="line">    .access(<span class="string">"@rbacService.hasPermission(request, authentication)"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>其中 rbacService 指的是 Bean 的名字，hasPermission 是验证方法，返回一个布尔，后面跟上参数就 OK 了。</p><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>这些权限的对应简单的话还好，如果非常复杂使用硬编码的方式就很蛋疼了，那肯定支持从数据库读取，建表就采用一般的 RBAC 基于角色的控制就行了，具体就是用户表、角色表、资源表、用户角色关系表、角色资源关系表。<br>然后自定义你的 UserDetailsService 和 UserDetails 从数据库读取，加入该用户对应的权限信息，然后通过上面的自定义验证方法来进行校验。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT（JSON Web Token）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇笔记其实很早就开始写了，毕竟 SpringSecurity 现在用的非常多，而我还是半吊子水平，不过因为时间和心情问题，断断续续搞了这么久，跨度得三个月左右了，相应的这篇笔记也非常长，我就不再分篇了直接一次性怼上，基本的原理与知识点应该是覆盖全了，除了基础的 SpringSecurity 知识点，另有对 OAuth2 对支持，使用 Social 对第三方社交登陆的支持，Session 处理相关，SSO 相关的提了一下，看完之后不是问题。
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="安全" scheme="https://sakanoy.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://sakanoy.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript常用语法整理</title>
    <link href="https://sakanoy.com/2019/09/14/ECMAScript%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://sakanoy.com/2019/09/14/ECMAScript常用语法整理/</id>
    <published>2019-09-14T00:33:03.000Z</published>
    <updated>2024-11-14T17:46:09.401Z</updated>
    
    <content type="html"><![CDATA[<p>首先集百家之介绍：</p><blockquote><p>ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。</p><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p></blockquote><p>目前 ES 已经到达了 ES2018 版本，Google 的 V8 引擎支持率 100%，其他的并不友好，而我们常用 <strong>JavaScript</strong> 稳定版本的实现目前在 ES2016 版本，所以这里主要学习 ES6 的特性了。<a id="more"></a><br>如果真的有什么原因不能使用 ES6 可以使用 Babel 将 ES6 语法转为 ES5.<br>我会把实际中频繁用到的一些特性写出来，致力于用最优雅的写法写出更高质量的代码。</p><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><p>使用 <code>let</code> 声明的变量只在它所在的代码块内有效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6，使用 var 则都是 10</span></span><br></pre></td></tr></table></figure><p>例如 for 循环就合适使用 let 定义 i</p><blockquote><p><code>for</code> 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p></blockquote><p><code>var</code> 命令会发生“<strong>变量提升</strong>”现象，<strong>即变量可以在声明之前使用</strong>，值为 <code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，<code>let</code> 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><blockquote><p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p></blockquote><p>总之，在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ），不过应该提倡能用 let 的时候尽量别用 var，避免造成作用域的混乱。</p><hr><p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>这意味着，<code>const</code> 一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效，不提升、存在暂时性死区。</p><blockquote><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 ES6 中，对字符串进行了增强，尤其是模板字符串，真是非常的好用！</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义<strong>多行字符串</strong>，或者在字符串中<strong>嵌入变量</strong>或者调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串之中还能调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果模板字符串中的变量没有声明，将报错。如果大括号中的值不是字符串，将按照一般的规则（toString）转为字符串。</p><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>ES5 字符串的实例方法很有限，基本就是 indexOf 了，在 ES6 新加入了一些：</p><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li><li>repeat()：返回一个新字符串，表示将原字符串重复 n 次。</li></ul><p>在 ES2017 和 ES2019 又引入了 <code>padStart()</code> 用于头部补全，<code>padEnd()</code> 用于尾部补全和 <code>trimStart()</code> 和 <code>trimEnd()</code> 这两个方法。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与解构赋值默认值结合使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有提供参数，函数 foo 的参数默认为一个空对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>ES6 引入 rest 参数（形式为 <code>...变量名</code>），用于获取函数的多余参数，本质是个数组，跟 Java 很类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>其次还有函数的 <code>name</code> 属性，返回该函数的函数名。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>怎么说呢，这个其实就是简化的匿名函数，用在回调的地方非常好用。箭头函数有几个使用注意点。</p><ol><li>函数体内的 <code>this</code> 对象，就是<strong>定义时所在的对象</strong>，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li><li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。</li></ol><p>其中第一点尤其值得注意。<code>this</code> 对象的指向是可变的，<strong>但是在箭头函数中，它是固定的</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>关于 this 的这个问题，版本对比为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用情况</span></span><br><span class="line"><span class="comment">// 对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。<br>在 Vue 很多使用中，如果你使用箭头函数就不需要再在尾部来一个 <code>.bind(this)</code> 了。</p><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>使用 <code>JSON.stringify()</code> 方法可以将对象转为字符串类型的 json 格式。</p><hr><p>关于 apply 和 call ，ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。<br>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<br>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。<br>一般来说，<strong>它们的作用就是改变 this 的指向，或者借用别等对象的方法</strong>，那么它和 bind 什么区别呢？</p><blockquote><p>在 EcmaScript5 中扩展了叫 <code>bind</code> 的方法，在低版本的 IE 中不兼容。<br>它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。</p></blockquote><p>他们的主要区别就是：</p><p>bind 方法不会立即执行，而是<strong>返回一个改变了上下文 this 后的函数</strong>。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。<br>在参数传递上，也有一些区别，看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = func.bind(<span class="literal">null</span>,<span class="string">'linxin'</span>);</span><br><span class="line"></span><br><span class="line">func(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);            <span class="comment">// A B C</span></span><br><span class="line">func1(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);           <span class="comment">// linxin A B</span></span><br><span class="line">func1(<span class="string">'B'</span>, <span class="string">'C'</span>);                <span class="comment">// linxin B C</span></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="string">'linxin'</span>);      <span class="comment">// linxin undefined undefined</span></span><br></pre></td></tr></table></figure><p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是<strong>在 bind 中参数的基础上再往后排</strong>。</p><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>对于数组的克隆与合并，有了扩展运算符也变得简单多了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure><p>ES5 中只能使用 concat 函数间接达到目的。<br>字符串也可以被展开：<code>[...&#39;hello&#39;]</code>，还可以用于 Generator 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>现在对象的属性有了更简洁的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说就是<strong>当 key 和 val 一样时，可以进行简写</strong>。其实，方法也可以进行简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法会非常的简洁，另外常用的还有 setter 和 getter，就是采用的这种方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点就是简洁写法的属性名总是字符串。在对象定义上，也变得更加灵活了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的<strong>原型对象</strong>。</p><hr><p>另外，对象也有扩展运算符，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ll = &#123;<span class="attr">name</span>:<span class="string">'loli'</span>, <span class="attr">age</span>: <span class="number">12</span>, getVal(val)&#123;<span class="built_in">console</span>.log(val)&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> test = &#123;...User, <span class="attr">dd</span>:<span class="string">'dd'</span>&#125;</span><br><span class="line">test.getVal(test.dd)</span><br></pre></td></tr></table></figure><p>简单说就是把对象里的方法进行拷贝，Vuex 中的这种写法算是明白了吧，Vuex 中，我们经常用类似 <code>...mapState({xxx})</code> 的写法，很显然 mapState 函数返回的是一个对象，然后我们使用“展开运算符”将其展开了。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>变量数组或者对象，可以使用 forEach 这个函数（ES5 中也可使用）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(alert);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(item)&#125;)</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><blockquote><p>使用 forEach 函数进行遍历时，中途无法跳过或者退出；<br>在 forEach 中的 return、break、continue 是无效的。</p><p>see：<a href="https://www.jianshu.com/p/bdf77ee23089" target="_blank" rel="noopener">https://www.jianshu.com/p/bdf77ee23089</a></p></blockquote><p>然后遍历除了基本的 fori，还有两种：<code>for...in</code> 和 <code>for...of</code> ，那么他们俩有啥区别呢？</p><ol><li>推荐在循环对象属性的时候，使用 <code>for...in</code>，在遍历数组的时候的时候使用 <code>for...of</code>。</li><li><code>for...in</code> 循环出的是 key，<code>for...of</code> 循环出的是 value</li><li>注意，<code>for...of</code> 是 ES6 新引入的特性。修复了 ES5 引入的 <code>for...in</code> 的不足</li><li><code>for...of</code> <strong>不能循环普通的对象</strong>，需要通过和 <code>Object.keys()</code> 搭配使用</li></ol><p>下面是一段示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArray = [<span class="string">'a'</span>,<span class="number">123</span>,&#123;<span class="attr">a</span>:<span class="string">'1'</span>,<span class="attr">b</span>:<span class="string">'2'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;aArray[index]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// &#123;a: "1", b: "2"&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 for...of 遍历 Map，它部署了 Iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>作用于数组的 <code>for-in</code> 循环除了遍历数组元素以外，还会遍历自定义属性。<br><code>for...of</code> 循环不会循环对象的 key，只会循环出数组的 value，因此 <code>for...of</code> 不能循环遍历<strong>普通对象</strong>，对普通对象的属性遍历推荐使用 <code>for...in</code></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>某次，遇到一个做累加的需求，用传统的方式肯定是没问题，但是我想到既然是动态语言，就没有什么骚操作？<br>结果搜了一下，确实有很多骚操作，还有直接用 eval 黑魔法的，不过，我觉得比较优雅的就是 reduce 方法了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>总感觉似曾相识，不知道在哪里用过，也许是 J8 的 Lambda 吧，这样看来 reduce 可以做的东西就多了。</p><h2 id="forEach与map"><a href="#forEach与map" class="headerlink" title="forEach与map"></a>forEach与map</h2><p>MDN 上的描述：</p><blockquote><p><code>forEach()</code>：针对每一个元素执行提供的函数 (executes a provided function once for each array element)。</p><p><code>map()</code>：<strong>创建一个新的数组</strong>，其中每一个元素由调用数组中的每一个元素执行提供的函数得来 (creates a new array with the results of calling a provided function on every element in the calling array)。</p></blockquote><p><code>forEach</code> 方法不会返回执行结果，而是 <code>undefined</code>。也就是说，<code>forEach()</code> 会修改原来的数组。而 <code>map()</code> 方法会得到一个新的数组并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组中的数据翻倍</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (arr[index] = num * <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubled = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果都为： [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>如果你习惯使用函数是编程，那么肯定喜欢使用 <code>map()</code>。因为 <code>forEach()</code> 会改变原始的数组的值，而 <code>map()</code> 会返回一个全新的数组，原本的数组不受到影响。<br>总之，能用<code>forEach()</code>做到的，<code>map()</code>同样可以。反过来也是如此。<br>一般来说，使用 map 速度会更快，测试地址：<a href="https://jsperf.com/map-vs-foreach-speed-test" target="_blank" rel="noopener">https://jsperf.com/map-vs-foreach-speed-test</a></p><h2 id="Class语法"><a href="#Class语法" class="headerlink" title="Class语法"></a>Class语法</h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。<br>基本上，ES6 的 <code>class</code> 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>class</code> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于做静态语言后端的我，果然还是 ES6 的写法更舒服。</p><blockquote><p>定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p></blockquote><p>既然说 class 只是一个语法糖，那么我们就要深入一点看看了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************分割线********************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure><p>类的数据类型就是函数，类本身就指向构造函数。<br>构造函数的 <code>prototype</code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面。<br>类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致。<br>生成实例对象如果忘记加上 <code>new</code>，像函数那样调用 <code>Class</code>，将会报错。<br>类不存在变量提升（hoist），也就是没办法先使用后定义。<br>此外还有很多需要注意的点，不过我认为我知道这一部分就足够了，了解更多就去看阮一峰的书吧。</p><h2 id="Promise函数"><a href="#Promise函数" class="headerlink" title="Promise函数"></a>Promise函数</h2><p>在 JavaScript 的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致 JavaScript 的所有网络操作，浏览器事件，都必须是异步执行，也就是要通过异步来处理。<br>Promise 有各种开源实现，在 ES6 中被统一规范，由浏览器直接支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (timeOut &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      log(<span class="string">'call resolve()...'</span>);</span><br><span class="line">      resolve(<span class="string">'200 OK'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log(<span class="string">'call reject()...'</span>);</span><br><span class="line">      reject(<span class="string">'timeout in '</span> + timeOut + <span class="string">' seconds.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, timeOut * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(test).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'成功：'</span> + result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'失败：'</span> + reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下所有的 job 与 p 开头的都是 Promise 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套顺序调用</span></span><br><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br><span class="line"><span class="comment">// job1.then([return Promise]).then(...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: ['P1', 'P2']</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意一个成功即可继续：</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// 'P1'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就我来说，它最重要的功能是来解决回调地狱问题，解决异步中回调的多层嵌套。<br>还有一个，就是异步剥夺了 return 的权利，你用异步，return 基本就没啥意义，只能通过传入方法来执行，也是相当于回调了。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>异步操作是 JavaScript 编程的麻烦事，麻烦到一直有人提出各种各样的方案，试图解决这个问题。从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底，<strong>异步编程的最高境界，就是根本不用关心它是不是异步。</strong><br><strong>一句话，async 函数就是 Generator 函数的语法糖。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>async 自带执行器，相比 Generator 也有更好的寓意，<strong>async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</strong><br>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中。<br>await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p><h2 id="Module语法"><a href="#Module语法" class="headerlink" title="Module语法"></a>Module语法</h2><blockquote><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p></blockquote><p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<strong>编译时就能确定模块的依赖关系</strong>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载 <code>fs</code> 模块（即加载 <code>fs</code> 的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。<br>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="comment">// 仅加载三个方法（函数）</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。<br>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><strong>一个模块就是一个独立的文件</strong>。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。<br>下面展示一下几种 export 的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种（推荐）</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, year &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数或者类或者对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出函数自定义名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系，所以你不能直接输出一个值，例如数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p><code>export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数名</span></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br><span class="line">a.foo = <span class="string">'hello'</span>; <span class="comment">// 合法操作（非常不建议）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="comment">// 通过 别名.函数名 调用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code> 命令输入的变量都是只读的，因为它的本质是输入接口。<br>注意，<code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行，同时 <code>.js</code> 后缀可以省略。<br>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>为了给用户提供方便，让他们不用阅读文档就能加载模块（不需要知道名字），就要用到 <code>export default</code> 命令，为模块指定默认输出。<br>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认与非默认方法</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>这时 <code>import</code> 命令后面，不使用大括号。显然，一个模块只能有一个默认输出，因此 <code>export default</code> 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 <code>export default</code>命令。<br>本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字。正是如此所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>静态化固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。<br>如果 <code>import</code> 命令要取代 Node 的 <code>require</code> 方法，这就形成了一个障碍。<strong>因为 <code>require</code> 是运行时加载模块，<code>import</code> 命令无法取代 <code>require</code> 的动态加载功能</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure><p>因此，有一个<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">提案</a>，建议引入 <code>import()</code> 函数，完成动态加载，对于这个import  函数，我就不多进行了解了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于 a 标签默认行为（href 跳转）：<br>常见的阻止默认行为的方式：<code>&lt;a href=&quot;javascript:void(0);&quot;  onclick= &quot;myjs( )&quot;&gt;  Click Me  &lt;/a&gt;</code><br><strong>函数 onclick 要优于 href 执行</strong>，而 void 是一个操作符，<code>void(0)</code> 返回 undefined，地址不发生跳转，使用 <code>javascript:;</code> 也是一样的效果。<br>在 onclick 函数中，如果返回的是 true，则认为该链接发生了点击行为；如果返回为 false，则认为未被点击。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先集百家之介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。&lt;/p&gt;
&lt;p&gt;ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 ES 已经到达了 ES2018 版本，Google 的 V8 引擎支持率 100%，其他的并不友好，而我们常用 &lt;strong&gt;JavaScript&lt;/strong&gt; 稳定版本的实现目前在 ES2016 版本，所以这里主要学习 ES6 的特性了。
    
    </summary>
    
      <category term="Web" scheme="https://sakanoy.com/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="https://sakanoy.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue核心使用总结</title>
    <link href="https://sakanoy.com/2019/06/02/Vue%E6%A0%B8%E5%BF%83%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sakanoy.com/2019/06/02/Vue核心使用总结/</id>
    <published>2019-06-02T21:13:05.000Z</published>
    <updated>2024-11-14T17:46:09.413Z</updated>
    
    <content type="html"><![CDATA[<p>将之前的 Vue 学习笔记进行了整理，即使仅是 Vue 核心的功能发现也还是比较有货的，跟后端的学法都是一样的，关键理解其设计思想，上手使用都不难，关键是能 get 到为什么这样设计，这样设计什么好处，这个有点玄学，全靠自己理解了 o(￣▽￣<em>)ゞ))￣▽￣</em>)o。<a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vueJS 是一种轻量级的 MVVM 框架，它同时吸收了 react 和 angular 的优点，强调了 react 组件化的概念，可以轻松的实现数据和展现的分离。也吸收了 angular 灵活的指令和页面操作的一些方法。</p><p>Vue 引入建议放在头部，避免发生抖屏的现象。<br>Vue 使用后不再需要任何 Dom 操作，Vue 接管了 Dom 的操作。<br><strong>Vue 只会处理挂载点下的内容</strong></p><p>当数据发生变化时（比如被函数改变），Vue 会自动去更新页面的数据，整个过程不需要操作 Dom</p><blockquote><p>关于 MVC、MVP、 MVVM 的介绍：<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p></blockquote><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><p>首先，来复习下 Vue 最常用的一些东西，基本语法和模式</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>学习 Vue 首先接触的可能是挂载点、模板、Vue 实例等这些词，先来看一段示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-Hans"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 放在头部引用，避免抖屏现象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"num"</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="xml">        // template: "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">          msg: <span class="string">"Hello World!"</span>,</span></span><br><span class="line"><span class="undefined">          num: 123</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">          handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert("test")</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.msg = <span class="string">"Loli"</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是标准的一个 HTML，其中 script 部分是 Vue 的主要施展的部分，通过 <code>new Vue()</code> 出的对象自然就称作是<strong>实例</strong>了。<br>其中，那个 id 为 root 的 div 就可以称作是<strong>挂载点</strong>；也可以说是 Vue 实例中 el 所指向的元素。<br>在挂载点内部的内容，都可以称作是<strong>模板内容</strong>；同时模板也可以写在 Vue 实例中，效果是一样的。</p><p>这里补充一个生命周期的图示：</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期"></p><h3 id="数据指令及处理"><a href="#数据指令及处理" class="headerlink" title="数据指令及处理"></a>数据指令及处理</h3><p>通过两对花括号的方式取值方式我们称之为“<strong>插值表达式</strong>”.<br>在实例定义的方法中，可以直接通过 <code>this.name</code> 的方式来获取定义的数据对象（data 属性里的），相当于是个别名了，不需要太在意 this 指向，Vue 会进行进一步的处理的，简单理解为代表本组件即可。</p><p>指令：</p><ul><li><p><strong>v-text</strong><br>标签的内容就是 v-text 指向的变量，例如：<code>&lt;p v-text=&quot;num&quot;&gt;&lt;/p&gt;</code><br><strong>特殊字符会被转义</strong></p></li><li><p><strong>v-html</strong><br>和 v-text 基本一致，区别在于它不会转义那些 HTML 字符</p></li><li><p><strong>v-on(@)</strong><br>绑定事件函数，比如点击事件（v-on:click），函数的定义可以写在实例的 methods 对象内。<br>其中 <code>v-on:</code> 可以简写为 <code>@</code></p></li><li><p><strong>v-bind(:)</strong></p><p>属性绑定，和双大括号类似，只不过是用在属性里的，例如：<code>&lt;div v-bind:title=&quot;is + title&quot;&gt;Test&lt;/div&gt;</code><br>同样，它可以简写为 <code>:</code></p></li></ul><p>使用了指令后，比如 <code>v-xxx:</code> 之类的形式，后面跟的是一个 js 表达式，也就是说可以使用 js 中的基本表达方式，比如 <code>+</code> 之类的连接符。</p><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>上面一顿操作都是单向绑定的，也就是说实例的数据决定页面的显示，但是页面的显示不能改变实例中的数据，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">"is Content"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就需要使用模板指令：v-mode，使用格式直接是：<code>v-model=&quot;msg&quot;</code></p><h3 id="计算属性与侦听器"><a href="#计算属性与侦听器" class="headerlink" title="计算属性与侦听器"></a>计算属性与侦听器</h3><p>计算属性就是某一个属性的结果是其他几个属性值计算得出来的，并且在其他属性没有改变的情况下，再次使用会直接返回缓存值，避免重复计算。<br>侦听器就是监听某一个数据的变化，一旦发生变化就执行相应的逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#cal"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        firstName: <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="string">""</span>,</span></span><br><span class="line"><span class="undefined">        count: 0</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      computed: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性声明</span></span></span><br><span class="line"><span class="javascript">        fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 再次使用 fullName 时，如果这两个变量没有改变会使用缓存值</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 避免重复进行计算</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// get set 的方式</span></span></span><br><span class="line"><span class="undefined">        test: &#123;</span></span><br><span class="line"><span class="undefined">          get () &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          set (newVal) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      watch: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 侦听器，也会有缓存</span></span></span><br><span class="line"><span class="javascript">        firstName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：不要忘记使用 this，要不然找不到，Vue 会自动处理这个“别名”。<br>计算属性 computed 可以使用 get 和 set，用来提供获取和设置的情况。</p><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h4 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h4><p>来看 <code>v-if</code> 和 <code>v-show</code></p><p>他们<strong>控制标签的显示和隐藏</strong>，当为 true 时就显示，false 时就隐藏，他们的区别在于，<strong>v-if 的表现形式是将标签直接删除，v-show 则是通过 display 来实现。</strong></p><blockquote><p>这可能带来了 dom 复用的问题，例如 input 框不会清空，这种情况下可以使用 key 值来绑定唯一，这样 Vue 就会不复用了。</p></blockquote><p><strong>性能上来说，频繁更改的话 v-show 更好，如果只是改一次那么 v-if 可能就更好了。</strong><br>其次还支持紧贴 v-if 的 v-else-if 和 v-else</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>然后就是 v-for 用来遍历数据的，举个例子：<br><code>&lt;li v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;</code><br>list 就是定义的数组数据，item 是每次遍历的值，index 是索引，使用 <code>:key</code> 可以提高效率，<strong>但是要保证 key 的唯一</strong>；所以这里我加了个 index，如果 item 是唯一的那么可以直接使用 item：<br><code>&lt;li v-for=&quot;item of list&quot; :key=&quot;item&quot;&gt;&lt;/li&gt;</code><br>如果还要对其进行排序之类的操作，那么使用 index 也不是很合适了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myClick"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;li v-for="item of list" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        text: <span class="string">"我是内容"</span>,</span></span><br><span class="line"><span class="javascript">        flag: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">        list: [1,2,3]</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        myClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h3><p>关于样式的控制，可以使用 class 对象绑定： <code>:class=&quot;{className: isActivated}&quot;</code> 然后通过控制 isActivated 变量来控制 class 的显示或隐藏。<br>还可以通过 <code>:class=&quot;[activated, className]&quot;</code> 这样通过 activated 这个变量来控制。<br>如果是内联样式（<code>:style</code>），可以直接引用一个 js 对象，在对象里面定义 css 样式就行，同样也可以使用数组来挂载多个对象。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>当某一块的布局复杂后就需要抽取出来，形成了一个模板，模板又分为全局的和局部的，它们的使用也各不相同，这一个个的模板加上一下逻辑就可以当作是一个组件，在下面的代码中可以体现出来。<br>因为模板中取不到外部的属性，所以使用了属性传值的方式来将数据传进去，在模板中接收一下就可以使用了。<br><strong>模板也可以看作是一个实例，可以说在一个 Vue 项目中，是由很多很多 Vue 实例（组件）组成的</strong>。<br>根据“发布-订阅”模型，可以在子组件中向父组件发布消息，然后父组件可以监听子组件的自定义消息，然后调用相应的方法来进行处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'todo-item'</span>, &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收传入的属性</span></span></span><br><span class="line"><span class="javascript">      props: [<span class="string">'content'</span>, <span class="string">'index'</span>],</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 因为模板也是一个实例可以定义事件</span></span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 向外发布一个自定义事件（订阅-发布模型）, 并且将 index 传递过去</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$emit(<span class="string">'delete'</span>, <span class="keyword">this</span>.index)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义局部组件,必须要在 Vue 实例中声明才能用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> TodoItem = &#123;</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span>item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// components: &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   // 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   'todo-item': TodoItem</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        mSubmit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        handleDelete: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：<strong>模板中要求只能有一个根标签，所以在最外层一般都会套一个 div</strong></p><p>总之，当年看到奇奇怪怪的 HTML 标签时，一般就是一个 Vue 组件了，一个组件一般会写在一个 xxx.vue 文件里，通过 ES6 的 import 语法导入进行使用。</p><blockquote><p>我们导入的组件（component）起的名字一般是跟组件的 name 属性对应的，在 HTML 中使用组件直接用这个名字的标签即可，因为 HTML 对大小写不敏感，所以使用 <code>-</code> 进行转换，例如：<br>name：todoList  =&gt;  <code>&lt;todo-list&gt;&lt;/todo-list&gt;</code></p></blockquote><p>下面是一个组件的基本 js 结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"basic"</span>,</span><br><span class="line">  props: [],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  watch: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是，组件里的 data 是一个函数，返回的是一个对象。</p><h3 id="组件参数校验"><a href="#组件参数校验" class="headerlink" title="组件参数校验"></a>组件参数校验</h3><p>在父子组件之间传值都已经知道了，那么接下来就看看如果子组件要对父组件传递的数据进行校验要怎么办，使用的还是子组件里的 props 属性，只不过这里由本来的字符串数组变成了对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 不是校验的话可以直接用字符串数组来标识</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// content: [Number,String]</span></span><br><span class="line">    content: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'def val'</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>补充一下这个 props 特性，也就是如果你在子组件的 props 中接收了传递的属性，那么 Vue 在视图渲染的时候就不会再在 HTML 中加上这个属性了。<br>在子组件上绑定的事件默认都是自定义事件，也就是说原生的事件可能会失效，例如在子组件标签里使用 <code>@click</code> 是无效的，不过你可以在子组件的模板里来绑定，这样就不是自定义事件了。<br>触发自定义事件就是手动的调用 emit 了；但是有些时候就想用子组件的原生事件，就想让它生效怎么办，也是有办法的，只需要一点点的改动：<code>@click.native=&quot;fun&quot;</code>。<br>同时，为了解决手机端兼容问题，可以使用类似 <code>@touchstart.prevent</code> 的方式阻止事件的默认行为。</p><h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><p>这里主要说的就是非父子组件之间的传值，例如父与子的子、兄弟组件，虽然可以间接完成，但是过于麻烦，由于 Vue 的定义轻量级，它并不具备解决这个问题的能力，但是我们可以借助其他的方案。</p><ol><li>Vue 官方推荐的 Vuex 框架。</li><li>发布-订阅模式，也就是总线机制，可以理解为是观察者模式。</li></ol><p>一般情况下，都是使用 Vuex，非常简单的项目可以考虑下 bus</p><h4 id="总线模式"><a href="#总线模式" class="headerlink" title="总线模式"></a>总线模式</h4><p>这里仅说一下总线的这种方式，其实就是在所有子组件上挂一个 Vue 实例，然后通过这个实例来进行事件的发送与处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 bus</span></span><br><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 子组件的 data 必须是函数</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      selfContent: <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    content: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div @click='handleClick'&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 向总线发送事件</span></span><br><span class="line">      <span class="keyword">this</span>.bus.$emit(<span class="string">"change"</span>, <span class="keyword">this</span>.selfContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期，挂载时触发</span></span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> this_ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.bus.$on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      this_.selfContent = val;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就是通过一个生命周期来完成的。</p><blockquote><p>在 Vue 中，类似 <code>vm.$xx</code> 这种的调用，后面跟一个 <code>$</code> 符号，意思是调用 Vue 实例的方法。</p></blockquote><h4 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h4><p>简单说 Vuex 就是一个单向数据的改变流，把需要改变的数据单独存储起来，然后通过指定的流程来进行更改。</p><p><img src="https://vuex.vuejs.org/vuex.png" alt=""></p><p>一般情况下，我们在单独的一个 js 中设置 Vuex，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: localStorage.name || <span class="string">"xxx"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeName (ctx, name) &#123;</span><br><span class="line">      <span class="comment">// 调用 mutations</span></span><br><span class="line">      ctx.commit(<span class="string">'changeName'</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeName (state, name) &#123;</span><br><span class="line">      state.name = name</span><br><span class="line">      <span class="comment">// 本地存储 (低版本浏览器或者隐身模式可能会抛异常)</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        localStorage.name = name</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在 App 入口 js 中进行引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样在任何子组件中就可以通过 <code>this.$store.state</code> 来获取 Vuex 中 state 的数据啦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发修改</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'changeName'</span>, name)</span><br><span class="line"><span class="comment">// 如果没有异步获取数据逻辑，可以直接调用 mutations</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'changeName'</span>, name)</span><br></pre></td></tr></table></figure><p>其中我们还使用了本地存储 localStorage。</p><p>实际中，大多会拆分 index.js 将 state、actions、mutations 单独放在一个文件中。</p><hr><p>另外，Vuex 还提供了高级 API 允许我们更精简的写代码，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick (name) &#123;</span><br><span class="line">    <span class="comment">// 使用 Vuex 改变全局数据</span></span><br><span class="line">    <span class="comment">// this.$store.dispatch('changeName', name)</span></span><br><span class="line">    <span class="keyword">this</span>.changeName(name)</span><br><span class="line">    <span class="comment">// 或者可以直接调用 mutations</span></span><br><span class="line">    <span class="comment">// this.$store.commit('changeName', name)</span></span><br><span class="line">    <span class="comment">// 跳转回首页</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 展开运算符，可以直接调用 changeName 方法了</span></span><br><span class="line">  ...mapActions([<span class="string">'changeName'</span>])</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用 Vuex 的便捷映射, 数组、对象皆可</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    name: <span class="string">'loli'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的 Vuex 操作就是这些了。</p><h3 id="使用插槽"><a href="#使用插槽" class="headerlink" title="使用插槽"></a>使用插槽</h3><p>简单来说，当子组件有一部分内容是由父组件传递过来的 dom 来显示的时候，就可以使用插槽来处理。<br>要解决的问题，之前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'content'</span>],</span><br><span class="line">  <span class="comment">// ES6 语法</span></span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;Dear&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;div v-html="this.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;&lt;/child&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出子组件里的内容会被 slot 标签插入。<br>如果需要将子组件里内容分片，那么也是可以的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"one"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"two"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是稍微改变了下，进行了标识。</p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>最后来看一下高级用法：作用域插槽，从例子开始：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">show</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 固定写法，template 开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">show</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'show'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">        list: [1,2,3,4]</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                &lt;slot </span></span><br><span class="line"><span class="javascript">                  v-<span class="keyword">for</span>=<span class="string">"item of list"</span></span></span><br><span class="line"><span class="undefined">                  :item=item</span></span><br><span class="line"><span class="javascript">                &gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下，在 template 中，使用 for 来“循环插槽”，将每次循环的数据绑定到了 item 变量，然后视图中通过 slot-scope 来接收。</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>这里说的是动态的切换组件，可以手动实现，也可以通过 Vue 提供的 component 标签来实现，例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">'type'</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-one</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-one'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-one</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-two</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-two'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-two</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-one'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-two'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="string">'child-one'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">      handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.type = <span class="keyword">this</span>.type === <span class="string">'child-one'</span> ? <span class="string">'child-two'</span> : <span class="string">'child-one'</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>component 和下面使用 v-if 控制的标签是一样的，因为每次切换都需要销毁、重新创建，所以性能上会有点损耗，可以在模板上使用 <code>v-once</code> 来将实例放到内存中，这样就省去了创建、销毁的时间。</p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>使用异步加载方式，避免所有的业务逻辑打包后在一个 js 文件中； 适用于打包后生成的 app.js 文件太大的情况，不然多发 http 请求反而更加不好。</p><blockquote><p>以下内容建议阅读完『使用脚手架-使用路由』之后再阅读。</p></blockquote><p>改用异步组件非常简单，在很多地方都可以用，例如 router 下的 index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/home/Home'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/city'</span>,</span><br><span class="line">      name: <span class="string">'City'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/city/City'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/detail/:id'</span>,</span><br><span class="line">      name: <span class="string">'Detail'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/detail/Detail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即，把 <code>import Router from &#39;vue-router&#39;</code> 更换为箭头函数 <code>() =&gt; import(&#39;@/xxx&#39;)</code></p><h2 id="使用脚手架"><a href="#使用脚手架" class="headerlink" title="使用脚手架"></a>使用脚手架</h2><p>新版 vue-cli3 的使用参考<a href="https://cli.vuejs.org/zh/guide/installation.html" target="_blank" rel="noopener">官方文档</a>。<br>相比 cli2 目录发生了一些变化，Webpack 从 3 升级到 4，支持 ui 创建，非常推荐，篇幅原因不再详细写，跟 2 差不多。<br>初始化完成的项目一般我们还需要增加一些目录和配置，例如 views、api、vue.config.js 等，可参考<a href="https://juejin.im/post/6844904035925884935" target="_blank" rel="noopener">这里</a>。</p><hr><p>对于老版 cli2 官方提供的安装和初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装 vue-cli</span><br><span class="line">npm install --global vue-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>因为是采用的 webpack 的方式，所以方便了很多，直接可以在浏览器中进行预览。<br>这里就可以看出模块化了，其中 Vue 实例都集中放在了 <code>.vue</code> 结尾的文件中，vue  文件分成三部分，模板、js代码、样式。<br>工程的入口是根目录下的 index.html 文件，其中有个 id 为 app 的 div，这就是 Vue 的挂载点了，然后看主要的代码在 src 中。<br>在 main.js 中创建了 Vue 实例，也就是所谓的启动配置，并且定义了模板，导入了相应的子模板，这里就来修改下看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块化语法</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 引入子模板</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和上面写的差不多，创建了一个 Vue 实例，挂载到 app 这个 id 下面，模板采用的是实例内定义的，里面就是引用了个 <code>&lt;App/&gt;</code> ，也就是 <code>App.vue</code> 中定义的那一堆。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">'./components/TodoItem'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 相当于子模板的定义区</span></span></span><br><span class="line"><span class="javascript">    name: <span class="string">'App'</span>,</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="string">'todo-list'</span>: TodoItem</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// vue 文件中 data 只能使用函数来定义</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 简便写法</span></span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      mSubmit () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      handleDelete (index) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 vue-cli 中，当写一个实例的数据的时候使用的是函数方式，而不再是对象！！<br>然后，App 这个模块中又引入了一个 TodoItem 的模板，就是曾经的子模板，完整的例子到 GitHub 仓库查看。<br>再次说明，Vue 底层会处理 this 的指向，不需要太过担心，指的就是此实例.</p><h3 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h3><p>使用路由来根据访问 url 动态切换的目的，在 App 主入口加入 <code>&lt;router-view/&gt;</code> 即可启用，在 <code>src\router\index.js</code> 进行配置路由规则即可，前提是安装了 vue-router 组件。<br>其中路由规则的 url 映射可以使用变量来进行区分，例如：<code>/detail/:id</code> ，然后可以在子组件通过 <code>this.$route.params.id</code> 来获得变量。<br>使用 <code>&lt;router-link to=&quot;/list&quot;&gt;跳转&lt;/router-link&gt;</code> 可进行单页应用的跳转，在跳转过程中不需要请求新的 HTML，但是首屏加载会慢一点，SEO 也不是很好。<br>除了使用标签来路由，在 JS 环境下，可以使用编程式导航：<code>this.$router.push(&#39;/&#39;)</code></p><hr><p>为了防止路由调整后滚动条不会重置，官方文档的解决方案是在路由的 js 配置中加入下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就解决了跳转后滚动条错乱的情况。<br>最后记得在 main.js 中开启路由功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>h =&gt; h(App)</code> 是创建标签挂载组件的一个简写形式，参考<a href="https://segmentfault.com/q/1010000007130348" target="_blank" rel="noopener">这里</a>。</p><h3 id="使用Axios发送请求"><a href="#使用Axios发送请求" class="headerlink" title="使用Axios发送请求"></a>使用Axios发送请求</h3><p>既然都用 Vue 了，那么基本是前后端分离的架构，于是 ajax 请求必然少不了，一般情况在 Vue 中处理请求都是用 Axios 这个库，直接 npm 安装后导入就可以用了。<br>这里说下基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  getHomeInfo () &#123;</span><br><span class="line">    Axios.get(<span class="string">'/api/index.json?city='</span> + <span class="keyword">this</span>.$store.state.city)</span><br><span class="line">      .then(<span class="keyword">this</span>.getHomeInfoCallback)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getHomeInfoCallback (res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data.ret &amp;&amp; res.data.data) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.data.data</span><br><span class="line">      <span class="keyword">this</span>.swiperList = data.swiperList</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>嗯，基本上就是这个样子了，then 表示才成功后回调，catch 表示失败后回调。<br>注意下，成功或者失败的 res 都会给你包一层，<code>res.data</code> 才是真正响应的东西。</p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>因为一般是前后端分离，有时候后端的接口还没开发完，这时候我们可以改 url，但是这样之后你还得再改回去，特别麻烦，webpack 提供了代理的工具，将我们 Axios 发送的请求按照指定规则进行转发，例如我们可以使用静态文件来模拟数据。<br>一般在 webpack 的配置文件里这样写：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">  // Paths</span><br><span class="line">  assetsSubDirectory: 'static',</span><br><span class="line">  assetsPublicPath: '/',</span><br><span class="line">  proxyTable: &#123;</span><br><span class="line">    // 添加 URL 的替换，转发为本地静态文件</span><br><span class="line">    '/api': &#123;</span><br><span class="line">      target: 'http://localhost:8080',</span><br><span class="line">      secure: false,  // 如果是https接口，需要配置这个参数</span><br><span class="line">      changeOrigin: true,  // 是否跨域</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        '^/api': '/static/mock'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是将 url 重写，然后转发到你对应的地址。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>这里列举下在项目中使用的一些特性或技术，除了动画，其他还是用的非常多的。</p><h3 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h3><p>最简单的淡出淡然，可以使用 transition 标签进行包裹，作用简单说就是：<br>在开始前，会给被包裹的标签增加两个 css 样式：<strong>v-enter 和 v-enter-active</strong>，当动画运行到第二帧的时候会去除 v-enter 这个样式，再增加一个 v-enter-to 样式；最后动画结束时去除所有样式。<br>在使用 transition 标签的时候，如果加了 name 属性，那么样式就以你定义的名字作为前缀代替 v。<br>上面说的是显示的动画，隐藏的过度也是类似，只需要把 enter 换成 leave 就可以了。<br>如果想自定义 css 的名字，可以使用 <strong>enter-active-class</strong> 属性来定义，其他同理。</p><p>或者可以使用 <code>animated.css</code> 提供的样式，快速开发，使用起来非常简单，引入不要的 css 库，然后利用上面所说来自定义 css 名字，格式就是：<code>animated 动画名</code> 名字可以在官网找，其实就是封装了下 css3 的 @keyframes 特性。</p><p>PS：想要初始化的时候就展示动画需要使用 appear 属性来配合。</p><hr><p>除了使用 css 来做动画，也可以使用 js 实现，在标签中通过 <strong>@before-enter、@enter、@after-enter</strong> 等来绑定方法，会传递一个参数过去，也就是包裹的 dom 元素 el。<br>其中 @enter 会传递两个参数，第一个与上面一样，第二个是个函数引用 done，在动画完成后调用一下它告诉 Vue 动画结束，这样就会再继续执行下面的 after。<br>如果嫌麻烦，可以使用像 <strong>Velocity</strong> 这样的 js 动画库。</p><hr><p>对于列表动画，可以使用 transition-group 标签来包裹，其实它的作用就是将里面的循环每一个都包裹一个 transition 标签。</p><h3 id="优化相关"><a href="#优化相关" class="headerlink" title="优化相关"></a>优化相关</h3><p>使用 <code>&lt;keep-alive&gt;</code> 标签 Vue 会自动帮你进行优化请求，例如 ajax 请求，如果启用了 <code>&lt;keep-alive&gt;</code> 标签，当第二次进行 ajax 请求时，会直接从内存里拿数据（mounted 函数不会执行）。<br>一般就直接在 App.vue 中使用了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启用缓存,重新路由后不再发请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"Detail"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'App'</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后有的数据我们是不想进行缓存的，所以就可以使用 exclude 指定组件的名字（就是 name 属性）进行排除。<br>或者可以使用生命周期函数 activated 来刷新数据（可能需要进行一定的逻辑判断·），这个函数在页面重新加载时执行。</p><hr><p>默认情况下 webpack-server 是不支持 ip 访问的，如果就想 ip 访问，可以在 <strong>package.json</strong> 文件中的 dev 加一个配置：<br><code>&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot;</code><br>以及可以在 devServer 下配置 host 为 <code>0.0.0.0</code> 的方式允许局域网访问。<br>参考：<a href="https://github.com/bfchengnuo/MyRecord/issues/61" target="_blank" rel="noopener">https://github.com/bfchengnuo/MyRecord/issues/61</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用 v-for 无论是遍历数组还是遍历对象，直接使用下标增加、修改数组 View 不一定会刷新，<strong>想要视图跟着刷新就必须用方法来增加</strong>，例如数组的 pop、push 等方法；对于对象的属性增加，可以使用 Vue 的全局方法 set（<code>Vue.set(obj, key, val)</code> 或者使用实例的 set 方法，<code>vm.$set(obj, key, val)</code>），当然 set 方法也可以用来修改数组 key 就是下标了。</p><hr><p>使用 v-for 的时候，为了不引入多余的 HTML 结构，可以使用 template 标签占位，在这个标签里使用 v-for 这样渲染后就没有痕迹了。</p><hr><p>可以通过绑定 class 属性的方式来改变样式，支持对象、数组。</p><hr><p>解决组件与 HTML5 规范冲突，可以使用 is 属性来标识其真正的组件，例如：<code>&lt;tr is:&quot;row&quot;&gt;&lt;/tr&gt;</code>。<br>使用 Vue 提供的标签也是类似，例如：<code>&lt;router-link tag=&quot;li&quot; :to=&quot;/index/&quot;&gt;</code></p><hr><p>子组件里，data 属性必须是函数，可以是这个函数返回一个对象，里面包含一些属性；这样也就达到了多个子组件数据互不影响的目的。</p><hr><p>必要的操作 Dom 时，通过 ref 属性来标识，在事件中可以 <code>this.$refs.name</code> 来获取 Dom 元素；如果 ref 加在了组件上，那么得到的就是这个组件的引用了。<br>特殊情况下，如果 ref 和 v-for 连用，那么使用 <code>:ref=</code> 的形式，并且获取的是数组，需要 <code>name[0]</code> 使用。</p><hr><p>子组件向父组件传值是通过事件的形式，一般来说在子组件中使用 <code>this.$emit(&#39;name&#39;, data)</code> 来进行手动触发；配合子组件的 HTML 标签中使用 <code>@name=&quot;fun&quot;</code> 来进行监听。</p><hr><p>在导入语法中，使用 <code>@</code> 来表示 src 目录；在组件样式编写的时候，如果不想影响到其他组件的样式，在 style 标签里加一个 scoped 即可。<br>使用 @import 导入 css 变量域，<code>~</code> 固定前缀：<code>@import &#39;~@style/varibles.styl&#39;</code><br>如果使用 stylus 语法，可以使用 <code>&gt;&gt;&gt;</code> 来做样式穿透。<br>如果使用 less/sass 语法，可以使用 <code>父样式名 /deep/ 子样式名</code> 做穿透。</p><hr><p>在 webpack 的配置文件里，可以使用 alias 来定义别名，快速引用文件夹，例如默认的 <code>@</code> 表示 src 就是这样设置的。</p><h3 id="使用定时器来截流"><a href="#使用定时器来截流" class="headerlink" title="使用定时器来截流"></a>使用定时器来截流</h3><p>某些场景，例如字母表滑动选择、实时搜索，这些绑定的事件会被频繁的调用，为优化效率，我们可以对其做削峰或者叫函数截流进行处理； 就是利用 setTimeout 的特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的局部变量来控制</span></span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免第一次执行时的 NPE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">  <span class="comment">// 当 timer 在指定的延迟内还没有执行时，又进行了调用，则会取消上次执行</span></span><br><span class="line">  <span class="comment">// 如果已经执行，那....就执行了，也会先 clear，再进行下面的赋值</span></span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.timer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 timer 新的延迟执行方案</span></span><br><span class="line"><span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将之前的 Vue 学习笔记进行了整理，即使仅是 Vue 核心的功能发现也还是比较有货的，跟后端的学法都是一样的，关键理解其设计思想，上手使用都不难，关键是能 get 到为什么这样设计，这样设计什么好处，这个有点玄学，全靠自己理解了 o(￣▽￣&lt;em&gt;)ゞ))￣▽￣&lt;/em&gt;)o。
    
    </summary>
    
      <category term="Web" scheme="https://sakanoy.com/categories/Web/"/>
    
    
      <category term="前端" scheme="https://sakanoy.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-排序</title>
    <link href="https://sakanoy.com/2019/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F/"/>
    <id>https://sakanoy.com/2019/04/03/算法之美-排序/</id>
    <published>2019-04-03T14:48:50.000Z</published>
    <updated>2019-04-09T09:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法可能就是排序，大学里的 C 入门就是写的它吧？排序是非常重要的，但是排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。<br>我这里就只看最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<a id="more"></a></p><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>冒泡、插入、选择</td><td>O(n^2)</td><td>是</td></tr><tr><td>快排、归并</td><td>O(nlogn)</td><td>是</td></tr><tr><td>桶、计数、基数</td><td>O(n)</td><td>否</td></tr></tbody></table><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）就是特指空间复杂度是 O(1) 的排序算法，可以理解为<strong>不需要开辟很多空间的算法</strong>。</p><p>然后还有一个<strong>稳定性</strong>的概念，简单说就是<strong>排序前后，相等的元素还是原来的顺序不变</strong>，这个性质其实很重要，实际中我们都是对对象的某个属性排序，如果还能保证顺序就省事很多。<br>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？<br>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。<br>两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作<strong>相邻的两个数据</strong>。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置</strong>，重复 n 次，就完成了 n 个数据的排序工作。</p><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// 表示有数据交换</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<strong>原地排序</strong>算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是<strong>稳定的</strong>排序算法。</p><p>对于一个给定的初始序列，移动操作的次数总是固定的。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>描述下过程就是：首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间；<br>初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。<br>重复这个过程，直到未排序区间中元素为空，算法结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 要插入的数</span></span><br><span class="line">    <span class="keyword">int</span> value = arr[i];</span><br><span class="line">    <span class="comment">// 有序区间的末尾</span></span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    arr[j + <span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟练后 for 循环可以简化：</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">  array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-- ) &#123;</span><br><span class="line">  arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序</strong>算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的</strong>排序算法。</p><p>对于一个给定的初始序列，移动操作的次数总是固定的。</p><h3 id="为什么插入更受欢迎"><a href="#为什么插入更受欢迎" class="headerlink" title="为什么插入更受欢迎"></a>为什么插入更受欢迎</h3><p>把他们循环的最多次的代码拿出来比较下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要小看少的这两句语句，在数据量大的时候，就能带来显著的差距，所以尽量做到极致的话当然会选择插入排序，另外，如果喜欢插入排序，可以看看极致的改进版：<strong>希尔排序</strong>，不过它是<strong>非稳定</strong>的。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="comment">// 只循环到倒数第二个即可，最后一个没数可比</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">        temp = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说明一下，选择排序是一种<strong>原地排序</strong>算法，但<strong>不是稳定的</strong>排序算法。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组<strong>从中间分成前后两部分</strong>，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>这就是分治思想，分而治之，跟递归思想有点像。</p><p>然后重点说下将两个已经有序的数组拼装起来，我们可以先申请一个临时数组 tmp，大小与原数组 A 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。<br>比较这两个元素 A[i] 和 A[j]，如果 <code>A[i]&lt;=A[j]</code>，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。<br>直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s1, <span class="keyword">int</span> middle, <span class="keyword">int</span> arrEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start1 = s1;</span><br><span class="line">    <span class="keyword">int</span> start2 = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arrEnd - s1 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 临时数组的索引</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= middle &amp;&amp; start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[start1] &lt;= arr[start2]) &#123;</span><br><span class="line">        tmp[k++] = arr[start1++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = arr[start2++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据，默认设为第一个剩余</span></span><br><span class="line">    <span class="keyword">int</span> start = start1;</span><br><span class="line">    <span class="keyword">int</span> end = middle;</span><br><span class="line">    <span class="keyword">if</span> (start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="comment">// 改变为第二个剩余</span></span><br><span class="line">      start = start2;</span><br><span class="line">      end = arrEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = arr[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (start1 = <span class="number">0</span>; start1 &lt;= arrEnd - s1; ++start1) &#123;</span><br><span class="line">      arr[s1 + start1] = tmp[start1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是<strong>稳定的</strong>算法，只要保证合并时稳定就好了。<br>它<strong>不是原地排序</strong>算法，所以快排更加出名一些，即使它的最好情况下的时间复杂度要优于快排。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排利用的也是分治思想，乍看和归并差不多，其实思想还是有差别的，快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。<br>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br>当区间缩小为 1 的时候就可以认为它有序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序，a是数组，n表示数组的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    quickSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">    quickSortInternally(a, p, q - <span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">    <span class="keyword">int</span> left = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = p; right &lt; r; ++right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[right] &lt; pivot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">          a[left++] = a[right];</span><br><span class="line">          a[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换 pivot，返回缩小后区间的最后一个（新 pivot）</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">    a[left] = a[r];</span><br><span class="line">    a[r] = tmp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"i="</span> + left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排并<strong>不是一个稳定的</strong>算法，它<strong>是一个原地排序</strong>算法；<br>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p><p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><p>快排 B 站有个视频讲的不错：<a href="https://www.bilibili.com/video/av39093184" target="_blank" rel="noopener">https://www.bilibili.com/video/av39093184</a></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个<strong>有序的</strong>桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p>他的时间复杂度是 O(n)，只不过对数据的要求比较苛刻。<br>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。<br>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><blockquote><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。<br>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>如果数据不能平均分，集中在一个桶里，为了避免时间复杂度的退化，那么你只能继续拆分。</p></blockquote><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。<strong>每个桶内的数据值都是相同的</strong>，省掉了桶内排序的时间。<br>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，arr 是数组，size 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">      max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个计数数组 countArr，下标大小 [0,max]，初始化为 0</span></span><br><span class="line">  <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 countArr 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    countArr[arr[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = countArr[i - <span class="number">1</span>] + countArr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组 temp，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = countArr[arr[i]] - <span class="number">1</span>;</span><br><span class="line">    temp[index] = arr[i];</span><br><span class="line">    countArr[arr[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给 arr 数组</span></span><br><span class="line">  System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（小数就先乘以倍数，负数就先加成正数）。</p><p>例如，对 50 万考生的成绩排名，假设满分是 900 最低是 0，数据范围很小，可以搞 901 个桶，然后将这些考试分布进这些桶里，<strong>并不需要排序，只需要扫描，时间复杂度是 O(n)。</strong></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？<br>对于手机号，再用之前的桶排序就不合适了，因为它太大了，刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。<br>借助稳定排序算法，这里有一个巧妙的实现思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。<br>不过要保证在每一位的排序中，<strong>算法要是稳定的</strong>。<br>每一位的排序就可以用上面的桶排序了~这样时间复杂度也是 O(n).</p><p>那么对于不等长的数据怎么排序（字符串为例）？我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据 ASCII 码，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>基数排序对要排序的数据是有要求的，需要<strong>可以分割出独立的“位”来比较，而且位之间有递进的关系</strong>，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序（O(n)）算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种<strong>原地的</strong>、<strong>不稳定</strong>的、时间复杂度为 O(nlogn) 的排序算法，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好。</p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种特殊的树，只要满足这两点，它就是一个堆：</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>第一点，堆必须是一个<strong>完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。<br>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。</p><p>关于树的介绍，我之前写过一篇，<a href="https://bfchengnuo.com/2017/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/">点我跳转</a></p><h3 id="实现一个堆"><a href="#实现一个堆" class="headerlink" title="实现一个堆"></a>实现一个堆</h3><p>完全二叉树比较适合用数组来存储，用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br>为了方便计算，通常会把数组的 1 号索引作为根，也就是前面空一个，数组中下标为 i 的节点的左子节点，就是下标为 <code>i∗2</code> 的节点，右子节点就是下标为 <code>i∗2+1</code> 的节点，父节点就是下标为 <code>i/2</code> 的节点。</p><p>通过调整，让其满足堆的特性的过程就叫“堆化”，堆化实际上有两种，从下往上和从上往下；<br>例如从下往上的，先插入到数组的最后，然后与父节点比较，不符合规则就交换，然后再跟父节点比较，直到合适为止。<br>删除的话也有一个巧妙的方法，直接把最后一个替换到删除的元素上，然后进行调整。</p><h3 id="实现堆排序"><a href="#实现堆排序" class="headerlink" title="实现堆排序"></a>实现堆排序</h3><p>首先，我们需要将数组<strong>原地</strong>建成一个堆，思路这里说一种，假设数组 size 是 10，编号就是 0-9：<br>我们从后面开始，按照规律 8、9 所对应的父节点的索引是 4，所以我们比较 4 是不是比 8 和 9 的数大，如果小就交换最大的；<br>然后继续找 6、7 对应的父节点 3，它们三个再比较，重复上面的步骤，最终就形成了符合规律的树，也就是堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span></span><br><span class="line"><span class="comment">// 需要注意，此算法数组需要空出第一个元素来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i * <span class="number">2</span>]) maxPos = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i * <span class="number">2</span> + <span class="number">1</span>]) maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">  arr[a] = arr[b];</span><br><span class="line">  arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。<br>有点类似删除操作，然后最大的就找出来了，依次往前，最终1就是个从小到大的有序数组了。</p><h3 id="总结-amp-应用"><a href="#总结-amp-应用" class="headerlink" title="总结&amp;应用"></a>总结&amp;应用</h3><p>至于说为什么堆排序不如快排效率高，可以从两点来说：<br>堆排序数据访问的方式没有快速排序友好，因为不是顺序访问，Cpu 缓存表示很无奈。<br>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序，就算是原本有序的数组，在堆化过程也会打乱的。</p><hr><ul><li><p><strong>优先级队列</strong><br>在优先级队列中，就不是先进先出了，用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。<br>很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p></li><li><p><strong>利用堆求 Top K</strong><br>我们可以维护一个大小为 K 的<strong>小顶堆</strong>，顺序遍历数组，从数组中取出取数据与堆顶元素比较。<br>如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素<strong>插入到</strong>堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。<br>这样每次只需要跟堆顶数比较即可，因为它肯定是全堆最小的。</p></li><li><p><strong>利用堆求中位数</strong><br>对于静态数据，当然数组求一下最好了，也不会变；如果是动态数据：<br>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。<br>也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。<br>如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。<br>这样，<strong>大顶堆中的堆顶元素就是我们要找的中位数</strong>。</p><p>下面就是插入新数据了，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新数据插入到小顶堆。<br>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况，这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。<br>例如将小顶堆的堆顶元素移动到大顶堆的堆顶。</p></li></ul><p>举几个例子，合并有序小文件的时候，我们可以从很多小文件先取第一个，构建一个小顶堆，每次从堆顶取出最小的放入合并后的文件，再找到这个元素来自那个文件读取下一个。<br>定时任务的时候，为了避免频繁扫描，可以根据时间来构造小顶堆，这样就知道最早执行的时间，避免多余的扫描。</p><p>PS：最后中位数说的那个约定：如果 n 是偶数，两个堆中的数据个数都是 n/2；如果 n 是奇数，大顶堆有 n/2+1 个数据，小顶堆有 n/2 个数据。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p><p>例如在 JDK8 中，排序函数并不是仅仅使用一种算法，在元素小于 47 的时候用插入排序，大于 47 小于 286 用双轴快排，大于 286 用 timsort 归并排序，并在 timesort 中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。</p><h2 id="娱乐时间"><a href="#娱乐时间" class="headerlink" title="娱乐时间"></a>娱乐时间</h2><p>下面就来给看看猴子排序、睡眠排序、面条排序（太蠢不说 2333），别笑。。。</p><h3 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h3><p>构造 n 个线程，它们和这 n 个数一一对应。初始化后，线程们开始睡眠，等到对应的数那么多个时间单位后各自醒来，然后输出它对应的数。这样最小的数对应的线程最早醒来，这个数最早被输出。等所有线程都醒来，排序就结束了。能脑洞大开想出此算法的，绝壁天才啊。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只需要输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//创建指定长度的线程数组</span></span><br><span class="line">    SortThread[] sortThreads = <span class="keyword">new</span> SortThread[arr.length];  </span><br><span class="line">    <span class="comment">//指定每个线程数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i] = <span class="keyword">new</span> SortThread(arr[i]);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//开启每个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i].start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SortThread</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.s = s;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      sleep(s*<span class="number">10</span>+<span class="number">10</span>);  <span class="comment">//睡眠指定的时间</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line"></span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//输出该数</span></span><br><span class="line">    System.out.println(s);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算需要拿到顺序的数组，也有办法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums=&#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    SleepSort.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)</span><br><span class="line">      System.out.printf(<span class="string">"%d   "</span>,n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Sleeper.idx=<span class="number">0</span>;</span><br><span class="line">    Sleeper.output=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      <span class="keyword">new</span> Sleeper(nums[i]).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 主线程需要睡足够的时间，等他们都排好</span></span><br><span class="line">      <span class="comment">// 当然可以使用其他 join、循环检查等方法</span></span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      nums[i]=Sleeper.output[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] output;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sleep_time;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(<span class="keyword">int</span> sleep_time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="keyword">this</span>.sleep_time);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    output[idx++]=<span class="keyword">this</span>.sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h3><p>随机打乱数组，检查是否排好序，若是，则输出，否则再次打乱，再检查…最佳情况 O(n)，平均 O(n*n!)，最坏可执行直到世界的尽头。<br>无限猴子定理 ：一只猴子随机敲打打字机键盘，如果时间足够长，总是能打出特定的文本，比如莎士比亚全集。<br>用伪代码表示很简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(! isOrdered(nums))</span><br><span class="line">    shuffle(nums);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法可能就是排序，大学里的 C 入门就是写的它吧？排序是非常重要的，但是排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。&lt;br&gt;我这里就只看最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。
    
    </summary>
    
      <category term="自我提升" scheme="https://sakanoy.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="算法" scheme="https://sakanoy.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java性能监控与调优</title>
    <link href="https://sakanoy.com/2019/03/29/Java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <id>https://sakanoy.com/2019/03/29/Java性能监控与调优/</id>
    <published>2019-03-29T14:48:50.000Z</published>
    <updated>2019-03-30T07:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要有更强的竞争力，这部分一定是得学的，并且小公司的话，你也不太可能只仅仅开发，这些也要全要搞。多了解一些总不是坏事，想要走的更远的话。<br>介绍下 JDK 或者第三方的一些工具来祝你优化你的程序！<a id="more"></a></p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>首先来了解下 JVM 参数的类型，一般来说，可以分为下面的三大类：</p><ul><li>标准参数<br>在 JVM 的各个版本中基本不变，比较稳定的。<br>例如：<code>-help</code>、 <code>-server</code>、 <code>-client</code>、 <code>-version</code>、<code>-cp</code>、 <code>-classpath</code></li><li>X 参数<br>非标准化参数，有可能会变，但是变化比较小。<br>例如，解释执行：<code>-Xint</code>、第一次使用就编译成本地代码：<code>-Xcomp</code> 、混合模式（默认）：<code>-Xmixed</code></li><li>XX 参数<br>使用的最多的一类参数，相对不稳定，主要用于 JVM 调优和 Debug。<br>它还可以再分类，例如：<br>布尔类型：<code>-XX:[+-]&lt;name&gt;</code> 表示启用或者禁用某个属性，启用 G1 垃圾收集器 <code>-XX:+UseG1GC</code>。<br>非布尔类型，也就是 K-V 的形式：<code>-XX:&lt;name&gt;=&lt;val&gt;</code> 就是用来调整属性的。</li></ul><p>我们见的最多的应该是 -Xms 和 -Xmx 了，然而它俩其实是 XX 参数，是一种简写形式。<br>-Xms 等价于 <code>-XX:InitialHeapSize</code> ；-Xmx 等价于 <code>-XX:MaxHeapSize</code> ；-Xss 等价于 <code>-XX:ThreadStackSize</code></p><h3 id="查看JVM运行时参数"><a href="#查看JVM运行时参数" class="headerlink" title="查看JVM运行时参数"></a>查看JVM运行时参数</h3><p>使用到的参数有：</p><ul><li>-XX:+PrintFlagsInitial<br>查看初始值</li><li>-XX:+PrintFlagsFinal<br>查看最终值</li><li>-XX:+UnlockExperimentalVMOptions<br>解锁实验参数，有些参数需要解锁后才可以设置。</li><li>-XX:+UnlockDiagnosticVMOptions<br>解锁诊断参数</li><li>-XX:+PrintCommandLineFlags<br>打印命令行参数</li></ul><h3 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h3><p>打印的值有两类，<code>=</code> 表示默认值；<code>:=</code> 表示被用户或者 JVM 修改后的值。<br>可以在命令行中使用 <code>java -XX:+PrintFlagsFinal -version</code> 来体验一把。</p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>专门用来查看 Java 进程的，跟 Linux 中的 ps 指令类似，可以使用 <code>jps -l</code> 来查看详细信息，更多的参数介绍可以在官方的文档中找到。</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可以用来查看正在运行的 JVM 进程的参数，不过需要你知道参数的名字才行，例如：<code>jinfo -flag MaxHeapSize [pid]</code> 、查看垃圾回收器的：<code>jinfo -flag [UseConcMarkSweepGC, UseG1GC] [pid]</code></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>可以查看 JVM 统计信息，例如类装载（-class）、垃圾收集（-gc）、JIT编译信息。<br>举个例子：<code>jstat -class [pid] 1000 10</code> 后面两个是可选的，意思是每隔 1000ms 输出一次，一共输出 10 次。<br>至于输出的是什么，文档里都有写，C 结尾表示的就是总量，U 结尾就是表示的已使用。</p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>简单起见可以参考这张图：</p><p><img src="/image/dev/JVM内存结构.png" alt="JVM内存结构"></p><p>非堆区也叫 Metaspace，是 JDK8+ 才有的，它移除了永久代的概念，使用堆外直接内存；其中的 CCS 不一定存在，当启用了指针压缩（64 -&gt; 32）才会有，CodeCache 是跟 JIT 编译相关的，还有一些其他的东西。<br>之前也看到过 64 位的 JVM 跟 32 位的 JVM 其实变化很大的，指针膨胀就是个大问题。</p><h2 id="关于内存溢出"><a href="#关于内存溢出" class="headerlink" title="关于内存溢出"></a>关于内存溢出</h2><p>OOM 应该是常见的一种情况了，常见的分析思路就是看 Dump 文件，也就是内存镜像文件，发生 OOM 时自动导出这个文件可以这样配置：<code>-XX:+HeapDumpOnOutOfMemoryError</code> 、<code>-XX:HeapDumpPath=./</code></p><p>除了自动导出，还可以使用 jmap 命令来手动导出。<br>例：<code>jmap -dump:format=b,file=heap.hprof [pid]</code> 、<code>jmap -heap [pid]</code></p><h3 id="使用MAT分析"><a href="#使用MAT分析" class="headerlink" title="使用MAT分析"></a>使用MAT分析</h3><p>这是 Eclipse 的一个工具，非常好用，官方地址：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a><br>载入 hprof 文件后，主页就会展示内存占用的分布情况，并且猜测那一块会有 OOM 的可能。<br>常用的就两个功能，查看对象的数量和查看对象占用的内存，一般来说只看强引用就行。<br>这个软件的详细用法 Google 一下。</p><h2 id="死循环与死锁"><a href="#死循环与死锁" class="headerlink" title="死循环与死锁"></a>死循环与死锁</h2><p>这里要介绍下 jstack 这个命令，它可以看到线程信息，当发现我们的 CPU 飙高，就有可能发生了死循环或者死锁的情况。<br>使用 jstack 输出指定 pid 的情况，然后重定向到一个文件里，拿下来分析就好了。</p><p>PS：使用 <code>top -p [pid] -H</code> 命令可以查看某个进程里面的线程情况，使用 <code>printf &quot;%x&quot; xxx</code> 可以将十进制的 pid 转换为 16 进制。</p><h2 id="jvisualvm可视化"><a href="#jvisualvm可视化" class="headerlink" title="jvisualvm可视化"></a>jvisualvm可视化</h2><p>jvisualvm 是 JDK 自带的一个工具，使用它可以可视化的监控 Java 程序的运行情况，当然，远程的也是可以进行监控的，不过需要设置了 JMX 才行。<br>然后，它可以安装第三方插件，推荐的两个插件是：VisualGC 和 BtraceWorkbench。</p><p>插件地址：<a href="http://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">http://visualvm.github.io/pluginscenters.html</a><br>需要先把对应版本的源添加进配置里才可以下载安装。<br>并且官网是有中文版的教程的，可以看一看。</p><h2 id="Btrace调试"><a href="#Btrace调试" class="headerlink" title="Btrace调试"></a>Btrace调试</h2><p>它的作用是在我们的应用程序不重启不修改，正在运行的情况下动态修改字节码，达到监控调试的目的。<br>使用步骤按照官方文档，设置个 <strong>BTRACE_HOME</strong> 的环境变量就可以了，运行方式有两种，一种直接命令行：<code>btrace &lt;PID&gt; &lt;trace_script&gt;</code> ，另一种可以使用 jvisualvm 插件来配合实现。<br>脚本代码非常简单，跟我们的 Java 代码也很类似（拦截器），所以不要怕。</p><p>至于下载地址，在 Github 上搜就可以了，项目主页：<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">https://github.com/btraceio/btrace</a></p><p>脚本示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArgSimple</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在那个类，那个方法，什么时候进行拦截</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    method=<span class="string">"arg1"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.ENTRY)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.printArray(args);</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写脚本所依赖的几个 jar 包在你下载的安装包里都有，使用也非常简单，直接跟类名就行，他没有包的概念，并且跟程序是独立的。</p><p>使用 -cp 来指定额外的 classpath 依赖第三方的类库。</p><h3 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h3><p>包括构造方法也是可以的，使用的是字节码风格 <code>&lt;init&gt;</code>。<br>默认是在入口的时候进行拦截，其他的拦截时机：</p><ul><li>ENTRY：入口（默认）</li><li>RETURN：返回</li><li>THROW：异常</li><li>Line：行</li></ul><p>如果你的代码有异常，但是被 try 给吃掉了，那么如何确定代码是否抛异常了呢，可以使用官方提供的一个代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOnThrow</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// store current exception in a thread local</span></span><br><span class="line">  <span class="comment">// variable (@TLS annotation). Note that we can't</span></span><br><span class="line">  <span class="comment">// store it in a global variable!</span></span><br><span class="line">  <span class="meta">@TLS</span> </span><br><span class="line">  <span class="keyword">static</span> Throwable currentException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// introduce probe into every constructor of java.lang.Throwable</span></span><br><span class="line">  <span class="comment">// class and store "this" in the thread local variable.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow</span><span class="params">(@Self Throwable self)</span> </span>&#123;<span class="comment">//new Throwable()</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s)</span> </span>&#123;<span class="comment">//new Throwable(String msg)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(String msg, Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow2</span><span class="params">(@Self Throwable self, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when any constructor of java.lang.Throwable returns</span></span><br><span class="line">  <span class="comment">// print the currentException's stack trace.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.RETURN)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrowreturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentException != <span class="keyword">null</span>) &#123;</span><br><span class="line">      BTraceUtils.Threads.jstack(currentException);</span><br><span class="line">      BTraceUtils.println(<span class="string">"====================="</span>);</span><br><span class="line">      currentException = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，你可以判断方法的某行代码是否执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    <span class="comment">// 支持使用正则表达式： /.*/</span></span><br><span class="line">    method=<span class="string">"exception"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(value=Kind.LINE, line=<span class="number">20</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn + <span class="string">","</span> +line);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理方法参数类型的时候，你可以使用 AnyType 来接收，也可以使用确定的类型。</p><p>生产环境下可以使用，但是要注意，被修改的字节码是不会被还原的，除非重启 JVM。</p><h2 id="tomcat调试"><a href="#tomcat调试" class="headerlink" title="tomcat调试"></a>tomcat调试</h2><p>使用 jpda 可以进行远程调试，相关的开启方法自行 Google，在配置文件中设置好端口后，在本地的 IDE 里直接填上就可以了。</p><p>tomcat 自带的管理界面比较简陋，更好的方案是使用 <strong>psi-probe</strong> 来监控，可以在 Github 上找到。</p><p>优化方面，主要着重的配置是：</p><ul><li>maxConnections<br>猫能够接受和处理的最大连接数，在 8+ 版本，使用了 NIO 技术，多路复用提高了性能。<br>使用 NIO 的情况下，默认是 10000</li><li>acceptCount<br>当连接数超出了最大值，进入一个等待队列，这个属性控制队列的大小，默认 100</li><li>maxThreads<br>配置工作线程的个数，默认是 200，同时并发处理的个数。</li><li>minSpareThreads<br>最小空闲的工作线程数，不要太小。</li><li>enableLookups<br>使用  <code>request.getRemoteHost()</code> 时进行 DNS 查询，建议禁用，8.5 默认禁用。</li><li>autoDeploy<br>猫运行时，要不要周期性的检查是不是有新应用需要部署，需要开一个线程来周期性检测，生产环境要关闭，默认开启。</li><li>reloadable<br>来监控 <code>/WEB-INF/classes/</code> 和 <code>/WEB-INF/lib</code> 的变化，同理建议禁用，8.5 默认禁用。<br>开发环境，用来支持热加载还是不错的。</li><li>protocol<br>在 server.xml 文件中配置，8+ 版本默认的使用 NIO，如果是高并发可以尝试使用 APR ，它使用的是 native 方法，性能会有一定提升。</li><li>分布式情况下，如果使用了 SpringSession 类似的解决方案，建议禁用猫的 session，尤其是使用 JSP 的时候。</li></ul><p>参考文档：docs/config/http.html、docs/config/host.html、docs/config/context.html</p><h2 id="nginx优化"><a href="#nginx优化" class="headerlink" title="nginx优化"></a>nginx优化</h2><p>配置文件的解读就不说了，Google 很多，要注意的是，配置反向代理要关闭 selinux，setenforce 0。<br>使用 <code>nginx -V</code> 可以查看编译参数。</p><p>使用 nginx 提供的 <strong>ngx_http_stub_status</strong> 配置来监控连接信息，要使用它需要将这个模块加入编译参数才行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = /nginx_status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个好用的工具 ngxtop，使用 python 的 pip 包管理直接 install 就好。<br>在 Github 上可以找到它的官方文档（不过这个项目已经不活跃了）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 基本使用</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询状态是 200 的</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -i 'status == 200'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询访问最多的 ip</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -g remote_addr</span><br></pre></td></tr></table></figure><p>再来介绍另一款图形化的监控工具：Nginx-rrd，这个是基于 PHP 来做的，所以需要 PHP 的相关依赖，然后需要在 php-fpm 中跟 nginx 统一用户，具体的配置还蛮多的，可以去 Google 一下。<br>它的原理是使用定时任务来扫描，每次都会存储成一张张的图片，最后使用 web 端来进行展示。</p><p>PS：这些监控工具都是基于 ngx_http_stub_status 来做的，所以上面那个 location 配置不能少。</p><hr><p>一些常见的基本的 Nginx 优化：</p><ul><li>增加工作线程数和并发连接数<br>默认情况下，Nginx 只有一个工作线程，并发数为 1024。</li><li>启用长连接<br>默认对客户端使用的是长连接，也可以对反向代理的后端使用长连接。</li><li>启用缓存、压缩</li><li>操作系统参数优化</li></ul><p>下面见一个示例的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 配置工作线程，受限于 CPU 的数量，一般配置与 CPU 的数量相等。</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"># 每一个线程打开的最大连接数，包含 nginx 与客户端和 nginx 与 upstream 之间的连接</span><br><span class="line"># 受限于操作系统，需要修改操作系统参数，默认 1024</span><br><span class="line">worker_connections  10240;</span><br><span class="line"># 可以一次建立多个连接</span><br><span class="line">multi_accept on;</span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置与后端的长连接示例</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name loli.com;</span><br><span class="line"></span><br><span class="line"># 配置反向代理的集群</span><br><span class="line">upstream server_pool&#123;</span><br><span class="line">    server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    # 300个长连接</span><br><span class="line">    keepalive 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置反向代理</span><br><span class="line">location / &#123; </span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">proxy_pass http://server_poll/;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>nginx -t</code> 来测试下配置文件是否正确。<br>开启缓存和压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">gzip_comp_level 2;</span><br><span class="line"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"># 禁用IE 6 gzip</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line"># 开启缓存</span><br><span class="line">location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; </span><br><span class="line">    access_log   off; </span><br><span class="line">    expires      30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires      24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">    expires      1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 格式</span><br><span class="line"># expires 30s;</span><br><span class="line"># expires 30m;</span><br><span class="line"># expires 2h;</span><br><span class="line"># expires 30d;</span><br></pre></td></tr></table></figure><p>操作系统参数优化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span> ipv4 相关优化</span><br><span class="line"><span class="meta">#</span> 防止一个套接字在有过多试图连接到达时引起过载，默认为 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta">#</span> os 的一个等待队列，默认 128，连接队列</span><br><span class="line">sysctl -w net.core.somaxconn = 1024</span><br><span class="line"><span class="meta">#</span> timewait 超时时间，在 tcp 的四次挥手时的状态，此状态下虽然已经断开，但是不能拿来用，没必要太长</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout = 10</span><br><span class="line"><span class="meta">#</span> os 直接使用 timewait 的连接，默认 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span> timewait 回收禁用，默认 0，为了不必要的麻烦</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 每个进程打开文件数量的限制</span><br><span class="line"><span class="meta">#</span> /etc/security/limits.conf</span><br><span class="line">* hard nofile 204800</span><br><span class="line">* soft nofile 204800</span><br><span class="line">* soft core unlimited</span><br><span class="line">* soft stack 204800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> nginx 的 TCP 优化</span><br><span class="line">http &#123;</span><br><span class="line"><span class="meta">#</span> 减少文件在应用和内核之间拷贝</span><br><span class="line">  sendfile           on;</span><br><span class="line"><span class="meta">  #</span> 当数据包达到一定大小再发送</span><br><span class="line">  tcp_nopush         on;</span><br><span class="line"><span class="meta">  #</span> 有数据随时发送</span><br><span class="line">  tcp_nodelay        off;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细配置参考：<br><a href="https://wsgzao.github.io/post/sysctl/" target="_blank" rel="noopener">https://wsgzao.github.io/post/sysctl/</a><br><a href="https://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-wpo.html</a><br><a href="http://sfau.lt/b5DA5u" target="_blank" rel="noopener">http://sfau.lt/b5DA5u</a></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如何选择垃圾收集器呢？</p><ul><li>优先调整堆大小，让服务器自己来选择</li><li>如果内存小于 100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或者 JVM 自己选</li><li>如果允许停顿时间超过 1 秒，选择并行或者 JVM 自己选</li><li>如果响应时间很重要，并且不能超过 1 秒，使用并发收集器</li></ul><p>几种垃圾收集器在之前的笔记里都有介绍，这里只作补充。<br>对于并行的 GC，是有自适应的特性的，就是说你给定几个指标（吞吐量、停顿时间等）它会自动调整堆大小，但这不是最优的方案，因为动态调整也是消耗性能的。<br>对应 Web 应用，我们还是比较关注停顿时间的，所以一般都是用并发的 GC，例如 CMS，这类收集器是对 CPU 敏感的，虽然跟用户线程并发执行，但是用户线程的 cpu 资源就少了，并且会产生浮动垃圾和空间碎片，在 G1 出现之前使用还是非常广泛的，在 J8 中官方推荐使用 G1。</p><p>G1 在 JDK7 开始提供，到 J8 已经比较成熟了，适用于大内存、低停顿的场景，在 J9 里 G1 已经成为默认的收集器，并且将 CMS 设置为废弃。<br>在 G1 中，老年代新生代是逻辑上的称呼了，它将堆分为一个个的 Region，还有一些成为 H 区用来存放大对象（超过了 Region 的一半）。<br>G1 中的 YoungGC 和传统的并没有什么区别，但是它没有了 FullGC，多了个 MixedGC，它回收所有 Young 和部分 Old，它也有并发标记的过程，默认堆的占有率达到 45% 就会触发。在每次 YGC 之后和 MGC 之前，会检查垃圾占比是否达到了某一个阀值，只有达到了才会发生 MGC。<br>G1 的相关概念和参数还多得多，这里不再一一举例。</p><p>G1 最佳实践：</p><ul><li>年轻代大小避免使用  -Xmn、 -XX:NewRatio 等显式设置，会覆盖暂停时间目标值</li><li>暂停时间目标时间不要太严苛，其吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间，太严苛会直接影响吞吐量。</li></ul><p>当发生了下面的几种情况，可以考虑切换到 G1 了：</p><ul><li>50% 以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过了 1 秒</li></ul><p>调优的过程就是在<strong>吞吐量</strong>和<strong>响应时间</strong>之间找平衡的过程，并且……在 J12 又带来了新的收集器 ZGC….。</p><p>参考资料：<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">J8 JVM 规范</a><br><a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">J8文档</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">J8 GC选择</a></p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>既然是分析日志，那么首先得拿到日志，使用这些参数来开启，然后就有日志文件了，直接读也是可以的，不过可视化更方便，可以使用这个<a href="https://gceasy.io/" target="_blank" rel="noopener">在线分析</a>，或者使用 GCViewer（在 Github）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:$CATALINA HOME/logs/gc.log</span><br><span class="line"></span><br><span class="line">## 下面的不用也可以</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure><h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>先来看并行的 ParallelGC，指导原则：</p><ul><li>除非确定，否则不要设置最大堆内存</li><li>优先设置吞吐量目标</li><li>如果吞吐量目标达不到，调大最大内存，不能让 OS 使用 Swap，如果仍然达不到，降低目标</li><li>吞吐量能达到，GC 时间太长，设置停顿时间的目标</li></ul><p>这些在 Oracle 官方文档里都有写的。<br>关于 G1 的调优，参考上面的 G1 最佳实践规则就可以了。</p><p>调优过程要一个参数一个参数的设置，避免不知道是改的那个参数起的作用，然后这是个循序渐进的过程，不太可能一步到位的。<br>这一块的内容，还是去慕课网看视频比较好，文字不太好描述。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JVM 是基于栈的架构，相比经典的基于寄存器的架构来说，它的指令更短，但是指令数量会更多。<br>例如一个经典的问题，i++ 和 ++i 那个效率高，在 fori 循环里是很常用的，可以分析字节码，会发现这两种形式翻译的字节码是一样的，所以他们的效率其实是一样的。<br>然后再看下面的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    s = <span class="string">"ll"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到底返回的是那个呢，答案是 hello，通过字节码可以看出，因为字符串是不可变对象，会将 hello 和 ll 同时压入两个本地变量，在走到 return 的时候把第一个也就是 hello 返回，然后又将第二个 ll 赋值给了第一个本地变量。</p><hr><p>我们知道在使用 + 进行字符串拼接时，默认会转换为 StringBuilder，那么这是绝对的么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">final</span> String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以去分析字节码，这里就直接说结论，当 String 类型为 final 时，是在编译阶段就直接确定了，不会再进行拼接。<br>关于 String，还有一个很有趣的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s.intern();</span><br><span class="line">  String s2 = <span class="string">"1"</span>; </span><br><span class="line">  System.out.print1n(s == s2);</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s3.intern();</span><br><span class="line">  String s4 = <span class="string">"11"</span>;</span><br><span class="line">  System.out.print1n(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK7- 和 JDK7+ 结果是不一样的，之前是两个 false，之后变成了 false 、 true，原因就是在 J7 之后字符串常量池移到了堆中，当使用 intern 方法并且常量池没有，堆中有的情况下，会将堆中的这个引用放到常量池中（常量池已经在堆中了），这样 s3 和 s4 就相等了。<br>G1 还有个字符串去重的功能（需要手动开启），也就是我们程序中字符串常量是占了很大比重的，而堆中和常量池中都有的话是很浪费的，当堆中字符串生命周期很长（有个阀值）就会触发去重操作。</p><hr><p>常见的代码优化：</p><ul><li>尽量重用对象，不要循环创建对象，比如：for 循环字符串拼接</li><li>容器类初始化的时候指定长度（List、Map）</li><li>集合遍历尽量减少重复计算（例如条件是不确定的 size）</li><li>尽量使用 Entry 来遍历 Map</li><li>尽量使用基本类型而不是包装类型</li><li>及时消除过期对象的引用，防止内存泄露</li><li>尽量使用局部变量，减小变量的作用域</li><li>ThreadLocal 缓存线程不安全的对象 SimpleDateFormat（J8 可以直接用新的 API DateTimeFormat 它是线程安全的）</li><li>尽量使用延时加载，例如单例模式（内部静态类）</li><li>尽量减少使用反射，用的话也尽量加缓存</li><li>慎用异常，不要用抛异常来表示正常业务逻辑，因为抛异常是比较重的操作，但是也别为了这个而不用，有些地方该用就得用。</li><li>String 操作尽量少用正则</li></ul><p>又一个有趣的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer a = <span class="number">100</span>;</span><br><span class="line">  Integer b = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  </span><br><span class="line">  Integer c = <span class="number">1000</span>;</span><br><span class="line">  Integer d = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 Integer 会自动缓存一个字节的数字，如果在缓存中直接返回，如果不在才 new，其他有的包装类型也有部分有缓存，比如 Long，不过 Double 这种肯定是没有的啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要有更强的竞争力，这部分一定是得学的，并且小公司的话，你也不太可能只仅仅开发，这些也要全要搞。多了解一些总不是坏事，想要走的更远的话。&lt;br&gt;介绍下 JDK 或者第三方的一些工具来祝你优化你的程序！
    
    </summary>
    
      <category term="Java" scheme="https://sakanoy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sakanoy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>体验ZooKeeper</title>
    <link href="https://sakanoy.com/2019/02/26/%E4%BD%93%E9%AA%8CZooKeeper/"/>
    <id>https://sakanoy.com/2019/02/26/体验ZooKeeper/</id>
    <published>2019-02-26T12:39:58.000Z</published>
    <updated>2019-02-28T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apache ZooKeeper 是 Apache 软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，是主要用于分布式中<strong>一致性处理的框架</strong>。ZooKeeper 曾经是 Hadoop 的一个子项目，但现在是一个独立的顶级项目。<br>ZooKeeper 的架构通过冗余服务实现高可用性。ZooKeeper 节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。<a id="more"></a></p><p>Zookeeper 从设计模式角度来理解：是一个<strong>基于观察者模式设计的分布式服务管理框架</strong>，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应。</p><blockquote><p>所谓的一致性，实际上就是围绕着“看见”来的。谁能看见？能否看见？什么时候看见？<br>也对应着：强一致性、弱一致性、最终一致性。</p></blockquote><h2 id="ZK特点"><a href="#ZK特点" class="headerlink" title="ZK特点"></a>ZK特点</h2><ul><li>一个领导者（Leader），多个跟随者（Follower）组成的集群。</li><li>集群中只要有<strong>半数以上（不包括一半）</strong>节点存活，Zookeeper 集群就能正常服务（所以集群最少 3 推荐奇数个）。</li><li>全局数据一致：每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致的。</li><li>更新请求顺序进行，来自<strong>同一个</strong> Client 的更新请求按其发送顺序依次执行。</li><li><strong>数据更新原子性，一次数据更新要么成功，要么失败</strong>。</li><li>实时性，在一定时间范围内，Client 能读到最新数据。</li></ul><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，<strong>每个 ZNode 都可以通过其路径唯一标识</strong>。</p><p>需要注意的是 ZK 的选举过程是非常复杂的，也就是耗时比较长，选举过程整个集群不可用，所以说 ZK 是 CP 的，相对的 Eureka 则是 AP 设计的，他们的比较看<a href="https://bfchengnuo.com/2018/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A2%E7%B4%A2/#CAP%E5%AE%9A%E7%90%86">这里</a>就够了。</p><p><strong>为什么要保证半数以上？</strong><br>从概念上来说，ZooKeeper 它所做的就是确保对 Znode 树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ZK 提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><ul><li>统一命名<br>在分布式场景下，经常需要对应用/服务进行统一命名，便于识别，例如 ip 和域名的关系。</li><li>统一配置管理<br>分布式中配置文件同步是常见的，一般要求在一个集群中，所有节点的配置是一致的。<br>对某一个节点的配置修改后也会快速同步到其他节点上。<br>因为客户端在监听，一旦 ZNode 中的数据变化，ZK 将通知各个客户端。</li><li>统一集群管理<br>分布式中，实时掌握每个节点的状态是必要的，可以根据节点的状态做出一些调整。<br>ZK 会将节点的相关信息一起写入到 ZNode 中。</li><li>服务器动态上下线<br>客户端能够实时的洞察服务器的上下线情况。<br>因为服务器注册的时候创建的是临时节点，服务器下线后会自动删除，ZK 会通知监听的客户端，然后客户端会去重新获取列表。</li><li>软负载均衡<br>ZK 可以记录每台服务器的访问次数，让访问最少的来处理最新的客户端请求。</li></ul><h2 id="安装ZK"><a href="#安装ZK" class="headerlink" title="安装ZK"></a>安装ZK</h2><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>windows 版的没啥好说的，就说说 linux 版，正常情况应该是搞集群的，不过测试用机器性能有限，开一个就行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">tar -zxvf zookeeper-3.x.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta">#</span> 进入 conf 文件夹修改配置文件名</span><br><span class="line"><span class="meta">#</span> 进入配置文件将 dataDir= 修改到指定的目录，需要自己创建文件夹，例如 zkData</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span> 查看进程使用 jps</span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动客户端，退出 quit</span><br><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure><p>其他常用配置参数：</p><ul><li>tickTime<br>通信心跳数，Zookeeper 服务器与客户端心跳时间，单位毫秒。<br>它用于心跳机制，并且设置最小的 session 超时时间为两倍心跳时间。</li><li>initLimit<br>集群中的 Follower（跟随者）服务器与 Leader（领导者）服务器之间初始连接时能容忍的最多心跳数（总时间就是它乘以 tickTime），用它来限定集群中的 Zookeeper 服务器连接到 Leader 的时限。</li><li>syncLimit<br>同步通信时限，集群中 Leader 与 Follower 之间的最大响应时间单位，假如响应超过 syncLimit * tickTime，Leader 认为 Follwer 死掉，从服务器列表中删除 Follwer。</li><li>clientPort<br>客户端连接的端口</li></ul><p>客户端操作的常用命令：</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path [watch]</td><td>使用 ls 命令来查看当前 znode 中所包含的内容</td></tr><tr><td>ls2 path   [watch]</td><td>查看当前节点数据并能看到更新次数等数据</td></tr><tr><td>create</td><td>普通创建   -s  含有序列   -e  临时（重启或者超时消失）</td></tr><tr><td>get path   [watch]</td><td>获得节点的值</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>rmr</td><td>递归删除节点</td></tr></tbody></table><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>解压跟上面一样，如果安装了 rsync 远程同步工具，可以使用 xsync 命令同步过去，然后在设置的数据文件夹目录下创建一个 myid 的文件，在里面写上对应的编号。<br>然后在所有的配置文件中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#######################cluster##########################</span><br><span class="line">server.2=hostname102:2888:3888</span><br><span class="line">server.3=hostname103:2888:3888</span><br><span class="line">server.4=hostname104:2888:3888</span><br><span class="line"></span><br><span class="line"># server.A=B:C:D</span><br><span class="line"># A 是一个数字，表示这个是第几号服务器，就是 myid 文件里写的那个数字，</span><br><span class="line">#   Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。</span><br><span class="line"># B 是这个服务器的 ip 地址；</span><br><span class="line"># C 是这个服务器与集群中的 Leader 服务器交换信息的端口；</span><br><span class="line"># D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</span><br></pre></td></tr></table></figure><p>最后分别启动就可以了，可以使用查看状态来查看。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>客户端使用 get 或者 ls2 命令获取到的信息解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">czxid - 创建节点的事务 zxid</span><br><span class="line">每次修改 ZooKeeper 状态都会收到一个 zxid 形式的时间戳，也就是 ZooKeeper 事务 ID。</span><br><span class="line">事务 ID 是 ZooKeeper 中所有修改总的次序。每个修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。</span><br><span class="line"></span><br><span class="line">ctime - znode被创建的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">mzxid - znode最后更新的事务zxid</span><br><span class="line"></span><br><span class="line">mtime - znode最后修改的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">pZxid - znode最后更新的子节点zxid</span><br><span class="line"></span><br><span class="line">cversion - znode子节点变化号，znode子节点修改次数</span><br><span class="line"></span><br><span class="line">dataversion - znode数据变化号</span><br><span class="line"></span><br><span class="line">aclVersion - znode访问控制列表的变化号</span><br><span class="line"></span><br><span class="line">ephemeralOwner - 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</span><br><span class="line"></span><br><span class="line">dataLength - znode的数据长度</span><br><span class="line"></span><br><span class="line">numChildren - znode子节点数量</span><br></pre></td></tr></table></figure><p>主要留意最后两个就好了。</p><h2 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>半数机制：集群中半数以上机器存活，集群可用。所以 Zookeeper 适合安装<strong>奇数台服务器</strong>。<br>Zookeeper 虽然在配置文件中并没有指定 Master 和 Slave。但是，Zookeeper 工作时，是有一个节点为 Leader，其他则为 Follower，Leader 是通过内部的选举机制临时产生的。</p><p>选举机制简单说就是每个服务都首先选自己，如果超过了集群数量的半数以上，那么选举结果即确定，否则放弃选自己继而选择 id 比自己大的一个。<br>假设集群里有五台服务器，id 编号 1-5，依次启动他们。</p><ol><li>服务器 1 启动，此时只有它一台服务器启动了，它首先选择自己，但是发出去的报文没有任何响应，所以它的选举状态一直是 LOOKING 状态。</li><li>服务器 2 启动，它与最开始启动的服务器 1 进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以 id 值较大的服务器 2 胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是 3)，所以服务器 1、2 还是继续保持 LOOKING 状态。</li><li>服务器 3 启动，根据前面的理论分析，服务器 3 成为服务器 1、2、3 中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的 Leader。</li><li>服务器 4 启动，根据前面的分析，理论上服务器 4 应该是服务器 1、2、3、4 中最大的，但是由于前面已经有半数以上的服务器选举了服务器 3，所以只能作为 Follower，第五个也是类似。</li></ol><p>真实的选举机制是非常复杂的，所以耗时长，Leader 选举是保证分布式数据一致性的关键所在，期间还需要对投票是否有效等进行检查，一般会进行多轮投票才会选出。</p><p>非初始化的情况下，通常那台服务器上的数据越新（ZXID 会越大），其成为 Leader 的可能性越大，也就越能够保证数据的恢复。如果 ZXID 相同，则 SID 越大机会越大。</p><hr><p>Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议（Zookeeper Atomic broadcast protocol）。<br>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</p><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。<br>状态同步保证了 leader 和 Server 具有相同的系统状态。</p><p>仅靠 Paxos 不能满足 ZooKeeper 需求。ZooKeeper 是一个树形结构，很多操作都要先检查才能确定能不能执行，例如创建 <code>/a/b</code> 之前要先确定 <code>/a</code> 的存在，我们就能从此看出 Paxos 的一致性达不到 ZooKeeper 一致性的要求，所以就有了 Zab 协议，它保证了：</p><ul><li>同一个 leader 的发起的事务要<strong>按顺序</strong>被 apply，同时还要保证只有先前的 leader 的所有事务都被 apply 之后，新选的 leader 才能在发起事务。</li><li>一些已经 Skip 的消息，需要仍然被 Skip。</li></ul><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态（包括数据的恢复）。<br>Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的；系统默认的选举算法为 fast paxos。<br>选完 leader 以后，zk 就进入状态同步过程。</p><blockquote><p>关于恢复模式。</p><p>选好新 leader 后它通过一个多数派获得老 leader 提交的最新数据；<br>老 leader 重启后，可能还会认为自己是 leader，可能会继续发送未完成的请求，从而因为两个 leader 同时存在导致算法过程失败；<br>解决办法是把 leader 信息加入每条消息的 id 中，Zookeeper 中称为 zxid 为一 64 位数字，高 32 位为 leader 信息又称为 epoch，每次 leader 转换时递增；低 32 位为消息编号，leader 转换时应该从 0 重新开始编号。<br>通过 zxid，follower 能很容易发现请求是否来自老 leader，从而拒绝老 leader 的请求。新 leader 首先要获得大多数节点的支持，然后从状态最新的节点同步事务，完成后才可正式成为 leader 发起事务。</p><ol><li>新 Leader 等待 server 连接；</li><li>Follower 连接 leader，将最大的 zxid 发送给 leader；</li><li>Leader 根据 follower 的 zxid 确定同步点；</li><li>完成同步后通知 follower 已经成为 uptodate 状态；</li><li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li></ol></blockquote><p>详细分析见：<br><a href="https://www.cnblogs.com/binyue/p/4270393.html" target="_blank" rel="noopener">https://www.cnblogs.com/binyue/p/4270393.html</a><br><a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/6107600.html</a><br><a href="https://www.cnblogs.com/sunddenly/p/4138580.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4138580.html</a><br><a href="https://www.jianshu.com/p/e126bb01331c" target="_blank" rel="noopener">https://www.jianshu.com/p/e126bb01331c</a></p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>节点的类型大体可分为两类：</p><ul><li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</li><li>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</li></ul><p>其中每一种里又细分为两类，目录节点和顺序编号目录节点，就如同名字一类会在后面加一个递增的序号，由父节点负责维护，可以用于排序，记录事件的顺序。</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>当 ZK 客户端运行后，会创建两个线程，一个负责网络连接通信（connect）一个负责监听（listener）；<br>通过 connect 线程将注册监听事件发给 ZK，ZK 收到后会将其加入到监听列表，类似 <em>ip:port:监听内容</em> 这样的形式。<br>满足条件后，ZK 就会按照监听列表告诉客户端，然后 listener 线程会回调 process 方法。<br>监听一般分为两类，一种是数据变化的监听，一种是子节点变化的监听。</p><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>首先 Client 向 ZooKeeper 的 Server1 上写数据，发送一个写请求。<br>如果 Server1 不是 Leader，那么 Server1 会把接受到的请求进一步转发给 Leader，这个 Leader 会将写请求广播给各个 Server，各个 Server 写成功后就会通知 Leader。<br>当 Leader 收到大多数 Server 数据写成功了，那么就说明数据写成功了。如果这里三个节点的话，只要有两个节点数据写成功了，那么就认为数据写成功了。<br>认为写成功之后，Leader 会告诉 Server1 数据写成功了，Server1 会进一步通知 Client 数据写成功了，这时就认为整个写操作成功。</p><p>所以，你可以知道 Zookeeper 并不保证读取的是最新数据，也就是强一致性，它只能保证最终一致性，同时它具有原子性：更新操作要么成功要么失败，没有中间状态。<br>而只需要一半以上写入完成即可认为成功也就好理解了，首先写操作只能由 Leader 发起，那么它肯定是最新的，后续可以同步给其他的 Follower，即使还没同步 Leader 就挂掉了，那么依然能保证新的 Leader 是有最新数据的，这就是靠 Zab 协议中的恢复模式了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>使用原生 API 的基本操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleZkClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 收到事件通知后的回调函数</span></span><br><span class="line">        System.out.println(event.getType() + <span class="string">"---"</span> + event.getPath());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取子节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建数据节点到 zk 中</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：要创建的节点的路径 </span></span><br><span class="line">    <span class="comment">// 参数2：节点的数据</span></span><br><span class="line">    <span class="comment">// 参数3：节点的权限</span></span><br><span class="line">    <span class="comment">// 参数4：节点的类型</span></span><br><span class="line">    String nodeCreated = zkClient.create(<span class="string">"/servers"</span>,</span><br><span class="line">                                         <span class="string">"hellozk"</span>.getBytes(),</span><br><span class="line">                                         Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                         CreateMode.PERSISTENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点是否存在</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    Stat stat = zkClient.exists(<span class="string">"/java6"</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat == <span class="keyword">null</span> ? <span class="string">"not exist"</span> : <span class="string">"exist"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点的数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZnode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数2：指定要删除的版本，-1 表示删除所有版本</span></span><br><span class="line">    zkClient.delete(<span class="string">"/java6"</span>, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    zkClient.setData(<span class="string">"/java6"</span>, <span class="string">"I Miss you"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器节点动态上下线示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributedServer server = <span class="keyword">new</span> DistributedServer();</span><br><span class="line">    server.getConnect();</span><br><span class="line">    <span class="comment">// 利用zk连接注册服务器信息</span></span><br><span class="line">    server.registerServer(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 启动业务功能</span></span><br><span class="line">    server.handleBussiness(args[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建到zk的客户端连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向zk集群注册服务器信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerServer</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时序号节点</span></span><br><span class="line">    String create = zkClient.create(parentNode + <span class="string">"/server"</span>,</span><br><span class="line">                                    hostname.getBytes(), </span><br><span class="line">                                    Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                    CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(hostname + <span class="string">"is online.."</span> + create);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBussiness</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(hostname + <span class="string">"start working....."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">    client.getConnect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servers的子节点信息，从中获取服务器信息列表</span></span><br><span class="line">    client.getServerList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务进程启动</span></span><br><span class="line">    client.business();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要再次启动监听</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          getServerList();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器列表信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取服务器子节点信息，并且对父节点进行监听</span></span><br><span class="line">    List&lt;String&gt; children = zk.getChildren(parentNode, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.遍历所有节点，获取节点中的主机名称信息</span></span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = zk.getData(parentNode + <span class="string">"/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">      servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(servers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 业务功能</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"client is working ..."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于集群来说，无论是服务器还是消费端，都是客户端；服务端就是向集群添加信息，消费端就是监听信息。</p><h3 id="节点权限"><a href="#节点权限" class="headerlink" title="节点权限"></a>节点权限</h3><p><strong>ZK 的节点有 5 种操作权限：</strong><br>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这 5 种权限简写为 crwda 。<br>注：这 5 种权限中，delete 是指对子节点的删除权限，其它 4 种权限指对自身节点的操作权限。</p><p><strong>身份的认证有 4 种方式：</strong><br>world：默认方式，相当于全世界都能访问<br>auth：代表已经认证通过的用户(cli 中可以通过 <code>addauth digest user:pwd</code> 来添加当前上下文中的授权用户)<br>digest：即 <code>用户名:密码</code> 这种方式认证，这也是业务系统中最常用的<br>ip：使用 Ip 地址认证。</p><p>Java API 中，<code>Ids.OPEN_ACL_UNSAFE</code> ：默认匿名权限；<code>Ids.READ_ACL_UNSAFE</code> ：只读权限； <code>CREATOR_ALL_ACL</code> ：给创建该 znode 连接所有权限。 事实上这里是采用了 auth 验证模式，使用 sessionID 做验证，所以创建该 znode 的连接可以对该 znode 做任何修改。</p><h2 id="关于服务发现"><a href="#关于服务发现" class="headerlink" title="关于服务发现"></a>关于服务发现</h2><p>相比 ZK，现在也有了不少其他优秀的选择，感兴趣的可以了解下 etcd、consul、Eureka。</p><table><thead><tr><th>Feature</th><th>Consul</th><th>zookeeper</th><th>etcd</th><th>euerka</th></tr></thead><tbody><tr><td>服务健康检查</td><td>服务状态，内存，硬盘等</td><td>(弱)长连接，keepalive</td><td>连接心跳</td><td>可配支持</td></tr><tr><td>多数据中心</td><td>支持</td><td>—</td><td>—</td><td>—</td></tr><tr><td>kv 存储服务</td><td>支持</td><td>支持</td><td>支持</td><td>—</td></tr><tr><td>一致性</td><td>raft</td><td>paxos</td><td>raft</td><td>—</td></tr><tr><td>CAP</td><td>CA</td><td>CP</td><td>CP</td><td>AP</td></tr><tr><td>使用接口(多语言能力)</td><td>支持http和dns</td><td>客户端</td><td>http/grpc</td><td>http（sidecar）</td></tr><tr><td>watch支持</td><td>全量/支持long polling</td><td>支持</td><td>支持 long polling</td><td>支持 long polling/大部分增量</td></tr><tr><td>自身监控</td><td>metrics</td><td>—</td><td>metrics</td><td>metrics</td></tr><tr><td>安全</td><td>acl /https</td><td>acl</td><td>https支持（弱）</td><td>—</td></tr><tr><td>SpringCloud集成</td><td>已支持</td><td>已支持</td><td>已支持</td><td>已支持</td></tr></tbody></table><p>真的是百家争鸣 o(￣▽￣<em>)ゞ))￣▽￣</em>)o</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/zero01/2108483" target="_blank" rel="noopener">https://blog.51cto.com/zero01/2108483</a><br><a href="https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/" target="_blank" rel="noopener">https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/</a><br><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/" target="_blank" rel="noopener">https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache ZooKeeper 是 Apache 软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，是主要用于分布式中&lt;strong&gt;一致性处理的框架&lt;/strong&gt;。ZooKeeper 曾经是 Hadoop 的一个子项目，但现在是一个独立的顶级项目。&lt;br&gt;ZooKeeper 的架构通过冗余服务实现高可用性。ZooKeeper 节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。
    
    </summary>
    
      <category term="自我提升" scheme="https://sakanoy.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="分布式" scheme="https://sakanoy.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="微服务" scheme="https://sakanoy.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
