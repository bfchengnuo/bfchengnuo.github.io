<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冰封承諾</title>
  <icon>https://www.gravatar.com/avatar/f08a170c76cf99aa6ee4da7e6c7775c2</icon>
  <subtitle>立于浮华之世,奏响天籁之音.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bfchengnuo.com/"/>
  <updated>2019-09-13T16:35:30.909Z</updated>
  <id>http://bfchengnuo.com/</id>
  
  <author>
    <name>Kerronex</name>
    <email>bfchengnuo@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ECMAScript常用语法整理</title>
    <link href="http://bfchengnuo.com/2019/09/14/ECMAScript%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://bfchengnuo.com/2019/09/14/ECMAScript常用语法整理/</id>
    <published>2019-09-13T16:33:03.000Z</published>
    <updated>2019-09-13T16:35:30.909Z</updated>
    
    <content type="html"><![CDATA[<p>首先集百家之介绍：</p><blockquote><p>ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。</p><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p></blockquote><p>目前 ES 已经到达了 ES2018 版本，Google 的 V8 引擎支持率 100%，其他的并不友好，而我们常用 <strong>JavaScript</strong> 稳定版本的实现目前在 ES2016 版本，所以这里主要学习 ES6 的特性了。<a id="more"></a><br>如果真的有什么原因不能使用 ES6 可以使用 Babel 将 ES6 语法转为 ES5.<br>我会把实际中频繁用到的一些特性写出来，致力于用最优雅的写法写出更高质量的代码。</p><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><p>使用 <code>let</code> 声明的变量只在它所在的代码块内有效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6，使用 var 则都是 10</span></span><br></pre></td></tr></table></figure><p>例如 for 循环就合适使用 let 定义 i</p><blockquote><p><code>for</code> 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p></blockquote><p><code>var</code> 命令会发生“<strong>变量提升</strong>”现象，<strong>即变量可以在声明之前使用</strong>，值为 <code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，<code>let</code> 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><blockquote><p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p></blockquote><p>总之，在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ），不过应该提倡能用 let 的时候尽量别用 var，避免造成作用域的混乱。</p><hr><p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>这意味着，<code>const</code> 一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效，不提升、存在暂时性死区。</p><blockquote><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 ES6 中，对字符串进行了增强，尤其是模板字符串，真是非常的好用！</p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义<strong>多行字符串</strong>，或者在字符串中<strong>嵌入变量</strong>或者调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串之中还能调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果模板字符串中的变量没有声明，将报错。如果大括号中的值不是字符串，将按照一般的规则（toString）转为字符串。</p><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>ES5 字符串的实例方法很有限，基本就是 indexOf 了，在 ES6 新加入了一些：</p><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li><li>repeat()：返回一个新字符串，表示将原字符串重复 n 次。</li></ul><p>在 ES2017 和 ES2019 又引入了 <code>padStart()</code> 用于头部补全，<code>padEnd()</code> 用于尾部补全和 <code>trimStart()</code> 和 <code>trimEnd()</code> 这两个方法。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与解构赋值默认值结合使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有提供参数，函数 foo 的参数默认为一个空对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>ES6 引入 rest 参数（形式为 <code>...变量名</code>），用于获取函数的多余参数，本质是个数组，跟 Java 很类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>其次还有函数的 <code>name</code> 属性，返回该函数的函数名。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>怎么说呢，这个其实就是简化的匿名函数，用在回调的地方非常好用。箭头函数有几个使用注意点。</p><ol><li>函数体内的 <code>this</code> 对象，就是<strong>定义时所在的对象</strong>，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li><li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。</li></ol><p>其中第一点尤其值得注意。<code>this</code> 对象的指向是可变的，<strong>但是在箭头函数中，它是固定的</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>关于 this 的这个问题，版本对比为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用情况</span></span><br><span class="line"><span class="comment">// 对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。<br>在 Vue 很多使用中，如果你使用箭头函数就不需要再在尾部来一个 <code>.bind(this)</code> 了。</p><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>使用 <code>JSON.stringify()</code> 方法可以将对象转为字符串类型的 json 格式。</p><hr><p>关于 apply 和 call ，ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。<br>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<br>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。<br>一般来说，<strong>它们的作用就是改变 this 的指向，或者借用别等对象的方法</strong>，那么它和 bind 什么区别呢？</p><blockquote><p>在 EcmaScript5 中扩展了叫 <code>bind</code> 的方法，在低版本的 IE 中不兼容。<br>它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。</p></blockquote><p>他们的主要区别就是：</p><p>bind 方法不会立即执行，而是<strong>返回一个改变了上下文 this 后的函数</strong>。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。<br>在参数传递上，也有一些区别，看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = func.bind(<span class="literal">null</span>,<span class="string">'linxin'</span>);</span><br><span class="line"></span><br><span class="line">func(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);            <span class="comment">// A B C</span></span><br><span class="line">func1(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);           <span class="comment">// linxin A B</span></span><br><span class="line">func1(<span class="string">'B'</span>, <span class="string">'C'</span>);                <span class="comment">// linxin B C</span></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="string">'linxin'</span>);      <span class="comment">// linxin undefined undefined</span></span><br></pre></td></tr></table></figure><p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是<strong>在 bind 中参数的基础上再往后排</strong>。</p><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>对于数组的克隆与合并，有了扩展运算符也变得简单多了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure><p>ES5 中只能使用 concat 函数间接达到目的。<br>字符串也可以被展开：<code>[...&#39;hello&#39;]</code>，还可以用于 Generator 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>现在对象的属性有了更简洁的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说就是<strong>当 key 和 val 一样时，可以进行简写</strong>。其实，方法也可以进行简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种写法会非常的简洁，另外常用的还有 setter 和 getter，就是采用的这种方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点就是简洁写法的属性名总是字符串。在对象定义上，也变得更加灵活了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的<strong>原型对象</strong>。</p><hr><p>另外，对象也有扩展运算符，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ll = &#123;<span class="attr">name</span>:<span class="string">'loli'</span>, <span class="attr">age</span>: <span class="number">12</span>, getVal(val)&#123;<span class="built_in">console</span>.log(val)&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> test = &#123;...User, <span class="attr">dd</span>:<span class="string">'dd'</span>&#125;</span><br><span class="line">test.getVal(test.dd)</span><br></pre></td></tr></table></figure><p>简单说就是把对象里的方法进行拷贝，Vuex 中的这种写法算是明白了吧，Vuex 中，我们经常用类似 <code>...mapState({xxx})</code> 的写法，很显然 mapState 函数返回的是一个对象，然后我们使用“展开运算符”将其展开了。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>变量数组或者对象，可以使用 forEach 这个函数（ES5 中也可使用）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(alert);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(item)&#125;)</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><blockquote><p>使用 forEach 函数进行遍历时，中途无法跳过或者退出；<br>在 forEach 中的 return、break、continue 是无效的。</p><p>see：<a href="https://www.jianshu.com/p/bdf77ee23089" target="_blank" rel="noopener">https://www.jianshu.com/p/bdf77ee23089</a></p></blockquote><p>然后遍历除了基本的 fori，还有两种：<code>for...in</code> 和 <code>for...of</code> ，那么他们俩有啥区别呢？</p><ol><li>推荐在循环对象属性的时候，使用 <code>for...in</code>，在遍历数组的时候的时候使用 <code>for...of</code>。</li><li><code>for...in</code> 循环出的是 key，<code>for...of</code> 循环出的是 value</li><li>注意，<code>for...of</code> 是 ES6 新引入的特性。修复了 ES5 引入的 <code>for...in</code> 的不足</li><li><code>for...of</code> <strong>不能循环普通的对象</strong>，需要通过和 <code>Object.keys()</code> 搭配使用</li></ol><p>下面是一段示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArray = [<span class="string">'a'</span>,<span class="number">123</span>,&#123;<span class="attr">a</span>:<span class="string">'1'</span>,<span class="attr">b</span>:<span class="string">'2'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;aArray[index]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// &#123;a: "1", b: "2"&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 for...of 遍历 Map，它部署了 Iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>作用于数组的 <code>for-in</code> 循环除了遍历数组元素以外，还会遍历自定义属性。<br><code>for...of</code> 循环不会循环对象的 key，只会循环出数组的 value，因此 <code>for...of</code> 不能循环遍历<strong>普通对象</strong>，对普通对象的属性遍历推荐使用 <code>for...in</code></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>某次，遇到一个做累加的需求，用传统的方式肯定是没问题，但是我想到既然是动态语言，就没有什么骚操作？<br>结果搜了一下，确实有很多骚操作，还有直接用 eval 黑魔法的，不过，我觉得比较优雅的就是 reduce 方法了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>总感觉似曾相识，不知道在哪里用过，也许是 J8 的 Lambda 吧，这样看来 reduce 可以做的东西就多了。</p><h2 id="forEach与map"><a href="#forEach与map" class="headerlink" title="forEach与map"></a>forEach与map</h2><p>MDN 上的描述：</p><blockquote><p><code>forEach()</code>：针对每一个元素执行提供的函数 (executes a provided function once for each array element)。</p><p><code>map()</code>：<strong>创建一个新的数组</strong>，其中每一个元素由调用数组中的每一个元素执行提供的函数得来 (creates a new array with the results of calling a provided function on every element in the calling array)。</p></blockquote><p><code>forEach</code> 方法不会返回执行结果，而是 <code>undefined</code>。也就是说，<code>forEach()</code> 会修改原来的数组。而 <code>map()</code> 方法会得到一个新的数组并返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组中的数据翻倍</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (arr[index] = num * <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubled = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果都为： [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>如果你习惯使用函数是编程，那么肯定喜欢使用 <code>map()</code>。因为 <code>forEach()</code> 会改变原始的数组的值，而 <code>map()</code> 会返回一个全新的数组，原本的数组不受到影响。<br>总之，能用<code>forEach()</code>做到的，<code>map()</code>同样可以。反过来也是如此。<br>一般来说，使用 map 速度会更快，测试地址：<a href="https://jsperf.com/map-vs-foreach-speed-test" target="_blank" rel="noopener">https://jsperf.com/map-vs-foreach-speed-test</a></p><h2 id="Class语法"><a href="#Class语法" class="headerlink" title="Class语法"></a>Class语法</h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。<br>基本上，ES6 的 <code>class</code> 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>class</code> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于做静态语言后端的我，果然还是 ES6 的写法更舒服。</p><blockquote><p>定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p></blockquote><p>既然说 class 只是一个语法糖，那么我们就要深入一点看看了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************分割线********************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure><p>类的数据类型就是函数，类本身就指向构造函数。<br>构造函数的 <code>prototype</code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面。<br>类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致。<br>生成实例对象如果忘记加上 <code>new</code>，像函数那样调用 <code>Class</code>，将会报错。<br>类不存在变量提升（hoist），也就是没办法先使用后定义。<br>此外还有很多需要注意的点，不过我认为我知道这一部分就足够了，了解更多就去看阮一峰的书吧。</p><h2 id="Module语法"><a href="#Module语法" class="headerlink" title="Module语法"></a>Module语法</h2><blockquote><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p></blockquote><p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<strong>编译时就能确定模块的依赖关系</strong>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载 <code>fs</code> 模块（即加载 <code>fs</code> 的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。<br>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="comment">// 仅加载三个方法（函数）</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。<br>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><strong>一个模块就是一个独立的文件</strong>。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。<br>下面展示一下几种 export 的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种（推荐）</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, year &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数或者类或者对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出函数自定义名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系，所以你不能直接输出一个值，例如数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><p><code>export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数名</span></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br><span class="line">a.foo = <span class="string">'hello'</span>; <span class="comment">// 合法操作（非常不建议）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="comment">// 通过 别名.函数名 调用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br></pre></td></tr></table></figure><p><code>import</code> 命令输入的变量都是只读的，因为它的本质是输入接口。<br>注意，<code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行，同时 <code>.js</code> 后缀可以省略。<br>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>为了给用户提供方便，让他们不用阅读文档就能加载模块（不需要知道名字），就要用到 <code>export default</code> 命令，为模块指定默认输出。<br>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认与非默认方法</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>这时 <code>import</code> 命令后面，不使用大括号。显然，一个模块只能有一个默认输出，因此 <code>export default</code> 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 <code>export default</code>命令。<br>本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字。正是如此所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>静态化固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。<br>如果 <code>import</code> 命令要取代 Node 的 <code>require</code> 方法，这就形成了一个障碍。<strong>因为 <code>require</code> 是运行时加载模块，<code>import</code> 命令无法取代 <code>require</code> 的动态加载功能</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure><p>因此，有一个<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">提案</a>，建议引入 <code>import()</code> 函数，完成动态加载，对于这个import  函数，我就不多进行了解了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于 a 标签默认行为（href 跳转）：<br>常见的阻止默认行为的方式：<code>&lt;a href=&quot;javascript:void(0);&quot;  onclick= &quot;myjs( )&quot;&gt;  Click Me  &lt;/a&gt;</code><br><strong>函数 onclick 要优于 href 执行</strong>，而 void 是一个操作符，<code>void(0)</code> 返回 undefined，地址不发生跳转，使用 <code>javascript:;</code> 也是一样的效果。<br>在 onclick 函数中，如果返回的是 true，则认为该链接发生了点击行为；如果返回为 false，则认为未被点击。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先集百家之介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。&lt;/p&gt;
&lt;p&gt;ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 ES 已经到达了 ES2018 版本，Google 的 V8 引擎支持率 100%，其他的并不友好，而我们常用 &lt;strong&gt;JavaScript&lt;/strong&gt; 稳定版本的实现目前在 ES2016 版本，所以这里主要学习 ES6 的特性了。
    
    </summary>
    
      <category term="Web" scheme="http://bfchengnuo.com/categories/Web/"/>
    
    
      <category term="JavaScript" scheme="http://bfchengnuo.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue核心使用总结</title>
    <link href="http://bfchengnuo.com/2019/06/02/Vue%E6%A0%B8%E5%BF%83%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://bfchengnuo.com/2019/06/02/Vue核心使用总结/</id>
    <published>2019-06-02T13:13:05.000Z</published>
    <updated>2019-09-25T13:13:02.727Z</updated>
    
    <content type="html"><![CDATA[<p>将之前的 Vue 学习笔记进行了整理，即使仅是 Vue 核心的功能发现也还是比较有货的，跟后端的学法都是一样的，关键理解其设计思想，上手使用都不难，关键是能 get 到为什么这样设计，这样设计什么好处，这个有点玄学，全靠自己理解了 o(￣▽￣<em>)ゞ))￣▽￣</em>)o。<a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vueJS 是一种轻量级的 MVVM 框架，它同时吸收了 react 和 angular 的优点，强调了 react 组件化的概念，可以轻松的实现数据和展现的分离。也吸收了 angular 灵活的指令和页面操作的一些方法。</p><p>Vue 引入建议放在头部，避免发生抖屏的现象。<br>Vue 使用后不再需要任何 Dom 操作，Vue 接管了 Dom 的操作。<br><strong>Vue 只会处理挂载点下的内容</strong></p><p>当数据发生变化时（比如被函数改变），Vue 会自动去更新页面的数据，整个过程不需要操作 Dom</p><blockquote><p>关于 MVC、MVP、 MVVM 的介绍：<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p></blockquote><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><p>首先，来复习下 Vue 最常用的一些东西，基本语法和模式</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>学习 Vue 首先接触的可能是挂载点、模板、Vue 实例等这些词，先来看一段示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-Hans"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 放在头部引用，避免抖屏现象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"num"</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="xml">        // template: "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">          msg: <span class="string">"Hello World!"</span>,</span></span><br><span class="line"><span class="undefined">          num: 123</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">          handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert("test")</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.msg = <span class="string">"Loli"</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是标准的一个 HTML，其中 script 部分是 Vue 的主要施展的部分，通过 <code>new Vue()</code> 出的对象自然就称作是<strong>实例</strong>了。<br>其中，那个 id 为 root 的 div 就可以称作是<strong>挂载点</strong>；也可以说是 Vue 实例中 el 所指向的元素。<br>在挂载点内部的内容，都可以称作是<strong>模板内容</strong>；同时模板也可以写在 Vue 实例中，效果是一样的。</p><p>这里补充一个生命周期的图示：</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期"></p><h3 id="数据指令及处理"><a href="#数据指令及处理" class="headerlink" title="数据指令及处理"></a>数据指令及处理</h3><p>通过两对花括号的方式取值方式我们称之为“<strong>插值表达式</strong>”.<br>在实例定义的方法中，可以直接通过 <code>this.name</code> 的方式来获取定义的数据对象（data 属性里的），相当于是个别名了，不需要太在意 this 指向，Vue 会进行进一步的处理的，简单理解为代表本组件即可。</p><p>指令：</p><ul><li><p><strong>v-text</strong><br>标签的内容就是 v-text 指向的变量，例如：<code>&lt;p v-text=&quot;num&quot;&gt;&lt;/p&gt;</code><br><strong>特殊字符会被转义</strong></p></li><li><p><strong>v-html</strong><br>和 v-text 基本一致，区别在于它不会转义那些 HTML 字符</p></li><li><p><strong>v-on(@)</strong><br>绑定事件函数，比如点击事件（v-on:click），函数的定义可以写在实例的 methods 对象内。<br>其中 <code>v-on:</code> 可以简写为 <code>@</code></p></li><li><p><strong>v-bind(:)</strong></p><p>属性绑定，和双大括号类似，只不过是用在属性里的，例如：<code>&lt;div v-bind:title=&quot;is + title&quot;&gt;Test&lt;/div&gt;</code><br>同样，它可以简写为 <code>:</code></p></li></ul><p>使用了指令后，比如 <code>v-xxx:</code> 之类的形式，后面跟的是一个 js 表达式，也就是说可以使用 js 中的基本表达方式，比如 <code>+</code> 之类的连接符。</p><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>上面一顿操作都是单向绑定的，也就是说实例的数据决定页面的显示，但是页面的显示不能改变实例中的数据，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">"is Content"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里就需要使用模板指令：v-mode，使用格式直接是：<code>v-model=&quot;msg&quot;</code></p><h3 id="计算属性与侦听器"><a href="#计算属性与侦听器" class="headerlink" title="计算属性与侦听器"></a>计算属性与侦听器</h3><p>计算属性就是某一个属性的结果是其他几个属性值计算得出来的，并且在其他属性没有改变的情况下，再次使用会直接返回缓存值，避免重复计算。<br>侦听器就是监听某一个数据的变化，一旦发生变化就执行相应的逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#cal"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        firstName: <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="string">""</span>,</span></span><br><span class="line"><span class="undefined">        count: 0</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      computed: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性声明</span></span></span><br><span class="line"><span class="javascript">        fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 再次使用 fullName 时，如果这两个变量没有改变会使用缓存值</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 避免重复进行计算</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// get set 的方式</span></span></span><br><span class="line"><span class="undefined">        test: &#123;</span></span><br><span class="line"><span class="undefined">          get () &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          set (newVal) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      watch: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 侦听器，也会有缓存</span></span></span><br><span class="line"><span class="javascript">        firstName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：不要忘记使用 this，要不然找不到，Vue 会自动处理这个“别名”。<br>计算属性 computed 可以使用 get 和 set，用来提供获取和设置的情况。</p><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h4 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h4><p>来看 <code>v-if</code> 和 <code>v-show</code></p><p>他们<strong>控制标签的显示和隐藏</strong>，当为 true 时就显示，false 时就隐藏，他们的区别在于，<strong>v-if 的表现形式是将标签直接删除，v-show 则是通过 display 来实现。</strong></p><blockquote><p>这可能带来了 dom 复用的问题，例如 input 框不会清空，这种情况下可以使用 key 值来绑定唯一，这样 Vue 就会不复用了。</p></blockquote><p><strong>性能上来说，频繁更改的话 v-show 更好，如果只是改一次那么 v-if 可能就更好了。</strong><br>其次还支持紧贴 v-if 的 v-else-if 和 v-else</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>然后就是 v-for 用来遍历数据的，举个例子：</p><p><code>&lt;li v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;</code></p><p>list 就是定义的数组数据，item 是每次遍历的值，index 是索引，使用 <code>:key</code> 可以提高效率，<strong>但是要保证 key 的唯一</strong>；所以这里我加了个 index，如果 item 是唯一的那么可以直接使用 item：</p><p><code>&lt;li v-for=&quot;item of list&quot; :key=&quot;item&quot;&gt;&lt;/li&gt;</code></p><p>如果还要对其进行排序之类的操作，那么使用 index 也不是很合适了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myClick"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;li v-for="item of list" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        text: <span class="string">"我是内容"</span>,</span></span><br><span class="line"><span class="javascript">        flag: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">        list: [1,2,3]</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        myClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h3><p>关于样式的控制，可以使用 class 对象绑定： <code>:class=&quot;{className: isActivated}&quot;</code> 然后通过控制 isActivated 变量来控制 class 的显示或隐藏。<br>还可以通过 <code>:class=&quot;[activated, className]&quot;</code> 这样通过 activated 这个变量来控制。<br>如果是内联样式（<code>:style</code>），可以直接引用一个 js 对象，在对象里面定义 css 样式就行，同样也可以使用数组来挂载多个对象。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>当某一块的布局复杂后就需要抽取出来，形成了一个模板，模板又分为全局的和局部的，它们的使用也各不相同，这一个个的模板加上一下逻辑就可以当作是一个组件，在下面的代码中可以体现出来。<br>因为模板中取不到外部的属性，所以使用了属性传值的方式来将数据传进去，在模板中接收一下就可以使用了。<br><strong>模板也可以看作是一个实例，可以说在一个 Vue 项目中，是由很多很多 Vue 实例（组件）组成的</strong>。<br>根据“发布-订阅”模型，可以在子组件中向父组件发布消息，然后父组件可以监听子组件的自定义消息，然后调用相应的方法来进行处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'todo-item'</span>, &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收传入的属性</span></span></span><br><span class="line"><span class="javascript">      props: [<span class="string">'content'</span>, <span class="string">'index'</span>],</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 因为模板也是一个实例可以定义事件</span></span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 向外发布一个自定义事件（订阅-发布模型）, 并且将 index 传递过去</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$emit(<span class="string">'delete'</span>, <span class="keyword">this</span>.index)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义局部组件,必须要在 Vue 实例中声明才能用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> TodoItem = &#123;</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span>item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// components: &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   // 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   'todo-item': TodoItem</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        mSubmit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        handleDelete: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：<strong>模板中要求只能有一个根标签，所以在最外层一般都会套一个 div</strong></p><p>总之，当年看到奇奇怪怪的 HTML 标签时，一般就是一个 Vue 组件了，一个组件一般会写在一个 xxx.vue 文件里，通过 ES6 的 import 语法导入进行使用。</p><blockquote><p>我们导入的组件（component）起的名字一般是跟组件的 name 属性对应的，在 HTML 中使用组件直接用这个名字的标签即可，因为 HTML 对大小写不敏感，所以使用 <code>-</code> 进行转换，例如：<br>name：todoList  =&gt;  <code>&lt;todo-list&gt;&lt;/todo-list&gt;</code></p></blockquote><h3 id="组件参数校验"><a href="#组件参数校验" class="headerlink" title="组件参数校验"></a>组件参数校验</h3><p>在父子组件之间传值都已经知道了，那么接下来就看看如果子组件要对父组件传递的数据进行校验要怎么办，使用的还是子组件里的 props 属性，只不过这里由本来的字符串数组变成了对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 不是校验的话可以直接用字符串数组来标识</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// content: [Number,String]</span></span><br><span class="line">    content: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'def val'</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>补充一下这个 props 特性，也就是如果你在子组件的 props 中接收了传递的属性，那么 Vue 在视图渲染的时候就不会再在 HTML 中加上这个属性了。<br>在子组件上绑定的事件默认都是自定义事件，也就是说原生的事件可能会失效，例如在子组件标签里使用 <code>@click</code> 是无效的，不过你可以在子组件的模板里来绑定，这样就不是自定义事件了。<br>触发自定义事件就是手动的调用 emit 了；但是有些时候就想用子组件的原生事件，就想让它生效怎么办，也是有办法的，只需要一点点的改动：<code>@click.native=&quot;fun&quot;</code>。<br>同时，为了解决手机端兼容问题，可以使用类似 <code>@touchstart.prevent</code> 的方式阻止事件的默认行为。</p><h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><p>这里主要说的就是非父子组件之间的传值，例如父与子的子、兄弟组件，虽然可以间接完成，但是过于麻烦，由于 Vue 的定义轻量级，它并不具备解决这个问题的能力，但是我们可以借助其他的方案。</p><ol><li>Vue 官方推荐的 Vuex 框架。</li><li>发布-订阅模式，也就是总线机制，可以理解为是观察者模式。</li></ol><p>一般情况下，都是使用 Vuex，非常简单的项目可以考虑下 bus</p><h4 id="总线模式"><a href="#总线模式" class="headerlink" title="总线模式"></a>总线模式</h4><p>这里仅说一下总线的这种方式，其实就是在所有子组件上挂一个 Vue 实例，然后通过这个实例来进行事件的发送与处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 bus</span></span><br><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 子组件的 data 必须是函数</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      selfContent: <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    content: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div @click='handleClick'&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 向总线发送事件</span></span><br><span class="line">      <span class="keyword">this</span>.bus.$emit(<span class="string">"change"</span>, <span class="keyword">this</span>.selfContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期，挂载时触发</span></span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> this_ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.bus.$on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      this_.selfContent = val;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就是通过一个生命周期来完成的。</p><blockquote><p>在 Vue 中，类似 <code>vm.$xx</code> 这种的调用，后面跟一个 <code>$</code> 符号，意思是调用 Vue 实例的方法。</p></blockquote><h4 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h4><p>简单说 Vuex 就是一个单向数据的改变流，把需要改变的数据单独存储起来，然后通过指定的流程来进行更改。</p><p><img src="https://vuex.vuejs.org/vuex.png" alt=""></p><p>一般情况下，我们在单独的一个 js 中设置 Vuex，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: localStorage.name || <span class="string">"xxx"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeName (ctx, name) &#123;</span><br><span class="line">      <span class="comment">// 调用 mutations</span></span><br><span class="line">      ctx.commit(<span class="string">'changeName'</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeName (state, name) &#123;</span><br><span class="line">      state.name = name</span><br><span class="line">      <span class="comment">// 本地存储 (低版本浏览器或者隐身模式可能会抛异常)</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        localStorage.name = name</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在 App 入口 js 中进行引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样在任何子组件中就可以通过 <code>this.$store.state</code> 来获取 Vuex 中 state 的数据啦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发修改</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'changeName'</span>, name)</span><br><span class="line"><span class="comment">// 如果没有异步获取数据逻辑，可以直接调用 mutations</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'changeName'</span>, name)</span><br></pre></td></tr></table></figure><p>其中我们还使用了本地存储 localStorage。</p><p>实际中，大多会拆分 index.js 将 state、actions、mutations 单独放在一个文件中。</p><hr><p>另外，Vuex 还提供了高级 API 允许我们更精简的写代码，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick (name) &#123;</span><br><span class="line">    <span class="comment">// 使用 Vuex 改变全局数据</span></span><br><span class="line">    <span class="comment">// this.$store.dispatch('changeName', name)</span></span><br><span class="line">    <span class="keyword">this</span>.changeName(name)</span><br><span class="line">    <span class="comment">// 或者可以直接调用 mutations</span></span><br><span class="line">    <span class="comment">// this.$store.commit('changeName', name)</span></span><br><span class="line">    <span class="comment">// 跳转回首页</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 展开运算符，可以直接调用 changeName 方法了</span></span><br><span class="line">  ...mapActions([<span class="string">'changeName'</span>])</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用 Vuex 的便捷映射, 数组、对象皆可</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    name: <span class="string">'loli'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的 Vuex 操作就是这些了。</p><h3 id="使用插槽"><a href="#使用插槽" class="headerlink" title="使用插槽"></a>使用插槽</h3><p>简单来说，当子组件有一部分内容是由父组件传递过来的 dom 来显示的时候，就可以使用插槽来处理。<br>要解决的问题，之前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'content'</span>],</span><br><span class="line">  <span class="comment">// ES6 语法</span></span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;Dear&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;div v-html="this.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;&lt;/child&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出子组件里的内容会被 slot 标签插入。<br>如果需要将子组件里内容分片，那么也是可以的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"one"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"two"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是稍微改变了下，进行了标识。</p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>最后来看一下高级用法：作用域插槽，从例子开始：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">show</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 固定写法，template 开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">show</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'show'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">        list: [1,2,3,4]</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                &lt;slot </span></span><br><span class="line"><span class="javascript">                  v-<span class="keyword">for</span>=<span class="string">"item of list"</span></span></span><br><span class="line"><span class="undefined">                  :item=item</span></span><br><span class="line"><span class="javascript">                &gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>稍微解释一下，在 template 中，使用 for 来“循环插槽”，将每次循环的数据绑定到了 item 变量，然后视图中通过 slot-scope 来接收。</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>这里说的是动态的切换组件，可以手动实现，也可以通过 Vue 提供的 component 标签来实现，例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">'type'</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-one</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-one'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-one</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-two</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-two'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-two</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-one'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-two'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="string">'child-one'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">      handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.type = <span class="keyword">this</span>.type === <span class="string">'child-one'</span> ? <span class="string">'child-two'</span> : <span class="string">'child-one'</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>component 和下面使用 v-if 控制的标签是一样的，因为每次切换都需要销毁、重新创建，所以性能上会有点损耗，可以在模板上使用 <code>v-once</code> 来将实例放到内存中，这样就省去了创建、销毁的时间。</p><h2 id="使用脚手架"><a href="#使用脚手架" class="headerlink" title="使用脚手架"></a>使用脚手架</h2><p>官方提供的安装和初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装 vue-cli</span><br><span class="line">npm install --global vue-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>因为是采用的 webpack 的方式，所以方便了很多，直接可以在浏览器中进行预览。<br>这里就可以看出模块化了，其中 Vue 实例都集中放在了 <code>.vue</code> 结尾的文件中，vue  文件分成三部分，模板、js代码、样式。<br>工程的入口是根目录下的 index.html 文件，其中有个 id 为 app 的 div，这就是 Vue 的挂载点了，然后看主要的代码在 src 中。<br>在 main.js 中创建了 Vue 实例，也就是所谓的启动配置，并且定义了模板，导入了相应的子模板，这里就来修改下看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块化语法</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 引入子模板</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和上面写的差不多，创建了一个 Vue 实例，挂载到 app 这个 id 下面，模板采用的是实例内定义的，里面就是引用了个 <code>&lt;App/&gt;</code> ，也就是 <code>App.vue</code> 中定义的那一堆。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">'./components/TodoItem'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 相当于子模板的定义区</span></span></span><br><span class="line"><span class="javascript">    name: <span class="string">'App'</span>,</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="string">'todo-list'</span>: TodoItem</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// vue 文件中 data 只能使用函数来定义</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 简便写法</span></span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      mSubmit () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      handleDelete (index) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 vue-cli 中，当写一个实例的数据的时候使用的是函数方式，而不再是对象！！<br>然后，App 这个模块中又引入了一个 TodoItem 的模板，就是曾经的子模板，完整的例子到 GitHub 仓库查看。<br>再次说明，Vue 底层会处理 this 的指向，不需要太过担心，指的就是此实例.</p><h3 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h3><p>使用路由来根据访问 url 动态切换的目的，在 App 主入口加入 <code>&lt;router-view/&gt;</code> 即可启用，在 <code>src\router\index.js</code> 进行配置路由规则即可。<br>其中路由规则的 url 映射可以使用变量来进行区分，例如：<code>/detail/:id</code> ，然后可以在子组件通过 <code>this.$route.params.id</code> 来获得变量。<br>使用 <code>&lt;router-link to=&quot;/list&quot;&gt;跳转&lt;/router-link&gt;</code> 可进行单页应用的跳转，在跳转过程中不需要请求新的 HTML，但是首屏加载会慢一点，SEO 也不是很好。<br>除了使用标签来路由，在 JS 环境下，可以使用编程式导航：<code>this.$router.push(&#39;/&#39;)</code></p><hr><p>为了防止路由调整后滚动条不会重置，官方文档的解决方案是在路由的 js 配置中加入下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就解决了跳转后滚动条错乱的情况。</p><h3 id="使用Axios发送请求"><a href="#使用Axios发送请求" class="headerlink" title="使用Axios发送请求"></a>使用Axios发送请求</h3><p>既然都用 Vue 了，那么基本是前后端分离的架构，于是 ajax 请求必然少不了，一般情况在 Vue 中处理请求都是用 Axios 这个库，直接 npm 安装后导入就可以用了。<br>这里说下基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  getHomeInfo () &#123;</span><br><span class="line">    Axios.get(<span class="string">'/api/index.json?city='</span> + <span class="keyword">this</span>.$store.state.city)</span><br><span class="line">      .then(<span class="keyword">this</span>.getHomeInfoCallback)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getHomeInfoCallback (res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data.ret &amp;&amp; res.data.data) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.data.data</span><br><span class="line">      <span class="keyword">this</span>.swiperList = data.swiperList</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>嗯，基本上就是这个样子了，then 表示才成功后回调，catch 表示失败后回调。<br>注意下，成功或者失败的 res 都会给你包一层，<code>res.data</code> 才是真正响应的东西。</p><h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>因为一般是前后端分离，有时候后端的接口还没开发完，这时候我们可以改 url，但是这样之后你还得再改回去，特别麻烦，webpack 提供了代理的工具，将我们 Axios 发送的请求按照指定规则进行转发，例如我们可以使用静态文件来模拟数据。<br>一般在 webpack 的配置文件里这样写：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">  // Paths</span><br><span class="line">  assetsSubDirectory: 'static',</span><br><span class="line">  assetsPublicPath: '/',</span><br><span class="line">  proxyTable: &#123;</span><br><span class="line">    // 添加 URL 的替换，转发为本地静态文件</span><br><span class="line">    '/api': &#123;</span><br><span class="line">      target: 'http://localhost:8080',</span><br><span class="line">      secure: false,  // 如果是https接口，需要配置这个参数</span><br><span class="line">      changeOrigin: true,  // 是否跨域</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        '^/api': '/static/mock'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是将 url 重写，然后转发到你对应的地址。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>这里列举下在项目中使用的一些特性或技术，除了动画，其他还是用的非常多的。</p><h3 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h3><p>最简单的淡出淡然，可以使用 transition 标签进行包裹，作用简单说就是：<br>在开始前，会给被包裹的标签增加两个 css 样式：<strong>v-enter 和 v-enter-active</strong>，当动画运行到第二帧的时候会去除 v-enter 这个样式，再增加一个 v-enter-to 样式；最后动画结束时去除所有样式。<br>在使用 transition 标签的时候，如果加了 name 属性，那么样式就以你定义的名字作为前缀代替 v。<br>上面说的是显示的动画，隐藏的过度也是类似，只需要把 enter 换成 leave 就可以了。<br>如果想自定义 css 的名字，可以使用 <strong>enter-active-class</strong> 属性来定义，其他同理。</p><p>或者可以使用 <code>animated.css</code> 提供的样式，快速开发，使用起来非常简单，引入不要的 css 库，然后利用上面所说来自定义 css 名字，格式就是：<code>animated 动画名</code> 名字可以在官网找，其实就是封装了下 css3 的 @keyframes 特性。</p><p>PS：想要初始化的时候就展示动画需要使用 appear 属性来配合。</p><hr><p>除了使用 css 来做动画，也可以使用 js 实现，在标签中通过 <strong>@before-enter、@enter、@after-enter</strong> 等来绑定方法，会传递一个参数过去，也就是包裹的 dom 元素 el。<br>其中 @enter 会传递两个参数，第一个与上面一样，第二个是个函数引用 done，在动画完成后调用一下它告诉 Vue 动画结束，这样就会再继续执行下面的 after。<br>如果嫌麻烦，可以使用像 <strong>Velocity</strong> 这样的 js 动画库。</p><hr><p>对于列表动画，可以使用 transition-group 标签来包裹，其实它的作用就是将里面的循环每一个都包裹一个 transition 标签。</p><h3 id="优化相关"><a href="#优化相关" class="headerlink" title="优化相关"></a>优化相关</h3><p>使用 <code>&lt;keep-alive&gt;</code> 标签 Vue 会自动帮你进行优化请求，例如 ajax 请求，如果启用了 <code>&lt;keep-alive&gt;</code> 标签，当第二次进行 ajax 请求时，会直接从内存里拿数据（mounted 函数不会执行）。<br>一般就直接在 App.vue 中使用了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启用缓存,重新路由后不再发请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"Detail"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'App'</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后有的数据我们是不想进行缓存的，所以就可以使用 exclude 指定组件的名字（就是 name 属性）进行排除。<br>或者可以使用生命周期函数 activated 来刷新数据（可能需要进行一定的逻辑判断·），这个函数在页面重新加载时执行。</p><hr><p>默认情况下 webpack-server 是不支持 ip 访问的，如果就想 ip 访问，可以在 <strong>package.json</strong> 文件中的 dev 加一个配置：<code>&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot;</code></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用 v-for 无论是遍历数组还是遍历对象，直接使用下标增加、修改数组 View 不一定会刷新，<strong>想要视图跟着刷新就必须用方法来增加</strong>，例如数组的 pop、push 等方法；对于对象的属性增加，可以使用 Vue 的全局方法 set（<code>Vue.set(obj, key, val)</code> 或者使用实例的 set 方法，<code>vm.$set(obj, key, val)</code>），当然 set 方法也可以用来修改数组 key 就是下标了。</p><hr><p>使用 v-for 的时候，为了不引入多余的 HTML 结构，可以使用 template 标签占位，在这个标签里使用 v-for 这样渲染后就没有痕迹了。</p><hr><p>可以通过绑定 class 属性的方式来改变样式，支持对象、数组。</p><hr><p>解决组件与 HTML5 规范冲突，可以使用 is 属性来标识其真正的组件，例如：<code>&lt;tr is:&quot;row&quot;&gt;&lt;/tr&gt;</code>。<br>使用 Vue 提供的标签也是类似，例如：<code>&lt;router-link tag=&quot;li&quot; :to=&quot;/index/&quot;&gt;</code></p><hr><p>子组件里，data 属性必须是函数，可以是这个函数返回一个对象，里面包含一些属性；这样也就达到了多个子组件数据互不影响的目的。</p><hr><p>必要的操作 Dom 时，通过 ref 属性来标识，在事件中可以 <code>this.$refs.name</code> 来获取 Dom 元素；如果 ref 加在了组件上，那么得到的就是这个组件的引用了。<br>特殊情况下，如果 ref 和 v-for 连用，那么使用 <code>:ref=</code> 的形式，并且获取的是数组，需要 <code>name[0]</code> 使用。</p><hr><p>子组件向父组件传值是通过事件的形式，一般来说在子组件中使用 <code>this.$emit(&#39;name&#39;, data)</code> 来进行手动触发；配合子组件的 HTML 标签中使用 <code>@name=&quot;fun&quot;</code> 来进行监听。</p><hr><p>在导入语法中，使用 <code>@</code> 来表示 src 目录；在组件样式编写的时候，如果不想影响到其他组件的样式，在 style 标签里加一个 scoped 即可。<br>使用 @import 导入 css 变量域，<code>~</code> 固定前缀：<code>@import &#39;~@style/varibles.styl&#39;</code><br>如果使用 stylus 语法，可以使用 <code>&gt;&gt;&gt;</code> 来做样式穿透。</p><hr><p>在 webpack 的配置文件里，可以使用 alias 来定义别名，快速引用文件夹，例如默认的 <code>@</code> 表示 src 就是这样设置的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将之前的 Vue 学习笔记进行了整理，即使仅是 Vue 核心的功能发现也还是比较有货的，跟后端的学法都是一样的，关键理解其设计思想，上手使用都不难，关键是能 get 到为什么这样设计，这样设计什么好处，这个有点玄学，全靠自己理解了 o(￣▽￣&lt;em&gt;)ゞ))￣▽￣&lt;/em&gt;)o。
    
    </summary>
    
      <category term="Web" scheme="http://bfchengnuo.com/categories/Web/"/>
    
    
      <category term="前端" scheme="http://bfchengnuo.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法之美-排序</title>
    <link href="http://bfchengnuo.com/2019/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F/"/>
    <id>http://bfchengnuo.com/2019/04/03/算法之美-排序/</id>
    <published>2019-04-03T14:48:50.000Z</published>
    <updated>2019-04-09T09:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法可能就是排序，大学里的 C 入门就是写的它吧？排序是非常重要的，但是排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。<br>我这里就只看最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<a id="more"></a></p><table><thead><tr><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>冒泡、插入、选择</td><td>O(n^2)</td><td>是</td></tr><tr><td>快排、归并</td><td>O(nlogn)</td><td>是</td></tr><tr><td>桶、计数、基数</td><td>O(n)</td><td>否</td></tr></tbody></table><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）就是特指空间复杂度是 O(1) 的排序算法，可以理解为<strong>不需要开辟很多空间的算法</strong>。</p><p>然后还有一个<strong>稳定性</strong>的概念，简单说就是<strong>排序前后，相等的元素还是原来的顺序不变</strong>，这个性质其实很重要，实际中我们都是对对象的某个属性排序，如果还能保证顺序就省事很多。<br>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？<br>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。<br>两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作<strong>相邻的两个数据</strong>。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置</strong>，重复 n 次，就完成了 n 个数据的排序工作。</p><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// 表示有数据交换</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<strong>原地排序</strong>算法。</p><p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是<strong>稳定的</strong>排序算法。</p><p>对于一个给定的初始序列，移动操作的次数总是固定的。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>描述下过程就是：首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间；<br>初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。<br>重复这个过程，直到未排序区间中元素为空，算法结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 要插入的数</span></span><br><span class="line">    <span class="keyword">int</span> value = arr[i];</span><br><span class="line">    <span class="comment">// 有序区间的末尾</span></span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    arr[j + <span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟练后 for 循环可以简化：</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">  array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-- ) &#123;</span><br><span class="line">  arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序</strong>算法。</p><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的</strong>排序算法。</p><p>对于一个给定的初始序列，移动操作的次数总是固定的。</p><h3 id="为什么插入更受欢迎"><a href="#为什么插入更受欢迎" class="headerlink" title="为什么插入更受欢迎"></a>为什么插入更受欢迎</h3><p>把他们循环的最多次的代码拿出来比较下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要小看少的这两句语句，在数据量大的时候，就能带来显著的差距，所以尽量做到极致的话当然会选择插入排序，另外，如果喜欢插入排序，可以看看极致的改进版：<strong>希尔排序</strong>，不过它是<strong>非稳定</strong>的。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="comment">// 只循环到倒数第二个即可，最后一个没数可比</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">        temp = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说明一下，选择排序是一种<strong>原地排序</strong>算法，但<strong>不是稳定的</strong>排序算法。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组<strong>从中间分成前后两部分</strong>，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>这就是分治思想，分而治之，跟递归思想有点像。</p><p>然后重点说下将两个已经有序的数组拼装起来，我们可以先申请一个临时数组 tmp，大小与原数组 A 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。<br>比较这两个元素 A[i] 和 A[j]，如果 <code>A[i]&lt;=A[j]</code>，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。<br>直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s1, <span class="keyword">int</span> middle, <span class="keyword">int</span> arrEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start1 = s1;</span><br><span class="line">    <span class="keyword">int</span> start2 = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arrEnd - s1 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 临时数组的索引</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= middle &amp;&amp; start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[start1] &lt;= arr[start2]) &#123;</span><br><span class="line">        tmp[k++] = arr[start1++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = arr[start2++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据，默认设为第一个剩余</span></span><br><span class="line">    <span class="keyword">int</span> start = start1;</span><br><span class="line">    <span class="keyword">int</span> end = middle;</span><br><span class="line">    <span class="keyword">if</span> (start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="comment">// 改变为第二个剩余</span></span><br><span class="line">      start = start2;</span><br><span class="line">      end = arrEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = arr[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (start1 = <span class="number">0</span>; start1 &lt;= arrEnd - s1; ++start1) &#123;</span><br><span class="line">      arr[s1 + start1] = tmp[start1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是<strong>稳定的</strong>算法，只要保证合并时稳定就好了。<br>它<strong>不是原地排序</strong>算法，所以快排更加出名一些，即使它的最好情况下的时间复杂度要优于快排。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排利用的也是分治思想，乍看和归并差不多，其实思想还是有差别的，快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。<br>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br>当区间缩小为 1 的时候就可以认为它有序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序，a是数组，n表示数组的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    quickSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">    quickSortInternally(a, p, q - <span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">    <span class="keyword">int</span> left = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = p; right &lt; r; ++right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[right] &lt; pivot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">          a[left++] = a[right];</span><br><span class="line">          a[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换 pivot，返回缩小后区间的最后一个（新 pivot）</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">    a[left] = a[r];</span><br><span class="line">    a[r] = tmp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"i="</span> + left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排并<strong>不是一个稳定的</strong>算法，它<strong>是一个原地排序</strong>算法；<br>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p><p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><p>快排 B 站有个视频讲的不错：<a href="https://www.bilibili.com/video/av39093184" target="_blank" rel="noopener">https://www.bilibili.com/video/av39093184</a></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个<strong>有序的</strong>桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p>他的时间复杂度是 O(n)，只不过对数据的要求比较苛刻。<br>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。<br>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><blockquote><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。<br>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>如果数据不能平均分，集中在一个桶里，为了避免时间复杂度的退化，那么你只能继续拆分。</p></blockquote><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。<strong>每个桶内的数据值都是相同的</strong>，省掉了桶内排序的时间。<br>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，arr 是数组，size 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">      max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个计数数组 countArr，下标大小 [0,max]，初始化为 0</span></span><br><span class="line">  <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 countArr 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    countArr[arr[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = countArr[i - <span class="number">1</span>] + countArr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组 temp，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = countArr[arr[i]] - <span class="number">1</span>;</span><br><span class="line">    temp[index] = arr[i];</span><br><span class="line">    countArr[arr[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给 arr 数组</span></span><br><span class="line">  System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（小数就先乘以倍数，负数就先加成正数）。</p><p>例如，对 50 万考生的成绩排名，假设满分是 900 最低是 0，数据范围很小，可以搞 901 个桶，然后将这些考试分布进这些桶里，<strong>并不需要排序，只需要扫描，时间复杂度是 O(n)。</strong></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？<br>对于手机号，再用之前的桶排序就不合适了，因为它太大了，刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。<br>借助稳定排序算法，这里有一个巧妙的实现思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。<br>不过要保证在每一位的排序中，<strong>算法要是稳定的</strong>。<br>每一位的排序就可以用上面的桶排序了~这样时间复杂度也是 O(n).</p><p>那么对于不等长的数据怎么排序（字符串为例）？我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据 ASCII 码，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>基数排序对要排序的数据是有要求的，需要<strong>可以分割出独立的“位”来比较，而且位之间有递进的关系</strong>，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序（O(n)）算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种<strong>原地的</strong>、<strong>不稳定</strong>的、时间复杂度为 O(nlogn) 的排序算法，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好。</p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种特殊的树，只要满足这两点，它就是一个堆：</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>第一点，堆必须是一个<strong>完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。<br>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。</p><p>关于树的介绍，我之前写过一篇，<a href="https://bfchengnuo.com/2017/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/">点我跳转</a></p><h3 id="实现一个堆"><a href="#实现一个堆" class="headerlink" title="实现一个堆"></a>实现一个堆</h3><p>完全二叉树比较适合用数组来存储，用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br>为了方便计算，通常会把数组的 1 号索引作为根，也就是前面空一个，数组中下标为 i 的节点的左子节点，就是下标为 <code>i∗2</code> 的节点，右子节点就是下标为 <code>i∗2+1</code> 的节点，父节点就是下标为 <code>i/2</code> 的节点。</p><p>通过调整，让其满足堆的特性的过程就叫“堆化”，堆化实际上有两种，从下往上和从上往下；<br>例如从下往上的，先插入到数组的最后，然后与父节点比较，不符合规则就交换，然后再跟父节点比较，直到合适为止。<br>删除的话也有一个巧妙的方法，直接把最后一个替换到删除的元素上，然后进行调整。</p><h3 id="实现堆排序"><a href="#实现堆排序" class="headerlink" title="实现堆排序"></a>实现堆排序</h3><p>首先，我们需要将数组<strong>原地</strong>建成一个堆，思路这里说一种，假设数组 size 是 10，编号就是 0-9：<br>我们从后面开始，按照规律 8、9 所对应的父节点的索引是 4，所以我们比较 4 是不是比 8 和 9 的数大，如果小就交换最大的；<br>然后继续找 6、7 对应的父节点 3，它们三个再比较，重复上面的步骤，最终就形成了符合规律的树，也就是堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span></span><br><span class="line"><span class="comment">// 需要注意，此算法数组需要空出第一个元素来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i * <span class="number">2</span>]) maxPos = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i * <span class="number">2</span> + <span class="number">1</span>]) maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">  arr[a] = arr[b];</span><br><span class="line">  arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。<br>有点类似删除操作，然后最大的就找出来了，依次往前，最终1就是个从小到大的有序数组了。</p><h3 id="总结-amp-应用"><a href="#总结-amp-应用" class="headerlink" title="总结&amp;应用"></a>总结&amp;应用</h3><p>至于说为什么堆排序不如快排效率高，可以从两点来说：<br>堆排序数据访问的方式没有快速排序友好，因为不是顺序访问，Cpu 缓存表示很无奈。<br>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序，就算是原本有序的数组，在堆化过程也会打乱的。</p><hr><ul><li><p><strong>优先级队列</strong><br>在优先级队列中，就不是先进先出了，用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。<br>很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p></li><li><p><strong>利用堆求 Top K</strong><br>我们可以维护一个大小为 K 的<strong>小顶堆</strong>，顺序遍历数组，从数组中取出取数据与堆顶元素比较。<br>如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素<strong>插入到</strong>堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。<br>这样每次只需要跟堆顶数比较即可，因为它肯定是全堆最小的。</p></li><li><p><strong>利用堆求中位数</strong><br>对于静态数据，当然数组求一下最好了，也不会变；如果是动态数据：<br>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。<br>也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。<br>如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。<br>这样，<strong>大顶堆中的堆顶元素就是我们要找的中位数</strong>。</p><p>下面就是插入新数据了，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新数据插入到小顶堆。<br>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况，这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。<br>例如将小顶堆的堆顶元素移动到大顶堆的堆顶。</p></li></ul><p>举几个例子，合并有序小文件的时候，我们可以从很多小文件先取第一个，构建一个小顶堆，每次从堆顶取出最小的放入合并后的文件，再找到这个元素来自那个文件读取下一个。<br>定时任务的时候，为了避免频繁扫描，可以根据时间来构造小顶堆，这样就知道最早执行的时间，避免多余的扫描。</p><p>PS：最后中位数说的那个约定：如果 n 是偶数，两个堆中的数据个数都是 n/2；如果 n 是奇数，大顶堆有 n/2+1 个数据，小顶堆有 n/2 个数据。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p><p>例如在 JDK8 中，排序函数并不是仅仅使用一种算法，在元素小于 47 的时候用插入排序，大于 47 小于 286 用双轴快排，大于 286 用 timsort 归并排序，并在 timesort 中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。</p><h2 id="娱乐时间"><a href="#娱乐时间" class="headerlink" title="娱乐时间"></a>娱乐时间</h2><p>下面就来给看看猴子排序、睡眠排序、面条排序（太蠢不说 2333），别笑。。。</p><h3 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h3><p>构造 n 个线程，它们和这 n 个数一一对应。初始化后，线程们开始睡眠，等到对应的数那么多个时间单位后各自醒来，然后输出它对应的数。这样最小的数对应的线程最早醒来，这个数最早被输出。等所有线程都醒来，排序就结束了。能脑洞大开想出此算法的，绝壁天才啊。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只需要输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//创建指定长度的线程数组</span></span><br><span class="line">    SortThread[] sortThreads = <span class="keyword">new</span> SortThread[arr.length];  </span><br><span class="line">    <span class="comment">//指定每个线程数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i] = <span class="keyword">new</span> SortThread(arr[i]);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//开启每个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i].start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SortThread</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.s = s;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      sleep(s*<span class="number">10</span>+<span class="number">10</span>);  <span class="comment">//睡眠指定的时间</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line"></span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//输出该数</span></span><br><span class="line">    System.out.println(s);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算需要拿到顺序的数组，也有办法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums=&#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    SleepSort.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)</span><br><span class="line">      System.out.printf(<span class="string">"%d   "</span>,n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Sleeper.idx=<span class="number">0</span>;</span><br><span class="line">    Sleeper.output=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      <span class="keyword">new</span> Sleeper(nums[i]).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 主线程需要睡足够的时间，等他们都排好</span></span><br><span class="line">      <span class="comment">// 当然可以使用其他 join、循环检查等方法</span></span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      nums[i]=Sleeper.output[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] output;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sleep_time;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(<span class="keyword">int</span> sleep_time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="keyword">this</span>.sleep_time);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    output[idx++]=<span class="keyword">this</span>.sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h3><p>随机打乱数组，检查是否排好序，若是，则输出，否则再次打乱，再检查…最佳情况 O(n)，平均 O(n*n!)，最坏可执行直到世界的尽头。<br>无限猴子定理 ：一只猴子随机敲打打字机键盘，如果时间足够长，总是能打出特定的文本，比如莎士比亚全集。<br>用伪代码表示很简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(! isOrdered(nums))</span><br><span class="line">    shuffle(nums);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法可能就是排序，大学里的 C 入门就是写的它吧？排序是非常重要的，但是排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。&lt;br&gt;我这里就只看最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。
    
    </summary>
    
      <category term="自我提升" scheme="http://bfchengnuo.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="算法" scheme="http://bfchengnuo.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java性能监控与调优</title>
    <link href="http://bfchengnuo.com/2019/03/29/Java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <id>http://bfchengnuo.com/2019/03/29/Java性能监控与调优/</id>
    <published>2019-03-29T14:48:50.000Z</published>
    <updated>2019-03-30T07:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要有更强的竞争力，这部分一定是得学的，并且小公司的话，你也不太可能只仅仅开发，这些也要全要搞。多了解一些总不是坏事，想要走的更远的话。<br>介绍下 JDK 或者第三方的一些工具来祝你优化你的程序！<a id="more"></a></p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>首先来了解下 JVM 参数的类型，一般来说，可以分为下面的三大类：</p><ul><li>标准参数<br>在 JVM 的各个版本中基本不变，比较稳定的。<br>例如：<code>-help</code>、 <code>-server</code>、 <code>-client</code>、 <code>-version</code>、<code>-cp</code>、 <code>-classpath</code></li><li>X 参数<br>非标准化参数，有可能会变，但是变化比较小。<br>例如，解释执行：<code>-Xint</code>、第一次使用就编译成本地代码：<code>-Xcomp</code> 、混合模式（默认）：<code>-Xmixed</code></li><li>XX 参数<br>使用的最多的一类参数，相对不稳定，主要用于 JVM 调优和 Debug。<br>它还可以再分类，例如：<br>布尔类型：<code>-XX:[+-]&lt;name&gt;</code> 表示启用或者禁用某个属性，启用 G1 垃圾收集器 <code>-XX:+UseG1GC</code>。<br>非布尔类型，也就是 K-V 的形式：<code>-XX:&lt;name&gt;=&lt;val&gt;</code> 就是用来调整属性的。</li></ul><p>我们见的最多的应该是 -Xms 和 -Xmx 了，然而它俩其实是 XX 参数，是一种简写形式。<br>-Xms 等价于 <code>-XX:InitialHeapSize</code> ；-Xmx 等价于 <code>-XX:MaxHeapSize</code> ；-Xss 等价于 <code>-XX:ThreadStackSize</code></p><h3 id="查看JVM运行时参数"><a href="#查看JVM运行时参数" class="headerlink" title="查看JVM运行时参数"></a>查看JVM运行时参数</h3><p>使用到的参数有：</p><ul><li>-XX:+PrintFlagsInitial<br>查看初始值</li><li>-XX:+PrintFlagsFinal<br>查看最终值</li><li>-XX:+UnlockExperimentalVMOptions<br>解锁实验参数，有些参数需要解锁后才可以设置。</li><li>-XX:+UnlockDiagnosticVMOptions<br>解锁诊断参数</li><li>-XX:+PrintCommandLineFlags<br>打印命令行参数</li></ul><h3 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h3><p>打印的值有两类，<code>=</code> 表示默认值；<code>:=</code> 表示被用户或者 JVM 修改后的值。<br>可以在命令行中使用 <code>java -XX:+PrintFlagsFinal -version</code> 来体验一把。</p><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>专门用来查看 Java 进程的，跟 Linux 中的 ps 指令类似，可以使用 <code>jps -l</code> 来查看详细信息，更多的参数介绍可以在官方的文档中找到。</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可以用来查看正在运行的 JVM 进程的参数，不过需要你知道参数的名字才行，例如：<code>jinfo -flag MaxHeapSize [pid]</code> 、查看垃圾回收器的：<code>jinfo -flag [UseConcMarkSweepGC, UseG1GC] [pid]</code></p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>可以查看 JVM 统计信息，例如类装载（-class）、垃圾收集（-gc）、JIT编译信息。<br>举个例子：<code>jstat -class [pid] 1000 10</code> 后面两个是可选的，意思是每隔 1000ms 输出一次，一共输出 10 次。<br>至于输出的是什么，文档里都有写，C 结尾表示的就是总量，U 结尾就是表示的已使用。</p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>简单起见可以参考这张图：</p><p><img src="/image/dev/JVM内存结构.png" alt="JVM内存结构"></p><p>非堆区也叫 Metaspace，是 JDK8+ 才有的，它移除了永久代的概念，使用堆外直接内存；其中的 CCS 不一定存在，当启用了指针压缩（64 -&gt; 32）才会有，CodeCache 是跟 JIT 编译相关的，还有一些其他的东西。<br>之前也看到过 64 位的 JVM 跟 32 位的 JVM 其实变化很大的，指针膨胀就是个大问题。</p><h2 id="关于内存溢出"><a href="#关于内存溢出" class="headerlink" title="关于内存溢出"></a>关于内存溢出</h2><p>OOM 应该是常见的一种情况了，常见的分析思路就是看 Dump 文件，也就是内存镜像文件，发生 OOM 时自动导出这个文件可以这样配置：<code>-XX:+HeapDumpOnOutOfMemoryError</code> 、<code>-XX:HeapDumpPath=./</code></p><p>除了自动导出，还可以使用 jmap 命令来手动导出。<br>例：<code>jmap -dump:format=b,file=heap.hprof [pid]</code> 、<code>jmap -heap [pid]</code></p><h3 id="使用MAT分析"><a href="#使用MAT分析" class="headerlink" title="使用MAT分析"></a>使用MAT分析</h3><p>这是 Eclipse 的一个工具，非常好用，官方地址：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a><br>载入 hprof 文件后，主页就会展示内存占用的分布情况，并且猜测那一块会有 OOM 的可能。<br>常用的就两个功能，查看对象的数量和查看对象占用的内存，一般来说只看强引用就行。<br>这个软件的详细用法 Google 一下。</p><h2 id="死循环与死锁"><a href="#死循环与死锁" class="headerlink" title="死循环与死锁"></a>死循环与死锁</h2><p>这里要介绍下 jstack 这个命令，它可以看到线程信息，当发现我们的 CPU 飙高，就有可能发生了死循环或者死锁的情况。<br>使用 jstack 输出指定 pid 的情况，然后重定向到一个文件里，拿下来分析就好了。</p><p>PS：使用 <code>top -p [pid] -H</code> 命令可以查看某个进程里面的线程情况，使用 <code>printf &quot;%x&quot; xxx</code> 可以将十进制的 pid 转换为 16 进制。</p><h2 id="jvisualvm可视化"><a href="#jvisualvm可视化" class="headerlink" title="jvisualvm可视化"></a>jvisualvm可视化</h2><p>jvisualvm 是 JDK 自带的一个工具，使用它可以可视化的监控 Java 程序的运行情况，当然，远程的也是可以进行监控的，不过需要设置了 JMX 才行。<br>然后，它可以安装第三方插件，推荐的两个插件是：VisualGC 和 BtraceWorkbench。</p><p>插件地址：<a href="http://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">http://visualvm.github.io/pluginscenters.html</a><br>需要先把对应版本的源添加进配置里才可以下载安装。<br>并且官网是有中文版的教程的，可以看一看。</p><h2 id="Btrace调试"><a href="#Btrace调试" class="headerlink" title="Btrace调试"></a>Btrace调试</h2><p>它的作用是在我们的应用程序不重启不修改，正在运行的情况下动态修改字节码，达到监控调试的目的。<br>使用步骤按照官方文档，设置个 <strong>BTRACE_HOME</strong> 的环境变量就可以了，运行方式有两种，一种直接命令行：<code>btrace &lt;PID&gt; &lt;trace_script&gt;</code> ，另一种可以使用 jvisualvm 插件来配合实现。<br>脚本代码非常简单，跟我们的 Java 代码也很类似（拦截器），所以不要怕。</p><p>至于下载地址，在 Github 上搜就可以了，项目主页：<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">https://github.com/btraceio/btrace</a></p><p>脚本示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArgSimple</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在那个类，那个方法，什么时候进行拦截</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    method=<span class="string">"arg1"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.ENTRY)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.printArray(args);</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写脚本所依赖的几个 jar 包在你下载的安装包里都有，使用也非常简单，直接跟类名就行，他没有包的概念，并且跟程序是独立的。</p><p>使用 -cp 来指定额外的 classpath 依赖第三方的类库。</p><h3 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h3><p>包括构造方法也是可以的，使用的是字节码风格 <code>&lt;init&gt;</code>。<br>默认是在入口的时候进行拦截，其他的拦截时机：</p><ul><li>ENTRY：入口（默认）</li><li>RETURN：返回</li><li>THROW：异常</li><li>Line：行</li></ul><p>如果你的代码有异常，但是被 try 给吃掉了，那么如何确定代码是否抛异常了呢，可以使用官方提供的一个代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOnThrow</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// store current exception in a thread local</span></span><br><span class="line">  <span class="comment">// variable (@TLS annotation). Note that we can't</span></span><br><span class="line">  <span class="comment">// store it in a global variable!</span></span><br><span class="line">  <span class="meta">@TLS</span> </span><br><span class="line">  <span class="keyword">static</span> Throwable currentException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// introduce probe into every constructor of java.lang.Throwable</span></span><br><span class="line">  <span class="comment">// class and store "this" in the thread local variable.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow</span><span class="params">(@Self Throwable self)</span> </span>&#123;<span class="comment">//new Throwable()</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s)</span> </span>&#123;<span class="comment">//new Throwable(String msg)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(String msg, Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow2</span><span class="params">(@Self Throwable self, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when any constructor of java.lang.Throwable returns</span></span><br><span class="line">  <span class="comment">// print the currentException's stack trace.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.RETURN)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrowreturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentException != <span class="keyword">null</span>) &#123;</span><br><span class="line">      BTraceUtils.Threads.jstack(currentException);</span><br><span class="line">      BTraceUtils.println(<span class="string">"====================="</span>);</span><br><span class="line">      currentException = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，你可以判断方法的某行代码是否执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    <span class="comment">// 支持使用正则表达式： /.*/</span></span><br><span class="line">    method=<span class="string">"exception"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(value=Kind.LINE, line=<span class="number">20</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn + <span class="string">","</span> +line);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理方法参数类型的时候，你可以使用 AnyType 来接收，也可以使用确定的类型。</p><p>生产环境下可以使用，但是要注意，被修改的字节码是不会被还原的，除非重启 JVM。</p><h2 id="tomcat调试"><a href="#tomcat调试" class="headerlink" title="tomcat调试"></a>tomcat调试</h2><p>使用 jpda 可以进行远程调试，相关的开启方法自行 Google，在配置文件中设置好端口后，在本地的 IDE 里直接填上就可以了。</p><p>tomcat 自带的管理界面比较简陋，更好的方案是使用 <strong>psi-probe</strong> 来监控，可以在 Github 上找到。</p><p>优化方面，主要着重的配置是：</p><ul><li>maxConnections<br>猫能够接受和处理的最大连接数，在 8+ 版本，使用了 NIO 技术，多路复用提高了性能。<br>使用 NIO 的情况下，默认是 10000</li><li>acceptCount<br>当连接数超出了最大值，进入一个等待队列，这个属性控制队列的大小，默认 100</li><li>maxThreads<br>配置工作线程的个数，默认是 200，同时并发处理的个数。</li><li>minSpareThreads<br>最小空闲的工作线程数，不要太小。</li><li>enableLookups<br>使用  <code>request.getRemoteHost()</code> 时进行 DNS 查询，建议禁用，8.5 默认禁用。</li><li>autoDeploy<br>猫运行时，要不要周期性的检查是不是有新应用需要部署，需要开一个线程来周期性检测，生产环境要关闭，默认开启。</li><li>reloadable<br>来监控 <code>/WEB-INF/classes/</code> 和 <code>/WEB-INF/lib</code> 的变化，同理建议禁用，8.5 默认禁用。<br>开发环境，用来支持热加载还是不错的。</li><li>protocol<br>在 server.xml 文件中配置，8+ 版本默认的使用 NIO，如果是高并发可以尝试使用 APR ，它使用的是 native 方法，性能会有一定提升。</li><li>分布式情况下，如果使用了 SpringSession 类似的解决方案，建议禁用猫的 session，尤其是使用 JSP 的时候。</li></ul><p>参考文档：docs/config/http.html、docs/config/host.html、docs/config/context.html</p><h2 id="nginx优化"><a href="#nginx优化" class="headerlink" title="nginx优化"></a>nginx优化</h2><p>配置文件的解读就不说了，Google 很多，要注意的是，配置反向代理要关闭 selinux，setenforce 0。<br>使用 <code>nginx -V</code> 可以查看编译参数。</p><p>使用 nginx 提供的 <strong>ngx_http_stub_status</strong> 配置来监控连接信息，要使用它需要将这个模块加入编译参数才行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = /nginx_status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个好用的工具 ngxtop，使用 python 的 pip 包管理直接 install 就好。<br>在 Github 上可以找到它的官方文档（不过这个项目已经不活跃了）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 基本使用</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询状态是 200 的</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -i 'status == 200'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询访问最多的 ip</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -g remote_addr</span><br></pre></td></tr></table></figure><p>再来介绍另一款图形化的监控工具：Nginx-rrd，这个是基于 PHP 来做的，所以需要 PHP 的相关依赖，然后需要在 php-fpm 中跟 nginx 统一用户，具体的配置还蛮多的，可以去 Google 一下。<br>它的原理是使用定时任务来扫描，每次都会存储成一张张的图片，最后使用 web 端来进行展示。</p><p>PS：这些监控工具都是基于 ngx_http_stub_status 来做的，所以上面那个 location 配置不能少。</p><hr><p>一些常见的基本的 Nginx 优化：</p><ul><li>增加工作线程数和并发连接数<br>默认情况下，Nginx 只有一个工作线程，并发数为 1024。</li><li>启用长连接<br>默认对客户端使用的是长连接，也可以对反向代理的后端使用长连接。</li><li>启用缓存、压缩</li><li>操作系统参数优化</li></ul><p>下面见一个示例的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 配置工作线程，受限于 CPU 的数量，一般配置与 CPU 的数量相等。</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"># 每一个线程打开的最大连接数，包含 nginx 与客户端和 nginx 与 upstream 之间的连接</span><br><span class="line"># 受限于操作系统，需要修改操作系统参数，默认 1024</span><br><span class="line">worker_connections  10240;</span><br><span class="line"># 可以一次建立多个连接</span><br><span class="line">multi_accept on;</span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置与后端的长连接示例</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name loli.com;</span><br><span class="line"></span><br><span class="line"># 配置反向代理的集群</span><br><span class="line">upstream server_pool&#123;</span><br><span class="line">    server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    # 300个长连接</span><br><span class="line">    keepalive 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置反向代理</span><br><span class="line">location / &#123; </span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">proxy_pass http://server_poll/;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>nginx -t</code> 来测试下配置文件是否正确。<br>开启缓存和压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">gzip_comp_level 2;</span><br><span class="line"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"># 禁用IE 6 gzip</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line"># 开启缓存</span><br><span class="line">location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; </span><br><span class="line">    access_log   off; </span><br><span class="line">    expires      30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires      24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">    expires      1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 格式</span><br><span class="line"># expires 30s;</span><br><span class="line"># expires 30m;</span><br><span class="line"># expires 2h;</span><br><span class="line"># expires 30d;</span><br></pre></td></tr></table></figure><p>操作系统参数优化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span> ipv4 相关优化</span><br><span class="line"><span class="meta">#</span> 防止一个套接字在有过多试图连接到达时引起过载，默认为 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta">#</span> os 的一个等待队列，默认 128，连接队列</span><br><span class="line">sysctl -w net.core.somaxconn = 1024</span><br><span class="line"><span class="meta">#</span> timewait 超时时间，在 tcp 的四次挥手时的状态，此状态下虽然已经断开，但是不能拿来用，没必要太长</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout = 10</span><br><span class="line"><span class="meta">#</span> os 直接使用 timewait 的连接，默认 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span> timewait 回收禁用，默认 0，为了不必要的麻烦</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 每个进程打开文件数量的限制</span><br><span class="line"><span class="meta">#</span> /etc/security/limits.conf</span><br><span class="line">* hard nofile 204800</span><br><span class="line">* soft nofile 204800</span><br><span class="line">* soft core unlimited</span><br><span class="line">* soft stack 204800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> nginx 的 TCP 优化</span><br><span class="line">http &#123;</span><br><span class="line"><span class="meta">#</span> 减少文件在应用和内核之间拷贝</span><br><span class="line">  sendfile           on;</span><br><span class="line"><span class="meta">  #</span> 当数据包达到一定大小再发送</span><br><span class="line">  tcp_nopush         on;</span><br><span class="line"><span class="meta">  #</span> 有数据随时发送</span><br><span class="line">  tcp_nodelay        off;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细配置参考：<br><a href="https://wsgzao.github.io/post/sysctl/" target="_blank" rel="noopener">https://wsgzao.github.io/post/sysctl/</a><br><a href="https://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-wpo.html</a><br><a href="http://sfau.lt/b5DA5u" target="_blank" rel="noopener">http://sfau.lt/b5DA5u</a></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如何选择垃圾收集器呢？</p><ul><li>优先调整堆大小，让服务器自己来选择</li><li>如果内存小于 100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或者 JVM 自己选</li><li>如果允许停顿时间超过 1 秒，选择并行或者 JVM 自己选</li><li>如果响应时间很重要，并且不能超过 1 秒，使用并发收集器</li></ul><p>几种垃圾收集器在之前的笔记里都有介绍，这里只作补充。<br>对于并行的 GC，是有自适应的特性的，就是说你给定几个指标（吞吐量、停顿时间等）它会自动调整堆大小，但这不是最优的方案，因为动态调整也是消耗性能的。<br>对应 Web 应用，我们还是比较关注停顿时间的，所以一般都是用并发的 GC，例如 CMS，这类收集器是对 CPU 敏感的，虽然跟用户线程并发执行，但是用户线程的 cpu 资源就少了，并且会产生浮动垃圾和空间碎片，在 G1 出现之前使用还是非常广泛的，在 J8 中官方推荐使用 G1。</p><p>G1 在 JDK7 开始提供，到 J8 已经比较成熟了，适用于大内存、低停顿的场景，在 J9 里 G1 已经成为默认的收集器，并且将 CMS 设置为废弃。<br>在 G1 中，老年代新生代是逻辑上的称呼了，它将堆分为一个个的 Region，还有一些成为 H 区用来存放大对象（超过了 Region 的一半）。<br>G1 中的 YoungGC 和传统的并没有什么区别，但是它没有了 FullGC，多了个 MixedGC，它回收所有 Young 和部分 Old，它也有并发标记的过程，默认堆的占有率达到 45% 就会触发。在每次 YGC 之后和 MGC 之前，会检查垃圾占比是否达到了某一个阀值，只有达到了才会发生 MGC。<br>G1 的相关概念和参数还多得多，这里不再一一举例。</p><p>G1 最佳实践：</p><ul><li>年轻代大小避免使用  -Xmn、 -XX:NewRatio 等显式设置，会覆盖暂停时间目标值</li><li>暂停时间目标时间不要太严苛，其吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间，太严苛会直接影响吞吐量。</li></ul><p>当发生了下面的几种情况，可以考虑切换到 G1 了：</p><ul><li>50% 以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过了 1 秒</li></ul><p>调优的过程就是在<strong>吞吐量</strong>和<strong>响应时间</strong>之间找平衡的过程，并且……在 J12 又带来了新的收集器 ZGC….。</p><p>参考资料：<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">J8 JVM 规范</a><br><a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">J8文档</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">J8 GC选择</a></p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>既然是分析日志，那么首先得拿到日志，使用这些参数来开启，然后就有日志文件了，直接读也是可以的，不过可视化更方便，可以使用这个<a href="https://gceasy.io/" target="_blank" rel="noopener">在线分析</a>，或者使用 GCViewer（在 Github）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:$CATALINA HOME/logs/gc.log</span><br><span class="line"></span><br><span class="line">## 下面的不用也可以</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure><h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>先来看并行的 ParallelGC，指导原则：</p><ul><li>除非确定，否则不要设置最大堆内存</li><li>优先设置吞吐量目标</li><li>如果吞吐量目标达不到，调大最大内存，不能让 OS 使用 Swap，如果仍然达不到，降低目标</li><li>吞吐量能达到，GC 时间太长，设置停顿时间的目标</li></ul><p>这些在 Oracle 官方文档里都有写的。<br>关于 G1 的调优，参考上面的 G1 最佳实践规则就可以了。</p><p>调优过程要一个参数一个参数的设置，避免不知道是改的那个参数起的作用，然后这是个循序渐进的过程，不太可能一步到位的。<br>这一块的内容，还是去慕课网看视频比较好，文字不太好描述。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JVM 是基于栈的架构，相比经典的基于寄存器的架构来说，它的指令更短，但是指令数量会更多。<br>例如一个经典的问题，i++ 和 ++i 那个效率高，在 fori 循环里是很常用的，可以分析字节码，会发现这两种形式翻译的字节码是一样的，所以他们的效率其实是一样的。<br>然后再看下面的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    s = <span class="string">"ll"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到底返回的是那个呢，答案是 hello，通过字节码可以看出，因为字符串是不可变对象，会将 hello 和 ll 同时压入两个本地变量，在走到 return 的时候把第一个也就是 hello 返回，然后又将第二个 ll 赋值给了第一个本地变量。</p><hr><p>我们知道在使用 + 进行字符串拼接时，默认会转换为 StringBuilder，那么这是绝对的么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">final</span> String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以去分析字节码，这里就直接说结论，当 String 类型为 final 时，是在编译阶段就直接确定了，不会再进行拼接。<br>关于 String，还有一个很有趣的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s.intern();</span><br><span class="line">  String s2 = <span class="string">"1"</span>; </span><br><span class="line">  System.out.print1n(s == s2);</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s3.intern();</span><br><span class="line">  String s4 = <span class="string">"11"</span>;</span><br><span class="line">  System.out.print1n(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK7- 和 JDK7+ 结果是不一样的，之前是两个 false，之后变成了 false 、 true，原因就是在 J7 之后字符串常量池移到了堆中，当使用 intern 方法并且常量池没有，堆中有的情况下，会将堆中的这个引用放到常量池中（常量池已经在堆中了），这样 s3 和 s4 就相等了。<br>G1 还有个字符串去重的功能（需要手动开启），也就是我们程序中字符串常量是占了很大比重的，而堆中和常量池中都有的话是很浪费的，当堆中字符串生命周期很长（有个阀值）就会触发去重操作。</p><hr><p>常见的代码优化：</p><ul><li>尽量重用对象，不要循环创建对象，比如：for 循环字符串拼接</li><li>容器类初始化的时候指定长度（List、Map）</li><li>集合遍历尽量减少重复计算（例如条件是不确定的 size）</li><li>尽量使用 Entry 来遍历 Map</li><li>尽量使用基本类型而不是包装类型</li><li>及时消除过期对象的引用，防止内存泄露</li><li>尽量使用局部变量，减小变量的作用域</li><li>ThreadLocal 缓存线程不安全的对象 SimpleDateFormat（J8 可以直接用新的 API DateTimeFormat 它是线程安全的）</li><li>尽量使用延时加载，例如单例模式（内部静态类）</li><li>尽量减少使用反射，用的话也尽量加缓存</li><li>慎用异常，不要用抛异常来表示正常业务逻辑，因为抛异常是比较重的操作，但是也别为了这个而不用，有些地方该用就得用。</li><li>String 操作尽量少用正则</li></ul><p>又一个有趣的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer a = <span class="number">100</span>;</span><br><span class="line">  Integer b = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  </span><br><span class="line">  Integer c = <span class="number">1000</span>;</span><br><span class="line">  Integer d = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 Integer 会自动缓存一个字节的数字，如果在缓存中直接返回，如果不在才 new，其他有的包装类型也有部分有缓存，比如 Long，不过 Double 这种肯定是没有的啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要有更强的竞争力，这部分一定是得学的，并且小公司的话，你也不太可能只仅仅开发，这些也要全要搞。多了解一些总不是坏事，想要走的更远的话。&lt;br&gt;介绍下 JDK 或者第三方的一些工具来祝你优化你的程序！
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>体验ZooKeeper</title>
    <link href="http://bfchengnuo.com/2019/02/26/%E4%BD%93%E9%AA%8CZooKeeper/"/>
    <id>http://bfchengnuo.com/2019/02/26/体验ZooKeeper/</id>
    <published>2019-02-26T12:39:58.000Z</published>
    <updated>2019-02-28T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apache ZooKeeper 是 Apache 软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，是主要用于分布式中<strong>一致性处理的框架</strong>。ZooKeeper 曾经是 Hadoop 的一个子项目，但现在是一个独立的顶级项目。<br>ZooKeeper 的架构通过冗余服务实现高可用性。ZooKeeper 节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。<a id="more"></a></p><p>Zookeeper 从设计模式角度来理解：是一个<strong>基于观察者模式设计的分布式服务管理框架</strong>，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应。</p><blockquote><p>所谓的一致性，实际上就是围绕着“看见”来的。谁能看见？能否看见？什么时候看见？<br>也对应着：强一致性、弱一致性、最终一致性。</p></blockquote><h2 id="ZK特点"><a href="#ZK特点" class="headerlink" title="ZK特点"></a>ZK特点</h2><ul><li>一个领导者（Leader），多个跟随者（Follower）组成的集群。</li><li>集群中只要有<strong>半数以上（不包括一半）</strong>节点存活，Zookeeper 集群就能正常服务（所以集群最少 3 推荐奇数个）。</li><li>全局数据一致：每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致的。</li><li>更新请求顺序进行，来自<strong>同一个</strong> Client 的更新请求按其发送顺序依次执行。</li><li><strong>数据更新原子性，一次数据更新要么成功，要么失败</strong>。</li><li>实时性，在一定时间范围内，Client 能读到最新数据。</li></ul><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，<strong>每个 ZNode 都可以通过其路径唯一标识</strong>。</p><p>需要注意的是 ZK 的选举过程是非常复杂的，也就是耗时比较长，选举过程整个集群不可用，所以说 ZK 是 CP 的，相对的 Eureka 则是 AP 设计的，他们的比较看<a href="https://bfchengnuo.com/2018/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A2%E7%B4%A2/#CAP%E5%AE%9A%E7%90%86">这里</a>就够了。</p><p><strong>为什么要保证半数以上？</strong><br>从概念上来说，ZooKeeper 它所做的就是确保对 Znode 树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ZK 提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><ul><li>统一命名<br>在分布式场景下，经常需要对应用/服务进行统一命名，便于识别，例如 ip 和域名的关系。</li><li>统一配置管理<br>分布式中配置文件同步是常见的，一般要求在一个集群中，所有节点的配置是一致的。<br>对某一个节点的配置修改后也会快速同步到其他节点上。<br>因为客户端在监听，一旦 ZNode 中的数据变化，ZK 将通知各个客户端。</li><li>统一集群管理<br>分布式中，实时掌握每个节点的状态是必要的，可以根据节点的状态做出一些调整。<br>ZK 会将节点的相关信息一起写入到 ZNode 中。</li><li>服务器动态上下线<br>客户端能够实时的洞察服务器的上下线情况。<br>因为服务器注册的时候创建的是临时节点，服务器下线后会自动删除，ZK 会通知监听的客户端，然后客户端会去重新获取列表。</li><li>软负载均衡<br>ZK 可以记录每台服务器的访问次数，让访问最少的来处理最新的客户端请求。</li></ul><h2 id="安装ZK"><a href="#安装ZK" class="headerlink" title="安装ZK"></a>安装ZK</h2><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>windows 版的没啥好说的，就说说 linux 版，正常情况应该是搞集群的，不过测试用机器性能有限，开一个就行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">tar -zxvf zookeeper-3.x.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta">#</span> 进入 conf 文件夹修改配置文件名</span><br><span class="line"><span class="meta">#</span> 进入配置文件将 dataDir= 修改到指定的目录，需要自己创建文件夹，例如 zkData</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span> 查看进程使用 jps</span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动客户端，退出 quit</span><br><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure><p>其他常用配置参数：</p><ul><li>tickTime<br>通信心跳数，Zookeeper 服务器与客户端心跳时间，单位毫秒。<br>它用于心跳机制，并且设置最小的 session 超时时间为两倍心跳时间。</li><li>initLimit<br>集群中的 Follower（跟随者）服务器与 Leader（领导者）服务器之间初始连接时能容忍的最多心跳数（总时间就是它乘以 tickTime），用它来限定集群中的 Zookeeper 服务器连接到 Leader 的时限。</li><li>syncLimit<br>同步通信时限，集群中 Leader 与 Follower 之间的最大响应时间单位，假如响应超过 syncLimit * tickTime，Leader 认为 Follwer 死掉，从服务器列表中删除 Follwer。</li><li>clientPort<br>客户端连接的端口</li></ul><p>客户端操作的常用命令：</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path [watch]</td><td>使用 ls 命令来查看当前 znode 中所包含的内容</td></tr><tr><td>ls2 path   [watch]</td><td>查看当前节点数据并能看到更新次数等数据</td></tr><tr><td>create</td><td>普通创建   -s  含有序列   -e  临时（重启或者超时消失）</td></tr><tr><td>get path   [watch]</td><td>获得节点的值</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>rmr</td><td>递归删除节点</td></tr></tbody></table><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>解压跟上面一样，如果安装了 rsync 远程同步工具，可以使用 xsync 命令同步过去，然后在设置的数据文件夹目录下创建一个 myid 的文件，在里面写上对应的编号。<br>然后在所有的配置文件中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#######################cluster##########################</span><br><span class="line">server.2=hostname102:2888:3888</span><br><span class="line">server.3=hostname103:2888:3888</span><br><span class="line">server.4=hostname104:2888:3888</span><br><span class="line"></span><br><span class="line"># server.A=B:C:D</span><br><span class="line"># A 是一个数字，表示这个是第几号服务器，就是 myid 文件里写的那个数字，</span><br><span class="line">#   Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。</span><br><span class="line"># B 是这个服务器的 ip 地址；</span><br><span class="line"># C 是这个服务器与集群中的 Leader 服务器交换信息的端口；</span><br><span class="line"># D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</span><br></pre></td></tr></table></figure><p>最后分别启动就可以了，可以使用查看状态来查看。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>客户端使用 get 或者 ls2 命令获取到的信息解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">czxid - 创建节点的事务 zxid</span><br><span class="line">每次修改 ZooKeeper 状态都会收到一个 zxid 形式的时间戳，也就是 ZooKeeper 事务 ID。</span><br><span class="line">事务 ID 是 ZooKeeper 中所有修改总的次序。每个修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。</span><br><span class="line"></span><br><span class="line">ctime - znode被创建的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">mzxid - znode最后更新的事务zxid</span><br><span class="line"></span><br><span class="line">mtime - znode最后修改的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">pZxid - znode最后更新的子节点zxid</span><br><span class="line"></span><br><span class="line">cversion - znode子节点变化号，znode子节点修改次数</span><br><span class="line"></span><br><span class="line">dataversion - znode数据变化号</span><br><span class="line"></span><br><span class="line">aclVersion - znode访问控制列表的变化号</span><br><span class="line"></span><br><span class="line">ephemeralOwner - 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</span><br><span class="line"></span><br><span class="line">dataLength - znode的数据长度</span><br><span class="line"></span><br><span class="line">numChildren - znode子节点数量</span><br></pre></td></tr></table></figure><p>主要留意最后两个就好了。</p><h2 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>半数机制：集群中半数以上机器存活，集群可用。所以 Zookeeper 适合安装<strong>奇数台服务器</strong>。<br>Zookeeper 虽然在配置文件中并没有指定 Master 和 Slave。但是，Zookeeper 工作时，是有一个节点为 Leader，其他则为 Follower，Leader 是通过内部的选举机制临时产生的。</p><p>选举机制简单说就是每个服务都首先选自己，如果超过了集群数量的半数以上，那么选举结果即确定，否则放弃选自己继而选择 id 比自己大的一个。<br>假设集群里有五台服务器，id 编号 1-5，依次启动他们。</p><ol><li>服务器 1 启动，此时只有它一台服务器启动了，它首先选择自己，但是发出去的报文没有任何响应，所以它的选举状态一直是 LOOKING 状态。</li><li>服务器 2 启动，它与最开始启动的服务器 1 进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以 id 值较大的服务器 2 胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是 3)，所以服务器 1、2 还是继续保持 LOOKING 状态。</li><li>服务器 3 启动，根据前面的理论分析，服务器 3 成为服务器 1、2、3 中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的 Leader。</li><li>服务器 4 启动，根据前面的分析，理论上服务器 4 应该是服务器 1、2、3、4 中最大的，但是由于前面已经有半数以上的服务器选举了服务器 3，所以只能作为 Follower，第五个也是类似。</li></ol><p>真实的选举机制是非常复杂的，所以耗时长，Leader 选举是保证分布式数据一致性的关键所在，期间还需要对投票是否有效等进行检查，一般会进行多轮投票才会选出。</p><p>非初始化的情况下，通常那台服务器上的数据越新（ZXID 会越大），其成为 Leader 的可能性越大，也就越能够保证数据的恢复。如果 ZXID 相同，则 SID 越大机会越大。</p><hr><p>Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议（Zookeeper Atomic broadcast protocol）。<br>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</p><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。<br>状态同步保证了 leader 和 Server 具有相同的系统状态。</p><p>仅靠 Paxos 不能满足 ZooKeeper 需求。ZooKeeper 是一个树形结构，很多操作都要先检查才能确定能不能执行，例如创建 <code>/a/b</code> 之前要先确定 <code>/a</code> 的存在，我们就能从此看出 Paxos 的一致性达不到 ZooKeeper 一致性的要求，所以就有了 Zab 协议，它保证了：</p><ul><li>同一个 leader 的发起的事务要<strong>按顺序</strong>被 apply，同时还要保证只有先前的 leader 的所有事务都被 apply 之后，新选的 leader 才能在发起事务。</li><li>一些已经 Skip 的消息，需要仍然被 Skip。</li></ul><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态（包括数据的恢复）。<br>Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的；系统默认的选举算法为 fast paxos。<br>选完 leader 以后，zk 就进入状态同步过程。</p><blockquote><p>关于恢复模式。</p><p>选好新 leader 后它通过一个多数派获得老 leader 提交的最新数据；<br>老 leader 重启后，可能还会认为自己是 leader，可能会继续发送未完成的请求，从而因为两个 leader 同时存在导致算法过程失败；<br>解决办法是把 leader 信息加入每条消息的 id 中，Zookeeper 中称为 zxid 为一 64 位数字，高 32 位为 leader 信息又称为 epoch，每次 leader 转换时递增；低 32 位为消息编号，leader 转换时应该从 0 重新开始编号。<br>通过 zxid，follower 能很容易发现请求是否来自老 leader，从而拒绝老 leader 的请求。新 leader 首先要获得大多数节点的支持，然后从状态最新的节点同步事务，完成后才可正式成为 leader 发起事务。</p><ol><li>新 Leader 等待 server 连接；</li><li>Follower 连接 leader，将最大的 zxid 发送给 leader；</li><li>Leader 根据 follower 的 zxid 确定同步点；</li><li>完成同步后通知 follower 已经成为 uptodate 状态；</li><li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li></ol></blockquote><p>详细分析见：<br><a href="https://www.cnblogs.com/binyue/p/4270393.html" target="_blank" rel="noopener">https://www.cnblogs.com/binyue/p/4270393.html</a><br><a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/6107600.html</a><br><a href="https://www.cnblogs.com/sunddenly/p/4138580.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4138580.html</a><br><a href="https://www.jianshu.com/p/e126bb01331c" target="_blank" rel="noopener">https://www.jianshu.com/p/e126bb01331c</a></p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>节点的类型大体可分为两类：</p><ul><li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</li><li>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</li></ul><p>其中每一种里又细分为两类，目录节点和顺序编号目录节点，就如同名字一类会在后面加一个递增的序号，由父节点负责维护，可以用于排序，记录事件的顺序。</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>当 ZK 客户端运行后，会创建两个线程，一个负责网络连接通信（connect）一个负责监听（listener）；<br>通过 connect 线程将注册监听事件发给 ZK，ZK 收到后会将其加入到监听列表，类似 <em>ip:port:监听内容</em> 这样的形式。<br>满足条件后，ZK 就会按照监听列表告诉客户端，然后 listener 线程会回调 process 方法。<br>监听一般分为两类，一种是数据变化的监听，一种是子节点变化的监听。</p><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>首先 Client 向 ZooKeeper 的 Server1 上写数据，发送一个写请求。<br>如果 Server1 不是 Leader，那么 Server1 会把接受到的请求进一步转发给 Leader，这个 Leader 会将写请求广播给各个 Server，各个 Server 写成功后就会通知 Leader。<br>当 Leader 收到大多数 Server 数据写成功了，那么就说明数据写成功了。如果这里三个节点的话，只要有两个节点数据写成功了，那么就认为数据写成功了。<br>认为写成功之后，Leader 会告诉 Server1 数据写成功了，Server1 会进一步通知 Client 数据写成功了，这时就认为整个写操作成功。</p><p>所以，你可以知道 Zookeeper 并不保证读取的是最新数据，也就是强一致性，它只能保证最终一致性，同时它具有原子性：更新操作要么成功要么失败，没有中间状态。<br>而只需要一半以上写入完成即可认为成功也就好理解了，首先写操作只能由 Leader 发起，那么它肯定是最新的，后续可以同步给其他的 Follower，即使还没同步 Leader 就挂掉了，那么依然能保证新的 Leader 是有最新数据的，这就是靠 Zab 协议中的恢复模式了。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>使用原生 API 的基本操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleZkClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 收到事件通知后的回调函数</span></span><br><span class="line">        System.out.println(event.getType() + <span class="string">"---"</span> + event.getPath());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取子节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建数据节点到 zk 中</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：要创建的节点的路径 </span></span><br><span class="line">    <span class="comment">// 参数2：节点的数据</span></span><br><span class="line">    <span class="comment">// 参数3：节点的权限</span></span><br><span class="line">    <span class="comment">// 参数4：节点的类型</span></span><br><span class="line">    String nodeCreated = zkClient.create(<span class="string">"/servers"</span>,</span><br><span class="line">                                         <span class="string">"hellozk"</span>.getBytes(),</span><br><span class="line">                                         Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                         CreateMode.PERSISTENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点是否存在</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    Stat stat = zkClient.exists(<span class="string">"/java6"</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat == <span class="keyword">null</span> ? <span class="string">"not exist"</span> : <span class="string">"exist"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点的数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZnode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数2：指定要删除的版本，-1 表示删除所有版本</span></span><br><span class="line">    zkClient.delete(<span class="string">"/java6"</span>, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    zkClient.setData(<span class="string">"/java6"</span>, <span class="string">"I Miss you"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器节点动态上下线示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributedServer server = <span class="keyword">new</span> DistributedServer();</span><br><span class="line">    server.getConnect();</span><br><span class="line">    <span class="comment">// 利用zk连接注册服务器信息</span></span><br><span class="line">    server.registerServer(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 启动业务功能</span></span><br><span class="line">    server.handleBussiness(args[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建到zk的客户端连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向zk集群注册服务器信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerServer</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时序号节点</span></span><br><span class="line">    String create = zkClient.create(parentNode + <span class="string">"/server"</span>,</span><br><span class="line">                                    hostname.getBytes(), </span><br><span class="line">                                    Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                    CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(hostname + <span class="string">"is online.."</span> + create);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBussiness</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(hostname + <span class="string">"start working....."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">    client.getConnect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servers的子节点信息，从中获取服务器信息列表</span></span><br><span class="line">    client.getServerList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务进程启动</span></span><br><span class="line">    client.business();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要再次启动监听</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          getServerList();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器列表信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取服务器子节点信息，并且对父节点进行监听</span></span><br><span class="line">    List&lt;String&gt; children = zk.getChildren(parentNode, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.遍历所有节点，获取节点中的主机名称信息</span></span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = zk.getData(parentNode + <span class="string">"/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">      servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(servers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 业务功能</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"client is working ..."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于集群来说，无论是服务器还是消费端，都是客户端；服务端就是向集群添加信息，消费端就是监听信息。</p><h3 id="节点权限"><a href="#节点权限" class="headerlink" title="节点权限"></a>节点权限</h3><p><strong>ZK 的节点有 5 种操作权限：</strong><br>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这 5 种权限简写为 crwda 。<br>注：这 5 种权限中，delete 是指对子节点的删除权限，其它 4 种权限指对自身节点的操作权限。</p><p><strong>身份的认证有 4 种方式：</strong><br>world：默认方式，相当于全世界都能访问<br>auth：代表已经认证通过的用户(cli 中可以通过 <code>addauth digest user:pwd</code> 来添加当前上下文中的授权用户)<br>digest：即 <code>用户名:密码</code> 这种方式认证，这也是业务系统中最常用的<br>ip：使用 Ip 地址认证。</p><p>Java API 中，<code>Ids.OPEN_ACL_UNSAFE</code> ：默认匿名权限；<code>Ids.READ_ACL_UNSAFE</code> ：只读权限； <code>CREATOR_ALL_ACL</code> ：给创建该 znode 连接所有权限。 事实上这里是采用了 auth 验证模式，使用 sessionID 做验证，所以创建该 znode 的连接可以对该 znode 做任何修改。</p><h2 id="关于服务发现"><a href="#关于服务发现" class="headerlink" title="关于服务发现"></a>关于服务发现</h2><p>相比 ZK，现在也有了不少其他优秀的选择，感兴趣的可以了解下 etcd、consul、Eureka。</p><table><thead><tr><th>Feature</th><th>Consul</th><th>zookeeper</th><th>etcd</th><th>euerka</th></tr></thead><tbody><tr><td>服务健康检查</td><td>服务状态，内存，硬盘等</td><td>(弱)长连接，keepalive</td><td>连接心跳</td><td>可配支持</td></tr><tr><td>多数据中心</td><td>支持</td><td>—</td><td>—</td><td>—</td></tr><tr><td>kv 存储服务</td><td>支持</td><td>支持</td><td>支持</td><td>—</td></tr><tr><td>一致性</td><td>raft</td><td>paxos</td><td>raft</td><td>—</td></tr><tr><td>CAP</td><td>CA</td><td>CP</td><td>CP</td><td>AP</td></tr><tr><td>使用接口(多语言能力)</td><td>支持http和dns</td><td>客户端</td><td>http/grpc</td><td>http（sidecar）</td></tr><tr><td>watch支持</td><td>全量/支持long polling</td><td>支持</td><td>支持 long polling</td><td>支持 long polling/大部分增量</td></tr><tr><td>自身监控</td><td>metrics</td><td>—</td><td>metrics</td><td>metrics</td></tr><tr><td>安全</td><td>acl /https</td><td>acl</td><td>https支持（弱）</td><td>—</td></tr><tr><td>SpringCloud集成</td><td>已支持</td><td>已支持</td><td>已支持</td><td>已支持</td></tr></tbody></table><p>真的是百家争鸣 o(￣▽￣<em>)ゞ))￣▽￣</em>)o</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/zero01/2108483" target="_blank" rel="noopener">https://blog.51cto.com/zero01/2108483</a><br><a href="https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/" target="_blank" rel="noopener">https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/</a><br><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/" target="_blank" rel="noopener">https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache ZooKeeper 是 Apache 软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，是主要用于分布式中&lt;strong&gt;一致性处理的框架&lt;/strong&gt;。ZooKeeper 曾经是 Hadoop 的一个子项目，但现在是一个独立的顶级项目。&lt;br&gt;ZooKeeper 的架构通过冗余服务实现高可用性。ZooKeeper 节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。
    
    </summary>
    
      <category term="自我提升" scheme="http://bfchengnuo.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="分布式" scheme="http://bfchengnuo.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="微服务" scheme="http://bfchengnuo.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式中的那把锁</title>
    <link href="http://bfchengnuo.com/2019/01/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E9%82%A3%E6%8A%8A%E9%94%81/"/>
    <id>http://bfchengnuo.com/2019/01/25/分布式中的那把锁/</id>
    <published>2019-01-25T12:24:23.000Z</published>
    <updated>2019-02-26T12:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的面试，动不动就微服务、分布式、高并发、缓存、并发编程等，不管用不用得到，你反正得会才行，分布式锁也算是很重要的一块，之前我在 <a href="https://github.com/bfchengnuo/MyRecord/issues/22" target="_blank" rel="noopener">Github 的 issues</a> 中写过，现在单独摘出来再总结下，因为真的问的太多了。</p><p>分布式锁，是控制分布式系统之间<strong>同步访问共享资源的一种方式</strong>。<a id="more"></a><br>在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要<strong>互斥来防止彼此干扰来保证一致性</strong>，在这种情况下，便需要使用到分布式锁。</p><p>传统实现分布式锁的方案一般是利用持久化数据库（如利用 InnoDB 行锁，或事务、乐观锁），大部分时候可以满足大部分人的需求。<br>而如今互联网应用的量级已经几何级别的爆发，利用诸如 zookeeper、redis 等更高效的分布式组件来实现分布式锁，可以提供高可用的更强壮的锁特性，并且支持丰富化的使用场景。</p><p>开源实现已有不少比如 Redis 作者基于 Redis 设计的 Redlock、Redission 等。</p><p>常见的分布式锁的实现：</p><ol><li>Memcached 分布式锁<br>利用 Memcached 的 add 命令。此命令是<strong>原子性操作</strong>，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁。</li><li>Redis 分布式锁<br>和 Memcached 的方式类似，利用 Redis 的 setnx 命令。此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。（setnx 命令并不完善，后续可能会介绍替代方案）</li><li>Zookeeper 分布式锁<br>利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。</li><li>Chubby<br>Google 公司实现的粗粒度分布式锁服务，底层利用 Paxos 一致性算法。</li><li>Etcd<br>后起之秀，从读写性能、可靠性、可用性、安全性和复杂度等方面综合考量，它完全媲美业界 “名宿” ZooKeeper，在有些方面，Etcd 甚至超越了 ZooKeeper。</li></ol><p>这里也就说说他们实现的原理，具体的代码并不会完整的贴出来。</p><h2 id="Memcached实现"><a href="#Memcached实现" class="headerlink" title="Memcached实现"></a>Memcached实现</h2><p>Memcached 是一个自由开源的，高性能，分布式内存对象缓存系统。<br>Memcached 是一种<strong>基于内存的 key-value 存储</strong>，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API 调用或者是页面渲染的结果。<br>Memcached 简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的 API 兼容大部分流行的开发语言。本质上，它是一个简洁的 key-value 存储系统。<br>一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<br>分布式锁也就是用了 add 操作原子性的特点，用伪代码表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mc.Add(<span class="string">"LockKey"</span>, <span class="string">"Value"</span>, expiredTime))&#123;</span><br><span class="line">  <span class="comment">//得到锁</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//do business function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查超时</span></span><br><span class="line">    <span class="keyword">if</span> (!CheckedTimeOut())&#123;</span><br><span class="line">      mc.Delete(<span class="string">"LockKey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    mc.Delete(<span class="string">"LockKey"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，现在大部分都用 Redis 来搞了。</p><h3 id="与Redis比较"><a href="#与Redis比较" class="headerlink" title="与Redis比较"></a>与Redis比较</h3><p>看到这里就不得不说它和 Redis 的区别了：</p><ol><li>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash, 有序&amp;无序列表 数据结构的存储。</li><li>Redis支持数据的备份，即 master-slave 模式的数据备份。</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis 可以实现主从复制，实现故障恢复。</li><li>Redis 的 Sharding 技术： 很容易将数据分布到多个 Redis 实例中</li><li>Redis 支持服务器端的数据操作</li><li>使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。</li><li>由于 Redis 只使用单核，而 Memcached 可以使用多核，单实例吞吐量极高，可以达到几十万 QPS，但是平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。</li><li>Memcached 是多线程，分为监听线程、worker 线程，引入锁，带来了性能损耗。Redis 使用单线程的 IO 复用模型，将速度优势发挥到最大，也提供了较简单的计算功能 。</li></ol><p>Redis 中有不少好用的命令，例如 getset，比先 get 然后再 set 来回的网络开销不知道好了多少倍。<br>不过还是要根据实际情况来选择使用。</p><blockquote><p>为什么 Redis 采用单核单线程？</p><p>因为 CPU 不是 Redis 的瓶颈。Redis 的瓶颈最有可能是机器内存或者网络带宽。<br>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>PS：普通笔记本轻松处理每秒几十万的请求</p><p><strong>如果万一 CPU 成为你的 Redis 瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？</strong></p><p>那也很简单，你多起几个 Redis 进程就好了。Redis 是 key-value 数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。<br>redis-cluster 可以帮你做的更好。</p></blockquote><h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><blockquote><p>参见笔记地址：<a href="https://github.com/bfchengnuo/MyRecord/blob/315f44429d31f73661e617c96b081fad2cbb1e33/%E7%AC%94%E8%AE%B0/Java/Web/%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md" target="_blank" rel="noopener">MyRecord</a></p></blockquote><p>使用 Redis 实现分布式锁首先要先知道几个 Redis 的命令，分布式锁就是通过这几个命令来实现的</p><ul><li>setnx<br>只有不存在的时候，setnx 才会设置值成功；<br>可以理解为是否存在和设置值这两条命令的集合版，不过是原子性的。</li><li>getset<br>先 get 再 set，也是两条命令的整合，具有原子性。</li><li>expire<br>设置有效期</li><li>del<br>删除</li></ul><h3 id="实现原理-流程"><a href="#实现原理-流程" class="headerlink" title="实现原理-流程"></a>实现原理-流程</h3><p>首先使用 setnx 存入一个值，key 为锁名，val 为当前的时间戳加一个超时时间，这是为了防止死锁。</p><p><img src="https://user-images.githubusercontent.com/16206117/45962253-02682b80-c053-11e8-8873-06ebe570140f.png" alt="one"></p><p>仔细看这个架构好像有点问题，因为我们设置的 val 根本没用，也没有任何的防死锁措施，只是实现比较简单而已，更完善的第二版在这：</p><p><img src="https://user-images.githubusercontent.com/16206117/45962340-39d6d800-c053-11e8-8bf1-f073a31debc8.png" alt="two"></p><p>当获取锁失败时，为了防止死锁，我们还需要进行一些判断，只要判定时间已经超时，就可以认为可以尝试去得到锁，然后接下来判断新的值写进去了没，只有新的时间戳写进去了才能认为是得到锁了，这样基本就不会出现死锁的情况了，下面来看看具体的代码。</p><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>按照有瑕疵的第一张流程实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">  <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>,<span class="string">"5000"</span>));</span><br><span class="line"></span><br><span class="line">  Long setnxResult = RedisShardedPoolUtil</span><br><span class="line">    .setnx(</span><br><span class="line">    Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">    String.valueOf(System.currentTimeMillis()+lockTimeout)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">    closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log.info(<span class="string">"没有获得分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 有效期5秒，防止死锁</span></span><br><span class="line">  RedisShardedPoolUtil.expire(lockName,<span class="number">5</span>);</span><br><span class="line">  log.info(<span class="string">"获取&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">           Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">           Thread.currentThread().getName());</span><br><span class="line">  <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil</span><br><span class="line">                              .getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">  orderService.closeOrder(hour);</span><br><span class="line">  <span class="comment">// 删除 key，释放锁</span></span><br><span class="line">  RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  log.info(<span class="string">"释放&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">           Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">           Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这个防不了死锁，我们设置的超时时间也没用到，当执行到 closeOrder 方法之前宕掉的话，那么因为这个 key 没有设置有效期，就会到期其他模块一直进不去。<br>closeOrder 中的设置有效期和执行后的删除键（释放锁）也是双重防死锁，这个有效期需要根据线上运行的实际情况来得出一个合理的时间。</p><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>循序渐进，来看看如何解决死锁问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron=<span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">  <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>,<span class="string">"5000"</span>));</span><br><span class="line">  Long setnxResult = RedisShardedPoolUtil.setnx(</span><br><span class="line">    Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">    String.valueOf(System.currentTimeMillis()+lockTimeout));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>)&#123;</span><br><span class="line">    closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁</span></span><br><span class="line">    String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    <span class="keyword">if</span>(lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123;</span><br><span class="line">      String getSetResult = RedisShardedPoolUtil.getSet(</span><br><span class="line">        Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">        String.valueOf(System.currentTimeMillis()+lockTimeout));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据返回的旧值，判断是否可以获取锁</span></span><br><span class="line">      <span class="keyword">if</span>(getSetResult == <span class="keyword">null</span></span><br><span class="line">         || (getSetResult != <span class="keyword">null</span> </span><br><span class="line">             &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123;</span><br><span class="line">        <span class="comment">//已真正获取到锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        log.info(<span class="string">"没有获取到分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      log.info(<span class="string">"锁未失效，没有获取到分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看上去基本就是万无一失了，前半段并不需要修改，我们在 else 后做了一个超时判断，来觉得是否可以重置锁，这个判断可是不简单呢。<br>首先通过 get 方法来获取 val，用这个 val 和当前时间的时间戳来判断是否超时，然后我们使用 getset 方法重新获取老值，并且重新设置超时时间（原子操作）；<br>根据返回的旧值，判断是否可以获取锁，这里会有三种情况：</p><ul><li>当 key 没有旧值时，即 key 不存在时，返回 nil 对应 Java 中的 Null 这说明其他分布式程序已经执行完使用 del 删除了键（释放了锁）或者过了 Redis 的生存时间； 这时可以安全获取锁。</li><li>当 key 有旧值，并且旧值和之前获取的一致的情况下 这说明这段时间没有程序操作这把锁，并且因为 getset 之后重新设置了有效期，可以保证现在也是安全的，可以获取锁。</li><li>当 key 有旧值，并且旧值和之前获取的不一致的情况下 这说明在程序执行期间有其他的分布式模块也操作了这把锁，并且对方比较快，先执行了 getset 这就导致两个旧值对不起来，这种情况下只能放弃，等待下次获取。</li></ul><h3 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h3><p>先来看看基本的介绍：</p><blockquote><p>Redisson 是架设在 Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）。<br>充分的利用了 Redis 键值数据库提供的一系列优势，基于 Java 实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，<strong>更进一步简化了分布式环境中程序相互之间的协作。</strong><br>Redisson 采用了基于 NIO 的 Netty 框架，不仅能作为 Redis 底层驱动<strong>客户端</strong>，具备提供对 Redis 各种组态形式的连接功能，对 Redis 命令能以同步发送、异步形式发送、异步流形式发送或管道形式发送的功能，LUA 脚本执行处理，以及处理返回结果的功能，还在此基础上融入了更高级的应用方案。<br>Redisson 生而具有的高性能，分布式特性和丰富的结构等特点恰巧与 Tomcat 这类服务程序对会话管理器（Session Manager）的要求相吻合。利用这样的特点，Redisson 专门为 Tomcat 提供了会话管理器（Tomcat Session Manager）。<br>在此不难看出，Redisson 同其他 Redis Java 客户端有着很大的区别，<strong>相比之下其他客户端提供的功能还仅仅停留在作为数据库驱动层面上</strong>，比如仅针对 Redis 提供连接方式，发送命令和处理返回结果等。像上面这些高层次的应用则只能依靠使用者自行实现。</p></blockquote><p>可以看出 Redisson 对分布式一些工具做了很好的封装，如今分布式盛行的年代下，越来越多的项目使用 Redisson 作为 Redis 的客户端，使用它可以更方便的使用 Redis 分布式锁，来看第三版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RLock lock = redissonManager</span><br><span class="line">    .getRedisson()</span><br><span class="line">    .getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  <span class="keyword">boolean</span> getLock = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(getLock = lock.tryLock(<span class="number">0</span>,<span class="number">50</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">      log.info(<span class="string">"Redisson获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">               Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">               Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">int</span> hour = Integer</span><br><span class="line">        .parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">      orderService.closeOrder(hour);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      log.info(<span class="string">"Redisson没有获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">               Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">               Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">"Redisson分布式锁获取异常"</span>,e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!getLock)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    log.info(<span class="string">"Redisson分布式锁释放锁"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中使用了 Redisson 提供的 RLock 对象来获取、释放锁，这其实是一种<strong>可重入锁</strong>，Redisson 还提供了其他的多种锁，就不多说了；用这个来实现分布式锁原理其实是一样的，只不过被 Redisson 封装后更加的简单了。<br>使用 RLock 的 tryLock 方法来尝试获取锁，可以使用三个参数的构造，第一个是最多等待时间（超时就直接过了），第二个是自动解锁时间，第三个是时间单位。<br>这里的等待时间如果预估不准可以写 0，否则就会出现同时获得锁的情况，也就是程序执行的太快，还没超过等待时间所以又被第二个拿到了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外，关掉 Tomcat 的时候如果你不是直接 kill 掉，而是温柔的杀死他，使用 <em>shutdown</em>，那么可以使用这个注解来保证在它死之前执行 del 删除锁来避免死锁，虽然这很不现实，如果方法执行时间过长很多人也不能忍受。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有类似的好用注解，例如 @PostConstruct 标注 init 方法，会在构造完成后执行这个初始化。</p><h2 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h2><p>常见的实现方式又分两种，但总的来说并不常用，因为用数据库的话比较费资源，效率也不高：</p><ul><li>完全基于数据库表的</li><li>基于数据库排它锁</li></ul><p>参见：<a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1716</a></p><h3 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h3><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。<br><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</strong><br>创建这样一张数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p>当我们想要锁住某个方法时，执行以下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了<strong>唯一性约束</strong>，这里如果有多个请求同时提交到数据库的话，<strong>数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁</strong>，可以执行方法体内容。<br>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><p>上面这种简单的实现有以下几个问题：</p><ol><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是<strong>非阻塞</strong>的，因为数据的 insert 操作，一旦插入失败就会直接报错。<br>没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是<strong>非重入</strong>的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ol><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？<br>搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？<br>只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？<br>搞一个 while 循环，直到 insert 成功再返回成功。</li><li>非重入的？<br>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul><h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><p>除了可以通过增删操作数据表中的记录以外，其实还可以<strong>借助数据中自带的锁来实现分布式的锁</strong>。<br>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于 MySql 的 InnoDB 引擎，可以使用以下方法来实现加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        result = <span class="string">"select * from methodLock where method_name=xxx for update"</span>;</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁。</p><blockquote><p>这里再多提一句，InnoDB 引擎在加锁的时候，<strong>只有通过索引进行检索的时候才会使用行级锁</strong>，<strong>否则会使用表级锁</strong>。<br>这里我们希望使用行级锁，就要给 method_name 添加索引，值得注意的是，这个索引<strong>一定要创建成唯一索引</strong>，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。<br>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p></blockquote><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>connection.commit()</code>操作来释放锁。<br>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？<br><code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？<br>使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><blockquote><p>这里还可能存在另外一个问题，虽然我们对 method_name 使用了唯一索引，并且显示使用 <code>for update</code> 来使用行级锁。<br>但是，MySql 会对查询进行优化，即便在条件中使用了索引字段，但<strong>是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的</strong>，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p></blockquote><p><strong>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下使用数据库来实现分布式锁的方式，这两种方式<strong>都是依赖数据库的一张表</strong>，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p><ul><li><strong>优点</strong><br>直接借助数据库，容易理解。</li><li><strong>缺点</strong><br>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。<br>操作数据库需要一定的开销，性能问题需要考虑。<br>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</li></ul><p>关于其他的各种锁，参加  <a href="https://github.com/bfchengnuo/MyRecord/issues/5" target="_blank" rel="noopener">issues</a>，整理中…</p><h2 id="Zookeeper实现"><a href="#Zookeeper实现" class="headerlink" title="Zookeeper实现"></a>Zookeeper实现</h2><p>基于 zookeeper 临时有序节点可以实现的分布式锁。<br>大致思想即为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点，操作完成后断开自动删除。<br>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个（非阻塞情况下，直接判断有没有节点就好了）。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。<br>来看下 Zookeeper 能不能解决前面提到的问题。</p><ul><li>锁无法释放？<br>使用 Zookeeper 可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在 ZK 中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session 连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>只能是非阻塞锁？<br>使用 Zookeeper 可以实现阻塞的锁，客户端可以通过在 ZK 中<strong>创建顺序节点</strong>，并且在节点上<strong>绑定监听器</strong>，一旦节点有变化，Zookeeper 会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>不可重入？<br>使用 Zookeeper 也可以有效的解决不可重入的问题，客户端在创建节点的时候，<strong>把当前客户端的主机信息和线程信息直接写入到节点中</strong>，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。<br>如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>单点问题？<br>使用 Zookeeper 可以有效的解决单点问题，ZK 是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul><p>可以直接使用 zookeeper 第三方库 <a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a> 客户端，这个客户端中封装了一个可重入的锁服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    interProcessMutex.release();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), </span><br><span class="line">                             delayTimeForClean,</span><br><span class="line">                             TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Curator 提供的 InterProcessMutex 是分布式锁的实现。acquire 方法用户获取锁，release 方法用于释放锁。</p><h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><p>使用 ZK 实现的分布式锁好像完全符合了我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper 实现的分布式锁其实存在一个缺点，那就是<strong>性能上可能并没有缓存服务那么高</strong>。<br>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同不到所有的 Follower 机器上。</p><hr><p>其实，使用 Zookeeper 也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可能和 ZK 集群的 session 连接断了，那么 zk 以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。<br>就可能产生并发问题。这个问题不常见是因为 zk 有重试机制，一旦 zk 集群检测不到客户端的心跳，就会重试， Curator 客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。<br>所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>优点</strong><br>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。<br>实现起来较为简单。</li><li><strong>缺点</strong><br>性能上不如使用缓存实现分布式锁。<br>需要对 ZK 的原理有所了解。</li></ul><h2 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像 CAP 一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><ul><li><strong>从理解的难易程度角度（从低到高）</strong><br>数据库 &gt; 缓存 &gt; Zookeeper</li><li><strong>从实现的复杂性角度（从低到高）</strong><br>Zookeeper &gt;= 缓存 &gt; 数据库</li><li><strong>从性能角度（从高到低）</strong><br>缓存 &gt; Zookeeper &gt;= 数据库</li><li><strong>从可靠性角度（从高到低）</strong><br>Zookeeper &gt; 缓存 &gt; 数据库</li></ul><p>目前来说，一提到分布式锁很多人第一反应就是 Redis，但是分布式锁本质是一个 CP 需求，基于 Redis 的实现的是一个 AP 需求，不过脱离业务场景来谈架构都是耍流氓。<br>例如，业务是金融交易这种需要强锁的情况下，Redis 就不太行了，需要 CP 的实现，例如 etcd 等。</p><blockquote><p>一个<strong>分布式计算系统来说</strong>，不可能同时满足以下三点：</p><ul><li><strong>一致性（Consistency）</strong><br>等同于所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong><br>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</li><li><strong>分区容错性（Partition tolerance）</strong><br>以实际效果而言，分区相当于对通信的时限要求。<br>系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ul><p><strong>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项</strong>。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>其他没有说到的就自己搜索探寻吧！</p><p><a href="https://gitbook.cn/books/5bb037728f7d8b7e900ff2d7/index.html" target="_blank" rel="noopener">想了解 etcd 的点这</a><br><a href="http://catkang.github.io/2017/09/29/chubby.html" target="_blank" rel="noopener">想了解 Chubby 的点这</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的面试，动不动就微服务、分布式、高并发、缓存、并发编程等，不管用不用得到，你反正得会才行，分布式锁也算是很重要的一块，之前我在 &lt;a href=&quot;https://github.com/bfchengnuo/MyRecord/issues/22&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github 的 issues&lt;/a&gt; 中写过，现在单独摘出来再总结下，因为真的问的太多了。&lt;/p&gt;
&lt;p&gt;分布式锁，是控制分布式系统之间&lt;strong&gt;同步访问共享资源的一种方式&lt;/strong&gt;。
    
    </summary>
    
      <category term="自我提升" scheme="http://bfchengnuo.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="数据库" scheme="http://bfchengnuo.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="http://bfchengnuo.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="微服务" scheme="http://bfchengnuo.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>初探SpringCloud</title>
    <link href="http://bfchengnuo.com/2018/09/23/%E5%88%9D%E6%8E%A2SpringCloud/"/>
    <id>http://bfchengnuo.com/2018/09/23/初探SpringCloud/</id>
    <published>2018-09-23T13:11:49.000Z</published>
    <updated>2018-09-23T13:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>如期而至，关于什么是 SpringCloud 这里不多说，之前的<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Web/SpringCloud%E7%94%9F%E6%80%81%E5%9C%88.md" target="_blank" rel="noopener">笔记</a>已经把 SpringCloud 生态的主要技术都做了解释，但是这里对笔记进行补充一下，关于微服务、微服务架构，以及 SpringBoot 与 Cloud、Dubbo 之间微妙的关系做个简单的解释~<a id="more"></a><br>然后就是实践部分，先搞一个简单的 Demo 出来试试~</p><p>微服务：一种架构风格，重点在个体，拆分为单个的模块，具体的一个服务，仅关注自己负责的，比如现在流行使用 SpringBoot 来构建。<br>微服务架构：重点在整体，关注各个微服务之间的关系，如何治理好这些微服务，她要求各个微服务独立部署，能拥有“独立的空间（例如独立的数据库）”，现在流行使用 SpringCloud 提供的一站式解决方案构建。<br>微服务目前业内还没有一个准确的概念，<del>上面的是我瞎说的</del> o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br>说到微服务架构就必须要分布式了，其中涉及的还有服务注册发现中心、服务调用方式（轻量级网络协议交互，REST、RPC）、服务监控、断路器、服务网关、分布式配置、服务跟踪、服务总线、数据流、批量任务等等。</p><p>可以看出，SpringCloud 作为全局的服务治理框架，它依赖于 SpringBoot，而与 Dubbo 的最显著区别就是 SpringCloud 使用 REST；Dubbo 使用 RPC。<br>使用 REST 更加灵活，并且语言无关，但是没有 RPC 的效率高，同时 RPC 也存在一些自身的问题。</p><blockquote><p>当前由于 RPC 协议，注册中心元数据不匹配等问题，在面临微服务基础架构选型时，Dubbo 和 SpringCloud 只能二选一，所以才会出现两者的比较。<br>Dubbo 负责人表示之后会积极寻求适配到 SpringCloud 生态</p></blockquote><p>如果 Dubbo 不停更 5 年的话，说不定又是另一番景象呢。</p><h2 id="微服务搭建"><a href="#微服务搭建" class="headerlink" title="微服务搭建"></a>微服务搭建</h2><p>这个不是重点，但是确实前提条件，所以需要先用 SpringBoot 搭出至少两个微服务，一个做服务提供，一个做服务消费，然后在这个基础上加 SpringCloud。<br>关于 SpringCloud 的生态圈涉及的技术太多了，看了不少视频和资料，大部分都是对主要的几个技术来做介绍，实际上也大部分都是用这些技术，其他的也就不多说了，感兴趣的可以去官方或者<a href="https://springcloud.cc/" target="_blank" rel="noopener">中文网</a>逛逛，挺全的。</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>使用 Eureka 来实现服务的注册与发现，介绍之前说过了不多说，它分为客户端和服务端，一般会新建一个项目（微服务）作为服务端，这里就需要加入 SpringCloud 的依赖管理来负责做版本仲裁，然后也需要加入 EureKa 服务端的依赖，注意是以结尾的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在启动类使用注解开启功能，这个是 SpringCloud 的通用套路，先加依赖，然后在启动类添加 @EnableXXX 开启相关配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明这是一个Eureka服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，配置一下相关参数就可以启动测试了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中，本身就是,所以无需注册</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Eureka客户端与Eureka服务端进行交互的地址</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>访问一下就可以看到相关的系统信息了，下面就可以把之前创建的微服务服务方注册到 Eureka 中了，如果某个微服务确定没有其他的微服务依赖它，那可以不用注册进来；<br>方法和之前的套路一样，加入 SpringCloud 的依赖管理，加入 Eureka 的依赖（可以是客户端也可以是服务端，推荐客户端），然后关键的地方就是配置文件的修改了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span> </span><br><span class="line">    <span class="comment"># 指定服务名，非常重要</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-item</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中，默认为 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息，默认为true</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line">  <span class="comment"># 将自己的 ip 地址注册到 Eureka 服务中</span></span><br><span class="line"><span class="attr">  instance:</span> </span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 可以手动指定地址，可以可以通过表达式来获取</span></span><br><span class="line">    <span class="comment"># $&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br><span class="line"><span class="attr">    ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>最后，在主启动类上加入 <code>@EnableDiscoveryClient</code> 注解，表名这是个客户端即可。<br>另一个作为消费端的微服务也是一样，唯一不同的是配置文件里就不需要将自己注册到 Eureka 服务中了，也不需要设置了 instance 了。<br>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">queryItemById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    String serviceId = <span class="string">"microService-item"</span>;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.discoveryClient.getInstances(serviceId);</span><br><span class="line">    <span class="keyword">if</span>(instances.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了演示，在这里只获取一个实例</span></span><br><span class="line">    ServiceInstance serviceInstance = instances.get(<span class="number">0</span>);</span><br><span class="line">    String url = serviceInstance.getHost() + <span class="string">":"</span> + serviceInstance.getPort();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://"</span> + url + <span class="string">"/item/"</span> + id, Item.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果导入的是服务端依赖，某些版本的 SpringCloud 会响应 XML 格式的数据，而我们希望它是 JSON，破坏了 SpringMVC 的默认配置，可以在 eureka server 的依赖中排除 jackson-dataformat-xml。<br>对于 eureka 来说，这两个微服务都属于客户端，所以还是建议只导客户端依赖就好。<br>另外，你还可以开启 Eureka 的身份认证，需要导入相应的依赖，一旦开启，需要在客户端配置好凭证。</p><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>Eureka 的集群非常好搭建，为了避免单点故障，集群是很有必要的，只要启动多个 Eureka 服务并且让这些服务之间彼此进行注册即可实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中,这次选择 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址，选择另一台 Eureka 服务端</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://loli:pwd@127.0.0.1:6869/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############## 第二台服务端 ################</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6869</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中,这次选择 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址，选择另一台 Eureka 服务端</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">security:</span> </span><br><span class="line"><span class="attr">  basic:</span> </span><br><span class="line">    <span class="comment"># 开启基于 HTTP basic 的认证</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">  user:</span> </span><br><span class="line"><span class="attr">    name:</span> <span class="string">loli</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">pwd</span></span><br></pre></td></tr></table></figure><p>他们的 defaultZone 互相指向对方，通过端口来区分，而微服务名字都是保持一致的，这样服务端的集群就搭建好了，而客户端注册的时候需要同时向这两台来注册，地址之间使用逗号分割。</p><h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>之前说过，Eureka 和 ZK 的一个区别，ZK 是按照 CP 原则来构建的，而 Eureka 是 AP 来做的。<br>默认情况下，如果 Eureka Server 在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server 将会移除该实例。但是当网络分区故障发生时，微服务与 Eureka Server 之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。<br>当 Eureka Server 节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server 就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该 Eureka Server 节点会自动退出自我保护模式。<br>Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，<strong>对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</strong><br>我们在单机测试的时候很容易满足心跳失败比例在 15 分钟之内低于 85%，这个时候就会触发 Eureka 的保护机制，一旦开启了保护机制，则服务注册中心维护的服务实例就不是那么准确了，此时我们可以使用<code>eureka.server.enable-self-preservation=false</code>来关闭保护机制，这样可以确保注册中心中不可用的实例被及时的剔除（<strong>不推荐</strong>）。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>这里再以 properties 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#================================服务端==============================</span><br><span class="line">#应用名称</span><br><span class="line">spring.application.name=eureka-server-v1</span><br><span class="line">#应用端口</span><br><span class="line">server.port=7000</span><br><span class="line">#=======eureka中心配置=======</span><br><span class="line">#主机名</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line"># 注册时显示ip</span><br><span class="line">#eureka.instance.prefer-ip-address=true</span><br><span class="line">#是否注册为服务</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">#是否检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line">#eureka默认空间的地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br><span class="line">#关闭自我保护(生产时打开该选项)</span><br><span class="line">eureka.server.enable-self-preservation=false</span><br><span class="line">#扫描失效服务的间隔时间（缺省为60*1000ms）</span><br><span class="line">eureka.server.eviction-interval-timer-in-ms=5000</span><br><span class="line"></span><br><span class="line">#================================客户端==============================</span><br><span class="line">#端口号</span><br><span class="line">server.port=8081</span><br><span class="line">#服务名</span><br><span class="line">spring.application.name=produce-service-v1</span><br><span class="line">#=======eureka配置========</span><br><span class="line">#注册到eureka中心，获取到配置服务</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:7000/eureka/</span><br><span class="line">#设置实例的ID为ip:port</span><br><span class="line">eureka.instance.instance-id=$&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;</span><br><span class="line">#========续约配置=========</span><br><span class="line"># 心跳时间，即服务续约间隔时间（缺省为30s）</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=5</span><br><span class="line"># 发呆时间，即服务续约到期时间（缺省为90s）</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=10</span><br><span class="line"># 开启健康检查（依赖spring-boot-starter-actuator）</span><br><span class="line">eureka.client.healthcheck.enabled=true</span><br></pre></td></tr></table></figure><p>这些应该够用了吧…..</p><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>使用 Ribbon 实现<strong>客户端负载均衡</strong>，说到负载均衡，可以简单分为两类：</p><ul><li>集中式<br>消费方和服务方中间使用独立的 LB 设施，例如 F5、nginx 这类就是。</li><li>进程内<br>一般集成到消费方，Ribbon 就是如此。</li></ul><p>使用前的老一套不说了，导入依赖（eureka-server 中已经包含了 Ribbon 的依赖），在主启动类使用 @RibbonClient （简单使用可以不加）进行配置工具类。<br>然后，在 Config 创建 RestTemplate 对象上设置 <code>@LoadBalanced</code> 注解就表示已经启用负载均衡啦！</p><blockquote><p>开启后，在执行请求前会经过 <code>org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor</code> 这个拦截器，并且通过 <code>org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</code> 的时候会根据 serverId 查找服务地址，然后在去做真正的请求；<br>所以 RestTemplate 请求的 URL 可以直接使用服务名，而不需要手动获取地址了。</p></blockquote><p>Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、 配置中心、 API 网关那样需要独立部署， 但是它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。 因为微服务间的调用，API 网关的请求转发等内容实际上都是通过Ribbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon实现的工具。<br>SpringCloud 服务调用的方式一般就是两种：</p><ul><li>Ribbon + RestTemplate</li><li>Feign</li></ul><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>Ribbon 自带了七中负载均衡的算法。默认轮询，当想选择其他算法时，在配置类里使用 @Bean 声明需要的官方提供的 IRule 其他实现类即可，这是 SpringBoot 自动配置的知识了。<br>也正是因为这个原因，如果我们想自己实现负载均衡算法，除了需要在启动类使用 @RibbonClient 注解指定服务名和负载均衡算法具体实现类（需要在 @Configuration 下）外，<strong>还要求这个类不能在包扫描范围内</strong>。<br>首先，可以自定义负载均衡规则，可以在配置文件里设置也可以使用注解：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">microService-consumer:</span>  </span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>在启动类上设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">// 在启动该微服务的时候就能去加载我们的自定义 Ribbon 配置类，从而使配置生效</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"MICROSERVICECLOUD-DEPT"</span>,configuration=MySelfRule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后就是实现自己的负载均衡算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 随机使用 RoundRobinRule();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestLB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLB</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>一般来说，默认的轮询就已经够用了。</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>使用 Feign 实现声明式的 REST 调用，是为了简化 RestTemplate 的使用，让我们的代码更优雅，添加依赖就不多说了，主启动类加上 <code>@EnableFeignClients</code> 注解，这也是加在客户端（消费端）的。<br>然后声明一个接口，然后可以像写 SpringMVC 哪样来定义这个接口的方法啦！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明这是一个Feign客户端，并且指明服务 id</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"microService-item"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemFeignClient</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里定义了类似于SpringMVC用法的方法，就可以进行RESTful的调用了</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/item/&#123;id&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">queryItemById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 多参数构造-1</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">get1</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id, @<span class="title">RequestParam</span><span class="params">(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line">  <span class="comment">// 多参数构造-2</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">get2</span><span class="params">(@RequestParam Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Feign 使用，简单说：创建一个接口（使用 @FeignClient 标注），在上面使用 SpringMVC 注解即可；相当于封装了 RestClient。<br>只需要定义接口就可以完成调用，很显然是用了动态代理，在 FeignClient 中的定义方法以及使用了 SpringMVC 的注解，Feign 就会根据注解中的内容生成对应的 URL，然后<strong>基于 Ribbon 的负载均衡去调用 REST 服务</strong>。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>使用 Hystrix 的熔断机制保护应用，在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。<br>它是在服务端（服务提供方）使用的技术，使用起来非常简单，除了必要的依赖、在主启动类使用 <code>@EnableHystrix</code> 注解开启功能，只需要在 Service 的方法上加上 <code>@HystrixCommand(fallbackMethod= &quot;fallbackMethod&quot;)</code> 注解就可以了，其中 fallbackMethod 是具有类似方法签名的备用方法，当此方法的调用不可用时就会走这个备用方法。<br>但是这里会有一个问题，如果一个核心方法对应一个备用方法，很容易就会造成方法膨胀，耦合性还很高，这样也太不优雅了，所以可以使用 AOP 的思想来解决这个问题嘛~其实这样可以做服务降级，配合 Feign 来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该接口下哪个方法抛异常，会调 fallbackFactory</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"MICROSERVICECLOUD-DEPT"</span>,fallbackFactory=MyFallbackFactory.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptClientService</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptClientService</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这样就可以达到容错的目的了，说到这里，不得不提涉及的两个概念，服务降级和服务熔断。</p><blockquote><ul><li><p>服务熔断<br>主逻辑因短期内多次失败（也有可能是由于自我保护机制），而被暂时性的忽略，不再尝试使用，这种叫熔断。</p></li><li><p>服务降级:<br>主逻辑失败采用备用逻辑的过程叫做降级（<del>也就是服务降级发生在服务熔断之后</del>）。<br>当整体资源快消耗殆尽的时候（例如内存、CPU等），将某些服务临时关掉一大部分以释放资源（一般留下一个来维持运行返回给用户友好的提示），减轻主模块的压力，待资源恢复可用再开启。</p></li></ul><p>看上去熔断和降级是非常相似的，都是调用失败后调用备用方法；但是他们的着重点是不同的。<br>不管是服务降级还是熔断，他们的目的都是为了保证程序的健壮性，对于一些非核心服务，如果出现大量的异常，可以通过技术手段，对服务进行降级并提供有损服务，保证服务的柔性可用，避免引起雪崩效应。<br>开启熔断之后，如何实现自动恢复？<br>每隔一段时间，会释放一个请求到服务端进行探测，如果后端服务已经恢复，则自动恢复。</p></blockquote><p>此外，Hystrix 还具有服务监控的功能，它提供了准实时的调用监控 HystrixDashboard，是可视化界面，可以进行实时监测。<br>这个监控使用非常简单，新建一个微服务，加入相关依赖，在启动类上加上 <code>@EnableHystrixDashboard</code> 就可以用啦！</p><h2 id="SpringCloudZuul"><a href="#SpringCloudZuul" class="headerlink" title="SpringCloudZuul"></a>SpringCloudZuul</h2><p>因为之前笔记有，介绍咱们还是略过，简单理解为它相当于是个过滤器或者拦截器就好了，继续新建一个微服务，导入相关依赖，在主启动类加入 <code>@EnableZuulProxy</code> 注解。<br>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 REST API 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能，将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。<br>从上面的介绍可以看出，它还需要 Eureka 等依赖加强功能，让后面的微服务专心做自己的事情。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6677</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-api-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span> </span><br><span class="line"><span class="attr">  ignored-services:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">  prefix:</span> <span class="string">/atguigu</span></span><br><span class="line"><span class="attr">  routes:</span> </span><br><span class="line">    <span class="comment"># 名字可以随意起</span></span><br><span class="line"><span class="attr">    item-service:</span></span><br><span class="line">      <span class="comment"># 配置请求 URL 的请求规则</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/item-service/**</span></span><br><span class="line">      <span class="comment"># 真正的微服务地址，可以使用 url ，也可以指定 Eureka 注册中心中的服务 id</span></span><br><span class="line">      <span class="comment"># url: http://127.0.0.1:8081</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">microservice-item</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否注册自己，默认为true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span> </span><br><span class="line">    <span class="comment"># 将自己的ip地址注册到Eureka服务中</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="string">app.name:</span> <span class="string">microcloud</span></span><br><span class="line">  <span class="string">company.name:</span> <span class="string">www.bfchengnuo.com</span></span><br><span class="line">  <span class="string">build.artifactId:</span> <span class="string">$project.artifactId$</span></span><br><span class="line">  <span class="string">build.version:</span> <span class="string">$project.version$</span></span><br></pre></td></tr></table></figure><p>同时，Zuul 还支持正则匹配、拦截器、路由前缀等功能，由于是入门，这里就不多说了。</p><h2 id="SpringCloudConfig"><a href="#SpringCloudConfig" class="headerlink" title="SpringCloudConfig"></a>SpringCloudConfig</h2><p>使用 SpringCloudConfig 统一管理微服务的配置，可以让我们统一管理配置文件，以及实时同步更新，并不需要重新启动应用程序，默认使用 Git 存储配置文件内容。<br>同样，它也分为客户端和服务端，服务端可以新建一个微服务，加入相应的依赖，在主启动类加上 <code>@EnableConfigServer</code> 注解就可以使用了，当然还是要写一点配置的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6688</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-config-server</span></span><br><span class="line"><span class="attr">  cloud:</span>  </span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span> </span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://172.16.55.138:10080/bfchengnuo/config-server.git</span></span><br><span class="line">          <span class="comment">#username: loli</span></span><br><span class="line">          <span class="comment">#password: 123456</span></span><br></pre></td></tr></table></figure><p>还是推荐使用 SSH 密钥认证的方式，这样就可以通过 SpringCloudConfig 直接访问 Git 上的配置文件，同时它支持 properties 和 yml 的互相转换，通过请求地址的后缀实现。<br>客户端的使用也是类似，导入没有 server 后缀的依赖，另外为了避免地址的硬编码，可以将服务端使用 @EnableDiscoveryClient 也注册到 Eureka 中，然后在客户端使用服务名来访问。<br>需要新建配置文件：<code>bootstrap.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line">      <span class="comment"># 对应的配置服务中的应用名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">microservice</span></span><br><span class="line">      <span class="comment"># uri: http://127.0.0.1:6869/</span></span><br><span class="line">      <span class="comment"># 对应配置服务中的 &#123;profile&#125;</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      discovery:</span> </span><br><span class="line">      <span class="comment"># 启用发现服务功能</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 指定服务名称</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">microservice-config-server</span></span><br></pre></td></tr></table></figure><p>因为 <code>bootstrap.yml</code> 优先与 <code>application.yml</code> 加载（先读取了配置才能启动啊），所以把发现服务配置在 bootstrap 里。<br>然后你可以使用 @Value 来注入配置，就是和配置文件在本地是一样使用。<br>为了能够让配置自动更新，还需要为 Config Client 添加 refresh 支持，就是导入一个 <code>spring-boot-starter-actuator</code> 依赖，然后在配置类对应的实体类上加上 <code>@RefreshScope</code> 注解（测试可以临时把 actuator 安全认证关掉 <code>management.security.enabled</code>）。<br>然后就可以使用 post 请求 <code>/refresh</code> 地址来更新配置内容了。<br>更新后还需要手动访问下这个地址未免太麻烦了，所以，可以借助 git 的 webhook（web 钩子）实现自动更新。</p><h2 id="SpringCloudBus"><a href="#SpringCloudBus" class="headerlink" title="SpringCloudBus"></a>SpringCloudBus</h2><p>消息总线 Spring Cloud Bus 也是很重要的，例如它可以更优雅的完成自动更新配置文件，简单的你可以理解为它就是个消息的交换机，所有的微服务模块都监听它，所以可以实现配置、缓存等的更新。<br>以 RabbitMQ 为例，就先在 ConfigServer 中来加入吧，导入 spring-cloud-starter-bus-amqp 依赖，在 application.yml 添加 rabbitmq 的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">microservice</span></span><br><span class="line">      <span class="comment"># uri: http://127.0.0.1:6869/</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      discovery:</span> </span><br><span class="line">        <span class="comment"># 启用发现服务功能</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">microservice-config-server</span></span><br><span class="line">  <span class="comment"># RabbitMQ 相关的配置</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure><p>然后，会自动注册一个 <code>/bus/refresh</code> 的请求，这个请求就是由消息总线来处理的，那么我们可以设置当配置更新后 web 钩子向统一配置服务器发送 <code>/bus/refresh</code> 请求，然后配置服务器会将消息发送到 springCloudBus 的交换机，由于其他微服务的队列也绑定到交换机，所以也就都获取到了更新的通知，然后去 ConfigServer 获取最新的数据。<br>需要注意，其他的微服务（客户端）这个 bus 配置是要写在 bootstrap.yml 中的，保证优先加载。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/3463571febc2" target="_blank" rel="noopener">https://www.jianshu.com/p/3463571febc2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如期而至，关于什么是 SpringCloud 这里不多说，之前的&lt;a href=&quot;https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Web/SpringCloud%E7%94%9F%E6%80%81%E5%9C%88.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;笔记&lt;/a&gt;已经把 SpringCloud 生态的主要技术都做了解释，但是这里对笔记进行补充一下，关于微服务、微服务架构，以及 SpringBoot 与 Cloud、Dubbo 之间微妙的关系做个简单的解释~
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://bfchengnuo.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://bfchengnuo.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>分布式中数据一致性探索</title>
    <link href="http://bfchengnuo.com/2018/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A2%E7%B4%A2/"/>
    <id>http://bfchengnuo.com/2018/09/15/分布式中数据一致性探索/</id>
    <published>2018-09-15T13:25:45.000Z</published>
    <updated>2019-02-26T10:31:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于这个，在面试中好像出境频率挺高的，现在都搞微服务、分布式（至于项目适不适合搞，嘿嘿）不懂一点确实说不过去，关于这点其实以前看过，但是当别人问起还是一脸萌逼，查了查资料感觉以前看过，然后过段时间再问，再懵逼…..这就必须得做笔记了！<a id="more"></a><br>这篇基本都是概念性的东西，原理懂了下面的就好办了，基础最重要嘛~</p><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>首先，来看一下著名的 CAP 定理：</p><blockquote><p>在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个<strong>分布式计算系统来说</strong>，不可能同时满足以下三点：</p><ul><li><strong>一致性（Consistency）</strong><br>等同于所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong><br>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</li><li><strong>分区容错性（Partition tolerance）</strong><br>以实际效果而言，分区相当于对通信的时限要求。<br>系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ul><p><strong>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项</strong>。</p></blockquote><p>如果我们选择的是<strong>可用性(Availability，简称 A)</strong>， 就是系统能提供服务就好， 数据不一致可以忍受。<br>在网络节点之间无法通信的情况下,  和数据复制相关的功能， 要么选择可用性(A) , 要么选择一致性(C)， 不能同时选择两者。<br>如果选择了可用性(A) + 分区容错性(P) ,  就要放弃一致性(C)。<br>如果选在一致性(C) + 分区容错性(P) , 就得放弃可用性(A) 。<br>在选择 CP 的情况下，虽然系统的有些功能是不能使用的（放弃了 A）， 因为需要等待数据的同步， <strong>但是那些和数据同步无关的功能还是可以访问的 ， 相当于系统做了功能的降级。</strong><br>既然有 AP 和 CP,    会不会出现仅仅是 CA（一致性+可用性）这种组合呢？ 就是没有分区容错性， 只保留可用性和一致性？ 仔细想想， 这种情况其实就退化成了单机应用， 没有意义了。<br>然后，既然要做分布式，P 是肯定的，那么只能从 C 和 A 里再选择一个了，常见的有：<br><img src="/image/dev/CAP.png" alt=""><br>其中，常用的 Zookeeper 保证的是 CP，而 Eureka 则是 AP</p><blockquote><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接 down 掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。<br>但是 zk 会出现这样一种情况，当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间太长，30 ~ 120s, 且选举期间整个 zk 集群都是不可用的，这就导致在选举期间注册服务瘫痪。<br>在云部署的环境下，因网络问题使得 zk 集群失去 master 节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><hr><p>Eureka 看明白了这一点，因此在设计时就优先保证可用性。Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。<br>而 Eureka 的客户端在向某个 Eureka 注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台 Eureka 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p><ol><li>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </li><li>Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol></blockquote><p>因此， Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper 那样使整个注册服务瘫痪。<br>Eureka 作为单纯的服务注册中心来说要比 zookeeper 更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过 Eureka 目前 1.X 版本的实现是基于 servlet 的 java web 应用，它的极限性能肯定会受到影响。期待正在开发之中的 2.X 版本能够从 servlet 中独立出来成为单独可部署执行的服务（虽然闭源了）。</p><h2 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h2><p>XA 是由 X/Open 组织提出的分布式事务的规范。XA 规范主要定义了（全局）事务管理器（Transaction Manager）和（局部）资源管理器（Resource Manager）之间的接口。<br>XA 接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。<br>XA 引入的事务管理器充当上文所述全局事务中的“协调者”角色。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如数据库或 JMS 队列）。<br>目前，Oracle、Informix、DB2、Sybase 和 PostgreSQL 等各主流数据库都提供了对 XA 的支持。</p><h2 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h2><blockquote><p>Java 事务 API（Java Transaction API，简称 JTA ） 是一个 Java 企业版 的应用程序接口，在 Java 环境中，允许完成跨越多个 XA 资源的分布式事务。JTA 是在 Java 社区过程下制定的规范，编号 JSR 907。</p></blockquote><p>作为 Java 平台上事务规范 JTA（Java Transaction API）也定义了对 XA 事务的支持，实际上，<strong>JTA 是基于 XA 架构上建模的</strong>。<br>在 JTA 中，事务管理器抽象为 <code>javax.transaction.TransactionManager</code> 接口，并通过底层事务服务（即 Java Transaction Service）实现。像很多其他的 Java 规范一样，<strong>JTA 仅仅定义了接口，具体的实现则是由供应商(如 J2EE 厂商)负责提供</strong>，目前 JTA 的实现主要有以下几种：</p><ul><li>J2EE 容器所提供的 JTA 实现(如JBoss)。</li><li>独立的 JTA 实现：如 JOTM（Java Open Transaction Manager），Atomikos。<br>这些实现可以应用在那些不使用 J2EE 应用服务器的环境里用以提供分布事事务保证。</li></ul><p>JTA 的使用示例（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UserTransaction userTx = <span class="keyword">null</span>;</span><br><span class="line">Connection connA = <span class="keyword">null</span>;</span><br><span class="line">Connection connB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  userTx = getContext().lookup(<span class="string">"java:comp/userTransaction"</span>);</span><br><span class="line">  <span class="comment">// connA = 从数据库 A 获取连接</span></span><br><span class="line">  <span class="comment">// connB = 从数据库 B 获取连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动分布式事务</span></span><br><span class="line">  userTx.begin();</span><br><span class="line">  <span class="comment">// 在数据库 A 中执行操作</span></span><br><span class="line">  <span class="comment">// 在数据库 B 中执行操作</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  userTx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">  <span class="comment">// 回滚</span></span><br><span class="line">  userTx.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JTA 并没有取得像 JDBC 那样的广泛应用，分布式事务伴随着大量节点的通信交换， 协调者要确定其他节点是否完成， 加上网络带来的超时，导致 JTA 性能低下， 在高并发和高性能的场景下举步维艰。<br>很多应用服务器 Websphere , Weblogic 等都支持 JTA， 可是使用者确是寥寥无几， 都快成摆设了。<br>这个标准太理想化，完全不符合实情，总是想着让两个数据库保证实时的一致性（强一致性）， 为了达到这个目标，JTA 付出的代价太高了。</p><h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p>事务我们非常熟悉，特性 ACID，回滚非常的好用，但是一般只对单个数据库有用，如果需要夸数据库就会比较尴尬。</p><hr><p>在计算机网络以及数据库领域内，二阶段提交（英语：Two-phase Commit）是指，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。<br>通常，<strong>二阶段提交也被称为是一种协议(Protocol)</strong>。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。<br>当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终<strong>指示这些节点是否要把操作结果进行真正的提交</strong>(比如将更新后的数据写入磁盘等等)。<br>因此，二阶段提交的算法思路可以概括为： <strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p><blockquote><p>需要注意的是，二阶段提交(英文缩写：2PC)不应该与并发控制中的二阶段锁(英文缩写：2PL)进行混淆。<br>wiki：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p></blockquote><hr><p>两阶段提交协议：<br>由于涉及到多个分布式的数据库， 我们特设一个全局的事务管理器，它来负责协调各个数据库的事务提交， 为了实现分布式事务，需要两个阶段：</p><ul><li><strong>阶段一</strong><br>全局的事务管理器向各个数据库发出准备消息。 各个数据库需要在本地把一切都准备好，执行操作，锁住资源， 记录 redo/undo 日志， 但是并不提交。<br>总而言之，要进入一个时刻准备提交或回滚的状态， 然后向全局事务管理器报告是否准备好了。</li><li><strong>阶段二</strong><br>如果所有的数据库都报告说准备好了， 那全局的事务管理器就下命令： 提交！这时候各个数据库才真正提交，由于之前已经万事具备，只欠东风，只需要快速完成本地提交即可。<br>如果有任何一个数据库报告说没准备好， 事务管理器就下命令： 放弃！这时候各个数据库要执行回滚操作， 并且释放各种在阶段1锁住的资源。</li></ul><p><img src="/image/dev/二阶段提交.png" alt=""></p><p>阶段1就是让大家都准备好，阶段2就是迅速提交。<br>但是，一旦涉及到分布式，事情就不会那么简单，任何地方都有失败的可能。<br>比如在第二阶段，那个事务管理器要是出了问题怎么办？ 人家各个数据库还在等着你发命令呢？ 你迟迟不发命令，大家都阻塞在那里，不知所措，到底是提交呢？还是不提交呢， 我这里还锁着资源呢， 迟迟不能释放，多耽误事啊 ！<br>还是第二阶段，事务管理器发出的提交命令由于网络问题，数据库１收到了，数据库２没收到，这两个数据库就处于不一致状态了， 该怎么处理？</p><blockquote><p>拓展：<br>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型，或者叫 XA 规范， X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。<br><strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是根据这一思想衍生出来的。</p></blockquote><h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><blockquote><p>三阶段提交（英语：Three-phase commit），也叫三阶段提交协议（英语：Three-phase commit protocol），是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。</p><p><strong>三阶段提交是为解决两阶段提交协议的缺点而设计的。</strong></p></blockquote><p>与两阶段提交不同的是，三阶段提交是<strong>“非阻塞”协议</strong>。三阶段提交在两阶段提交的第一阶段与第二阶段<strong>之间插入了一个准备阶段</strong>，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p><hr><p>与 2PC 想比，3PC 主要有两个改动点：</p><ol><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的</li></ol><h3 id="第一阶段CanCommit"><a href="#第一阶段CanCommit" class="headerlink" title="第一阶段CanCommit"></a>第一阶段CanCommit</h3><p>这一阶段和 2PC 的准备阶段很像：</p><ol><li><strong>事务询问</strong><br>协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li><li><strong>响应反馈</strong><br>参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No</li></ol><h3 id="第二阶段PreCommit"><a href="#第二阶段PreCommit" class="headerlink" title="第二阶段PreCommit"></a>第二阶段PreCommit</h3><p>协调者根据参与者的反应情况来决定是否可以执行事务的 PreCommit 操作。根据响应情况，有以下两种可能。<br><strong>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</strong></p><ol><li><strong>发送预提交请求</strong><br>协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。</li><li><strong>事务预提交</strong><br>参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。</li><li><strong>响应反馈</strong><br>如果参与者成功的执行了事务操作，<strong>则返回 ACK 响应</strong>，同时开始等待最终指令。</li></ol><hr><p><strong>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p><ol><li><strong>发送中断请求</strong><br>协调者向所有参与者发送 abort 请求。</li><li><strong>中断事务</strong><br>参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ol><h3 id="第三阶段doCommit"><a href="#第三阶段doCommit" class="headerlink" title="第三阶段doCommit"></a>第三阶段doCommit</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。<br><strong>执行提交：</strong></p><ol><li><strong>发送提交请求</strong><br>协调接收到参与者发送的 ACK 响应（第二阶段发送的），那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</li><li><strong>事务提交</strong><br>参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li><li><strong>响应反馈</strong><br>事务提交完之后，<strong>向协调者发送 ACK 响应</strong>。</li><li><strong>完成事务</strong><br>协调者接收到所有参与者的 ACK 响应之后，完成事务。</li></ol><hr><p><strong>中断事务</strong> 协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p><ol><li><strong>发送中断请求</strong><br>协调者向所有参与者发送 abort 请求</li><li><strong>事务回滚</strong><br>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li><li><strong>反馈结果</strong><br>参与者完成事务回滚之后，<strong>向协调者发送 ACK 消息</strong></li><li><strong>中断事务</strong><br>协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</li></ol><blockquote><p>在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。<br>其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了 PreCommit 请求，那么协调者产生 PreCommit 请求的前提条件是他在第二阶段开始之前，收到所有参与者的 CanCommit 响应都是  Yes。<br>一旦参与者收到了 PreCommit，意味他知道大家其实都同意修改了；<br>所以，一句话概括就是，<strong>当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到 commit 或者 abort 响应，但是他有理由相信：成功提交的几率很大。</strong></p></blockquote><h3 id="与2PC的区别"><a href="#与2PC的区别" class="headerlink" title="与2PC的区别"></a>与2PC的区别</h3><p>相对于 2PC，3PC <strong>主要解决的单点故障问题，并减少阻塞</strong>，因为一旦参与者无法及时收到来自协调者的信息之后，<strong>他会默认执行 commit</strong>。而不会一直持有事务资源并处于阻塞状态。<br><strong>但是这种机制也会导致数据一致性问题</strong>，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。<br>了解了 2PC 和 3PC 之后，我们可以发现，<strong>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</strong><br>Google Chubby 的作者 Mike Burrows 说过：</p><blockquote><p>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos. </p></blockquote><p>意即<strong>世上只有一种一致性算法，那就是 Paxos</strong>，所有其他一致性算法都是 Paxos 算法的不完整版。</p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>知道了上面的知识，我们可以退一步，也就是我们可以忍受一段时间的不一致，只有最终一致就行。 比方说 A 给 B 转 100 元， A 中的钱已经扣除， 但是 B 中不会实时地增加，过段时间能保证增加就行了。</p><blockquote><p>“ 假设两个账户（吕秀才和郭芙蓉）在两个独立的数据库中， 我们原来设计的 JTA 是要求从吕秀才账户减去 100 两银子， 然后在郭芙蓉账户加上 100 两银子， 这两个操作要么全部做完，要么全部不做， 但是在网络的环境下， 这是不大容易做到的， 或者说在高并发的情况下做到的代价太高。”</p></blockquote><p><img src="/image/dev/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A71.png" alt=""></p><p>我们想从吕秀才账户转 100 两银子给郭芙蓉， 需要在数据库 1 发起一个事务， 从吕秀才账户扣除 100 两， 然后还得向消息队列插入一条给郭芙蓉账号增加 100 两的消息， 然后这个数据库 1 的事务就结束了！<br>消息队列中的消息会在某一刻被读取出来，进行处理，给郭芙蓉的账号增加 100 两。<br>至于这个加钱的操作什么时候执行，这个时间不确定， 就看具体怎么实现了， 比如有个后台程序定期运行，读取消息来处理，消息队列的数据都是持久化到硬盘上的， 不用怕宕机会丢失。<br>假设数据库 2 down 机了， 对郭芙蓉有两种选择：<br>一种是由于系统原因，转账操作完全不能操作；<br>另外一种是可以转账，但是钱稍后到账；<br>你说郭芙蓉会选哪一种？<br>这就是最终一致性，数据在某些时候看起来不一致，但是同步内容都在消息队列中暂存着，等数据处理完成，数据还是一致的。<br>第一种情况是完全不可用， 第二种只是是部分可用，对于高并发的场景，转账的时候扣完钱， 向消息队列插入消息，事务就结束了，根本不用什么两阶段提交，性能很好。</p><hr><p>上面的方案看似非常完美，但是，还隐藏有一个重大问题：</p><blockquote><p>这个事务同时操作了数据库和一个消息队列， 这两个东西是完全不同的， 怎么实现？难道再用 JTA？<br>JTA 不仅仅可以支持数据库， 只要是支持XA协议的数据源都可以。</p></blockquote><p>解决方案：<br><img src="/image/dev/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A72.png" alt=""></p><p>在这里，我们可以添加一个“<strong>事件表</strong>”， 转账开始的时候，把吕秀才的 100 两银子扣除， 同时还向事件表插入一行记录： 需要向郭芙蓉转 100 两， <strong>由于这两个表是在同一个数据库中，所以直接使用本地事务就行</strong>。不用什么分布式事务。<br>而那个定时运行程序就是个定时任务，它会定期从事件表中取出记录， 向 MQ 写入消息， 然后把记录的状态改成 “DONE”， 这样下次就不用再去取去处理了。<br>这里还有一个坑，读数据后，向消息队列写入了消息， 如果还没来得及把事件表的 status 改为 “DONE” 就崩溃了，等到定时运行程序重启以后，<strong>会再次读取， 再次向 MQ 写入消息</strong>，这样整个系统就不一致了。所以必须要做到幂等性。</p><blockquote><p>当你对一个事物操作的时候，<strong>可以一直重复地操作，那个事物不受影响</strong>， 例如对郭芙蓉的账号你查询一千次，一万次，账户余额还是那么多，不会变化。<br>转账操作就不是一个幂等性操作，每次操作都会导致账号的变化。<br>简单理解：read 是幂等的， modify 不是幂等的</p></blockquote><p>也就是那个定时运行的程序可以出错，<strong>可以向消息队列写入多次重复消息</strong> ， 但是消费方那边在执行的时候， 肯定也要判断之前是否执行过了， 如果没有的话就执行， 如果执行过了就简单的抛弃这个消息即可。<br>所以消费方在判断是否已经执行过的时候（可以设置一个 id 来进行区分），<strong>也需要查询之前的执行记录</strong>， 这就意味着之前执行过的也需要用一个表保存下来才行。</p><blockquote><p>有人说，可以消息内容直接为账户值 + 100，这样，无论任务操作多少次，郭芙蓉账户都是账户值 +100。<br>但是这样首先要保证顺序，并且还是得标记这个事儿已经做过了，并且对于日志不是很友好，采用的不是很多吧。</p></blockquote><p>如果遇到是对方账号输入错误，钱老是转不进去，也就是消息无法消费，只能使用补偿机制了（手动 or 自动？）。<br>这些都是建立在 MQ 是稳定、高可用的前提下。。。。<br>这种方法也就是 BASE 模型，BASE 模型反 ACID 模型，完全不同 ACID 模型，牺牲高一致性，获得可用性或可靠性。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p>首先来看一段解释，虽然未必看得懂…..</p><blockquote><p>Paxos算法是莱斯利·兰伯特（英语：Leslie Lamport）于1990年提出的一种<strong>基于消息传递</strong>且<strong>具有高度容错特性的一致性算法</strong>。<br>为描述 Paxos 算法，Lamport 虚拟了一个叫做 Paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。<br>所以无论是议员，议长或者传递纸条的服务员<strong>都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间</strong>。<br>但是这里假设没有拜占庭将军问题（Byzantine failure，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息）；只要等待足够的时间，消息就会被传到。<br>另外，Paxos 岛上的议员是不会反对其他议员提出的决议的。</p></blockquote><p>主要目的是通过这个算法，让参与分布式处理的每个参与者逐步达成一致意见。用好理解的方式来说，就是在一个选举过程中，让不同的选民最终做出一致的决定（少数服从多数）。<br>paxos 是个分布式一致性协议，它的事件需要多个节点共同参与，一个事件完成是指<strong>多个节点上均完成了自身负责的单机子事件</strong>(就让我门把这样的事件称为”分布式事件”)，这样的分布式事件可以看作是多个单机子事件的复合，但是<strong>即不能从两个分布式事件的先后推导出某个节点上它们的单机子事件的先后，也不能根据某个节点上两个单机子事件的先后断言它们对应的分布式事件的先后</strong>。<br>自 Paxos 问世以来就持续垄断了分布式一致性算法，Paxos 这个名词几乎等同于分布式一致性。<br>Google 的很多大型分布式系统都采用了 Paxos 算法来解决分布式一致性问题，如 Chubby、Megastore 以及 Spanner 等。开源的 ZooKeeper，以及 MySQL 5.7 推出的用来取代传统的主从复制的 MySQL Group Replication 等纷纷采用 Paxos 算法解决分布式一致性问题。<br>然而，Paxos 的最大特点就是难，不仅难以理解，更难以实现。</p><hr><p>Paxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了 2F+1 的容错能力，即 2F+1 个节点的系统最多允许 F 个节点同时出现故障。<br>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos 算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。<br>Paxos 将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</p><ul><li><strong>倡议者（Proposer）</strong>：倡议者可以提出提议（数值或者操作命令）以供投票表决</li><li><strong>接受者（Acceptor）</strong>：接受者可以对倡议者提出的提议进行投票表决，提议有超半数的接受者投票即被选中</li><li><strong>学习者（Learner）</strong>：学习者无投票权，只是从接受者那里获知哪个提议被选中</li></ul><hr><p>花费一晚上来看 Paxos ，本来想简单写写这个算法的原理，但是发现太难了！并且我也不确定是否真正看懂了，不过找到了两篇感觉比较好的文章放在了最后，有能力的请去看原作者论文。。。<br><img src="/image/dev/Paxos.png" alt="Paxos"></p><h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p>不同于 Paxos 算法直接从分布式一致性问题出发推导出来，Raft 算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。<br>Raft 实现了和 Paxos 相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft 算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32052223</a></p><h2 id="NWR模型"><a href="#NWR模型" class="headerlink" title="NWR模型"></a>NWR模型</h2><p>引用一句话：</p><blockquote><p><strong>要想让数据有高可用性，就得写多份数据。</strong><br><strong>写多份的问题会导致数据一致性的问题。</strong><br><strong>数据一致性的问题又会引发性能问题</strong><br>这就是软件开发，按下了葫芦起了瓢。</p></blockquote><p>一致性模型：</p><ul><li><strong>Weak 弱一致性</strong>：<br>当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。</li><li><strong>Eventually 最终一致性</strong>：<br>当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。</li><li><strong>Strong 强一致性</strong>：<br>新的数据一旦写入，在任意副本任意时刻都能读到新值。</li></ul><p>NWR 模型是 Amazon Dynamo 系统中提出的一个概念，非常的有意思，也值得学习分布式系统的人进行好好的思考。所谓 NWR 模型，N 代表 N 个备份，W 代表要写入至少 W 份才认为成功，R 表示至少读取 R 个备份。<br><strong>配置的时候要求 W+R&gt;N</strong>。因为 W+R&gt;N，所以 R&gt;N-W，这指的是<strong>读取的份数一定要比总备份数减去确保写成功的倍数的差值要大</strong>。也就是说，每次读取，都至少读取到一个最新的版本。<br>当我们需要高可写的环境的时候，我们可以配置 W=1，这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。<br>如果我们要求读的高效率，我们可以配置 W=N，R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。<br>NWR 模型的一些设置会造成脏数据的问题，因为这很明显不是像 Paxos 一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。所以，Amazon Dynamo <strong>引入了数据版本的设计</strong>。<br>也就是说，如果你读出来数据的版本是 v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了 v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。但是，对于分布式和 NWR 模型来说，版本也会有恶梦的时候 — 就是版本冲的问题，不过这里不多探讨了。<br>Amazon Dynamo 的 <strong>NWR</strong> 模型，把 <strong>CAP</strong> 的选择权交给了用户，让用户自己选择 CAP 中的哪两个。</p><ul><li>如果 W+R&gt;N ，是可以保证强一致性的。<br>因为 W+R &gt; N， 所以 R &gt; N-W，什么意思呢？<br>就是读取的份数必须要大于未成功写的份数，这样至少能读到一份最新值。</li><li>如果 W+R&lt;=N，则能够保证最终一致性。</li><li>如果我们要高可写的环境，我们可以配置 W=1，R=N。<br>这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。</li><li>如果我们要求读的高效率，我们可以配置 W=N，R=1。<br>这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</li></ul><hr><ul><li><strong>优化写性能(AP)</strong><br>当我们需要优化写性能（写多读少）的时候，可以配置 W = 1 （写完一个副本就成功，其他的副本就异步去慢慢复制）；<br>如果 N=3，那么根据公式 W+R&gt;N，则 R = 3（读取数据的时候需要读 3 个副本以判断数据是否有冲突）。<br>这种情况只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。</li><li><strong>优化读性能(CP)</strong><br>当我们需要优化读性能（读多写少）的时候，可以配置 W=N（写完所有的副本才成功，只能同步复制）；<br>根据公式 W+R&gt;N，则 R=1（只需读一个副本即可）。<br>这种情况任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</li><li><strong>平衡读写性能(AC)</strong><br>当我们数据不多，单台能搞定，且不需要容错和扩展性的时候，可以配置 N=1（只有一份数据）；<br>根据公式 W+R&gt;N，则 W=1，R=1。这种情况就简化为单机问题了。</li></ul><h2 id="数据库中的事务"><a href="#数据库中的事务" class="headerlink" title="数据库中的事务"></a>数据库中的事务</h2><p>要谈到事务的实现方式，最重要的要属 Undo 日志了，简单来聊一聊就是：<br>事务开始后，<strong>在做具体的操作之前</strong>，会先写入日志，例如来一个经典的转账例子：</p><blockquote><p>[事务T1,  旺财原有余额 ， 200]<br>[事务T1, 小强原有余额， 50 ] </p></blockquote><p>如果事务执行到一半，就断电了，那数据库重启以后可根据 undo 的日志文件来恢复。<br>并且，记录的日志是可以做到幂等性的，也就是可以一直做恢复，恢复过程中断电也不怕，只要把恢复做完就行。<br>恢复数据的时候， 那你怎么才能知道一个事务没有完成呢？</p><blockquote><p>[开始事务 T1]<br>[事务T1, 旺财原有余额，200]<br>[事务T1, 小强原有余额，50]<br>[提交事务 T1]</p></blockquote><p>Undo 日志文件中不仅仅只有余额， <strong>事务的开始和结束也会记录</strong>，如果我在日志文件中看到了 【提交事务 T1】，或者 【回滚事务 T1】， 我就知道这个事务已经结束，不用再去理会它了， 更不用去恢复。 如果我只看到 【开始事务 T1】, 而找不到提交或回滚，那我就得恢复。<br>特别是，恢复以后， 需要在日志文件中加上一行 【回滚事务 T1】 ， 这样下一次恢复就不用再考虑 T1 这个事务了。</p><hr><p>Undo 日志文件会面临和数据文件一样的问题， 都是需要加载到内存才能读写， 要不然会太慢。  那要是连日志文件还没写好就断电了呢？<br>要解决这个问题，也不难，只需要遵守两条规则就好：</p><ul><li>操作之前要把对应的日志写入硬盘的日志文件</li><li>像“提交事务”这样的日志，一定要在操作完成后写入到硬盘</li></ul><p>通常把日志记录也放到了内存的 Undo 日志缓冲区，伺机写入硬盘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/J1WH4ZYyVWGgXx9g2siocw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/J1WH4ZYyVWGgXx9g2siocw</a><br><a href="https://mp.weixin.qq.com/s/59iztoTssmIVri7UkZeGzw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/59iztoTssmIVri7UkZeGzw</a><br><a href="https://mp.weixin.qq.com/s/92SghOorf10dm3pM0DWzIg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/92SghOorf10dm3pM0DWzIg</a><br><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">http://www.hollischuang.com/archives/681</a><br><a href="http://blog.xiaohansong.com/2016/09/30/Paxos/" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/09/30/Paxos/</a><br><a href="https://segmentfault.com/a/1190000013478009" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013478009</a><br><a href="http://lemon0910.github.io/%E7%B3%BB%E7%BB%9F/2016/04/29/distributed-summary.html" target="_blank" rel="noopener">http://lemon0910.github.io/%E7%B3%BB%E7%BB%9F/2016/04/29/distributed-summary.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于这个，在面试中好像出境频率挺高的，现在都搞微服务、分布式（至于项目适不适合搞，嘿嘿）不懂一点确实说不过去，关于这点其实以前看过，但是当别人问起还是一脸萌逼，查了查资料感觉以前看过，然后过段时间再问，再懵逼…..这就必须得做笔记了！
    
    </summary>
    
      <category term="技能Get" scheme="http://bfchengnuo.com/categories/%E6%8A%80%E8%83%BDGet/"/>
    
    
      <category term="数据库" scheme="http://bfchengnuo.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://bfchengnuo.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot进阶</title>
    <link href="http://bfchengnuo.com/2018/08/26/SpringBoot%E8%BF%9B%E9%98%B6/"/>
    <id>http://bfchengnuo.com/2018/08/26/SpringBoot进阶/</id>
    <published>2018-08-26T09:44:32.000Z</published>
    <updated>2018-08-26T09:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了下之前的做的 SpringBoot 笔记连入门都算不上，顶多是个体验，然后外加现在 SpringBoot 这么火，还是有记录一下的价值的，也是为了更进一步了解 SpringBoot，同时也是为之后的 SpringCloud 做铺垫；<a id="more"></a><br>这次的笔记基于 1.x 的版本，后续打算会跟进 2.x 版本，对于这一点，SpringBoot 比较任性，2.x 和 1.x 的版本有很大的改动，虽然原理是差不多的，但是方法说删就删…..之后有机会再总结吧，在那篇体验里也介绍过一些 2.x 的特性，慢慢来~</p><h2 id="主程序入口"><a href="#主程序入口" class="headerlink" title="主程序入口"></a>主程序入口</h2><p>使用 SpringBoot 必须在 pom 文件中配置父工程，父工程中定义了大量的 JavaEE 常用库的版本号（用来做“版本仲裁”），这个大家都知道，就不多说了；然后我们知道在启动类上标注 @SpringBootApplication 注解，然后在 main 方法中运行：<code>SpringApplication.run(HelloWorldMainApplication.class,args);</code> 就可以让 web 工程跑起来（当然需要在 pom 中配置相关依赖，比如各种方便好用的各种 starter）</p><blockquote><p>为简化部署，SpringBoot 提供了 spring-boot-maven-plugin 的 Maven 插件，使用后可以直接通过 <code>Java -jar</code> 命令来运行 jar 包。</p></blockquote><p>SpringBoot 要求 run 方法第一个参数必须是  @SpringBootApplication 注解标注的类，既然这样就来看看这个注解是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;...&#125;</span><br></pre></td></tr></table></figure><p>一个一个来看，首先是 <strong>@SpringBootConfiguration</strong> 这个注解，从名字可以看出是 SpringBoot 的配置类，它其实继承了 @Configuration 注解，也就间接的继承了 @Component 注解，官方建议在 SpringBoot 应用中优先使用 @SpringBootConfiguration 注解。<br>再来看 <strong>@EnableAutoConfiguration</strong> 这个注解，从名字来看是开启自动配置，自动配置应该是 SpringBoot 的一大核心了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure><p>此注解继承了 @AutoConfigurationPackage ，也就是自动配置包，它里面重要的一句代码是：<code>@Import(AutoConfigurationPackages.Registrar.class)：</code> ，Spring 的底层注解 @Import 应该很熟悉了，主要是给容器中导入一个组件，这个类如果读源码的话，<strong>主要的作用就是将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器</strong>，这就可以解释一些问题了！<br>然后接下来看导入的 <strong>EnableAutoConfigurationImportSelector</strong> 这个类，从名字来看是来决定导入那些组件的选择器，它会将所有需要导入的组件以全类名的方式返回；这些组件（其实是自动配置类）就会被添加到容器中；<br>经过上面的操作，将会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；他们的作用就是根据当前环境的依赖配置好这些组件。<br>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。<br>Spring Boot 在启动的时候从类路径下的 <code>META-INF/spring.factories</code> 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，在特定的环境下帮我们进行自动配置工作；</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>号称无配置的 SpringBoot 其实就是给我们做了常见的自动配置，如上面所解释，避免淹没在无尽的配置文件中，但自动配置不可能符合每个项目的需求，所以 SpringBoot 必定要提供定制的方法，如果继续采用传统的 XML 文件来配置，那显得还是太复杂了，properties 是个不错的选择，同时，还支持一种新型的流行配置语法 yaml！<br>YAML 以数据为中心，比 json、XML 等更适合做配置文件。</p><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><p>基本语法：形如 <code>K:(空格)V</code> 这样的形式。<br>以空格的缩进来控制层级关系，<strong>空格多少无所谓，只要左对齐就行</strong> ，同时，它的属性和值是大小写敏感的。<br>对于值的写法，可分为下面几种形式：</p><ul><li><p>字面量<br>数字、字符串、布尔 直接写就可以了；<br>特殊的，双引号和单引号，<strong>双引号内的特殊字符会转义</strong>，比如 <code>\n</code> ；单引号内的字符串不会被转义。</p></li><li><p>对象、Map<br>另起一行写属性，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还支持行内写法</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">&#123;name:</span> <span class="string">zhansan,age:</span> <span class="number">20</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>两种写法效果一样，看个人喜好咯。</p></li><li><p>集合<br>用 <code>-</code> 表示数组中的一个元素，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog]</span></span><br></pre></td></tr></table></figure><p>两种写法的效果也是一致的。</p></li></ul><h3 id="配置文件的值注入"><a href="#配置文件的值注入" class="headerlink" title="配置文件的值注入"></a>配置文件的值注入</h3><p>将配置文件中配置的属性映射到 bean 中，使用 <code>@ConfigurationProperties(prefix=&quot;&quot;)</code> 注解实现。<br>需要注意的是，<strong>这个 bean 必须在 spring 容器中才行</strong>；其支持松散绑定，也就是说你可以使用驼峰、下划线分割（测试日期格式使用 2018/08/12 的格式是可正确注入），都会正确的识别，还支持 JSR303 校验规则，可以使用相关的校验注解，只需要在类上加个 @Validated 就好。<br><strong>这个注解默认从全局配置文件中获取值。</strong><br>要使用 @ConfigurationProperties 最好导入这个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当时测试如果在 @Configuration 标注的类上无法注入，原因就是缺少这个依赖，当然在普通 Bean 是没有问题的，迷….<br>你甚至可以直接把它标注在 @Bean 的方法上，比如数据源，可以直接注入到返回的 Bean 中，不用在调用那么多 setter 方法了。<br>除了使用 @ConfigurationProperties  注解，还可以使用 <code>@Value</code> 注解注入单个值，类似我们 xml 中 bean 标签里的 property 的 Value，所以它支持几种写法：</p><ul><li>字面量</li><li>${配置文件属性}</li><li>SPEL 表达式：{spel}</li></ul><p>还可以做一些简单的运算，可以说定制性很高了，至于他们的比较：</p><table><thead><tr><th>-</th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303 数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>不管配置文件是 yml 还是 properties 他们都能获取到值；<br>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用 @Value；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用 @ConfigurationProperties；</p><hr><p>有时候，我们并不希望把所有配置都写在主配置文件中，而是希望指定从那个配置文件中加载，那么就可以使用 @PropertySource 注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br></pre></td></tr></table></figure><p>通常，他们都是搭配使用的。</p><blockquote><p>1.5 以前的版本，那么可以通过 ConfigurationProperties 注解的 locations 指定 properties 文件的位置 ；<br>但是 1.5 版本后就没有这个属性了，需要添加 @Configuration 和 @PropertySource()后才可以读取</p></blockquote><p>SpringBoot 还有另一个导入配置文件的注解 @ImportResource：导入Spring 的配置文件，让配置文件里面的内容生效；这个导的是原始 Spring 的 XML 配置文件，可以写在 SpringBoot 配置类上，比如 SpringBoot 的启动类，但是官方是不推荐的，建议使用 Java 配置的方式（@Configuration）。</p><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><p>在 SpringBoot 的配置文件中，是可以使用 <code>${xx}</code> 这种表达式的，比如可以使用它来获取随机数：<code>${random.value}</code>、<code>${random.int}</code>、<code>${random.long}</code>、<code>${random.int(10)}</code>、<code>${random.int[1024,65536]}</code> ；<br>也可以使用它引用之前配置的值：<code>${person.hello:hello}</code> 通过冒号可以设置默认值。</p><h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><p>在 Maven 中是支持多环境的，操作有点繁琐，SpringBoot 默认就集成了这个功能，它以文件名进行区分不同的环境：<code>application-{profile}.properties/yml</code> .<br>如果使用的是 yaml 文件，还可以使用 <code>---</code> 来进行划分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure><p>至于激活那个环境，除了在主配置文件里配置，还有很多方式，比如命令行参数（<code>--spring.profiles.active=dev</code>）、JVM 参数（<code>-Dspring.profiles.active=dev</code>）</p><h3 id="配置文件的加载"><a href="#配置文件的加载" class="headerlink" title="配置文件的加载"></a>配置文件的加载</h3><p>springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件：</p><ul><li>当前项目下的 Config 文件夹（<code>file:./config/</code>）</li><li>当前项目下（<code>file:./</code>）</li><li>类加载路径下的 Config 文件夹（<code>classpath:/config/</code>）</li><li>类加载路径下（<code>classpath:/</code>）</li></ul><p>优先级由高到底，高优先级的配置会<strong>覆盖</strong>低优先级的配置；<strong>互补配置</strong> ；<br>另外，我们还可以通过在命令行指定 <code>spring.config.location</code> 来改变默认的配置文件位置，同样也是互补配置。<br>至于加载顺序，以及会扫描加载那些外部配置，官方定义了很多路径，这里就不说了，有需要的可以看官方文档，地址在这：<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">官方文档</a></p><p>配置文件能配的属性全都在这了：<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">官网直达</a></p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>关于自动配置，简单来讲，通过前面的主程序入口解析，我们知道 SpringBoot 在启动的时候会加载包下指定文件夹下的文件，然后导入了一堆的自动配置类；<br>这些自动配置类都是一样的套路，与之配套的还有一个 xxxProperties 类，这个类的作用就是通过 @ConfigurationProperties 注入配置文件中配置的属性，然后自动配置类中就可以使用这些值了；当然自动配置类还有一些 Conditional 注解来控制根据当前环境加载某些配置，最后就通过默认配置创建出了一个个的 Bean，而不需要我们再显式的声明了。<br>虽然文件中指定加载了一堆的自动配置类，但是很多的自动配置类都需要一些条件才能生效，所以并不是所有的功能都会生效的。</p><h2 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h2><p>SpringBoot 中默认使用的日志是 SLF4J + logback，然而 Spring 使用的是 JCL，日志统一是个问题。<br>关于 SLF4J 的使用，应该是都比较熟悉了，SpringBoot 中的 <code>spring-boot-starter</code> 中默认导入了一个 <code>spring-boot-starter-logging</code> ，它的作用就是来处理日志框架不统一的问题，使用各种 over 来转换成 SLF4J。<br>正是因为有它，所以 SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，<strong>只需要把这个框架依赖的日志框架排除掉即可</strong>。<br>并且，SpringBoot 会给我们默认配置日志的输出格式，也可以在配置文件中微调，或者直接将配置文件复制到 Resources 文件夹下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置等级，可以具体到包</span><br><span class="line">logging.level.com.bfchengnuo=trace</span><br><span class="line"></span><br><span class="line"># 不指定路径在当前项目下生成springboot.log日志</span><br><span class="line"># 可以指定完整的路径；</span><br><span class="line">#logging.file=G:/springboot.log</span><br><span class="line"></span><br><span class="line"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><br><span class="line">logging.path=/spring/log</span><br><span class="line"></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot 默认设置的日志等级是 info，滚动输出，最大文件 10M</p><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td>-</td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>输出到指定目录的 spring.log 文件中</td></tr></tbody></table><p>如果使用配置文件，多种文件名都可以被识别，例如 <code>logback-spring.xml</code> 和 <code>logback.xml</code> ，后者直接被日志框架所识别，而前者是由 Spring 来进行处理，所以它可以支持一些更强大的功能，例如 springProfile 标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面举个例子 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>并且，你还可以切换日志框架，例如像从 slf4j 切换到 log2j2，只需要导入 <code>spring-boot-starter-log4j2</code> 这个依赖即可；因为和 <code>spring-boot-starter-logging</code> 是二选一的关系，所以记得排除依赖。<br>使用 <code>spring-boot-starter-log4j2</code> 也会有相应的默认配置，官方文档中写的还是很详细的。</p><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><p>如果看 SpringBoot web 的自动配置，会发现默认的静态资源映射支持 webjars，就是将所有 <code>/webjars/**</code> 的请求映射到 <code>classpath:META-INF/resources/webjars</code> 下。</p><blockquote><p>webjars 简单说就是可以将 js、css 等前端使用的库通过 jar 包的方式导入到项目中，支持使用 Maven 管理，默认打包在 <code>classpath:META-INF/resources/webjars</code> 文件夹下。</p></blockquote><p>当请求没人处理时，会交给一个 <code>/**</code> 全局映射，默认从下面几个路径中寻找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure><p>还贴心的设置了欢迎页：静态资源文件夹下的所有叫 index.html 的页面；被 “/<strong>“ 映射。<br>所有的 </strong>/favicon.ico  都是在静态资源文件下找，可以来设置自己喜欢的网站图标。<br>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebMvcAuotConfiguration</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(</span><br><span class="line">      registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">      .addResourceLocations(</span><br><span class="line">        <span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">      .setCachePeriod(cachePeriod));</span><br><span class="line">  &#125;</span><br><span class="line">  String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">  <span class="comment">//静态资源文件夹映射</span></span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(</span><br><span class="line">      registry.addResourceHandler(staticPathPattern)</span><br><span class="line">      .addResourceLocations(</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">      .setCachePeriod(cachePeriod));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置欢迎页映射</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line">                                       <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">    mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">                                               faviconRequestHandler()));</span><br><span class="line">    <span class="keyword">return</span> mapping;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">    requestHandler</span><br><span class="line">      .setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">    <span class="keyword">return</span> requestHandler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就处理了静态文件的映射规则。<br>当然我们也可以自定义路径规则，使用 <code>spring.resources.static-locations=classpath:/hello/,classpath:/test/</code> ，但是这样 SpringBoot 的那些默认配置就失效了。</p><h3 id="模板引擎Thymeleaf"><a href="#模板引擎Thymeleaf" class="headerlink" title="模板引擎Thymeleaf"></a>模板引擎Thymeleaf</h3><p>SpringBoot 推荐的 Thymeleaf 虽然效率上经常被人黑，也确实很低，不过对于前后端解耦是比较友好的，要使用首先要引入依赖，对于 SpringBoot 直接加一个 starter 就好：<code>spring-boot-starter-thymeleaf</code><br>另外，你可以指定你要引入的版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Thymeleaf 的自动配置中，设置的默认前缀是 <code>classpath:/templates/</code> 默认后缀是 <code>.html</code> ，也就是说只要我们把 HTML 页面放在这个路径下，thymeleaf 就能自动渲染。<br>然后在 HTML 导入名称空间（为了有代码提示）：<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code><br>如何使用参考<a href="https://www.thymeleaf.org/index.html" target="_blank" rel="noopener">官方文档</a>例子很详细，我也考虑写一个笔记放在 Github。<br>简单来说就是他支持 OGNL 表达式，可以直接使用 <code>th:任意html属性</code> 替换原生 html 属性，如果直接打开，定义的这些属性就不会解析，如果使用模板引擎就替换为了 <code>th:text</code> 中的变量，前后端非常和谐。</p><h3 id="SpringMVC的自动配置"><a href="#SpringMVC的自动配置" class="headerlink" title="SpringMVC的自动配置"></a>SpringMVC的自动配置</h3><p>在 SpringBoot 的官方文档中有比较详细的描述，<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">地址在这</a>。<br>自动配置的关键就在 WebMvcAutoConfiguration 这个类中，根据文档描述，主要做了下面几件事情：</p><ul><li>自动配置了 ViewResolver （视图解析器，根据返回值得到具体的视图对象，视图对象决定如何渲染，例如是转发还是重定向）</li><li>使用 ContentNegotiatingViewResolver 组合所有的视图解析器，只要在容器中配一个试图解析器，就会自动组合进来。</li><li>静态资源文件夹路径。比如上面所说的 webjars、静态首页、图标等。</li><li>自动注册了 <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> 等 bean.<br>转换器：请求参数与实体类之间的类型转换使用的就是 Converter；<br>格式化器：例如日期格式化的注解，自己添加的格式化器转换器，我们只需要放在容器中即可；</li><li>自动注册消息转换器<br>例如 HttpMessageConverter 将实体对象转换成 json 等，自定义的方式也和上面一样。<br>另外还有定义错误代码生成规则的 MessageCodesResolver 等。</li></ul><p>相应扩展 SpringMVC 的配置，只需要<strong>编写一个配置类（@Configuration），是 WebMvcConfigurerAdapter 类型（继承它）；不标注 @EnableWebMvc（加上了就不会进行默认配置了，也就是说全面接管 MVC）</strong><br>之前我们通常在 SpringMVC中 中配置 HiddenHttpMethodFilter 来使其支持 RESTful，现在 SpringBoot 也给自动配置好了，只需要在前台创建一个 input 项（一般设置为隐藏），<code>name=&quot;_method&quot;</code> 值就是我们指定的请求方。</p><h3 id="修改SpringBoot默认配置"><a href="#修改SpringBoot默认配置" class="headerlink" title="修改SpringBoot默认配置"></a>修改SpringBoot默认配置</h3><p>一般套路为：</p><ul><li>SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；<br>有些组件（例如 ViewResolver）可以将用户配置的和自己默认的组合起来；</li><li>在SpringBoot中会有非常多的 xxxConfigurer 帮助我们进行扩展配置</li><li>在 SpringBoot 中会有很多的 xxxCustomizer 帮助我们进行定制配置</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>SpringBoot 有默认的错误处理机制，在浏览器访问的时候返回的是错误页面，其他客户端返回的是 JSON 格式的错误信息。<br>至于原理，其实是根据请求头来不同的处理，可以在 <strong>ErrorMvcAutoConfiguration</strong> 这个错误处理的自动配置类中看看具体是怎么实现的。它主要给容器添加了下面几个组件：</p><ul><li><p><strong>DefaultErrorAttributes</strong><br>主要是帮我们在页面共享信息，通过一个 getErrorAttributes 方法来组装了错误页面需要的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">  addStatus(errorAttributes, requestAttributes);</span><br><span class="line">  addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">  addPath(errorAttributes, requestAttributes);</span><br><span class="line">  <span class="keyword">return</span> errorAttributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ErrorAttributes 我们可以进行自定义。</p></li><li><p><strong>BasicErrorController</strong><br>它处理默认 <code>/error</code> 请求，我们可以通过 <code>server.error.path</code> 来自定义，它会根据请求头信息，来决定走那个方法，相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">      request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">    ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">    Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">                                                  isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ErrorPageCustomizer</strong><br><strong>系统出现错误以后</strong>，让其来到 error 请求进行处理，可以说是错误的入口类了。</p></li><li><p><strong>DefaultErrorViewResolver</strong><br>可以说，它是来觉定走那个视图的，源码写的很明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">  String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">  TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">    .getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line">  <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">  <span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板引擎中可以使用 OGNL 之类的表达式来取值，静态资源（例如 static 文件夹下）就不行啦</p></li></ul><p>下面来总结下：<br>一但系统出现 4xx 或者 5xx 之类的错误；ErrorPageCustomizer 就会生效（可定制错误的响应规则）；默认就会来到 <code>/error</code> 请求；就会被 <strong>BasicErrorController</strong> 处理；<br>响应去哪个页面是由 <strong>DefaultErrorViewResolver</strong> 解析得到的，有模板引擎的情况下；<code>error/状态码</code>【将错误页面命名为  <code>错误状态码.html</code> 放在模板引擎文件夹里面的 error 文件夹下】，发生此状态码的错误就会来到对应的页面。<br>我们可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先。<br>页面能获取的信息有：</p><ul><li>timestamp：时间戳</li><li>status：状态码</li><li>error：错误提示</li><li>exception：异常对象</li><li>message：异常消息</li><li>errors：JSR303 数据校验的错误都在这里</li></ul><p>模板引擎和静态资源文件夹都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面。</p><h3 id="定制错误数据"><a href="#定制错误数据" class="headerlink" title="定制错误数据"></a>定制错误数据</h3><p>统一处理异常还是用 SpringMVC 的知识，首先写一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种呢，没有自适应效果（不能区分浏览器和其他客户端），然后改进了一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">  Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程，因为forward默认 200</span></span><br><span class="line">  request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">  map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">  map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">  <span class="comment">// 转发到 /error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样自适应是有了（靠 SpringBoot 来实现），但是我们自定义的数据如何传递过去又是个问题了，错误请求最终会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是AbstractErrorController（ErrorController）规定的方法，所以我们可以编写一个 ErrorController 的实现类【或者是编写 AbstractErrorController 的子类】，放在容器中。<br>但是重新编写实现类太麻烦了，收集这些信息是通过 <code>DefaultErrorAttributes.getErrorAttributes()</code> 这个方法完成的，所以有更简便的方法就是写一个 ErrorAttributes。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的 ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">    map.put(<span class="string">"company"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们自定义了 ErrorAttributes 后，SpringBoot 就不再加载默认的 ErrorAttributes 而是使用容器中已存在的，这样就可以取到我们自定义的数据了。</p><h3 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h3><p>SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器，我们可以通过配置文件来进行定制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line">server.context-path=/crud</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line"># 通用的Servlet容器设置</span><br><span class="line">server.xxx</span><br><span class="line"># Tomcat的设置</span><br><span class="line">server.tomcat.xxx</span><br></pre></td></tr></table></figure><p>还可以编写一个<strong>EmbeddedServletContainerCustomizer</strong> 嵌入式的 Servlet 容器的定制器来进行定制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line">    <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">      container.setPort(<span class="number">8083</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实配置文件的方式 ServerProperties 本质也是 EmbeddedServletContainerCustomizer。<br>你也可以换用其他容器，步骤就是先把 Tomcat 排除，然后导入相关的依赖即可，支持 Jetty （长连接比较好）和 Undertow （NIO，并发不错）。<br>嵌入式容器默认并不支持 JSP，并且定制性复杂，还是要视情况而定。<br>如果使用外置 Servlet 容器，除了打包方式改成 war，将内置的 Tomcat 排除后（可使用 provided），必须编写一个 <strong>SpringBootServletInitializer</strong> 的子类，并调用 configure 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">    <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会把 SpringBoot 应用给带起来了，这多亏了 servlet3.0 规范的支持。</p><h3 id="注册三大组件"><a href="#注册三大组件" class="headerlink" title="注册三大组件"></a>注册三大组件</h3><p>SpringBoot 给我们提供了简便的方法注册三大组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 servlet</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Filter</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">  registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">  registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动配置的 SpringMVC 也是这样配置前端控制器的，看源码可得知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">  ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">    dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">  <span class="comment">// 默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">  <span class="comment">// 可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">  registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">  registration.setLoadOnStartup(</span><br><span class="line">    <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">    registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了下之前的做的 SpringBoot 笔记连入门都算不上，顶多是个体验，然后外加现在 SpringBoot 这么火，还是有记录一下的价值的，也是为了更进一步了解 SpringBoot，同时也是为之后的 SpringCloud 做铺垫；
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://bfchengnuo.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="http://bfchengnuo.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>ApacheCommons常用工具类使用</title>
    <link href="http://bfchengnuo.com/2018/07/24/ApacheCommons%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8/"/>
    <id>http://bfchengnuo.com/2018/07/24/ApacheCommons常用工具类使用/</id>
    <published>2018-07-24T13:31:26.000Z</published>
    <updated>2018-09-06T03:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Commons 项目包含了很多工具，并且非常好用，能提高我们的开发效率，在很多开源框架中使用广泛，所以….如果项目中引入了这些依赖，能用就用吧，起码 Apache 的应该是比自己写的强多了。。<a id="more"></a><br>另外，Google 的 Guava 也是非常好用的，也做了笔记，<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Guava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">地址在这里</a>。<br>常用工具一览表：</p><table><thead><tr><th><strong>组件</strong></th><th><strong>功能介绍</strong></th></tr></thead><tbody><tr><td><strong>BeanUtils</strong></td><td>提供了对于JavaBean进行各种操作，克隆对象,属性等等.</td></tr><tr><td>Betwixt</td><td>XML与Java对象之间相互转换.</td></tr><tr><td><strong>Codec</strong></td><td>处理常用的编码方法的工具类包 例如 DES、SHA1、MD5、Base64 等.</td></tr><tr><td><strong>Collections</strong></td><td>java集合框架操作.</td></tr><tr><td>Compress</td><td>java提供文件打包压缩类库.</td></tr><tr><td>Configuration</td><td>一个java应用程序的配置管理类库.</td></tr><tr><td>DBCP</td><td>提供数据库连接池服务.</td></tr><tr><td>DbUtils</td><td>提供对jdbc 的操作封装来简化数据查询和记录读取操作.</td></tr><tr><td>Email</td><td>java 发送邮件对 javamail 的封装.</td></tr><tr><td>FileUpload</td><td>提供文件上传功能.</td></tr><tr><td>HttpClien</td><td>提供 HTTP 客户端与服务器的各种通讯操作. 现在已改成 HttpComponents</td></tr><tr><td><strong>IO</strong></td><td>io 工具的封装.</td></tr><tr><td><strong>Lang</strong></td><td>Java 基本对象方法的工具类包 如：StringUtils，ArrayUtils 等等.</td></tr><tr><td>Logging</td><td>提供的是一个 Java 的日志接口.</td></tr><tr><td>Validator</td><td>提供了客户端和服务器端的数据验证框架.</td></tr></tbody></table><h2 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h2><p>提供了对于 JavaBean 进行各种操作，比如对象，属性复制等等。 </p><p><strong>克隆对象：</strong> <code>Person person2 =  (Person)BeanUtils.cloneBean(person);</code></p><blockquote><p>需要注意的是，cloneBean 方法拷贝对象只是浅拷贝，如果想深拷贝，可参考下面的代码</p><p>经测试，这种克隆效率很低，并且不是很稳定，推荐优先使用 Spring 的 BeanUtils 通过属性 copy 的方式来“克隆对象”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeanCopier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Returns a deeply cloned java bean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromBean java bean to be cloned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a new java bean cloned from fromBean.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">copy</span><span class="params">(Object fromBean)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    XMLEncoder out = <span class="keyword">new</span> XMLEncoder(bos);</span><br><span class="line">    out.writeObject(fromBean);</span><br><span class="line">    out.close();</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">    XMLDecoder in = <span class="keyword">new</span> XMLDecoder(bis);</span><br><span class="line">    Object toBean = in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> toBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>将一个 Map 对象转化为一个 Bean：</strong><br>首先这个 Map 对象的 key 必须与 Bean 的属性相对应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"tom"</span>);</span><br><span class="line">map.put(<span class="string">"email”,”1@1.com"</span>);</span><br><span class="line">map.put(<span class="string">"age”,”21"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将map转化为一个Person对象</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">BeanUtils.populate(person,map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// web 中示例</span></span><br><span class="line">Enumeration params = request.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (params.hasMoreElements())&#123;</span><br><span class="line">  String name = (String) params.nextElement();</span><br><span class="line">  map.put(name, request.getParameter(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean 转 map</span></span><br><span class="line">Map map = BeanUtils.describe(person);</span><br></pre></td></tr></table></figure><p>使用场景嘛…..如果不使用 web 层框架，还记得被 request.getParameter 支配的恐惧….</p><hr><p><strong>bean 的属性拷贝：</strong></p><p>在拼装 VO 或者 DTO 的时候非常有用吧：<code>BeanUtils.copyProperties(source, target);</code></p><blockquote><p>需要注意的是，除了属性名要一致，属性拷贝同时也会将值为 null 的属性拷贝，所以，这行代码放的位置很重要！</p></blockquote><hr><p><strong>其他常用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="keyword">new</span> Book());</span><br><span class="line"><span class="comment">// 使用beanUtils给对象的属性赋值</span></span><br><span class="line">BeanUtils.setProperty(p, <span class="string">"username"</span>, <span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用beanUtils获取对象的属性值</span></span><br><span class="line">System.out.println(BeanUtils.getProperty(p, <span class="string">"username"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// beanUtils 支持属性链赋值与获得值,不过赋值前 book 要先实例化</span></span><br><span class="line">BeanUtils.setProperty(p, <span class="string">"book.name"</span>, <span class="string">"历史小说"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(BeanUtils.getProperty(p, <span class="string">"book.name"</span>));</span><br><span class="line">System.out.println(p.getBook().getName());</span><br></pre></td></tr></table></figure><h2 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h2><p><code>commons-codec</code>是 Apache 开源组织提供的用于摘要运算、编码的包。在该包中主要分为四类加密：BinaryEncoders、DigestEncoders、LanguageEncoders、NetworkEncoders。<br>最常用的类有两个：</p><ul><li>DigestUtils<br>主要包括 MD5、SHA1、SHA256 算法等实现静态方法</li><li>Base64<br>主要包含 Base64 编码和解码静态方法</li></ul><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecTest</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * MD5散列算法实现(长度有16位和32位,常用32位的)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMD5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String md5String = DigestUtils.md5Hex(data);</span><br><span class="line">    System.out.println(md5String);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * SHA1散列算法实现(长度为40位)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSHA1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String sha1String = DigestUtils.sha1Hex(data);</span><br><span class="line">    System.out.println(sha1String.length());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * SHA256散列算法实现(长度为64位)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSHA256</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String sha256String = DigestUtils.sha256Hex(data);</span><br><span class="line">    System.out.println(sha256String.length());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 摘要算法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDigestAlgorithms</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 摘要算法在 MessageDigestAlgorithms 下有列出</span></span><br><span class="line">    <span class="comment">// public static final String MD2 = "MD2";</span></span><br><span class="line">    <span class="comment">// public static final String MD5 = "MD5";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_1 = "SHA-1";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_256 = "SHA-256";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_384 = "SHA-384";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_512 = "SHA-512";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备注:都是基于 HASH 算法实现的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64类进行编码和解码,注意其可以转换二进制数据到字符串(比如图片转字符串)</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 如果是小图片的话,可以使用Base64编码来存储,只是可以并不是推荐使用。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String encodeString = Base64.encodeBase64String(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">    System.out.println(encodeString);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(encodeString);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64将图片编码为字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">image2String</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"e:/test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将输入流转为子节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] imageBytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    String imageString = Base64.encodeBase64String(imageBytes);</span><br><span class="line"></span><br><span class="line">    System.out.println(imageString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64将字符串解码为图片</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">string2Image</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"e:/test.jpg"</span>);</span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将输入流转为子节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] imageBytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    String imageString = Base64.encodeBase64String(imageBytes);</span><br><span class="line"></span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"e:/testCopy.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(imageString);</span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将字节数组转为输出流</span></span><br><span class="line">    IOUtils.write(bytes, outputStream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再补充一个 URL 的编码和解码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testURLCodec</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"==============URLCodec================"</span>);</span><br><span class="line">   URLCodec codec = <span class="keyword">new</span> URLCodec();</span><br><span class="line">   String data = <span class="string">"啦啦啦"</span>;</span><br><span class="line">   String encode = codec.encode(data, <span class="string">"UTF-8"</span>);</span><br><span class="line">   System.out.println(encode);</span><br><span class="line">   System.out.println(codec.decode(encode, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>对 Java 中的集合类进行了一定的补充，定义了一些全新的集合，当然也是实现了 Collection 接口的，比如<code>Bag，BidiMap</code>。<br>同时拥有新版本的原有集合，比如 <code>FastArrayList</code>。最后，更为重要的是一系列 utils 类，提供了我们常用的集合操作，可以大大方便我们的日常编程。</p><h3 id="Bag"><a href="#Bag" class="headerlink" title="Bag"></a>Bag</h3><p>Bag 定义了一种集合：收集一个对象出现的次数。<br>例如 Bag：{a,a,b,c} 调用 <code>bag.getCount(a)</code> 返回 2，意味着里面有 2 个 a。 调用 <code>bag.uniqueSet()</code> 则返回一个 set，值为 {a,b,c}。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">HashBag bag = <span class="keyword">new</span> HashBag();</span><br><span class="line">bag.add(<span class="string">"rabbit"</span>,<span class="number">1</span>);</span><br><span class="line">bag.add(<span class="string">"fox"</span>,<span class="number">1</span>);</span><br><span class="line">bag.add(<span class="string">"rabbit"</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit count</span></span><br><span class="line">System.out.print(bag.getCount(<span class="string">"rabbit"</span>));</span><br><span class="line"><span class="comment">// how many animals</span></span><br><span class="line">System.out.print(bag.uniqueSet().size());</span><br></pre></td></tr></table></figure><p>除了 HashBag，还有 SynchronizedBag、TreeBag，自行了解哈….</p><h3 id="BidiMap"><a href="#BidiMap" class="headerlink" title="BidiMap"></a>BidiMap</h3><p>BidiMap 定义了一种 map，不仅可以通过 key 得到 value，还可以通过 value 得到 key。<br>Bidi 意思是 bidirectional，双向使用的 map。<br>除了传统 Map 的操作，还加入了一些新”技能“：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BidiMap bidi = <span class="keyword">new</span> DualHashBidiMap();</span><br><span class="line">bidi.put(<span class="string">"k1"</span>,<span class="string">"v1"</span>);</span><br><span class="line">bidi.put(<span class="string">"k2"</span>,<span class="string">"v2"</span>);</span><br><span class="line"></span><br><span class="line">bidi.get(<span class="string">"k2"</span>); <span class="comment">// return v2</span></span><br><span class="line">bidi.getKey(<span class="string">"v2"</span>); <span class="comment">// return k2</span></span><br><span class="line"></span><br><span class="line">bidi.inverseBidiMap(); <span class="comment">// 反转 bidi，原先的 value 作为 key</span></span><br></pre></td></tr></table></figure><p>作为代价，BidiMap 必须要求 k 和 v 是一一对应的，在上述代码之后，无法做到 <code>bidi.put(&quot;k2&quot;,&quot;v1&quot;);</code>，因为这样就无法实现响应操作。 现实中如学号和身份证号做对应就是这样一种关系，可以视情况使用。<br>同样，除了 DualHashBidiMap，还有 TreeBidiMap 等</p><h3 id="有用的工具类"><a href="#有用的工具类" class="headerlink" title="有用的工具类"></a>有用的工具类</h3><p>这是 collections 包中最有价值的一个部分，介绍 <code>ListUtils</code> 和 <code>CollectionUtils</code>。</p><h4 id="ListUtils-列表工具类"><a href="#ListUtils-列表工具类" class="headerlink" title="ListUtils 列表工具类"></a>ListUtils 列表工具类</h4><ul><li>ListUtils.intersection(list1, list2)<br>取交集；</li><li>ListUtils.subtract(list1, list2)<br>返回 list1 和 list2 的差。这里和 <code>list1.removeAll(list2)</code> 的差别在于：<br>前者不改变任何一个集合；<br>如果 list1 中有 2 个 a，list2 中有一个a：removeAll 会将 list1 中所有的 a 都抹去，而 subtract 结果 list1 仍然会剩下一个 a。</li><li>ListUtils.union(list1, list2)<br>取并集；</li><li>ListUtils.removeAll(list1, list2)<br>不改变 list 的情况下做 removeAll</li></ul><h4 id="CollectionUtils-通用的集合工具类"><a href="#CollectionUtils-通用的集合工具类" class="headerlink" title="CollectionUtils 通用的集合工具类"></a>CollectionUtils 通用的集合工具类</h4><ul><li>CollectionUtils.union(c1, c2)，CollectionUtils.intersection(c1,c2)<br>不再解释</li><li>CollectionUtils.disjunction(c1, c2)<br>返回两者的不相交部分的并集，没想到一个现实场景。。</li><li>CollectionUtils.containsAny(c1, c2)<br>只要 c1 包含任何一个 c2 的元素，返回 true</li><li><strong>CollectionUtils.find(c, predicate)</strong><br>重要方法：借助 Predicate 达到神一般的效果，从此减少一半 for 循环。返回第一个找到的元素</li><li><strong>CollectionUtils.filter(c, predicate)</strong><br>重要方法：同上，直接改变容器 c。</li><li>CollectionUtils.transform(c, transformer)<br>重要方法：还是神器，但是在 jdk8 中等同于 foreach 方法效果。如果 jdk&lt;8，可以用这个方法代替</li><li>CollectionUtils.countMatches(c,predicate)<br>根据 predicate 返回有多少元素满足预言，返回值 int。</li><li>CollectionUtils.select(c,predicate)<br>根据 predicate 找出满足的元素，组成新的 collection 并返回</li><li>CollectionUtils.select(c,predicate,outputCollection)<br>根据 predicate 找出满足的元素，加入到 outputCollection 中。</li><li><strong>CollectionUtils.isEmpty(c)</strong><br>简单实用，是否为 null 或者空集合</li></ul><h4 id="补充：predicate"><a href="#补充：predicate" class="headerlink" title="补充：predicate"></a>补充：predicate</h4><p>既然上面用到了还是说一说，感觉自从 JDK8 来了后，能省一大部分工具类了。。。<br>预言，这个类主要结合 <code>CollectionUtils.find,CollectionUtils.filter</code> 来使用。<br>他的作用类似于『断言』，其中只有一个方法：<code>public boolean evaluate(Object object);</code><br>这个方法用于判断一个对象是否满足某种标准，感觉和 JDK8 中的 stream + map 差不多呢~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line">Predicate predicate = <span class="keyword">new</span> Predicate&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyUtils.getSimpleProperty(object,<span class="string">"age"</span>) &gt;<span class="number">50</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Predicate predicate2 = <span class="keyword">new</span> Predicate&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyUtils.getSimpleProperty(object,<span class="string">"id"</span>) == <span class="number">12306</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不满足条件的结果</span></span><br><span class="line">CollectionUtils.filter(list,predicate);</span><br><span class="line"><span class="comment">//返回第一个满足的元素</span></span><br><span class="line">Object obj = CollectionUtils.find(list,predicate2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new AndPredicate(predicate1,predicate2);</span></span><br></pre></td></tr></table></figure><p>同时，Predicate 可以进行谓词连接，借助于：AndPredicate、OrPredicate、AnyPredicate、NotPredicate 这些类。</p><h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><p>提供了很多安全操作和工具类，避免我们编码校验各种的 null；<br>JDK8+ 后，对空值处理有了加强，但是嘛，国内用的人…..</p><ul><li>ArrayUtils:<br>数组工具类，提供数组拷贝、查找、反转等功能</li><li>StringUtils:<br>提供字符串操作，对 null 是安全的，字符串查找、替换、分割、去空格等操作；<br>isEmpty 和 isBlank 的区别在于 isEmpty 不会忽略空格，而isBlank会认为是空,isBlank更常用</li><li>ObjectUtils:<br>对 null 进行安全处理</li><li>RandomUtils:<br>随机数工具类，获得随机整数、小数、字符串等</li><li>NumberUtils:<br>数值工具类，数值类型转换等操作</li><li>DateUtils:<br>日期工具类</li><li>EnumUtils:<br>枚举工具类</li><li>ClassUtils<br>判断是否有内部类、是否可以转型、获取包名、类名等</li><li>ReflectionToStringBuilder/ToStringBuilder:<br>重写 toString 方法</li><li>EqualsBuilder/HashCodeBuilder:<br>提供了方便的方法来覆盖 equals() 和 hashCode() 方法  </li></ul><p>然后给一些示例代码吧，比如 Builder 系列，虽然一般我们都是工具自动生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ToStringBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ToStringBuilder(<span class="keyword">this</span>).append(<span class="keyword">this</span>.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername()).toString();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 以上输出格式为  Test@1270b73[&lt;null&gt;,&lt;null&gt;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashCodeBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> HashCodeBuilder.reflectionHashCode(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(<span class="keyword">this</span>).append(<span class="keyword">this</span>.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername()).hashCode();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EqulasBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (obj.getClass() == Test.class) &#123;  </span><br><span class="line">    Test test = (Test) obj;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().append(<span class="keyword">this</span>.getId(), test.getId())  </span><br><span class="line">      .append(<span class="keyword">this</span>.getUsername(), test.getUsername()).isEquals();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> EqualsBuilder.reflectionEquals(<span class="keyword">this</span>, obj);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareToBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Test o)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> CompareToBuilder.reflectionCompare(<span class="keyword">this</span>, o);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Test o)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CompareToBuilder().append(<span class="keyword">this</span>.getId(), o.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername(), o.getUsername()).toComparison();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面列举的，还有很多工具类，大部分也不说了，看一下方法基本就会用了，非常简单，看例子可去参考的第二个链接。<br>然后是日期，稍微提一下，也不常用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Date day1 = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于 Aache 的 DateUtils 和 DateFormatUtils 并没有 Joda 强大,  </span></span><br><span class="line"><span class="comment">     *  所以在这里只作简单的示例  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一天</span></span><br><span class="line">    DateUtils.addDays(day1, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 减少一年</span></span><br><span class="line">    DateUtils.addYears(day1, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化时间,第三参数为国际化,表示按美国时间显示</span></span><br><span class="line">    DateFormatUtils.format(day1, <span class="string">"yyyy-MM-dd"</span>, Locale.UK);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>看名字也知道，这是用来操作文件的工具类，工具类包括 FileUtils、IOUtils、FilenameUtils 和 FileSystemUtils，前三者的方法并没有多大的区别，只是操作的对象不同；<br>故名思议：FileUtils 主要操作 File 类，IOUtils 主要操作 IO 流，FilenameUtils 则是操作文件名，FileSystemUtils 包含了一些 JDK 没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。<br>果然还是例子最能说明问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtilsTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拷贝文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File destFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    FileUtils.copyFile(srcFile, destFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File delFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    FileUtils.forceDelete(delFile);</span><br><span class="line">    <span class="comment">//FileUtils.forceMkdir(delFile);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 比较文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompareFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File destFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = FileUtils.contentEquals(srcFile, destFile);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移动文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoveFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    File destDir = <span class="keyword">new</span> File(basePath + <span class="string">"move"</span>);</span><br><span class="line">    FileUtils.moveToDirectory(srcFile, destDir, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读取文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    String content = FileUtils.readFileToString(srcFile);</span><br><span class="line">    List&lt;String&gt; contents = FileUtils.readLines(srcFile);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String string : contents) &#123;</span><br><span class="line">      System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 写入文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    FileUtils.writeStringToFile(srcFile, <span class="string">"\nyes文件"</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemUtilsTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取磁盘空余空间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFreeSpace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 以字节为单位</span></span><br><span class="line">    System.out.println(FileSystemUtils.freeSpace(<span class="string">"c:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    System.out.println(FileSystemUtils.freeSpace(<span class="string">"d:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 以k为单位</span></span><br><span class="line">    System.out.println(FileSystemUtils.freeSpaceKb(<span class="string">"e:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    System.out.println(FileSystemUtils.freeSpaceKb(<span class="string">"f:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineIteratorTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试行迭代器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    LineIterator li = FileUtils.lineIterator(file);</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">      System.out.println(li.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">    LineIterator.closeQuietly(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空内容文件过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    String[] files = dir.list(EmptyFileFilter.NOT_EMPTY);</span><br><span class="line">    <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">      System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名称后缀过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuffixFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    String[] files = dir.list(<span class="keyword">new</span> SuffixFileFilter(<span class="string">"a.txt"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">      System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名称比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNameFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = NameFileComparator.NAME_COMPARATOR.compare(f1, f2);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPathFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = PathFileComparator.PATH_COMPARATOR.compare(f1, f2);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    CompositeFileComparator cfc = <span class="keyword">new</span> CompositeFileComparator(</span><br><span class="line">      DirectoryFileComparator.DIRECTORY_COMPARATOR,</span><br><span class="line">      NameFileComparator.NAME_COMPARATOR);</span><br><span class="line">    cfc.sort(files);</span><br><span class="line">    System.out.println(<span class="string">"*****after sort*****"</span>);</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的还是刚上来工具类的那些，精简一下，最多的就是复制文件/文件夹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件夹（文件夹里面的文件内容也会复制），file1和file2平级。</span></span><br><span class="line"><span class="comment">// 参数1：文件夹； 参数2：文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectory</span><span class="params">( file1 , file2 )</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件夹到另一个文件夹。 file1是file2的子文件夹.</span></span><br><span class="line"><span class="comment">// 参数1：文件夹； 参数2：文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectoryToDirectory</span><span class="params">( file1 , file2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件夹，带有文件过滤功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectory</span><span class="params">(File srcDir, File destDir, FileFilter filter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***********复制文件**************</span></span><br><span class="line"><span class="comment">// 复制文件到另外一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(<span class="keyword">final</span> File srcFile, <span class="keyword">final</span> File destFile)</span></span>;</span><br><span class="line"><span class="comment">// 复制文件到输出流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">long</span> <span class="title">copyFile</span><span class="params">(<span class="keyword">final</span> File input, <span class="keyword">final</span> OutputStream output)</span></span>;</span><br><span class="line"><span class="comment">// 复制文件到一个指定的目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFileToDirectory</span><span class="params">( file1 , file2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把输入流里面的内容复制到指定文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyInputStreamToFile</span><span class="params">( InputStream source, File destination)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把URL 里面内容复制到文件。可以下载文件。</span></span><br><span class="line"><span class="comment">// 参数1：URL资源 ； 参数2：目标文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyURLToFile</span><span class="params">(<span class="keyword">final</span> URL source, <span class="keyword">final</span> File destination)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把URL 里面内容复制到文件。可以下载文件。</span></span><br><span class="line"><span class="comment">// 参数1：URL资源 ； 参数2：目标文件；参数3：http连接超时时间 ； 参数4：读取超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyURLToFile</span><span class="params">(<span class="keyword">final</span> URL source, <span class="keyword">final</span> File destination,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> readTimeout)</span></span>;</span><br></pre></td></tr></table></figure><p>先暂时贴这么多吧，更多参考：<a href="https://blog.csdn.net/zhaoyanjun6/article/details/54972773" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/54972773</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c3c3ab2bad8d" target="_blank" rel="noopener">https://www.jianshu.com/p/c3c3ab2bad8d</a><br><a href="http://www.voidcn.com/article/p-ahnjkqaf-wo.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ahnjkqaf-wo.html</a><br><a href="https://blog.csdn.net/u011179993/article/details/46743521" target="_blank" rel="noopener">https://blog.csdn.net/u011179993/article/details/46743521</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Commons 项目包含了很多工具，并且非常好用，能提高我们的开发效率，在很多开源框架中使用广泛，所以….如果项目中引入了这些依赖，能用就用吧，起码 Apache 的应该是比自己写的强多了。。
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo学习笔记</title>
    <link href="http://bfchengnuo.com/2018/07/07/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://bfchengnuo.com/2018/07/07/Dubbo学习笔记/</id>
    <published>2018-07-07T02:49:58.000Z</published>
    <updated>2018-07-07T03:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Dubbo 以前也用过几次，都是浅度学习，也没做笔记，今天看了下官网竟然改版了，手册更新了，借这个契机来复习下，并且做下笔记，内容大部分来自官方手册。<br>官网：<a href="https://dubbo.incubator.apache.org" target="_blank" rel="noopener">https://dubbo.incubator.apache.org</a><br>旧版的用户使用手册：<a href="https://www.gitbook.com/book/dubbo/dubbo-user-book" target="_blank" rel="noopener">https://www.gitbook.com/book/dubbo/dubbo-user-book</a><a id="more"></a><br>官方文档开始的背景介绍写的挺不错的，可以去参考下，曾经的 ORM、MVC，到现在的分布式 RPC 和 SOA。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>个人感觉 Dubbo 的架构设计是很不错的，官网的文档也解释的很详细：<img src="https://dubbo.incubator.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"> </p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的服务提供方</td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的服务消费方</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td><code>Container</code></td><td>服务运行容器</td></tr></tbody></table><p><strong>调用关系说明</strong></p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者<strong>地址列表</strong>给消费者，如果有变更，注册中心将<strong>基于长连接</strong>推送变更数据给消费者。</li><li><strong>服务消费者</strong>，从提供者地址列表中，<strong>基于软负载均衡算法</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。<br>我认为 Dubbo 适用于比较大、复杂的服务调用需求的系统，一般的中小型使用通过配置服务的 URL 地址进行调用，通过 F5 等硬件进行负载均衡（或者通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务 ）这样就足够了。</p><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，<strong>服务提供者和消费者只在启动时与注册中心交互</strong>，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后<strong>每分钟一次发送到监控中心</strong>服务器，并以报表展示</li><li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li><li>服务消费者向注册中心获取服务提供者<strong>地址列表</strong>，并<strong>根据负载算法直接调用提供者，同时汇报调用时间到监控中心</strong>，此时间包含网络开销</li><li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li><li>注册中心通过长连接感知服务提供者的存在，<strong>服务提供者宕机，注册中心将立即推送事件通知消费者</strong></li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，<strong>消费者在本地缓存了提供者列表</strong></li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li></ul><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，<strong>注册中心仍能通过缓存提供服务列表查询</strong>，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li><strong>服务提供者无状态，任意一台宕掉后，不影响使用</strong></li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并<strong>无限次重连等待服务提供者恢复</strong></li></ul><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><ul><li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li><li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>仿照官方文档，最简单的代码示例放在了我 Github 上的 <a href="https://github.com/bfchengnuo/java_learn/tree/master/ExampleCode/Dubbo" target="_blank" rel="noopener">Java_lean</a> 仓库里，自取…..配置了 xml 版和注解版（推荐），<strong>Dubbo 采用全 Spring 配置方式，能基于 Spring 的 Schema 扩展进行加载</strong>，Dubbo 宣称能与 Spring（SpringBoot） 无缝整合，不能浪费。<br>就是添加了 Dubbo 的依赖，根据传递性，就自动导入了 Spring 相关依赖，所以测试的话只需要一个 Dubbo、zookeeper 、zkclient 和你定义的接口就可以了！<br>另外就是 Dubbo 底层用的是 netty 做通讯，所以效率会较高。<br>在搭建测试的时候终究还是踩了不少坑，记录在<a href="https://github.com/bfchengnuo/MyRecord/blob/e181f5c9e609a2a58a08894358510d512dc41e60/FixException/Maven%2BDubbo%E5%85%A5%E9%97%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.md" target="_blank" rel="noopener">这里</a>附上了解决方案。在使用注解方式时，尤其注意 <code>&lt;dubbo:annotation&gt;</code> 在 2.5.8 之后的版本不再支持了！请使用 @Configuration  大法解决。</p><hr><h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>关于 XML 的基本配置，主要是服务的提供方和消费方，配置非常类似：<br>服务提供方（remote-provider.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 提供方应用信息(当前应用名称)，用于计算依赖关系 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用 dubbo 协议，在 20880 端口暴露服务 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置需要提供远程服务的对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 增加暴露远程服务配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务消费方（remote-consumer.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-consumer"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 增加引用远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上就是最简单的纯 XML 方式使用 Dubbo，用的不多了吧，毕竟 XML 太繁琐了。<br>另外就是所有标签都支持自定义参数（通过子标签 <code>&lt;dubbo:parameter key=&quot;queue&quot; value=&quot;your_queue&quot; /&gt;</code>），用于不同扩展点实现的特殊配置 。<br>引用缺省是延迟初始化的，只有引用被注入到其它 Bean，或被 <code>getBean()</code> 获取，才会初始化，如需立即实例化，可配置：<code>&lt;dubbo:reference ... init=&quot;true&quot; /&gt;</code><br>对于相同的属性，例如 timeout 查找（优先级）顺序是： <code>referenceMethod --&gt;  serviceMethod --&gt; reference --&gt;  service --&gt; consumer --&gt; provider</code></p><hr><h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>需要 <code>2.5.7</code> 及以上版本支持，使用注解的方式配置：<br>使用 javaconfig 形式配置公共模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于 &lt;dubbo:application&gt;</span></span><br><span class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">    applicationConfig.setName(<span class="string">"provider-test"</span>);</span><br><span class="line">    <span class="keyword">return</span> applicationConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于 &lt;dubbo:registry&gt;</span></span><br><span class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">    registryConfig.setAddress(<span class="string">"zookeeper://127.0.0.1:2181"</span>);</span><br><span class="line">    registryConfig.setClient(<span class="string">"curator"</span>);</span><br><span class="line">    <span class="keyword">return</span> registryConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对于消费方，还可以配一个 consumerConfig</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConsumerConfig <span class="title">consumerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConsumerConfig consumerConfig = <span class="keyword">new</span> ConsumerConfig();</span><br><span class="line">    consumerConfig.setTimeout(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> consumerConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定 Dubbo 的扫描路径，就是自动扫描，提供方和消费方都是一样的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(basePackages = <span class="string">"com.alibaba.dubbo.test.service.impl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderTestApp</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次强调，2.5.8 之后 <code>&lt;dubbo:annotation&gt;</code> 不再可用！<br>服务提供方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(timeout = <span class="number">5000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateServiceImpl</span> <span class="keyword">implements</span> <span class="title">AnnotateService</span> </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于 XML 中的 <code>&lt;dubbo:service /&gt;</code> 用来暴露服务。<br>服务消费方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConsumeService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 就是自动注入了</span></span><br><span class="line">  <span class="meta">@Reference</span></span><br><span class="line">  <span class="keyword">public</span> AnnotateService annotateService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="properties配置"><a href="#properties配置" class="headerlink" title="properties配置"></a>properties配置</h3><p>在比较简单的情况下，例如没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，Dubbo 将自动加载 classpath 根目录下的 <code>dubbo.properties</code>，可以通过 JVM 启动参数 <code>-Ddubbo.properties.file=xxx.properties</code> 改变缺省配置位置。<br>将 XML 配置的标签名，加属性名，用点分隔，多个属性拆成多行：</p><ul><li>比如：<code>dubbo.application.name=foo</code>等价于<code>&lt;dubbo:application name=&quot;foo&quot; /&gt;</code></li><li>比如：<code>dubbo.registry.address=10.20.153.10:9090</code>等价于<code>&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; /&gt;</code></li></ul><p>如果 XML 有多行同名标签配置，可用 id 号区分，如果没有 id 号将对所有同名标签生效：</p><ul><li>比如：<code>dubbo.protocol.rmi.port=1234</code>等价于<code>&lt;dubbo:protocol id=&quot;rmi&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;</code></li><li>比如：<code>dubbo.registry.china.address=10.20.153.10:9090</code>等价于<code>&lt;dubbo:registry id=&quot;china&quot; address=&quot;10.20.153.10:9090&quot; /&gt;</code></li></ul><p>下面是 dubbo.properties 的一个典型配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=foo</span><br><span class="line">dubbo.application.owner=bar</span><br><span class="line">dubbo.registry.address=10.20.153.10:9090</span><br></pre></td></tr></table></figure><p>关于优先级，JVM 启动参数 -D 最优先，其次是 XML 的配置，最后是 properties 文件。</p><h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><p>Dubbo 缺省会在<strong>启动时检查依赖</strong>的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成 ，默认 <code>check=&quot;true&quot;</code>。 所以说，启动是有顺序的，默认下必须要服务方先启动。<br>check 属性可以加在 dubbo:reference  、dubbo:consumer  、dubbo:registry  标签中，分别控制的是：<br>某个服务的启动时检查（没有提供者时报错 ）、所有服务的启动时检查、注册中心启动时检查（注册订阅失败时报错）。<br>优先级是 reference &gt; consumer ，还可以设置全局参数，例如：<code>dubbo.reference.check=false</code> 、 <code>dubbo.consumer.check=false</code> 等</p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。 </p><p><img src="https://dubbo.incubator.apache.org/docs/zh-cn/user/sources/images/cluster.jpg" alt="cluster"> </p><p>根据上面的架构图，理下各节点关系：</p><ul><li>这里的 <code>Invoker</code> 是 <code>Provider（服务提供方）</code> 的一个可调用 <code>Service</code> 的抽象，<code>Invoker</code> 封装了 <code>Provider</code> 地址及 <code>Service</code> 接口信息。</li><li><code>Directory</code> 代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更。</li><li><code>Cluster（集群）</code> 将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code>，<strong>对上层透明</strong>，伪装过程包含了容错逻辑，调用失败后，重试另一个。</li><li><code>Router</code> 负责从多个 <code>Invoker</code> 中按路由规则<strong>选出子集</strong>，比如读写分离，应用隔离等。</li><li><code>LoadBalance</code> 负责从多个 <code>Invoker</code> 中<strong>选出具体的一个</strong>用于本次调用，选的过程包含了<strong>负载均衡算法</strong>，调用失败后，需要重选。</li></ul><h3 id="容错模式"><a href="#容错模式" class="headerlink" title="容错模式"></a>容错模式</h3><p>Dubbo 提供的容错模式有：</p><ul><li><strong>Failover Cluster</strong><br>默认的故障转移模式，就是失败自动切换，当出现失败，重试其它服务器 。<strong>通常用于读操作</strong>，但重试会带来更长延迟。<br>可通过 <code>retries</code> 属性来指定重试的次数（不含第一次）</li><li><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failsafe Cluster</strong><br>失败安全（指不会抛出异常），出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。通常<strong>用于消息通知</strong>操作。</li><li><strong>Forking Cluster</strong><br><strong>并行调用</strong>多个服务器，只要一个成功即返回。通常<strong>用于实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</li><li><strong>Broadcast Cluster</strong><br>广播调用<strong>所有</strong>提供者，<strong>逐个调用</strong>，任意一台报错则报错。通常用于<strong>通知所有提供者更新缓存或日志等</strong>本地资源信息。</li></ul><p>集群配置模式（以 XML 为例）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failsafe"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务消费方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failsafe"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。可以自行扩展负载均衡策略。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><ul><li><strong>Random LoadBalance</strong><br><strong>随机</strong>，按<strong>权重</strong>设置随机概率。<br>在一个截面上碰撞的概率高，但<strong>调用量越大分布越均匀</strong>，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li><li><strong>RoundRobin LoadBalance</strong><br><strong>轮循</strong>，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li><li><strong>LeastActive LoadBalance</strong><br><strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。<br><strong>使慢的提供者收到更少请求</strong>，因为越慢的提供者的调用前后计数差会越大。</li><li><strong>ConsistentHash LoadBalance</strong><br><strong>一致性 Hash</strong>，<em>相同参数的请求总是发到同一提供者。</em><br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<br>缺省只对第一个参数 Hash （由 <code>hash.arguments</code> 参数控制）。<br>缺省用 160 份虚拟节点（由 <code>hash.nodes</code> 参数控制）。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>示例为基于 XML 的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方法级别调用配在 &lt;dubbo:method&gt; 中 --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="直连提供者"><a href="#直连提供者" class="headerlink" title="直连提供者"></a>直连提供者</h2><p>在开发及测试环境下，经常需要<strong>绕过注册中心，只测试指定服务提供者</strong>，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。<br>通过 XML 来配置直接的提供者，在 <code>&lt;dubbo:reference&gt;</code> 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开：<code>&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.alibaba.xxx.XxxService&quot; url=&quot;dubbo://localhost:20890&quot; /&gt;</code><br>除外，还可以通过 -D 参数来指定：<code>java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</code><br>配置的服务如果较多，可采用文件（properties）映射。</p><h2 id="只订阅-amp-注册"><a href="#只订阅-amp-注册" class="headerlink" title="只订阅&amp;注册"></a>只订阅&amp;注册</h2><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。<br>可以让服务<strong>提供者</strong>开发方，<strong>只订阅服务</strong>(开发的服务可能依赖其它服务)，而<strong>不注册正在开发的服务</strong>，通过直连测试正在开发的服务。<br>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> <span class="attr">register</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090?register=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>对于只注册的情况，例如让服务<strong>提供者方只注册服务到某一注册中心</strong>，而消费方不从另外的注册中心订阅服务。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">subscribe</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090?subscribe=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h2><p>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</p><h3 id="不同服务不同协议"><a href="#不同服务不同协议" class="headerlink" title="不同服务不同协议"></a>不同服务不同协议</h3><p>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"registry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"hello1234"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多协议暴露服务"><a href="#多协议暴露服务" class="headerlink" title="多协议暴露服务"></a>多协议暴露服务</h3><p>需要与 http 客户端互操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"registry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"hello1234"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"hessian"</span> <span class="attr">port</span>=<span class="string">"8080"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">protocol</span>=<span class="string">"dubbo,hessian"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当然，Dubbo 也支持多注册中心。</p><h3 id="Dubbo协议"><a href="#Dubbo协议" class="headerlink" title="Dubbo协议"></a>Dubbo协议</h3><p>默认协议，也是推荐的协议，这里就只说它，关于 <code>dubbo://</code> 的基本介绍：</p><blockquote><p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。<br>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p></blockquote><p>特性：</p><ul><li>连接个数：单连接</li><li>连接方式：长连接</li><li>传输协议：TCP</li><li>传输方式：NIO 异步传输</li><li>序列化：Hessian 二进制序列化</li><li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</li><li>适用场景：常规远程服务方法调用</li></ul><p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。<br>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。<br>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p><h2 id="服务分组-amp-多版本"><a href="#服务分组-amp-多版本" class="headerlink" title="服务分组&amp;多版本"></a>服务分组&amp;多版本</h2><p>当一个接口有多种实现时，可以用 group 区分。<br>XML 配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"feedback"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"member"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"feedbackIndexService"</span> <span class="attr">group</span>=<span class="string">"feedback"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"memberIndexService"</span> <span class="attr">group</span>=<span class="string">"member"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 任意组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">group</span>=<span class="string">"*"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。 XML 配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务消费者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果不需要区分版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"*"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>官方给的版本迁移建议：</p><ol><li>在低压力时间段，先升级一半提供者为新版本</li><li>再将所有消费者升级为新版本</li><li>然后将剩下的一半提供者升级为新版本</li></ol><h2 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h2><p>用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量 。</p><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul><li><code>lru</code><br>基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。</li><li><code>threadlocal</code><br>当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。</li><li><code>jcache</code><br>与 <a href="http://jcp.org/en/jsr/detail?id=107%27" target="_blank" rel="noopener">JSR107</a> 集成，可以桥接各种缓存实现。</li></ul><p>XML 配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">cache</span>=<span class="string">"lru"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findBar"</span> <span class="attr">cache</span>=<span class="string">"lru"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。<br>首先，在 XML 中开启异步支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"fooService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.foo.FooService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findFoo"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.bar.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findBar"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码中进行异步调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">fooService.findFoo(fooId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">barService.findBar(barId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒</span></span><br><span class="line">Foo foo = fooFuture.get(); </span><br><span class="line"><span class="comment">// 同理等待bar返回</span></span><br><span class="line">Bar bar = barFuture.get(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。</span></span><br></pre></td></tr></table></figure><p>是否等待消息发出（配置在 dubbo:method 中即可）：</p><ul><li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常。</li><li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li></ul><p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本<br>其中，<strong>异步方式总是不等待返回</strong>。</p><h2 id="并发-amp-连接控制"><a href="#并发-amp-连接控制" class="headerlink" title="并发&amp;连接控制"></a>并发&amp;连接控制</h2><p>通过在 dubbo:service 标签中设置 executes  属性来控制服务器端并发执行（或占用线程池线程数）不能超过的个数。<br>通过设置 actives 属性（可在 dubbo:reference/service 中设置）来控制每客户端并发执行（或占用连接的请求数）不能超过的个数。<br>如果 <code>&lt;dubbo:service&gt;</code> 和 <code>&lt;dubbo:reference&gt;</code> 都配了actives，<code>&lt;dubbo:reference&gt;</code> 优先。</p><h3 id="Load-Balance-均衡"><a href="#Load-Balance-均衡" class="headerlink" title="Load Balance 均衡"></a>Load Balance 均衡</h3><p>配置服务的客户端的 <code>loadbalance</code> 属性为 <code>leastactive</code>，此 Loadbalance 会调用并发数最小的 Provider（Consumer端并发数）。 可在 dubbo:reference/service 中设置。</p><hr><p>连接控制分为服务端的连接控制和客户端的连接控制，XML 配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 限制服务器端接受的连接不能超过 10 个,两种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> <span class="attr">accepts</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">accepts</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 限制客户端服务使用连接不能超过 10 个，两种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">connections</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">connections</span>=<span class="string">"10"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>&lt;dubbo:service&gt;</code> 和 <code>&lt;dubbo:reference&gt;</code> 都配了 connections，<code>&lt;dubbo:reference&gt;</code> 优先.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>列举下没用过，但是可能会用到的，所以这些并不全，最全的还要去官网的示例看：</p><ul><li>分组聚合<br>接口一样，但有多种实现，用 group 区分，现在消费方需从每种 group 中调用一次返回结果，合并结果返回。</li><li>回声测试<br>回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。<br>所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可调用 <code>$echo(&quot;OK&quot;)</code> 方法看看是否返回 OK</li><li>上下文信息<br>上下文中存放的是当前调用过程中所需的环境信息（获取提供方 IP、判断是否为消费端等）。所有配置信息都将转换为 URL 的参数；<br>RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。</li><li>隐式参数<br>通过 RpcContext 上的 <code>setAttachment</code> 和 <code>getAttachment</code> 在服务消费方和提供方之间进行参数的隐式传递。<br>例如：<code>RpcContext.getContext().set/getAttachment()</code></li><li>本地调用<br>本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。</li><li><strong>参数回调&amp;事件通知</strong><br>参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。<br>在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。</li><li>延迟连接<br>延迟连接用于减少长连接数。当有调用发起时，再创建长连接。</li></ul><h2 id="推荐用法"><a href="#推荐用法" class="headerlink" title="推荐用法"></a>推荐用法</h2><p>在 Provider（提供方） 上尽量多配置 Consumer（消费方） 端属性：</p><ul><li>作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</li><li>在 Provider 配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的。<br><strong>覆盖规则：Consumer 端配置优于 Provider 配置，优于全局配置</strong></li></ul><p>这样可以让 Provider 实现者一开始就思考 Provider 服务特点、服务质量的问题。<br>常见的配置有：</p><ul><li>timeout 方法调用超时</li><li>retries 失败重试次数，缺省是 2（会调用 3 次）</li><li>loadbalance 负载均衡算法，缺省是随机 random。还可以有轮询 roundrobin、最不活跃优先 leastactive</li><li>actives 消费者端，最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会 Wait 直到超时 在方法上配置 <code>dubbo:method</code> 则并发限制针对方法，在接口上配置 <code>dubbo:service</code>，则并发限制针对服务</li></ul><p>Provider 上可以配置的 Provider 端属性有：</p><ul><li><code>threads</code> 服务线程池大小</li><li><code>executes</code> 一个服务提供者并行执行请求上限，即当 Provider 对一个服务的并发调用到上限后，新调用会 Wait，这个时候 Consumer可能会超时。在方法上配置 <code>dubbo:method</code> 则并发限制针对方法，在接口上配置 <code>dubbo:service</code>，则并发限制针对服务。</li></ul><p>XML 配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retry</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.WorldService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retry</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">retries</span>=<span class="string">"9"</span> <span class="attr">loadbalance</span>=<span class="string">"leastactive"</span> <span class="attr">actives</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Provider 上配置合理的 Provider 端属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">threads</span>=<span class="string">"200"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">executes</span>=<span class="string">"200"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">executes</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>配置管理信息：<br>目前有负责人信息和组织信息用于区分站点。有问题时便于的找到服务的负责人，至少写两个人以便备份。负责人和组织的信息可以在注册中心的上看到，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 应用配置负责人、组织 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> <span class="attr">organization</span>=<span class="string">”intl”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- service 配置负责人 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- reference 配置负责人 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> /&gt;</span></span><br></pre></td></tr></table></figure><hr><p>配置 Dubbo 缓存文件（在提供者方设置列表缓存文件）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">file</span>=<span class="string">”$&#123;user.home&#125;/output/dubbo.cache”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>文件的路径，应用可以根据需要调整，保证这个文件不会在发布过程中被清除。<br>如果有多个应用进程注意不要使用同一个文件，避免内容被覆盖。<br>这个文件会缓存注册中心的列表和服务提供者列表。</p><hr><p>对于监控，推荐使用固定端口暴露服务，而不要使用随机端口，这样在注册中心推送有延迟的情况下，消费者通过缓存列表也能调用到原地址，保证调用成功。<br>最后就是不要使用 <code>dubbo.properties</code> 文件配置，推荐使用对应 XML 配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Dubbo 以前也用过几次，都是浅度学习，也没做笔记，今天看了下官网竟然改版了，手册更新了，借这个契机来复习下，并且做下笔记，内容大部分来自官方手册。&lt;br&gt;官网：&lt;a href=&quot;https://dubbo.incubator.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dubbo.incubator.apache.org&lt;/a&gt;&lt;br&gt;旧版的用户使用手册：&lt;a href=&quot;https://www.gitbook.com/book/dubbo/dubbo-user-book&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.gitbook.com/book/dubbo/dubbo-user-book&lt;/a&gt;
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
      <category term="RPC" scheme="http://bfchengnuo.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="http://bfchengnuo.com/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://bfchengnuo.com/2018/05/15/设计模式总结/</id>
    <published>2018-05-15T12:51:36.000Z</published>
    <updated>2018-05-16T07:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完了 Head First 设计模式，收获还是蛮多的，这么多设计模式总算有了个了解，距离实用还有一定距离，毕竟是个经验活，不得不说设计模式中的思想真是太棒了！后面有几种模式没时间拿出来单独研究了，在这里就都战略性总结一下吧，啊哈哈~~<a id="more"></a><br>希望我也能写出一手漂亮的代码！</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>一览表：</p><table><thead><tr><th>设计原则名称</th><th>定 义</th><th>使用频率</th></tr></thead><tbody><tr><td>单一职责原则 (Single Responsibility Principle, SRP)</td><td>一个类只负责一个功能领域中的相应职责</td><td>★★★★☆</td></tr><tr><td>开闭原则 (Open-Closed Principle, OCP)</td><td>软件实体应对扩展开放，而对修改关闭</td><td>★★★★★</td></tr><tr><td>里氏代换原则 (Liskov Substitution Principle, LSP)</td><td>所有引用基类对象的地方能够透明地使用其子类的对象</td><td>★★★★★</td></tr><tr><td>依赖倒转原则 (Dependence Inversion Principle, DIP)</td><td>抽象不应该依赖于细节，细节应该依赖于抽象</td><td>★★★★★</td></tr><tr><td>接口隔离原则 (Interface Segregation Principle, ISP)</td><td>使用多个专门的接口，而不使用单一的总接口</td><td>★★☆☆☆</td></tr><tr><td>合成复用原则 (Composite Reuse Principle, CRP)</td><td>尽量使用对象组合，而不是继承来达到复用的目的</td><td>★★★★☆</td></tr><tr><td>迪米特法则 (Law of Demeter, LoD)</td><td>一个软件实体应当尽可能少地与其他实体发生相互作用</td><td>★★★☆☆</td></tr></tbody></table><h3 id="基本的设计原则"><a href="#基本的设计原则" class="headerlink" title="基本的设计原则"></a>基本的设计原则</h3><p>上面的表中都是专业的说法，但是貌似并不怎么好理解，反正我是看的比较懵逼，然后就用普通的语言来进行描述下，首先是下面总结的几条，应该是大纲级别的了</p><ul><li>封装变化<br>找出应用中可能需要变化的部分，把它们独立出来；不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>多用组合，少用继承</li><li>为交互对象之间的松耦合设计而努力</li></ul><p>这样设计类才能更好的利用 OO 的特性，也是基础：抽象、封装、继承、多态；<br>良好的 OO 设计必须具备：可复用、可扩充、可维护三个特性</p><p>对上面不太好理解的地方补充：<br><strong>松耦合：</strong><br>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节；也就是说，如果改变其中一方并不会影响到另一方，因为两者是松耦合的，所以只有它们之间的接口仍被遵守，那么我们就可以自由的改变它们（接口的重要性）<br><strong>松耦合的设计之所以能建立起富有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</strong></p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>从表中也可以看出，这个使用的非常频繁，开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则；它规定：类应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。<br>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为；装饰模式就是遵守的这个原则的体现（硬要说，观察者模式也是遵循的）<br>当然，并不是让每个地方都遵循开闭原则（这回增加代码的复杂度），我们要把注意力集中在最有可能改变的地方，然后应用开闭原则</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>规定的是：要依赖抽象，而不是依赖具体的类；emmm，和“针对接口编程，而不是针对实现编程”貌似是差不多的<br>它说明：不能让高层组件依赖低层组件，而且，不管高层或者低层组件，两者都应该依赖于抽象！</p><blockquote><p>所谓高层组件，是由其他低层组件定义其行为的类。<br>就比如人类是高层组件，男人就是低层组件，它的部分行为是由男人定义的（差不多就这个意思，不要太纠结）</p></blockquote><p>那么，究竟是哪里“倒置”了呢，低层组件会依赖高层的抽象，高层组件也依赖相同的抽象<br><del>（假定男人拥有一个抽象，那么相对于具体实现这个抽象是“高层”的，高层组件也依赖这个抽象）</del><br>我们一般的思维是从顶端开始，然后往下到具体的类，倒置你的想法就是别从顶端开始，首先想的是甭管什么样的男人都需要一个共同的抽象类，然后人类也会依赖这个抽象类，这样想其实就已经倒置了！大概…..<br>然后是几个指导方针：</p><ul><li>变量不可以持有具体类的引用</li><li>不要让类派生自具体类</li><li>不要覆盖基类中已经实现的方法</li></ul><p>但毕竟是指导作用，不可避免的在某些条件下要违反，只是尽量的遵守罢了；我们实例化字符串的时候都是 new 啊，违反了方针啊，但完全可以，因为字符串不可能改变，所以说要灵活<br>工厂模式就是这个原则的代表吧</p><h3 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h3><p>单一职责原则（SRP）<br>开放封闭原则（OCP）<br>里氏替换原则（LSP）<br>依赖倒置原则（DIP）<br>接口隔离原则（ISP）</p><h3 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h3><p>下面列出了基本的原则：</p><ul><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实现编程</li><li>为交互对象之间的松耦合设计而努力</li><li>类应该对修改关闭，对扩展开放</li><li>依赖抽象，不依赖具体类</li><li>只和“朋友”交谈（减少对象之间的交互）</li><li>别找（调用）我，我会找（调用）你</li><li>类应该只有一个改变的理由</li></ul><h2 id="设计模式一览"><a href="#设计模式一览" class="headerlink" title="设计模式一览"></a>设计模式一览</h2><p>这里只是列出了常用的一些模式，并不是全部，每一种模式只是做了简单的解释，具体的实践需要看以前的文章。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>定义算法族，分别封装起来，让它们之间可以互相替换；此模式让算法的变化独立于使用算法的客户。</p></blockquote><p>比如，提供一些 setter 方法设置相应的“策略”，详细解释：<a href="https://bfchengnuo.com/2017/05/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E8%80%85%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote><p>在对象之间定义一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并且自动更新。</p></blockquote><p>当有多个观察者时，不要依赖他们的通知次序，因为是不确定的。详细解释：<a href="https://bfchengnuo.com/2017/05/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote><p>动态的将责任附加到对象上；想要扩展功能，装饰者提供有别于继承的另一种选择。</p></blockquote><p>符合开闭原则，在动态代理中应用广泛。<br>装饰者一般对组件的客户是透明的，装饰者会导致设计中出现许多小对象，过度使用会使系统变的复杂。<br>通常，我们会在调用真正的原始对象方法之前或者之后做一些动作。详细解释：<a href="https://bfchengnuo.com/2017/05/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>工厂方法模式：定义了一个创建对象的接口，但子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。<br>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><p>我们常用的是简单工厂模式，而工厂方法模式相对复杂一些，另外还有抽象工厂模式；他们都是属于工厂模式。<br>其中使用到了依赖倒置原则。详细解释：<a href="https://bfchengnuo.com/2016/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava/">飞机</a></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>确保一个类只有一个实例，并提供全局访问点。</p></blockquote><p>最广泛的模式之一了吧，考察它的也相当多，写法也比较简单。<br>不过需要注意多线程并发的问题，懒汉式和饿汉式，使用双重判断的弊端、原子性和一致性，指令重排等，内容还是比较多的。<br>注意使用多个类加载器也会导致生成多实例。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><blockquote><p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。<br>命令模式也支持可撤销的操作。</p></blockquote><p>让请求调用者和请求接受者解耦，解耦的两者是通过命令对象进行沟通的，封装了其动作。<br>其中可能会使用“空对象模式”，它可以实现队列请求、日志请求等需求（实现日志系统和事务系统）。<br>宏命令是一种简单的延伸。详细解释：<a href="https://bfchengnuo.com/2017/09/14/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="适配器-amp-外观模式"><a href="#适配器-amp-外观模式" class="headerlink" title="适配器&amp;外观模式"></a>适配器&amp;外观模式</h3><blockquote><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p></blockquote><p>比如 JDK 中的枚举和迭代器？<br>其中其实还包含有另一个模式：外观模式，它让接口更简单（改变接口的原因），也将客户从组件的子系统解耦。<br>适配器的意图：“改变”接口符合客户的期望。<br>外观模式的意图：提供子系统的一个简化接口。</p><blockquote><p>提供了一个统一的接口，用来访问子系统中的一群接口。|外观定义了一个高层接口，让子系统更容易使用。</p></blockquote><p>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。<br>适配器：将一个对象包装起来以改变其接口。<br>装饰者：将一个对象包装起来增加新的行为和责任。<br>外观：将一群对象“包装”起来简化其接口。<br>详细解释：<a href="https://bfchengnuo.com/2017/09/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><blockquote><p>在一个方法中，定义一个算法骨架，而将一些步骤延迟到子类中。<br>模板方法使子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p></blockquote><p>其中可以使用钩子，钩子控制根据某些条件是否执行某部分算法。<br>还使用了好莱坞原则：别调用我们，我们会调用你。<br>模板方法可以是一种代码复用的技巧，可以定义具体方法、抽象方法、钩子（可以选择要不要覆盖）。<br>为了防止子类改变模板方法中的算法，可以定义为 final，并且可以说工厂方法是模板方法的一种特殊版本。<br>详细解释：<a href="https://bfchengnuo.com/2017/09/29/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">飞机</a></p><h3 id="迭代器-amp-组合模式"><a href="#迭代器-amp-组合模式" class="headerlink" title="迭代器&amp;组合模式"></a>迭代器&amp;组合模式</h3><blockquote><p>迭代器：<br>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。<br>组合：<br>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p></blockquote><p>他们两个往往能拼在一起使用， 使用组合我们能把相同的操作应用在组合和个别对象上（叶子节点），他们通常有（或者提取出）共同的接口，也就是说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别（只不过有的可能是空实现）。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>策略模式（主动）和状态模式是双胞胎，在出生时才分开。</p><blockquote><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p></blockquote><p>通常，状态模式用类代表状态；Context 会将行为委托给当前的状态对象，状态类可以被多个 Context 实例共享。<br>同样，使用状态模式通常会导致设计中的类数量大大增加。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote><p>为另一个对象提供一个替身或占位符以控制对这个对象的访问。<br>被代理的对象可以是远程的对象（远程代理）、创建开销大的对象（虚拟代理）或需要安全控制的对象（保护代理）。</p></blockquote><p>代理模式要做的主要就是：控制和管理访问，在 AOP 中使用广泛吧。。。<br>Java 中的 RMI 就是一个典型的例子，远程代理是一般代理模式的一种实现。<br>虚拟代理：只有当我们真正需要一个对象的时候才创建它，对象创建后代理就会将请求直接委托给对象（显示图片前的“加载中”）。<br>为了让客户使用代理而不是真正的对象，一般是创建一个工厂，由工厂返回代理对象。<br><strong>因为实际的代理类是运行时创建的，我们称这个 Java 技术为动态代理。</strong><br>衍生类还有很多，比如防火墙代理、缓存代理、智能引用代理、同步代理等。<br>代理在结构上类似装饰者，但是目的不同；装饰者模式是为对象加上行为；而代理是控制访问。<br>Java 中内置代理支持，代理同样会造成你设计中类的数目增加。</p><h3 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h3><blockquote><p>符合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p></blockquote><p>MVC 是典型的复合模式，其实控制器使用了策略模式（控制器是视图的策略）、模型使用了观察者模式、视图使用了组合模式。<br>Web 的开发人员对 MVC 进行适配，使它符合 B/S 模型，我们称这样的适配为 Model 2。</p><h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><blockquote><p>模式是在某情景（Context）下，针对某问题的某种解决方案。<br>情景：就是应用某个模式的情况。这应该是会不断出现的情况。<br>问题：你想在某情景下达到的目标，但也可以是某情景下的约束。<br>解决方案：就是你所追求的一个通用的设计。</p></blockquote><p>当然你可以改变模式。像设计原则一样，模式不是法律或准则，它只是指导方针，你可以改变模式来符合你的需要。</p><ul><li>架构模式</li><li>应用模式<br>三层架构、C/S 系统以及 Web 服务中</li><li>桥接模式<br>不只改变你的实现，也改变你的抽象；会增加复杂度</li><li>生成器模式<br>封装一个产品的构造过程，并允许按步骤构造。隐藏内部表现，产品的实现可以被替换，被用来创建组合结构。</li><li>责任链模式<br>当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式。<br>如果没有任何对象处理它，那它就可能不会被处理。</li><li>蝇量模式<br>如果想要某个类的一个实例能用来提供许多“虚拟实例”，就使用此模式。</li><li>解释器模式</li><li>中介者模式<br>使用中介者模式来集中相关对象之间复杂的沟通和控制方式。设计不当，本身会过于复杂</li><li>备忘录模式<br>当你需要让对象返回之前的状态时（比如撤销操作），用于存储状态。<br>存储和恢复的过程比较耗时，Java 中使用序列化</li><li>原型模式<br>当创建给定类的实例过程很昂贵或者很复杂时，就使用原型模式</li><li>访问者模式<br>当你想要为一个对象的组合增加新的能力，并且封装不重要时</li></ul><h2 id="与设计模式相处"><a href="#与设计模式相处" class="headerlink" title="与设计模式相处"></a>与设计模式相处</h2><ul><li>保持简单<br>你的目标应该是<strong>简单</strong>，而不是如何才能应用上模式；正确的说法是：为了让你的设计简单且有弹性，有时候使用模式是最好的方法。</li><li>考虑模式带来的后果</li><li>知道何时使用<br>这更多的是一种经验，要考虑后果，模式往往是在重构中加入的。<br>找出你设计中会改变的区域，通常这是需要模式的迹象。</li><li>利用模式进行重构<br>比如：你的代码中充满了 if 语句，那么可能需要状态模式；或者意味着工厂模式将这些具体的依赖消除掉。</li><li>拿掉不需要的模式<br>当你的系统变得非常复杂，并且不需要预留任何弹性的时候，就不要使用模式。</li><li>现在不需要，就别做<br>你不确定这一块以后会不会变化就别“过度优化”</li></ul><p>有些模式可能并不适合当前的情况，<strong>可以对其改编使其适合</strong>。<br>不应急切于使用模式，而是致力于最能解决问题的<strong>简单方案</strong>。<br><strong>设计模式也会在你的设计中加入更多的层，这不但增加复杂性，而且效率下降。</strong><br>并且可以适当了解下反模式（看起来是个好模式，真正采用后就会带来麻烦）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完了 Head First 设计模式，收获还是蛮多的，这么多设计模式总算有了个了解，距离实用还有一定距离，毕竟是个经验活，不得不说设计模式中的思想真是太棒了！后面有几种模式没时间拿出来单独研究了，在这里就都战略性总结一下吧，啊哈哈~~
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="设计模式" scheme="http://bfchengnuo.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shiro学习笔记</title>
    <link href="http://bfchengnuo.com/2018/02/08/Shiro%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://bfchengnuo.com/2018/02/08/Shiro学习笔记/</id>
    <published>2018-02-08T05:58:08.000Z</published>
    <updated>2018-08-25T09:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Shiro（读作“sheeroh”，即日语“城”）是一个开源安全轻量级框架，提供身份验证、授权、密码学和会话管理。Shiro 框架直观、易用，同时也能提供健壮的安全性。<br>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。<a id="more"></a><br>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在学习之前，先了解几个名词，对于权限管理来说，最重要的就是（用户）认证和（用户）授权。<br><strong>认证</strong>是为了确保你是个合法用户，常见的形式有账号+密码的方式，或者指纹、数字证书等。<br><strong>授权</strong>就是用来控制（认证后）用户访问资源的，确保对应的用户只能访问指定的资源。<br>一般情况，当用户或者程序访问资源时，系统先判断该资源是否允许匿名访问，如果不允许就会检查该用户是否通过认证，没有就要求进行认证，也就是一般最常见的输入用户名和密码登陆。<br>认证通过后就会进入权限控制，就是检查当前的用户是否拥有权限操作该资源，如果没有就直接拒绝访问。</p><hr><p>所以在设计的时候就有了这几个词：<strong>用户、权限、资源</strong>；为了方便一般会加入一个<strong>角色</strong>达到管理一堆权限的目的。<br>数据库设计中，一般就需要六张表：<strong>用户、权限、角色、资源、用户角色关系、角色权限关系</strong>。<br>用户与角色、角色与权限之间是多对多关系；权限与资源是多对一关系。<strong>因为权限都是针对资源来说的，资源在系统中都是固定的</strong>，所以一个资源（比如用户列表）对应多个权限（查看用户列表、修改用户列表）。<br>一般为了方便，会把资源和权限合并为一张表（资源名称、权限名称、资源地址）。</p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>关于权限的控制，主要可分为两类：</p><ul><li><strong>基于角色的访问控制</strong><br>代码中是以角色为判断条件来控制的，当用户（角色）的权限需求变更时，只能修改对应的代码。<br>比如类似：<code>if(user.hasRole(&quot;管理员&quot;)){....}</code></li><li><strong>基于资源的访问控制</strong><br>代码中是以权限为判断条件来控制的，当用户（角色）的权限需求变更时，只需要修改对应角色中的权限即可，不需要改变代码。<br>比如类似：<code>if(user.hasPermission(&quot;查看用户列表&quot;)){......}</code></li></ul><p>可以看出，<strong>第一种的扩展性很差，不利于系统维护</strong>，因为角色是针对人的，而人是活的（资源是死的）；第二种只需要修改对应的角色权限列表即可，就是修改数据库的内容而已，完全可以通过 web 端应用做到，所以用的比较多。</p><h2 id="权限管理的解决方案"><a href="#权限管理的解决方案" class="headerlink" title="权限管理的解决方案"></a>权限管理的解决方案</h2><p>一般情况也是分为两种：</p><ul><li>粗颗粒权限管理<br>对<strong>资源类型</strong>的权限管理，比如菜单、用户信息等。<br>具体的例子有：管理员可以访问用户信息等页面，部门管理员可查看用户信息。</li><li>细颗粒权限管理<br>对<strong>资源实例</strong>的权限管理，就是<strong>资源类型的具体化</strong>，比如 XX 菜单、XX 用户信息。<br>具体的例子有：部门经理只能查看本部门的员工信息，用户只能查看自己的菜单。</li></ul><p>然后下面就该谈实现了，对于粗颗粒来说是比较简单的，因为代码可以进行抽取，放<strong>在系统架构级别上统一处理</strong>，比如 SpringMVC 的拦截器就可以做到授权，基本上只需要判断下是否有权限就可以了。<br>但是对于细颗粒来说抽取就比较复杂了，<strong>在数据级别上是没有共性可言的</strong>，可以说是业务逻辑的一部分了（不单单是判断是否有权限那么简单了），在业务层去处理会比较简单，如果抽取到系统架构层面就非常麻烦，并且扩展性也很差，所以，<strong>一般情况下细颗粒的控制都是在业务层去实现。</strong></p><hr><p>下面来看具体的做法，一般情况下对于粗颗粒可以使用一些优秀的权限管理框架来做，比如 Shiro ，能够提高开发效率；如果不想用可以自己实现，方法一般用拦截器或者过滤器进行 url 的拦截（基于 url 拦截方式）。<br>如果自己实现的话，需要两个拦截器，一个负责用户认证的拦截（前面），一个负责用户权限（授权）的拦截。<br>可匿名访问的地址和公共地址一般是可配置的，也就是写在 prop 文件中，在写拦截器或者过滤器的时候读取这个文件来检查。<br>PS：自己实现的时候管理资源的 URL 是最头疼的，每一个页面里都有很多链接，都需要配置，确实麻烦；所以就有人想出来使用标识符来统一管理（数据库中增加一个标志字段）。</p><h2 id="初识Shiro"><a href="#初识Shiro" class="headerlink" title="初识Shiro"></a>初识Shiro</h2><p>最开始当然是先看看它能做什么，可以用一幅图来描述：</p><p><img src="/image/dev/shiro作用.png" alt="shiro作用.png"></p><ul><li><strong>Authentication</strong>：<br>身份认证 / 登录，验证用户是不是拥有相应的身份；</li><li><strong>Authorization</strong>：<br>授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情<br>常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li><li><strong>Session Manager</strong>：<br>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li><li><strong>Cryptography</strong>：<br>加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li><strong>Web Support</strong>：<br>Web 支持，可以非常容易的集成到 Web 环境；</li><li><strong>Caching</strong>：<br>缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li><li><strong>Concurrency</strong>：<br>shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><strong>Testing</strong>：<br>提供测试支持；</li><li><strong>Run As</strong>：<br>允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li><strong>Remember Me</strong>：<br>记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li></ul><p><strong>记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。</strong></p><h2 id="Shiro架构"><a href="#Shiro架构" class="headerlink" title="Shiro架构"></a>Shiro架构</h2><p>同样，还是根据图来学习，这是官方提供的架构图：</p><p><img src="/image/dev/Shiro架构.png" alt="Shiro架构.png"></p><ul><li><strong>Subject</strong>：主体<br>可以看到主体可以是任何可以与应用交互的 “用户”；也就是说可以是人的操作也可以是程序的操作。</li><li><strong>SecurityManager</strong>：安全管理器<br>相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li><li><strong>Authenticator</strong>：认证器<br><strong>负责主体认证的</strong>，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li><li><strong>Authrizer</strong>：授权器<br>或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li><li><strong>Realm</strong>：域、领域<br>可以有 1 个或多个 Realm，可以认为是安全实体<strong>数据源</strong>，即用于获取安全实体（认证、授权相关数据）；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；<strong>由用户提供</strong>；在 realm 中存储授权和认证逻辑。<br>注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li><li><strong>SessionManager</strong>：会话管理器<br>主要用来管理 Session 的生命周期，Web 应用一般是用 Web 容器（比如 Tomcat）来管理。<br>Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li><li><strong>SessionDAO</strong><br>通过 SessionDAO 管理 Session 数据，<strong>针对个性化的 Session 数据存储使用 SessionDAO</strong>。<br>DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</li><li><strong>CacheManager</strong>：缓存管理器<br>来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能。<br>Shiro 只提供了缓存逻辑，还需要具体的缓存实现，比如和 ehcache 整合。</li><li><strong>Cryptography</strong>：密码模块<br>Shiro 提高了一些常见的加密组件用于如密码加密 / 解密、散列的。</li></ul><h2 id="认证入门程序"><a href="#认证入门程序" class="headerlink" title="认证入门程序"></a>认证入门程序</h2><p>下面的入门代码是基于 SE 的，Realm 使用的是 ini 配置文件，就是说用户的认证信息都在 ini 配置文件里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、获取 SecurityManager 工厂，此处使用 ini 配置文件初始化 SecurityManager</span></span><br><span class="line">  Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2、得到 SecurityManager 实例</span></span><br><span class="line">  SecurityManager securityManager = factory.getInstance();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、把 securityManager 绑定给 SecurityUtils（设置到当前的运行环境）</span></span><br><span class="line">  SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4、得到 Subject 及创建用户名/密码身份验证 Token（即用户身份/凭证）</span></span><br><span class="line">  Subject subject = SecurityUtils.getSubject();</span><br><span class="line">  UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//5、登录，即身份验证</span></span><br><span class="line">    subject.login(token);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// isAuthenticated 判断是否通过验证</span></span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, subject.isAuthenticated()); <span class="comment">//断言用户已经登录</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//6、退出</span></span><br><span class="line">  subject.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖什么的就不说了，太简单了，尤其是用了 Maven 后，然后还有 ini 的配置文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="number">123</span></span><br><span class="line"><span class="attr">wang</span>=<span class="number">123</span></span><br><span class="line"><span class="section">[roles]</span></span><br></pre></td></tr></table></figure><p>用 ini 而不用 properties 的一个原因就是 ini 中可以对数据进行分组。<br>下面来简单捋一下：<br>SecurityManager 负责真正的身份验证逻辑；它会<strong>委托给 Authenticator 进行身份验证</strong>；Authenticator 才是真正的身份验证者，Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 <strong>ModularRealmAuthenticator</strong> 会调用 AuthenticationStrategy 进行多 Realm 身份验证；Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息。<br>这是稍微详细一点的执行流程（序号不是很对应）：</p><ol><li>首先通过 IniSecurityManagerFactory 并指定一个 ini 配置文件来创建一个 SecurityManager 工厂；</li><li>接着获取 SecurityManager 并绑定到 SecurityUtils，这是一个全局设置，设置一次即可；</li><li>通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；然后获取身份验证的 Token，如用户名 / 密码；</li><li>调用 <code>subject.login()</code> 方法进行登录，其会自动委托给 <code>SecurityManager.login()</code> 方法进行登录；</li><li>SecurityManager 最终由 <strong>ModularRealmAuthenticator</strong> 进行认证（本例），ModularRealmAuthenticator 会调用 IniRealm 去配置文件查找用户信息。<br>如果查到用户信息就给 ModularRealmAuthenticator 返回用户信息。（本例的账号、密码）<br>如果查不到用户信息就给 ModularRealmAuthenticator  返回 null。</li><li>ModularRealmAuthenticator  接收到 IniRealm 返回的 Authenticator  信息，如果是 null 就抛出 UnknownAccountException。<br>其他的可能抛出的 AuthenticationException 或其子类常见的如：<br>DisabledAccountException（禁用的帐号）<br>LockedAccountException（锁定的帐号）<br>UnknownAccountException（错误的帐号）<br>ExcessiveAttemptsException（登录失败次数过多）<br>IncorrectCredentialsException （错误的凭证）<br>ExpiredCredentialsException（过期的凭证）等</li><li>（拓展）SecurityManager 接着会委托给 Authorizer（<strong>ModularRealmAuthorizer</strong>）进行授权，也就是执行 realm 中的授权方法进行查询权限。</li><li>（拓展）权限信息返回给 ModularRealmAuthorizer 后会通过 <strong>PermissionResolver</strong> 把字符串转换成相应的 Permission 实例，然后进行对比，如果没有权限就抛出异常。</li><li>最后可以调用 <code>subject.logout()</code> 退出，其会自动委托给 <code>SecurityManager.logout()</code> 方法退出。</li></ol><p>对于页面的错误消息展示，最好使用如 “用户名 / 密码错误” 而不是 “用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库.</p><h2 id="关于授权"><a href="#关于授权" class="headerlink" title="关于授权"></a>关于授权</h2><p>授权的流程和认证差不多，只不过用的是 hasRole（判断是否具有某个角色） 而已，就不多说了。<br>授权的验证一般有三种形式，编程式（不推荐）、注解式、JSP/GSP 标签：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程式，测试时可以用</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(“admin”)) &#123;</span><br><span class="line">  <span class="comment">//有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//无权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注解式</span></span><br><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">// @RequiresPermissions("user:add")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 有权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签用法</span></span><br><span class="line">&lt;shiro:hasRole name=<span class="string">"admin"</span>&gt;</span><br><span class="line"><span class="comment">// &lt;!—- 有权限 -—&gt;</span></span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure><p>响应的在 ini 配置文件中也需要做出配置，主要是配角色：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># 规则：用户名=密码,角色1，角色2</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="number">123</span>,role1,role2</span><br><span class="line"><span class="attr">wang</span>=<span class="number">123</span>,role1</span><br><span class="line"><span class="comment"># 角色</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role1</span>=user:create,user:update</span><br><span class="line"><span class="attr">role2</span>=user:create,user:delete</span><br></pre></td></tr></table></figure><p>角色的配置规则是：<code>资源:操作:实例</code> ，上面的例子中就是对 user 这个资源的所有实例进行 create 操作，写两段就意味着是 <code>user:create:*</code>，所以说是可以使用通配符 <code>*</code> 的；多个规则用逗号分割。<br>下面是两个测试用例，一般分为两种，基于角色的授权和基于资源的授权；参考一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于资源的授权，根据资源标识符判断</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-permission.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//判断拥有权限：user:create</span></span><br><span class="line">  Assert.assertTrue(subject().isPermitted(<span class="string">"user:create"</span>));</span><br><span class="line">  <span class="comment">//判断拥有权限：user:update and user:delete</span></span><br><span class="line">  Assert.assertTrue(subject().isPermittedAll(<span class="string">"user:update"</span>, <span class="string">"user:delete"</span>));</span><br><span class="line">  <span class="comment">//判断没有权限：user:view</span></span><br><span class="line">  Assert.assertFalse(subject().isPermitted(<span class="string">"user:view"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>(expected = UnauthorizedException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckPermission</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-permission.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:create</span></span><br><span class="line">  subject().checkPermission(<span class="string">"user:create"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:delete and user:update</span></span><br><span class="line">  subject().checkPermissions(<span class="string">"user:delete"</span>, <span class="string">"user:update"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:view 失败抛出异常</span></span><br><span class="line">  subject().checkPermissions(<span class="string">"user:view"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于角色的授权，根据角色名来判断</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHasRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-role.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//判断拥有角色：role1</span></span><br><span class="line">  Assert.assertTrue(subject().hasRole(<span class="string">"role1"</span>));</span><br><span class="line">  <span class="comment">//判断拥有角色：role1 and role2</span></span><br><span class="line">  Assert.assertTrue(subject().hasAllRoles(Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>)));</span><br><span class="line">  <span class="comment">//判断拥有角色：role1 and role2 and !role3</span></span><br><span class="line">  <span class="keyword">boolean</span>[] result = subject().hasRoles(Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>, <span class="string">"role3"</span>));</span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, result[<span class="number">0</span>]);</span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, result[<span class="number">1</span>]);</span><br><span class="line">  Assert.assertEquals(<span class="keyword">false</span>, result[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>(expected = UnauthorizedException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-role.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//断言拥有角色：role1</span></span><br><span class="line">  subject().checkRole(<span class="string">"role1"</span>);</span><br><span class="line">  <span class="comment">//断言拥有角色：role1 and role3 失败抛出异常</span></span><br><span class="line">  subject().checkRoles(<span class="string">"role1"</span>, <span class="string">"role3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isXXX 方法会返回布尔值，checkXXX 失败会抛出异常；篇幅限制，更多的内容去参考里的 wiki 看吧，因为项目中未使用，等用到了再进行补充。</p><h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><p><img src="/image/dev/realm继承.png" alt="realm继承.png"></p><p>这是 Realm 的继承体系，自定义 Realm 可以直接继承自 Realm 这个顶级接口，也可以选择它的孩子;<br>一般，选择 <strong>AuthorizingRealm</strong>（授权）即可；其继承了 AuthenticatingRealm（即身份验证），而且也间接继承了 CachingRealm（带有缓存实现），只需要实现验证和授权这两个方法逻辑就可以了。<br>顶级 Realm 接口定义的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个唯一的Realm名字</span></span><br><span class="line"><span class="function">String <span class="title">getName</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断此Realm是否支持此Token</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span> <span class="params">(AuthenticationToken token)</span></span>;</span><br><span class="line"><span class="comment">//根据Token获取认证信息</span></span><br><span class="line"><span class="function">AuthenticationInfo <span class="title">getAuthenticationInfo</span> <span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br></pre></td></tr></table></figure><p>自定义 Realm 使用继承 AuthorizingRealm 的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">implements</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置 realm 的名称，可省略</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.setName(<span class="string">"MyRealm"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于认证</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span> <span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 从 token 得到用户名</span></span><br><span class="line">    String username = (String) token.getPrincipal();</span><br><span class="line">    <span class="comment">// String password = new String((char[])token.getCredentials()); //得到密码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据用户名查找密码，比如从数据库中；假如已经查到</span></span><br><span class="line">    String pwd = <span class="string">"123456"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果查不到信息，用户不存在；假设这种情况 pwd 为 null</span></span><br><span class="line">    <span class="keyword">if</span>(pwd == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果身份认证验证成功，返回一个 AuthenticationInfo 实现；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, pwd, <span class="keyword">this</span>.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于授权</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span> <span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 principals 获取身份信息</span></span><br><span class="line">    <span class="comment">// 强转为认证的时候填充到 SimpleAuthenticationInfo 中的第一个参数类型</span></span><br><span class="line">    String username = (String) principals.getPrimaryPrincipal();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据身份信息查询权限信息，比如从数据库中</span></span><br><span class="line">    List&lt;String&gt; permissions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    permissions.add(<span class="string">"user:create"</span>);</span><br><span class="line">    permissions.add(<span class="string">"user:update"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造 SimpleAuthorizationInfo 返回授权信息</span></span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    <span class="comment">// authorizationInfo.setRoles(userService.findRoles(username));</span></span><br><span class="line">    authorizationInfo.setStringPermissions(permissions);</span><br><span class="line">    <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查到的密码和 token 里的密码不符调用方就会抛出 IncorrectCredentialsException；如果返回 null 就会抛出 UnknownAccountException。<br>最后别忘了配置下 ini 文件，把自定义的 Realm 写进去，要不然 Shiro 也不识别：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="comment"># 声明一个 realm</span></span><br><span class="line"><span class="attr">myRealm</span>=com.bfchengnuo.shiro.realm.MyRealm</span><br><span class="line"><span class="comment"># 指定 securityManager 的 realms 实现</span></span><br><span class="line"><span class="comment"># 也就是把自定义的 realm 设置到 securityManager </span></span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure><p>其他的代码和入门程序一样，就是把配置文件改改就可以了。</p><h2 id="编码和加密"><a href="#编码和加密" class="headerlink" title="编码和加密"></a>编码和加密</h2><p>Shiro 还提供了一些关于常用的编码、加密。散列工具，使用也非常的简单，下面来看看简单的使用</p><h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码&amp;解码"></a>编码&amp;解码</h3><p>Shiro 提供了 base64 和 16 进制字符串编码 / 解码的 API 支持，方便一些编码解码操作。Shiro 内部的一些数据的存储 / 表示都使用了 base64 和 16 进制字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base64 操作</span></span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String base64Encoded = Base64.encodeToString(str.getBytes());</span><br><span class="line">String str2 = Base64.decodeToString(base64Encoded);</span><br><span class="line">Assert.assertEquals(str, str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16 进制字符串编码 / 解码操作</span></span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String base64Encoded = Hex.encodeToString(str.getBytes());</span><br><span class="line">String str2 = <span class="keyword">new</span> String(Hex.decode(base64Encoded.getBytes()));</span><br><span class="line">Assert.assertEquals(str, str2);</span><br></pre></td></tr></table></figure><p>还有一个可能经常用到的类 CodecSupport，提供了 toBytes(str,”utf-8”) / toString(bytes,”utf-8”) 用于在 byte 数组 /String 之间转换。</p><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐）防止暴力破解，盐有时是随机的（需要记录）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String salt = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">// 第一个参数：原文，明文</span></span><br><span class="line"><span class="comment">// 第二个参数：盐值</span></span><br><span class="line"><span class="comment">// 第三个参数：散列的次数，比如 2 就相当于：md5(md5(str))</span></span><br><span class="line">String md5 = <span class="keyword">new</span> Md5Hash(str, salt, <span class="number">1</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 SHA-256</span></span><br><span class="line">String sha1 = <span class="keyword">new</span> Sha256Hash(str, salt).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 SimpleHash 方式</span></span><br><span class="line"><span class="comment">// 内部使用 MessageDigest</span></span><br><span class="line">String simpleHash = <span class="keyword">new</span> SimpleHash(<span class="string">"SHA-1"</span>, str, salt, <span class="number">1</span>).toString();</span><br></pre></td></tr></table></figure><p>SimpleHash 可以指定散列算法，其内部使用了 Java 的 MessageDigest 实现。<br>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现。使用例子见参考。</p><h3 id="加密-amp-解密"><a href="#加密-amp-解密" class="headerlink" title="加密&amp;解密"></a>加密&amp;解密</h3><p>Shiro 还提供对称式加密 / 解密算法的支持，如 AES、Blowfish 等；<strong>当前还没有提供对非对称加密 / 解密算法支持</strong>，未来版本可能提供。<br>下面是一个使用 AES 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AesCipherService aesCipherService = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">aesCipherService.setKeySize(<span class="number">128</span>); <span class="comment">//设置key长度</span></span><br><span class="line"><span class="comment">// 生成 key</span></span><br><span class="line">Key key = aesCipherService.generateNewKey();</span><br><span class="line">String text = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">String encrptText = </span><br><span class="line">  aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">String text2 =</span><br><span class="line">  <span class="keyword">new</span> String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(text, text2);</span><br></pre></td></tr></table></figure><p>Shiro 还提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。<br>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现 PasswordMatcher 及 HashedCredentialsMatcher（更强大）。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>具体在 Shiro 中使用（也就是在 Realm 中）一般是先定义好 ini 文件，设置好使用什么，比如散列 md5，然后定义好散列几次</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="comment"># 定义凭证匹配器</span></span><br><span class="line"><span class="attr">credentialsMatcher</span>=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line"><span class="comment"># 散列算法</span></span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line"><span class="comment"># 散列次数</span></span><br><span class="line">credentialsMatcher.hashIterations=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#credentialsMatcher.storedCredentialsHexEncoded=true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myRealm</span>=com.bfchengnuo.shiro.realm.myRealm</span><br><span class="line"><span class="comment"># 将凭证匹配器设置到 Realm</span></span><br><span class="line">myRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure><p>然后在自定义的 Realm 里返回身份信息的时候稍微改造一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SimpleAuthenticationInfo ai = </span><br><span class="line">  <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt)); <span class="comment">//盐可以是用户名+随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">SimpleAuthenticationInfo ai2 = </span><br><span class="line">  <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, ByteSource.Util.bytes(salt), getName());</span><br></pre></td></tr></table></figure><p>其他的和上面自定义 Realm 的代码一致，不需要更改。<br>这里的 pwd 和 salt 是从数据库获取的（假设存储介质是数据库），程序会拿着 token 中的密码和 salt 进行 md5 处理，然后和 pwd 进行对比。<br>PS：这里针对是的散列的验证，用于认证；上面说的是生成，可放在注册或者修改密码逻辑中。</p><h2 id="与Spring整合"><a href="#与Spring整合" class="headerlink" title="与Spring整合"></a>与Spring整合</h2><p>单独使用 Shiro 或者 SE 中用的情况其实不多，最多的还是 web 项目中用，自然就少不了要和 Spring 进行整合，首先准备工作当然是导入相应的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro核心jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro对web的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro与spring整合jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ehcache 核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ehcache 与 Shiro 的整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就需要在 web.xml 中配置过滤器了，毕竟权限的管理主要还是靠过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro过滤器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置true由servlet容器控制filter的生命周期 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的关键是配 DelegatingFilterProxy，达到让 Spring 管理的 Bean 具有 Filter 的能力。<br>下面就是正式开始配置 Shiro 的配置了，可以建一个 <strong>spring-shiro.xml</strong> 文件，注意：一定要配置在 Spring 这个父容器，如果配置在 SpringMVC 子容器里是没用的，前面也提到过关于这父子容器的关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Shiro 整合包里的 Web 过滤器，id 对应 web.xml 中指定的 targetBeanName --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 请求此地址将由下面配置的formAuthenticationFilter进行表单认证 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.action"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 认证成功统一跳转到 first.action，建议不配置，shiro 认证成功自动到上一个请求路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/first.action"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 通过 unauthorizedUrl 指定没有权限操作时跳转页面--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.jsp"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自定义 filter 配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"authc"</span> <span class="attr">value-ref</span>=<span class="string">"formAuthenticationFilter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 过虑器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对静态资源设置匿名访问 --&gt;</span></span><br><span class="line">      /images/** = anon</span><br><span class="line">      /js/** = anon</span><br><span class="line">      /styles/** = anon</span><br><span class="line">      <span class="comment">&lt;!-- 验证码，可匿名访问 --&gt;</span></span><br><span class="line">      /validatecode.jsp = anon</span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 请求 logout.action地址，shiro去清除session，此地址可以是不存在的--&gt;</span></span><br><span class="line">      /logout.action = logout</span><br><span class="line">      <span class="comment">&lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- /items/queryItems.action = perms[item:query]</span></span><br><span class="line"><span class="comment">            /items/editItems.action = perms[item:edit] --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置记住我或认证通过可以访问的地址 --&gt;</span></span><br><span class="line">      /index.jsp  = user</span><br><span class="line">      /first.action = user</span><br><span class="line">      /welcome.jsp = user</span><br><span class="line">      <span class="comment">&lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt;</span></span><br><span class="line">      /** = authc</span><br><span class="line">      <span class="comment">&lt;!-- /** = anon所有url都可以匿名访问 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- securityManager安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入缓存管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入session管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeManager"</span> <span class="attr">ref</span>=<span class="string">"rememberMeManager"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义 realm --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customRealm"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.shiro.realm.CustomRealm"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缓存管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:shiro-ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- session的失效时长，单位毫秒 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"600000"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 删除失效的session --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteInvalidSessions"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义form认证过虑器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.bfchengnuo.shiro.CustomFormAuthenticationFilter "</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单中账号的input名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单中密码的input名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我input的名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeParam"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookie"</span> <span class="attr">ref</span>=<span class="string">"rememberMeCookie"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 记住我cookie --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- rememberMe是cookie的名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我cookie生效时间30天 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"2592000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内容比较多，需要注意的确实也不少，基本都是按最初没有使用 Spring 需要的那些对象来的，只要把那些对象搞定就 OK 了，比如 securityManager ，牵扯出了一系列的 Bean …..<br>使用了 authc 当用户没有认证时会跳转到指定页面，提交表单后凭证会传送给 FormAuthenticationFilter 进行验证（实际上最终会传给 Realm 进行查找凭证），如果没有找到或者凭证不正确会向 request 域填充异常信息（默认 key 为 shiroLoginFailure）。<br>然后可以在  controller 中从 request 取出这个异常信息判断是什么原因导致，值是异常的全路径，可以使用 <code>xxx.class.getName().equals()</code> 比较。<br>认证成功后 Controller 不需要处理，直接还是返回 login 页面即可，Shiro 会进行处理，默认是跳转到上一个页面。<br>在使用注解授权方式时，三层中都可以，但是推荐在 controller 中使用，比较直观，毕竟是入口；因为注解使用的是 AOP 代理的方式，所以还需要在 SpringMVC 的配置文件中开启 AOP 的支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启aop，对类代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启shiro注解支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配在 mvc 配置文件中的一个原因就是因为注解是加在 controller 上的，controller 的扫描是配在这的，所以放一起吧。<br>注解一般用 RequiresPermissions，而不用基于角色的。举几个例子：<code>@RequiresPermissions(value=&quot;XXX&quot;)</code> or <code>@RequiresPermissions(&quot;XXX&quot;)</code> or <code>@RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)</code> 拥有 <code>user:a</code> 或 <code>user:a</code> 权限。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>shiro 中提供了认证信息（上面已经配过了，更高级的如果需要用到 Redis 之类的保存 Session，那就研究下 SessionDAO）和授权信息的缓存.<br>注意: <strong>shiro 默认关闭认证信息缓存, 但是对于授权信息的缓存默认是开启的.</strong><br>由于 Shiro 只提供了缓存的处理逻辑，并没有实现具体的缓存逻辑（其实也有提供简单的实现），这里使用 <strong>ehcache</strong> 作为缓存的实现了，前面已经导入了相关的依赖，Spring 配置文件中也配好了，还缺一个 eh 缓存的配置文件 <strong>shiro-ehcache.xml</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--diskStore：缓存数据持久化的目录 地址  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"F:\develop\ehcache"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">eternal</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">overflowToDisk</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数就不解释了，以前也用过，在新版本中，无论用户正常退出还是非正常退出<strong>缓存都会自动清空。</strong><br>但是，当管理员修改了用户的权限，但是该用户还没有退出，在默认情况下，修改的权限无法立即生效。需要手动进行编程实现：在权限修改后调用 realm 的 clearCache 方法清除缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">  <span class="keyword">super</span>.clearCache(principals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的方法放在自定义的 Realm 中，在修改权限的 Service 中调用即可，但是我觉得这样只会清除当前用户的缓存，还有相关的一些代码贴在 github，等日后要仔细研究下，TODO。</p><blockquote><p>clearCache 其同时调用 clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo，意为清空 AuthenticationInfo 和 AuthorizationInfo。<br>UserRealm 还提供了 clearAllCachedAuthorizationInfo、clearAllCachedAuthenticationInfo、clearAllCache，用于清空整个缓存。</p><p>principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。<br>一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号</p></blockquote><h2 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h2><p>Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。<br>默认拦截器可以参考 <code>org.apache.shiro.web.filter.mgt.DefaultFilter</code> 中的枚举拦截器：</p><h3 id="身份验证相关的"><a href="#身份验证相关的" class="headerlink" title="身份验证相关的"></a>身份验证相关的</h3><p>包名太长，所以省略前面相同的 <code>org.apache.shiro.web.filter.authc</code> ；说明栏中的括号里的内容是默认值。</p><table><thead><tr><th>默认拦截器名</th><th>拦截器类</th><th>说明</th></tr></thead><tbody><tr><td><strong>authc</strong></td><td>FormAuthenticationFilter</td><td>基于表单的拦截器；如 <code>/**=authc</code>，如果没有登录会跳到相应的登录页面登录；<br>主要属性：<br>usernameParam：表单提交的用户名参数名（ username）；<br>passwordParam：表单提交的密码参数名（password）； <br>rememberMeParam：表单提交的密码参数名（rememberMe）；<br>loginUrl：登录页面地址（/login.jsp）；<br>successUrl：登录成功后的默认重定向地址；<br>failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）；</td></tr><tr><td><strong>authcBasic</strong></td><td>BasicHttpAuthenticationFilter</td><td>Basic HTTP 身份验证拦截器<br>主要属性： <br>applicationName：弹出登录框显示的信息（application）；</td></tr><tr><td><strong>logout</strong></td><td>LogoutFilter</td><td>退出拦截器<br>主要属性：redirectUrl：退出成功后重定向的地址（<strong>/</strong>）; 示例 ：<code>/logout=logout</code></td></tr><tr><td><strong>user</strong></td><td>UserFilter</td><td>用户拦截器，用户已经身份验证或记住我登录的都可；示例 ：<code>/**=user</code></td></tr><tr><td><strong>anon</strong></td><td>AnonymousFilter</td><td>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；<br>示例 <code>/static/**=anon</code></td></tr></tbody></table><p>另外还提供了一个 <code>org.apache.shiro.web.filter.authz.HostFilter</code>，即主机拦截器，比如其提供了属性：<br>authorizedIps：已授权的 ip 地址<br>deniedIps：表示拒绝的 ip 地址；不过目前还没有完全实现，不可用。</p><p>这些默认的拦截器会自动注册，可以直接在 ini 配置文件中通过 <code>拦截器名.属性</code> 设置其属性.</p><h3 id="授权相关的"><a href="#授权相关的" class="headerlink" title="授权相关的"></a>授权相关的</h3><p>包名太长，所以省略前面相同的 <code>org.apache.shiro.web.filter.authz</code> ；说明栏中的括号里的内容是默认值。</p><table><thead><tr><th>默认拦截器名</th><th>拦截器类</th><th>说明</th></tr></thead><tbody><tr><td><strong>roles</strong></td><td>RolesAuthorizationFilter</td><td>角色授权拦截器，验证用户是否拥有<strong>所有角色</strong>；<br>主要属性：<br>loginUrl：登录页面地址（/login.jsp）；<br>unauthorizedUrl：未授权后重定向的地址；示例 ：<code>/admin/**=roles[admin]</code></td></tr><tr><td><strong>perms</strong></td><td>PermissionsAuthorizationFilter</td><td>权限授权拦截器，验证用户是否拥有<strong>所有权限</strong>；属性和 roles 一样；<br>示例 ：<code>/user/**=perms[&quot;user:create&quot;]</code></td></tr><tr><td><strong>port</strong></td><td>PortFilter</td><td>端口拦截器，主要属性：port（80）：可以通过的端口；<br>示例 ：<code>/test= port[80]</code>，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径 / 参数等都一样</td></tr><tr><td><strong>rest</strong></td><td>HttpMethodPermissionFilter</td><td>rest 风格拦截器，自动根据请求方法构建权限字符串<br>（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）<br>示例 ：<code>/users=rest[user]</code>，会自动拼出“user:read,user:create,user:update,user:delete” 权限字符串进行权限匹配（所有都得匹配，isPermittedAll ）</td></tr><tr><td><strong>ssl</strong></td><td>SslFilter</td><td>SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样；</td></tr></tbody></table><p>此外，还有一个 <strong>noSessionCreation</strong>（org.apache.shiro.web.filter.session.NoSessionCreationFilter）不创建会话拦截器，调用 <code>subject.getSession(false)</code> 不会有什么问题，但是如果 <code>subject.getSession(true)</code> 将抛出 DisabledSessionException 异常。</p><p>其他的 JSP 标签之类的看 wiki 吧，实在是太长了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>需要验证验证码的就需要自定义 FormAuthenticationFilter 了，因为它是负责表单验证的，写一个类继承 FormAuthenticationFilter ，然后重写它的 onAccessDenied 方法，先从 Session 获取验证码和输入的比对，如果错误直接返回 true 终止执行，最好往 shiroLoginFailure 里加一下异常，便于 controller 的判断，通过则调用 super 的方法进行表单验证。<br>记得在配置文件里配一下自定义的验证器，上面其实已经配过了。</p><hr><p>使用 Shiro 的记住我功能时需要把相关的 bean 设置为可序列化的，然后再在配置文件中配置 CookieRememberMeManager。<br>然后就可以使用 User 过滤器来指定那些 URL 是可以认证或者通过记住我就可以访问的。<br>也就是说 authc 拦截器即使使用了 记住我 也不会放行，user 可以。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/shiro/overview.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/shiro/overview.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-shiro/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-shiro/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Shiro（读作“sheeroh”，即日语“城”）是一个开源安全轻量级框架，提供身份验证、授权、密码学和会话管理。Shiro 框架直观、易用，同时也能提供健壮的安全性。&lt;br&gt;Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
      <category term="安全" scheme="http://bfchengnuo.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="http://bfchengnuo.com/2018/01/29/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://bfchengnuo.com/2018/01/29/MongoDB学习笔记/</id>
    <published>2018-01-29T06:19:35.000Z</published>
    <updated>2019-02-26T13:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的<strong>开源</strong>数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为 WEB 应用提供<strong>可扩展</strong>的高性能数据存储解决方案。<br><strong>MongoDB 将数据存储为一个文档，数据结构由键值 (key =&gt; value ) 对组成。</strong>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<a id="more"></a><br>作为 NoSQL 里的著名项目，它比其他 NoSQL 数据库的优势之一是它强大的、基于文档的查询语言，由于查询非常容易转换(将 SQL 语句转换成 MongoDB 查询函数调用)，这使得从关系数据库到 MongoDB 的过渡变得简单，并且官方提供了完善的驱动支持，<del>它的目的就是替代传统的 SQL 数据库。</del></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>无数据结构限制<br>mongo 没有”表”的概念,也不用设计表。<br>它使用”集合”存储 多个”键值对”,取代表的功能；想像一下 JSON 这种数据类型。</li><li>支持完全索引</li><li>支持复制和故障恢复</li><li>快速、高扩展性(分片扩展)</li><li>mongo有数据库的概念,但可以不经创建,直接使用。</li></ul><p>当然它是不保证实时一致性，并且不支持事务的，绝大多数的 NoSQL 好像都是不支持的，带来的好处就是快！更好的性能！<br>mongo 没有mysql中”记录”的概念,mongo使用”文档”存储任意数量的”键值对”信息；<br>mongo 无需手动设置”主键”,系统会自动为每一个”文档”自动添加”_id”键值对,保证数据的唯一性.</p><table><thead><tr><th>mysql</th><th>mongodb</th></tr></thead><tbody><tr><td>表(table)</td><td>集合(collection)</td></tr><tr><td>记录(row)</td><td>文档(document)</td></tr><tr><td>主键(primary key) <code>手动设置</code></td><td>_id <code>自动生成</code></td></tr></tbody></table><p>然后再来说说以前写过的 Redis，同样是 NoSQL ，区别在那？具体的就不展开了，说主要的：Redis 是内存型数据库，常用于做缓存；MongoDB 是持久化存储的也就是存硬盘的，易用性不错，也更加的灵活，毕竟目标是取代 SQL 数据库的，性能也不俗，这或许是 NoSQL 的一大特点。<br>Redis 最大的优点就是快，快，还 TMD 是快！</p><blockquote><p>MongoDB 为什么比 MySQL 快？<br>写操作 MongoDB 比传统数据库快的根本原因是 Mongo 使用的内存映射技术 ：<br>写入数据时候只要在内存里完成就可以返回给应用程序，这样并发量自然就很高。而保存到硬体的操作则在后台异步完成。<br>读操作MongoDB快的原因是：<br>1）MongoDB 的设计要求你常用的数据（working set) 可以在内存里装下。这样大部分操作只需要读内存，自然很快。<br>2）文档性模式设计一般会是的你所需要的数据都相对集中在一起（内存或硬盘），大家知道硬盘读写耗时最多是随机读写所产生的磁头定位时间，数据集中在一起则减少了关系性数据库需要从各个地方去把数据找过来（然后Join）所耗费的随机读时间。<br>再有就是分布式集群的水平扩展所带来的压力分担。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我是在 Linux 上做测试，所以就简单说说 linux 下的安装，直接从官网下载二进制包，使用 <code>tar -zxvf</code> 解压，移到 <code>/usr/local</code> 即可。<br>接下来你可以配置下环境变量(比如编辑当前用户目录下的 <code>.bash_profile</code> 文件的方式)，然后使用 mongod  命令启动 mongodb 的服务。<br>执行 <code>./bin/mongod</code> 服务默认会在前台执行，如果数据目录不是 <code>/data/db</code> 那么可以手动指定目录，启动命令为：<code>./bin/mongod --dbpath=/usr/mongo_data MongoDB</code> 数据库服务的默认端口是 <strong>27017</strong> .<br>无论指定目录还是使用默认目录都需要手动进行创建。</p><p>其实还可以进行下简单的配置:<br>进入到 bin 目录下，编辑 <code>mongodb.conf</code> 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbpath = /data/db #数据文件存放目录</span><br><span class="line">logpath = /data/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line"></span><br><span class="line"># 通过访问http://IP:28017/可以查看到mongodb启动的一些信息，同时也对mongodb运行</span><br><span class="line"># 的统计情况进行监控。在使用mongodb过程中，我们可以使用参数将该功能禁用掉。</span><br><span class="line"># 修改配置文件 mongodb.conf，增加参数选项：nohttpinterface = true 即可。</span><br><span class="line"># 3.6+ 版本中已经被删除</span><br><span class="line">nohttpinterface = true</span><br></pre></td></tr></table></figure><p>执行<code>./mongod -f mongodb.conf</code>命令表示启动 MongoDB.</p><blockquote><p>相关配置说明：<br>–dbpath 数据库路径(数据文件)<br>–logpath 日志文件路径<br>–master 指为主机器<br>–slave 指定为从机器<br>–source 指定主机器的IP地址<br>–pologSize 指定日志文件大小不超过 64M. 因为 resync 是非常操作量大且耗时，最好通过设置一个足够大的oplogSize来避免resync(默认的 oplog大小是空闲磁盘大小的5%)。<br>–logappend 日志文件末尾添定加<br>–port 启用端口号<br>–fork 在后台运行<br>–only 指定只复制哪一个数据库<br>–slavedelay 指从复制检测的时间间隔<br>–auth 是否需要验证权限登录(用户名和密码)</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行<code>mongo</code>命令表示表示进入到 MongDB 的控制台，进入到控制台之后，我们输入<code>db.version()</code>命令，如果能显示出当前 MongoDB 的版本号，说明安装成功了。<br>默认情况下，连接地址是 127.0.0.1:27017，连接的数据库是 test 数据库，我们也可以手动指定连接地址和连接的数据库：<br><code>mongo 127.0.0.1:27017/admin</code><br>如果是 3.0+ 的版本，可能会提示下面这样的错误：</p><blockquote><p>WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’.<br>We suggest setting it to ‘never’<br>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’.<br>We suggest setting it to ‘never’</p></blockquote><p>解决方案：<br>执行下面的两句命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure><p>弊端是重启后会失效，所以可以加入到开机启动里面，编辑 <code>/etc/rc.local</code> 追加下面的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if test -f /sys/kernel/mm/transparent_hugepage/enabled; then</span><br><span class="line">   echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">fi</span><br><span class="line">if test -f /sys/kernel/mm/transparent_hugepage/defrag; then</span><br><span class="line">   echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这样就一劳永逸了，那么这个警告的原因是什么？<br>原因就是 HDFS 会因为这个性能严重受影响。设置以后就是允许 hugepage 可以动态分配，而不是系统启动时预先分配，看上去对内存消耗很大的服务都不喜欢它。感觉这是一个 lazy loading 的设计思想。</p><h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><p>在客户端里使用 <code>db.shutdownServer()</code> 命令可以关闭到 MongoDB 服务，但是这个命令的执行要在 admin 数据库下，所以先切换到 admin (<code>use admin</code>)</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查看所有数据库：<code>show dbs</code><br>删除当前数据库：<code>db.dropDatabase()</code><br>PS：默认是不需要手动创建数据库的，mongodb 会自动根据需要来创建。<br>查看当前使用的数据库：<code>db.getName()</code><br>查看当前数据库中的表（集合）：<code>show tables</code> or <code>show collections</code></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在 MongoDB 中，数据以集合的形式存储。如果需要，您可以分割文档。下面创建一个文档并把它存储到一个名为 “colors” 的新集合中（Json 格式）：<br><code>db.colors.save({name:&quot;red&quot;,value:&quot;FF0000&quot;});</code><br>通过查询数据库来验证文档已保存( findOne 可以返回一条数据)：<br><code>db.colors.find();</code><br>默认会查出所有的记录。MongoDB 中的文档以 BSON（二进制 JSON）形式存储。<br>因为 Mongodb 支持 Js 语法，所以可以使用 for 来批量插入：<br><code>for(i=1;i&lt;=10;i++)db.demo.insert({index:i});</code><br>还可以进行计数操作：<br><code>db.demo.find().count();</code><br>使用 skip、limit、sort 操作(<code>1</code>：升序；<code>-1</code>：降序)：<br><code>db.demo.find().skip(2).limit(3).sort({index:1})</code><br>上面插入数据使用了两种方式，一种是 save，另一种是 insert，它们的区别是：<br><strong>insert：</strong>当主键 “_id” 在集合中存在时，不做任何处理。<br><strong>save：</strong>当主键 “_id” 在集合中存在时，进行更新。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新数据同样使用的是 update 关键字：<br><code>db.demo.update({index:1},{index:100})</code><br>如果只需要更新部分字段，那么就需要使用 set 操作符：<br><code>db.colors.update({name:&quot;red&quot;},{$set:{value:&quot;red&quot;}})</code><br>当记录不存在时，插入一条数据：<br><code>db.demo.update({index:1},{index:100},true)</code><br>有时候查询会查到多条数据，默认只会更新第一条，如果需要批量更新那么可以使用：<br><code>db.colors.update({name:&quot;red&quot;},{$set:{value:&quot;red&quot;}},false,true)</code><br>和第二条类似，批量更新只支持 set 方式，第三个参数就是不存在时是否创建，第四个就是是否更新全部数据（默认false）</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与更新不同，删除默认会删除所有查到的数据，关键字为 remove ，参数不允许为空：<br><code>db.demo.remove({index:100})</code><br>删除表（集合）使用的是 drop 关键字：<br><code>db.demo.drop()</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>find 已经用过了，很简单，默认查出所有的数据，或者你需要一条用 findOne，配合 skip 和 limit 是非常有用的。<br>如果是查找单条数据可以 <code>find({x:1})</code> ，就是说如果你记得其中的属性的话，配合索引速度会更快。<br>或者根据某个属性是否存在来查询：<code>find({m:{$exists:false}})</code> ；<br>强制使用索引查询：<code>find({m:{$exists:false}}).hint(&quot;name&quot;)</code> 。<br>更多强大的查找功能参考拓展里，如果我用到或许会来进行补充。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的作用就是为了加快查询速度，这个都是一样的，3.0+ 的版本创建索引使用 createIndex，查看索引使用 getIndexes。<br><code>db.demo.createIndex({index:1})</code><br>和排序类似，1 代表正向，-1 代表反向。<br>PS：索引可以重复创建，不会报错，第二次会直接返回成功。<br>上面通过 createIndex 给 index 创建了索引（单键索引），如果我们插入的数据是：<code>{index:[1,2,3,4]}</code> 这样的形式，那么系统就会自动创建一个多键索引，并不需要显示的创建。</p><blockquote><p>MongoDB automatically creates a multikey index if any indexed field is an array; you do not need to explicitly specify the multikey type.</p></blockquote><p>如果要根据多个字段来创建索引那就是所谓的<strong>复合索引</strong>了：<br><code>db.demo.createIndex({index:1,name:1})</code><br>删除索引可以通过 dropIndex(name) 的形式，name 指的是索引名，可以通过 getIndexes() 获得。</p><h3 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h3><p>这个就非常有用了，比如可以存用户的登陆信息、日志等，因为它的特性是：<strong>超过设定的时间后索引被删除，同时相应的数据也会被清除。</strong><br>创建也非常的简单，只需要加一个时间参数：<br><code>db.demo.createIndex({time:1},{expireAfterSeconds:10})</code><br>这样数据 10 秒后就会被删除。<br><code>db.demo.insert({time:new Date()})</code><br>以这个例子来说，time 字段必须是 ISODate 或者 ISODate 数组（按照最小的时间进行删除），不能使用时间戳，否则不能被自动删除。<br>过期索引不能是复合索引，因为无法根据两个日期来进行删除。<br>删除的时间是不精确的，删除过程是由后台程序每 60s 跑一次，而且删除也需要一些时间，所以存在误差。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>看名字应该就知道是什么意思了，主要用在搜索上，根据某些关键字就能搜出相应的数据，创建全文索引的方式有下面几种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> key-字段名，value-固定字符串text</span><br><span class="line">db.articles.createIndex(&#123;key:"text"&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在多个字段上创建全文索引</span><br><span class="line">db.articles.createIndex(&#123;key1:"text",key2:"text"&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给所有字段创建全文索引</span><br><span class="line">db.articles.createIndex(&#123;"$**":"text"&#125;)</span><br></pre></td></tr></table></figure><p>然后就是使用了，根据建立的全文索引来查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查询包含 coffee 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"coffee"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>（或查询）查询包含 aa 或 bb 或 cc 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"aa bb cc"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -为排除包含有 cc 内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"aa bb -cc"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>（与查询）加查询内容前后用""包含，查询既包含 aa 又包含 bb cc 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:'"aa" "bb" "cc"'&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用 $meta 操作符来查看相似度，并根据相似度来排序</span><br><span class="line">db.imooc_2.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;)</span><br><span class="line">db.imooc_2.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;).sort(&#123;score:&#123;$meta:"textScore"&#125;&#125;);</span><br></pre></td></tr></table></figure><p>在 MongoDB 中<strong>每个数据集合只能创建一个全文索引</strong>, 所以使用全文索引进行查询时不会起冲突.<br>在 3.2+ 的版本中支持了对中文的全文搜索。英文搜索中是按单词来匹配，也就是说内容有空格进行区分，如果是混在一起的字符串，那效果也非常的差。<br>注意事项：</p><ul><li>每次查询，只能指定一个 <code>$text</code> 查询</li><li><code>$text</code> 查询不能出现在 <code>$nor</code> 查询中</li><li>查询中如果包含了 <code>$text</code>, hint 不再起作用</li></ul><p>全文索引会导致 mongodb 写入性能下降，因为所有字符串都要拆分，存储到不同地方。<br>还有就是虽然支持了中文，但是效果并不好，并且只有在企业版中才可以使用 rlp 之类，并且整句的话关键词搜索还是不好，解决方案现在有使用 Elastic Search 同步 mongodb，或者使用分词工具把分词存为单独的一个 tags。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>创建索引的时候系统会默认生成一个名字，为了可读性，我们可以手动定义生成索引的名字，就像这样：<br><code>db.articles.createIndex({x:1},{name:&quot;test&quot;})</code><br>就是说可以传入第二个参数，这里是 name 作为例子，其他的还有 unique（是否唯一）、sparse （稀疏性，默认 false）。<br>开启稀疏后当记录不存在索引字段时就不会创建索引，减少了磁盘的占用，但是带来的问题是强制使用索引查询（hint）时会出错（不存在）。</p><hr><p>然后就是地理位置索引，目前感觉用不到，简单提提，根据平面（X/Y 坐标）或者球面来定位，比如查找距离某个点 一定距离的点，包含在某区域内的点。</p><hr><p>评判索引构建情况（是否合理）的几种方式：</p><ul><li>mongostat 工具<br>自带的查看运行状态的工具，使用方法：<code>mongostat -h 127.0.0.1:27017</code> 有用户名密码的话再加 <code>-u x -p x</code><br>具体的状态说明，自行搜索（因为我没用到过，关注 qr/qw/idx miss）</li><li>profile 集合<br>查看状态：<code>db.getProfilingStatus()</code> ，一个是级别，另一个 slowms 是慢查询的阀值。<br>查看/设置等级：<code>db.get/setProfilingLevel()</code> 同时 set 也算是开启 profile ；<br>等级有三种，加一个关闭状态：<br>0：不开启；1：记录慢命令，默认为大于100ms；2：记录所有命令；3、查询 profiling 记录。</li><li>日志<br>配置文件里可以加入 berbose 来控制级别，数值在 1-5 个 V 之间。</li><li>explain 分析<br>使用：<code>db.demo.find({x:100}).explain()</code><br>用来查看设置索引后是否起作用。</li></ul><p>一些补充：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">db.system.profile.find()</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  "op" : "query",--操作类型</span><br><span class="line">  "ns" : "imooc.system.profile", --查询的命名空间，;databasename.collectionname'</span><br><span class="line">  "query" : &#123; "query" : &#123;  &#125;, --查询条件</span><br><span class="line">  "orderby" : &#123; "$natural" : -1 &#125; &#125;, --约束条件</span><br><span class="line">  "ntoreturn" : 1, --返回数据条目</span><br><span class="line">  "ntoskip" : 0,  --跳过的条目</span><br><span class="line">  "nscanned" : 1, --扫描的数目含索引</span><br><span class="line">  "nscannedObjects" : 1, --扫描的数据数目</span><br><span class="line">  "keyUpdates" : 0,  --</span><br><span class="line">  "numYield" : 0, --其他情况</span><br><span class="line">  "lockStats" : &#123;  --锁状态</span><br><span class="line">    "timeLockedMicros" : &#123; --锁占用时间（毫秒）</span><br><span class="line">      "r" : NumberLong(82), --读锁</span><br><span class="line">      "w" : NumberLong(0)   --写锁</span><br><span class="line">    &#125;,</span><br><span class="line">    "timeAcquiringMicros" : &#123;</span><br><span class="line">      "r" : NumberLong(2), "w" : NumberLong(2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "nreturned" : 1, </span><br><span class="line">  "responseLength" : 651,   --返回长度</span><br><span class="line">  "millis" : 0, --查询时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线上环境不推荐开启 profile ，上线前的观察可以使用。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>设置用户名密码是最常用的保护措施，虽然安全性不是很高，但是方便；开启权限认证有两种方法：<br>auth（配置文件里加 <code>auth = true</code> 即可） 或者 keyfile。<br>然后还需要创建用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> use admin</span><br><span class="line"><span class="meta">&gt;</span> db.createUser(</span><br><span class="line">...   &#123;</span><br><span class="line">...     user: "dba",</span><br><span class="line">...     pwd: "dba",</span><br><span class="line">...     roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ]</span><br><span class="line">...   &#125;</span><br><span class="line">... )</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 角色说明</span><br><span class="line">Built-In Roles（内置角色）：</span><br><span class="line">1. 数据库用户角色：read、readWrite;</span><br><span class="line">2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；</span><br><span class="line">3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</span><br><span class="line">4. 备份恢复角色：backup、restore；</span><br><span class="line">5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span><br><span class="line">6. 超级用户角色：root  </span><br><span class="line">  // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</span><br><span class="line">7. 内部角色：__system</span><br><span class="line"></span><br><span class="line">Read：</span><br><span class="line">允许用户读取指定数据库</span><br><span class="line"></span><br><span class="line">readWrite：</span><br><span class="line">允许用户读写指定数据库</span><br><span class="line"></span><br><span class="line">dbAdmin：</span><br><span class="line">允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</span><br><span class="line"></span><br><span class="line">userAdmin：</span><br><span class="line">允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</span><br><span class="line"></span><br><span class="line">clusterAdmin：</span><br><span class="line">只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</span><br><span class="line"></span><br><span class="line">readAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的读权限</span><br><span class="line"></span><br><span class="line">readWriteAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的读写权限</span><br><span class="line"></span><br><span class="line">userAdminAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</span><br><span class="line"></span><br><span class="line">dbAdminAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</span><br><span class="line"></span><br><span class="line">root：</span><br><span class="line">只在admin数据库中可用。超级账号，超级权限</span><br><span class="line"></span><br><span class="line">db.system.users.find();</span><br></pre></td></tr></table></figure><p><strong>帐号是跟着库走的，所以在指定库里授权，必须也在指定库里验证，账号信息存放在 admin 数据库中</strong>。<br>开始时没进行登陆可以使用 <code>db.auth(&#39;name&#39;,&#39;pwd&#39;)</code> 来进行授权，返回 1 表示成功。<br>就说到这吧，虽然是最简单的一些操作。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>更多内容参见：<br><a href="https://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb4/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-mongodb4/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的&lt;strong&gt;开源&lt;/strong&gt;数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。&lt;br&gt;MongoDB 旨在为 WEB 应用提供&lt;strong&gt;可扩展&lt;/strong&gt;的高性能数据存储解决方案。&lt;br&gt;&lt;strong&gt;MongoDB 将数据存储为一个文档，数据结构由键值 (key =&amp;gt; value ) 对组成。&lt;/strong&gt;MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
    
    </summary>
    
      <category term="自我提升" scheme="http://bfchengnuo.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="数据库" scheme="http://bfchengnuo.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性学习（二）</title>
    <link href="http://bfchengnuo.com/2018/01/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://bfchengnuo.com/2018/01/19/Java8新特性学习（二）/</id>
    <published>2018-01-19T11:19:59.000Z</published>
    <updated>2018-01-19T11:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。<br>上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。<br>这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认为经常用的就这些了，全部的新特性可以见参考的链接。<a id="more"></a></p><h2 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h2><p>Java 8 用默认方法与静态方法这两个新概念来扩展接口的声明。<br>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，如果接口定义了默认方法，那么必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">  <span class="comment">// may not implement (override) them.</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要实现默认方法 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以覆盖默认方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">  Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line"></span><br><span class="line">  defaulable = DefaulableFactory.create( OverridableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JVM中，<strong>默认方法的实现是非常高效的</strong>，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的 Java 接口，而同时能够保障正常的编译过程。<br>这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：stream()，parallelStream()，forEach()，removeIf()，……<br>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。</p><h3 id="为什么要有默认方法"><a href="#为什么要有默认方法" class="headerlink" title="为什么要有默认方法"></a>为什么要有默认方法</h3><p>在 java 8 之前，接口与其实现类之间的 <strong>耦合度</strong> 太高了（<strong>tightly coupled</strong>），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。<br>这个 forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类。</p><h3 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h3><p>和其它方法一样，接口默认方法也可以被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写默认方法并将它重新声明为抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceD</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InterfaceB() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceC() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceC foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceD() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InterfaceD foo"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.foo(); <span class="comment">// 打印：“InterfaceD foo”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 lambda 表达式</span></span><br><span class="line">    ((InterfaceD) () -&gt; System.out.println(<span class="string">"InterfaceD foo"</span>)).foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口默认方法的继承分三种情况（分别对应上面的 <code>InterfaceB</code> 接口、<code>InterfaceC</code> 接口和 <code>InterfaceD</code> 接口）：</p><ul><li>不覆写默认方法，直接从父接口中获取方法的默认实现。</li><li>覆写默认方法，这跟类与类之间的覆写规则相类似。</li><li>覆写默认方法并将它重新声明为抽象方法，这样新接口的子类必须再次覆写并实现这个抽象方法。</li></ul><hr><p>然后来考虑下多继承的问题，是的，默认方法在接口里，接口可以继承，接口可以多实现，那么自然就带来了默认方法多继承的问题；但是 Java 使用的是单继承、多实现的机制，为的是避免多继承带来的调用歧义的问题。当接口的子类同时拥有具有相同签名的方法时，就需要考虑一种解决冲突的方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在冲突</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，存在冲突</span></span><br><span class="line"><span class="comment">//class ClassB implements InterfaceB, InterfaceC &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceB 的 bar 方法</span></span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceC 的 bar 方法</span></span><br><span class="line">    System.out.println(<span class="string">"ClassB bar"</span>); <span class="comment">// 做其他的事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ClassB 类中，它实现的 InterfaceB 接口和 InterfaceC 接口中都存在相同签名的 foo 方法，需要手动解决冲突。覆写存在歧义的方法，并可以使用 <code>InterfaceName.super.methodName();</code> 的方式手动调用需要的接口默认方法。</p><hr><p>下面来看特殊情况：接口继承行为发生冲突时的解决规则。<br>比如，出现了下面的这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        InterfaceA.super.foo(); // 错误</span></span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 InterfaceB 接口继承了 InterfaceA 接口，那么 InterfaceB 接口一定包含了所有 InterfaceA 接口中的字段方法，因此一个同时实现了 InterfaceA 接口和 InterfaceB 接口的类与一个只实现了 InterfaceB 接口的类完全等价。<br>这很好理解，就相当于 <code>class SimpleDateFormat extends DateFormat</code> 与 <code>class SimpleDateFormat extends DateFormat</code>, Object 等价（如果允许多继承）。<br>而覆写意味着对父类方法的屏蔽，这也是 <strong>Override</strong> 的设计意图之一。因此在实现了 InterfaceB 接口的类中无法访问已被覆写的 InterfaceA 接口中的 foo 方法。<br>这是当接口继承行为发生冲突时的规则之一，即 <strong>被其它类型所覆盖的方法会被忽略</strong>。<br>如果想要调用 InterfaceA 接口中的 foo 方法，只能通过自定义一个新的接口同样继承 InterfaceA 接口并显示地覆写 foo 方法，在方法中使用 <code>InterfaceA.super.foo();</code> 调用 InterfaceA 接口的 foo 方法，最后让实现类同时实现 InterfaceB 接口和自定义的新接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！ 虽然 InterfaceC 接口的 foo 方法只是调用了一下父接口的默认实现方法，但是这个覆写 <strong>不能省略</strong>，否则 InterfaceC 接口中继承自 InterfaceA 接口的隐式的 foo 方法同样会被认为是被 InterfaceB 接口覆写了而被屏蔽，会导致调用 <code>InterfaceC.super.foo()</code> 时出错。<br>通过这个例子，应该注意到在使用一个默认方法前，一定要考虑它是否真的需要。因为 <strong>默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误</strong>。滥用默认方法可能给代码带来意想不到、莫名其妙的错误。</p><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>当接口继承行为发生冲突时的另一个规则是，<strong>类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AbstractClassA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassA classA = <span class="keyword">new</span> ClassA();</span><br><span class="line">    classA.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    classA.bar(); <span class="comment">// 打印：“AbstractClassA bar”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassA 类中并不需要手动覆写 bar 方法，因为优先考虑到 ClassA 类继承了的 AbstractClassA 抽象类中存在对 bar 方法的实现，同样的因为 AbstractClassA 抽象类中的 foo 方法是抽象的，所以在 ClassA 类中必须实现 foo 方法。<br>虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 <strong>不可相互代替的</strong>：</p><ul><li>接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。</li><li>接口中没有 <code>this</code> 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 <strong>状态</strong>（<strong>state</strong>），抽象方法中可以。</li><li>抽象类不能在 java 8 的 lambda 表达式中使用。</li><li>从设计理念上，接口反映的是 <strong>“like-a”</strong> 关系，抽象类反映的是 <strong>“is-a”</strong> 关系。</li></ul><p>顺便复习了下接口和抽象类的知识点~~</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>补充下其他的知识点：</p><ul><li><code>default</code> 关键字只能在接口中使用（以及用在 <code>switch</code> 语句的 <code>default</code> 分支），不能用在抽象类中。</li><li>接口默认方法不能覆写 <code>Object</code> 类的 <code>equals</code>、<code>hashCode</code> 和 <code>toString</code> 方法。</li><li>接口中的静态方法必须是 <code>public</code> 的，<code>public</code> 修饰符可以省略，<code>static</code> 修饰符不能省略。</li><li>即使使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依赖 IDE。</li></ul><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>其实就是上篇所说的双冒号操作，不知道还有没有印象，即 <code>目标引用::方法</code> ，下面就来看看具体的几种用法。<br>方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象的方法或构造器。与 lambda 联合使用（一般是不能独立使用的），方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>下面来看看 Java 支持的这四种不同的方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;              </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><p>这四类可以定义为：</p><ol><li>类名::new</li><li>类名::静态方法名</li><li>类名::实例方法名<br>这种方法引用有些特殊之处：当使用这种方式时，<strong>一定是 lambda 表达式所接收的第一个参数来调用实例方法，如果lambda表达式接收多个参数，其余的参数作为方法的参数传递进去。</strong><br>参考：<a href="http://sfau.lt/b5ZD16" target="_blank" rel="noopener">http://sfau.lt/b5ZD16</a></li><li>对象::实例方法名</li></ol><p>下面就来解释下上面例子里的四种方式，说的都是在本例的情况下。<br>第一种方法引用是构造器引用，它的语法是 <code>Class::new</code>，或者更一般的 <code>Class&lt; T &gt;::new</code>。new 不就是调用构造函数嘛~请注意构造器没有参数。<br>第二种方法引用是静态方法引用，它的语法是 <code>Class::static_method</code> ，请注意这个方法接受一个 Car 类型的参数。<br>第三种方法引用是特定类的任意对象的方法引用，它的语法是 <code>Class::method</code>。请注意，这个方法没有参数，并且是非静态。<br>最后，第四种方法引用是特定对象的方法引用，它的语法是 <code>instance::method</code>。请注意，这个方法接受一个 Car 类型的参数</p><h2 id="类库新特性"><a href="#类库新特性" class="headerlink" title="类库新特性"></a>类库新特性</h2><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 公司著名的 <strong>Guava</strong> 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。<br>受到 Google Guava 的启发，Optional 类已经成为 Java 8 类库的一部分。<br>Optional 实际上<strong>是个容器</strong>：它可以保存类型 T 的值，或者仅仅保存 null。Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。在 Javadoc 中的描述翻译过来就是：<br><em>这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。</em><br>下面就来看看它的几个方法（在前面说 stream 的时候大量使用了 Optional ）：</p><ul><li>of<br>为<strong>非 null</strong> 的值创建一个 Optional。<br>of 方法通过工厂方法<strong>创建</strong> Optional 类。需要注意的是，创建对象时传入的参数不能为 null。如果传入参数为 null，则抛出 NPE。</li><li>ofNullable<br>为指定的值<strong>创建</strong>一个 Optional，如果指定的值为 null，则返回一个空的 Optional。</li><li>empty<br>此方法用于创建一个没有值的 Optional 对象；如果对 emptyOpt 变量调用 isPresent() 方法会返回 false，调用 get() 方法抛出 NullPointerException 异常。</li><li><strong>isPresent</strong><br>如果值存在返回 true，否则返回 false。</li><li><strong>ifPresent</strong><br>如果 Optional 实例有值则为其调用 consumer（比如 lambda 表达式），否则不做处理</li><li>get<br>如果 Optional 有值则将其返回，否则抛出 NoSuchElementException。</li><li>orElse<br>如果有值则将其返回，否则返回指定的其它值(默认值)。<br><code>empty.orElse(&quot;There is no value present!&quot;);</code></li><li>orElseGet<br>orElseGet 与 orElse 方法类似，区别在于得到的默认值。<br>orElse 方法将传入的字符串作为默认值，orElseGet 方法可以接受 Supplier 接口的实现用来生成默认值。<br><code>empty.orElseGet(() -&gt; &quot;Default Value&quot;);</code></li><li>orElseThrow<br>如果有值则将其返回，否则抛出 supplier 接口创建的异常。<br>在 orElseThrow 中我们可以传入一个 lambda 表达式或方法，如果值不存在来抛出异常。<br><code>empty.orElseThrow(ValueAbsentException::new);</code></li><li>map<br>如果有值，则对其执行调用 mapping 函数得到返回值。<br>如果返回值不为 null，则创建包含 mapping 返回值的 Optional 作为 map 方法返回值，否则返回空 Optional。<br><code>Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</code></li><li>flatMap<br>如果有值，为其执行 mapping 函数返回 Optional 类型返回值，否则返回空 Optional。<br>flatMap 与 map（Funtion）方法类似，区别在于 flatMap 中的 mapper 返回值必须是 Optional。<br>调用结束时，flatMap 不会对结果用 Optional 封装。<br><code>upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</code></li><li>filter<br>如果有值并且满足断言条件返回包含该值的 Optional，否则返回空 Optional。<br>对于 filter 函数我们应该传入实现了 Predicate 接口的 lambda 表达式。<br><code>Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6);</code></li></ul><blockquote><p>要理解 ifPresent 方法，首先需要了解 Consumer 类。<br>简答地说，Consumer 类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。<br>Java8 支持不用接口直接通过 lambda 表达式传入参数。</p></blockquote><p>在 Java 9 中，对 Optional 还进行了增强，多加了几个方法，感兴趣的可以去：<a href="http://sfau.lt/b5KDt8" target="_blank" rel="noopener">http://sfau.lt/b5KDt8</a><br>最后通过一个例子来综合的展示下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Sanaulla"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">"There is some value!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"Sana"</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 提倡函数式编程，新增的许多 API 都可以用函数式编程表示，<code>Optional</code>类也是其中之一。这里有几条关于<code>Optional</code>使用的建议：</p><ol><li>尽量避免在程序中直接调用<code>Optional</code>对象的<code>get()</code>和<code>isPresent()</code>方法(活用 orElse 系列)；</li><li>避免使用<code>Optional</code>类型声明实体类的属性；</li></ol><p>第一条建议中直接调用<code>get()</code>方法是很危险的做法，如果<code>Optional</code>的值为空，那么毫无疑问会抛出 NPE 异常，而为了调用<code>get()</code>方法而使用<code>isPresent()</code>方法作为空值检查，这种做法与传统的用 if 语句块做空值检查没有任何区别。<br>第二条建议避免使用 Optional 作为实体类的属性，它在设计的时候就没有考虑过用来作为类的属性，如果你查看 Optional 的源代码，你会发现它没有实现 <code>java.io.Serializable</code> 接口，这在某些情况下是很重要的（比如你的项目中使用了某些序列化框架），使用了 Optional 作为实体类的属性，意味着他们不能被序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">  <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 if-else</span></span><br><span class="line">User user = ...</span><br><span class="line">  Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user.map(User::getUserName)</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>当你很确定一个对象不可能为 null 的时候，应该使用 <code>of()</code> 方法，否则，尽可能使用 <code>ofNullable()</code> 方法</p><h3 id="新的时间和日期API"><a href="#新的时间和日期API" class="headerlink" title="新的时间和日期API"></a>新的时间和日期API</h3><p>Java 8 另一个新增的重要特性就是引入了新的时间和日期 API，它们被包含在 <code>java.time</code> 包中。借助新的时间和日期 API 可以以更简洁的方法处理时间和日期。<br>在 Java 8 之前，所有关于时间和日期的 API 都存在各种使用方面的缺陷，主要有：</p><ol><li>Java 的 <code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，并且是可变的，也就意味着他们都不是线程安全的；</li><li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个 SimpleDateFormat 对象来处理日期格式化，并且 DateFormat 也是非线程安全，这意味着如果你在多线程程序中调用同一个 DateFormat 对象，会得到意想不到的结果。</li><li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，这意味着从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li></ol><p>由于以上这些问题，出现了一些三方的日期处理框架，例如 <strong>Joda-Time</strong>，data4j 等开源项目。<br>但是，Java 需要一套标准的用于处理时间和日期的框架，于是 Java 8 中引入了新的日期 API。新的日期 API 是 <a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">JSR-310</a> 规范的实现，Joda-Time 框架的作者正是 JSR-310 的规范的倡导者，所以能从 Java 8 的日期 API 中看到很多 Joda-Time 的特性。<br>常用的几个类就是 LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration 等.<br>下面通过几个示例代码来快速学会使用新版的日期时间 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Today's Local date : "</span> + today); <span class="comment">// 2014-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="keyword">int</span> year = today.getYear();</span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue();</span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth();</span><br><span class="line">System.out.printf(<span class="string">"Year : %d  Month : %d  day : %d t %n"</span>, year, month, day);</span><br><span class="line"><span class="keyword">int</span> length = today.lengthOfMonth();  <span class="comment">// 月份的天数</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = today.isLeapYear();  <span class="comment">// 是否为闰年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理特定日期（只需要传入年月日）</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">"Your Date of birth is : "</span> + dateOfBirth); <span class="comment">//  2010-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否相等</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span>(date1.equals(today))&#123;</span><br><span class="line">  System.out.printf(<span class="string">"Today %s and date1 %s are same date %n"</span>, today, date1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查像生日这种周期性事件,类似的还有 YearMonth</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">MonthDay currentMonthDay = MonthDay.from(today);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Many Many happy returns of the day !!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Sorry, today is not your birthday"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间（这次不是日期是时间）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"local time now : "</span> + time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期和时间，还可以进行拼接，或者 toLocalDate 拆分</span></span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间的操作（因为是不可变对象，所以操作后的是新实例）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">LocalTime newTime = time.plusHours(<span class="number">2</span>); <span class="comment">// adding two hours</span></span><br><span class="line">System.out.println(<span class="string">"Time after 2 hours : "</span> +  newTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期的操作，通过 withMonth 等方法可修改指定日期</span></span><br><span class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);  <span class="comment">// 可处理天，周，月</span></span><br><span class="line">System.out.println(<span class="string">"Today is : "</span> + today);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 week : "</span> + nextWeek);</span><br><span class="line"></span><br><span class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS);  <span class="comment">// 处理年</span></span><br><span class="line">System.out.println(<span class="string">"Date before 1 year : "</span> + previousYear);</span><br><span class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, YEARS);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 year : "</span> + nextYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否早于或者晚于一个日期</span></span><br><span class="line">LocalDate tomorrow = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">if</span>(tommorow.isAfter(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Tomorrow comes after today"</span>);</span><br><span class="line">&#125;</span><br><span class="line">LocalDate yesterday = today.minus(<span class="number">1</span>, DAYS);</span><br><span class="line"><span class="keyword">if</span>(yesterday.isBefore(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Yesterday is day before today"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理时区</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">LocalDateTime localtDateAndTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );</span><br><span class="line">System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + dateAndTimeInNewYork);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个日期之间的天数和月数</span></span><br><span class="line">LocalDate java8Release = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">14</span>);</span><br><span class="line">Period periodToNextJavaRelease = Period.between(today, java8Release);</span><br><span class="line">System.out.println(<span class="string">"Months left between today and Java 8 release : "</span></span><br><span class="line">                   + periodToNextJavaRelease.getMonths() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);  <span class="comment">// 第一个参数秒，第二个纳秒</span></span><br><span class="line">System.out.println(<span class="string">"What is value of this instant "</span> + timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化工具，第一个为字符串转日期，第二个日期转字符串</span></span><br><span class="line">String goodFriday = <span class="string">"Apr 18 2014"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);</span><br><span class="line">  LocalDate holiday = LocalDate.parse(goodFriday, formatter);</span><br><span class="line">  System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocalDateTime arrivalDate  = LocalDateTime.now();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy  hh:mm a"</span>);</span><br><span class="line">  String landing = arrivalDate.format(format);</span><br><span class="line">  System.out.printf(<span class="string">"Arriving at :  %s %n"</span>, landing);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面所用的 API 大部分都是不可变的，也就是说是线程安全的，可放心食用！<br>Instant 用于表示一个时间戳，它与我们常使用的 <code>System.currentTimeMillis()</code> 有些类似，不过 Instant 可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code> 方法只精确到毫秒（Milli-Second）。<br>类似的还有 Duration、Period 它们通过 between 方法来确定一段时间。</p><h3 id="Base64的API"><a href="#Base64的API" class="headerlink" title="Base64的API"></a>Base64的API</h3><p>在 JDK1.6 之前，JDK 核心类一直没有 Base64 的实现类，有人建议用 Sun/Oracle JDK 里面的 <code>sun.misc.BASE64Encoder</code> 和 <code>sun.misc.BASE64Decoder</code>，使用它们的优点就是不需要依赖第三方类库，缺点就是可能在未来版本会被删除（用 maven 编译会发出警告），而且性能不佳，性能测试见最后的参考链接。<br>JDK1.6 中添加了另一个 Base64 的实现，<code>javax.xml.bind.DatatypeConverter</code> 两个静态方法 parseBase64Binary 和  printBase64Binary，隐藏在 <code>javax.xml.bind</code> 包下面，不被很多开发者知道。<br>在 Java 8 在 <code>java.util</code> 包下面实现了 BASE64 编解码 API，而且性能不俗，API 也简单易懂，下面展示下这个类的使用例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic编码：是标准的BASE64编码，用于处理常规的需求 */</span></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">String asB64 = Base64.getEncoder().encodeToString(<span class="string">"some string"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(asB64); <span class="comment">// 输出为: c29tZSBzdHJpbmc=</span></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">byte</span>[] asBytes = Base64.getDecoder().decode(<span class="string">"c29tZSBzdHJpbmc="</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(asBytes, <span class="string">"utf-8"</span>)); <span class="comment">// 输出为: some string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* URL编码：使用下划线替换URL里面的反斜线“/”  */</span></span><br><span class="line">String urlEncoded = Base64.getUrlEncoder().encodeToString(<span class="string">"subjects?abcd"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(<span class="string">"Using URL Alphabet: "</span> + urlEncoded);</span><br><span class="line"><span class="comment">// 输出为: Using URL Alphabet: c3ViamVjdHM_YWJjZA==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIME编码：使用基本的字母数字产生BASE64输出，而且对MIME格式友好：每一行输出不超过76个字符，而且每行以“\r\n”符结束。 */</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">10</span>; ++t) &#123;</span><br><span class="line">  sb.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] toEncode = sb.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);</span><br><span class="line">System.out.println(mimeEncoded);</span><br></pre></td></tr></table></figure><p>之前我们常用的第三方工具有：<br>Apache Commons Codec library 里面的 <code>org.apache.commons.codec.binary.Base64</code> ；<br>Google Guava 库里面的 <code>com.google.common.io.BaseEncoding.base64()</code> 这个静态方法；<br><code>net.iharder.Base64</code> ，这个 jar 包就一个类；<br>号称 Base64 编码速度最快的 MigBase64，而且是 10 年前的实现.<br>关于他们之间的性能测试去参考里面的最后一个链接查看，总之，用 Java 8 自带的就足足够了！</p><h2 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h2><p>PermGen 空间被移除了，取而代之的是 Metaspace（JEP 122）。<br>JVM 选项 <code>-XX:PermSize</code> 与 <code>-XX:MaxPermSize</code> 分别被 <code>-XX:MetaSpaceSize</code> 与 <code>-XX:MaxMetaspaceSize</code> 所代替。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://ebnbin.com/2015/12/20/java-8-default-methods/" target="_blank" rel="noopener">http://ebnbin.com/2015/12/20/java-8-default-methods/</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">http://www.importnew.com/11908.html</a><br><a href="http://www.importnew.com/6675.html" target="_blank" rel="noopener">http://www.importnew.com/6675.html</a><br><a href="http://www.importnew.com/15637.html" target="_blank" rel="noopener">http://www.importnew.com/15637.html</a><br><a href="https://lw900925.github.io/java/java8-newtime-api.html" target="_blank" rel="noopener">https://lw900925.github.io/java/java8-newtime-api.html</a><br><a href="http://www.importnew.com/14961.html" target="_blank" rel="noopener">http://www.importnew.com/14961.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。&lt;br&gt;上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。&lt;br&gt;这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认为经常用的就这些了，全部的新特性可以见参考的链接。
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性学习</title>
    <link href="http://bfchengnuo.com/2018/01/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <id>http://bfchengnuo.com/2018/01/17/Java8新特性学习/</id>
    <published>2018-01-17T08:36:40.000Z</published>
    <updated>2018-01-18T04:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>很惭愧，关于 Java 8  的特性早就开坑想学，然而….现在都到 Java 9 了依然没填完，这份 MD 文档在桌面也放了半年多了（ :XD 捂脸），一直因为各种原因放在哪里吃灰，今天看了看有必要填坑了！<br>Java 8 新加入的一些特性是很有用的！Spring Framework 5+ 都是基于 Java 8 了，再不学要跟不上了！<br>这篇就说了说 Lambda 表达式和 Stream，发现已经很长了，其他的下次再聊，下篇应该不会太久，大概….<a id="more"></a></p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>简单说，Lambda 表达式是用来简化匿名类的一种写法，使用它有个条件就是，<strong>匿名类实现的接口中只能有一个方法</strong>，也就是只有一个需要实现的方法，并且它的写法有很多种，各种个样的简化。<br>其实 Lambda 表达式的本质只是一个”<a href="http://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96" target="_blank" rel="noopener"><strong>语法糖</strong></a>“，由编译器推断并帮你转换包装为常规的代码，因此你可以使用更少的代码来实现同样的功能。<br>Lambda 表达式赋予了 Java 程序员相较于其他函数式编程语言缺失的特性，结合虚拟扩展方法之类的特性，Lambda 表达式能写出一些极好的代码。<br>Lambda 表达式的加入，使得 Java 拥有了函数式编程的能力。<br>建议不要乱用，因为这就和某些很高级的黑客写的代码一样，简洁，难懂，难以调试，维护人员想骂娘。<br>Java SE 8 添加了 2 个对集合数据进行批量操作的包:  <code>java.util.function</code> 包以及 <code>java.util.stream</code> 包。<br>流 (stream) 就如同迭代器 (iterator),但附加了许多额外的功能。 总的来说，lambda 表达式和 stream 是自 Java 语言添加泛型(Generics)和注解(annotation)以来最大的变化。<br>简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>上面的这些是最最基本的，下面继续来看看还有那些骚操作吧</p><h3 id="基本的Lambda例子"><a href="#基本的Lambda例子" class="headerlink" title="基本的Lambda例子"></a>基本的Lambda例子</h3><p>比如我们要遍历一个 List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String[] atp = &#123;<span class="string">"Rafael Nadal"</span>, <span class="string">"Novak Djokovic"</span>,</span><br><span class="line">                <span class="string">"Stanislas Wawrinka"</span>,</span><br><span class="line">                <span class="string">"David Ferrer"</span>,<span class="string">"Roger Federer"</span>,</span><br><span class="line">                <span class="string">"Andy Murray"</span>,<span class="string">"Tomas Berdych"</span>,</span><br><span class="line">                <span class="string">"Juan Martin Del Potro"</span>&#125;;</span><br><span class="line">List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前的循环方式</span></span><br><span class="line"><span class="keyword">for</span> (String player : players) &#123;</span><br><span class="line">  System.out.print(player + <span class="string">"; "</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">players.forEach((player) -&gt; System.out.print(player + <span class="string">"; "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Java 8 中使用双冒号操作符(double colon operator)</span></span><br><span class="line">players.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>常用的还有使用 lambdas 来实现 Runnable接口，以及实现自定义排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1使用匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2使用 lambda expression</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello world !"</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1使用匿名内部类</span></span><br><span class="line">Runnable race1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2使用 lambda expression</span></span><br><span class="line">Runnable race2 = () -&gt; System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用 run 方法(没开新线程哦!)</span></span><br><span class="line">race1.run();</span><br><span class="line">race2.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 使用 lambda expression 排序 players</span></span><br><span class="line">Comparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2));</span><br><span class="line">Arrays.sort(players, sortByName);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3.2 也可以采用如下形式:</span></span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));</span><br></pre></td></tr></table></figure><p>这样一看，还是挺爽的。</p><blockquote><p>使用 <code>::</code> 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。</p></blockquote><h3 id="使用Lambdas和Streams"><a href="#使用Lambdas和Streams" class="headerlink" title="使用Lambdas和Streams"></a>使用Lambdas和Streams</h3><p>Stream 是对集合的包装,通常和 lambda 一起使用。 使用 lambdas 可以支持许多操作，如 map, filter, limit, sorted, count, min, max, sum, collect 等等。<br>同样，Stream 使用<strong>懒运算</strong>，他们并不会真正地读取所有数据，遇到像 getFirst() 这样的方法就会结束链式语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; javaProgrammers = <span class="keyword">new</span> ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Elsdon"</span>, <span class="string">"Jaycob"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">43</span>, <span class="number">2000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Tamsen"</span>, <span class="string">"Brittany"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">23</span>, <span class="number">1500</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Floyd"</span>, <span class="string">"Donny"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="number">1800</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Sindy"</span>, <span class="string">"Jonie"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">32</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Vere"</span>, <span class="string">"Hervey"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">22</span>, <span class="number">1200</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Maude"</span>, <span class="string">"Jaimie"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">27</span>, <span class="number">1900</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Shawn"</span>, <span class="string">"Randall"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">30</span>, <span class="number">2300</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Jayden"</span>, <span class="string">"Corrina"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">35</span>, <span class="number">1700</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Palmer"</span>, <span class="string">"Dene"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="number">2000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Addison"</span>, <span class="string">"Pam"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">34</span>, <span class="number">1300</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; phpProgrammers = <span class="keyword">new</span> ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Jarrod"</span>, <span class="string">"Pace"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">34</span>, <span class="number">1550</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Clarette"</span>, <span class="string">"Cicely"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">23</span>, <span class="number">1200</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Victor"</span>, <span class="string">"Channing"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">32</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Tori"</span>, <span class="string">"Sheryl"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">21</span>, <span class="number">1000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Osborne"</span>, <span class="string">"Shad"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">32</span>, <span class="number">1100</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Rosalind"</span>, <span class="string">"Layla"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">25</span>, <span class="number">1300</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Fraser"</span>, <span class="string">"Hewie"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">36</span>, <span class="number">1100</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Quinn"</span>, <span class="string">"Tamara"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">21</span>, <span class="number">1000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Alvin"</span>, <span class="string">"Lance"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">38</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Evonne"</span>, <span class="string">"Shari"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">40</span>, <span class="number">1800</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有程序员的姓名:"</span>);  </span><br><span class="line">javaProgrammers.forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  </span><br><span class="line">phpProgrammers.forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName())); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"给程序员加薪 5% :"</span>);  </span><br><span class="line">Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / <span class="number">100</span> * <span class="number">5</span> + e.getSalary());  </span><br><span class="line">javaProgrammers.forEach(giveRaise);  </span><br><span class="line">phpProgrammers.forEach(giveRaise); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"下面是月薪超过 $1,400 的PHP程序员:"</span>);</span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">  .filter((p) -&gt; (p.getSalary() &gt; <span class="number">1400</span>))  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName())); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 filters  </span></span><br><span class="line">Predicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; <span class="number">25</span>);  </span><br><span class="line">Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; <span class="number">1400</span>);  </span><br><span class="line">Predicate&lt;Person&gt; genderFilter = (p) -&gt; (<span class="string">"female"</span>.equals(p.getGender()));  </span><br><span class="line">System.out.println(<span class="string">"下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:"</span>);  </span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">  .filter(ageFilter)  </span><br><span class="line">  .filter(salaryFilter)  </span><br><span class="line">  .filter(genderFilter)  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  </span><br><span class="line"><span class="comment">// 重用filters  </span></span><br><span class="line">System.out.println(<span class="string">"年龄大于 24岁的女性 Java programmers:"</span>);  </span><br><span class="line">javaProgrammers.stream()  </span><br><span class="line">  .filter(ageFilter)  </span><br><span class="line">  .filter(genderFilter)  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure><p>上面展示了一些对于集合的“新操作”，这都是平常用的最多的，使用了语法糖后，真是更爽了。</p><h3 id="Lambda表达式的结构"><a href="#Lambda表达式的结构" class="headerlink" title="Lambda表达式的结构"></a>Lambda表达式的结构</h3><p>让我们了解一下 Lambda 表达式的结构。</p><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li><li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，<strong>函数式接口是只包含一个抽象方法声明的接口</strong>。<br><code>java.lang.Runnable</code> 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 <code>void run()</code> ；每个 Lambda 表达式都能隐式地赋值给函数式接口，当不指明函数式接口时，编译器会自动解释这种转化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">  () -&gt; System.out.println(<span class="string">"hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p><code>@FunctionalInterface</code> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你标注的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误.<br>需要记住的一件事是：<strong>默认方法（default）与静态方法并不影响函数式接口的契约</strong>，可以任意使用。</p><h3 id="双冒号操作符"><a href="#双冒号操作符" class="headerlink" title="双冒号操作符"></a>双冒号操作符</h3><p>双冒号（<code>::</code>）操作符是 Java 中的<strong>方法引用</strong>。 当们使用一个方法的引用时，目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用::方法</code>。比如：<code>Person::getAge;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 getAge 方法的 Function 对象</span></span><br><span class="line">Function&lt;Person, Integer&gt; getAge = Person::getAge;</span><br><span class="line"><span class="comment">// 传参数调用 getAge 方法</span></span><br><span class="line">Integer age = getAge.apply(p);</span><br></pre></td></tr></table></figure><p>目标引用的参数类型是 <code>Function&lt;T,R&gt;</code>，<code>T</code> 表示传入类型，<code>R</code> 表示返回类型。<br>比如，表达式 <code>person -&gt; person.getAge();</code>，传入参数是 <code>person</code>，返回值是 <code>person.getAge()</code>，那么方法引用 <code>Person::getAge</code> 就对应着 <code>Function&lt;Person,Integer&gt;</code> 类型。<br>“::” 称之为定界符，当我们使用它的时候，<strong>只是用来引用要使用的方法，而不是调用方法</strong>，所以不能在方法后面加 ()。<br><strong>你不能直接调用方法引用</strong>，只是用来替代 Lambda 表达式，所以，哪里使用 Lambda 表达式了，哪里就可以使用方法引用了。</p><h3 id="Lambda与匿名类"><a href="#Lambda与匿名类" class="headerlink" title="Lambda与匿名类"></a>Lambda与匿名类</h3><p>使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写入 Lambda 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String firstName = <span class="string">"Tom"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; addSurname = surname -&gt; &#123;</span><br><span class="line">      <span class="comment">// equivalent to this.firstName</span></span><br><span class="line">      <span class="keyword">return</span> firstName + <span class="string">" "</span> + surname;  <span class="comment">// or even,   </span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8 之前必须显示调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String firstName = <span class="string">"Jerry"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; addSurname = <span class="keyword">new</span> Function&lt;String,  </span><br><span class="line">    String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String surname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Example.<span class="keyword">this</span>.firstName + <span class="string">" "</span> + surname;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式与匿名类的另一不同在于两者的编译方法。Java 编译器编译 Lambda 表达式并将他们转化为类里面的<strong>私有函数</strong>，它使用 Java 7 中新加的 invokedynamic 指令<strong>动态绑定</strong>该方法.<br>还有一点 Lambda 表达式的<strong>代码块</strong>不允许调用接口中定义的默认方法，但是 Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中集成的默认方法。<br>Lambda 表达式不需要每次都要被实例化，对于 Java 来说，带来巨大的好处。不像实例化匿名类，对内存的影响可以降到最小。</p><h2 id="Java8中的forEach"><a href="#Java8中的forEach" class="headerlink" title="Java8中的forEach"></a>Java8中的forEach</h2><p><strong>forEach</strong> 方法是 JAVA 8 中在集合父接口 <code>java.lang.Iterable</code> 中新增的一个 <strong>default</strong> 实现方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(action);</span><br><span class="line">  <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">    action.accept(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，forEach 方法接受一个在 JAVA 8 中新增的 <code>java.util.function.Consumer</code> 的消费行为或者称之为动作 (Consumer action )类型；然后将集合中的每个元素作为消费行为的 accept 方法的参数执行。<br>那么自然我们就可以自定义消费行为动作 Consumer，只需要实现 Consumer 接口的 accept 方法。</p><h2 id="Java8中的Stream"><a href="#Java8中的Stream" class="headerlink" title="Java8中的Stream"></a>Java8中的Stream</h2><p>Stream 作为 Java 8 的一大亮点，<strong>它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念</strong>。<br>它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。<br><strong>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</strong><br>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。<br>通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 <code>java.util.stream</code> 是一个<strong>函数式语言+多核时代综合影响的产物</strong>。</p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。<br>而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。<br>下面比较下在 Java 7 与 Java 8 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7:</span></span><br><span class="line">List&lt;Transaction&gt; groceryTransactions = <span class="keyword">new</span> Arraylist&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: transactions)&#123;</span><br><span class="line"> <span class="keyword">if</span>(t.getType() == Transaction.GROCERY)&#123;</span><br><span class="line"> groceryTransactions.add(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(groceryTransactions, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Transaction t1, Transaction t2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;Integer&gt; transactionIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: groceryTransactions)&#123;</span><br><span class="line"> transactionsIds.add(t.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">List&lt;Integer&gt; transactionsIds = transactions.parallelStream()</span><br><span class="line"> .filter(t -&gt; t.getType() == Transaction.GROCERY)</span><br><span class="line"> .sorted(comparing(Transaction::getValue).reversed())</span><br><span class="line"> .map(Transaction::getId)</span><br><span class="line"> .collect(toList());</span><br></pre></td></tr></table></figure><p>Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快.</p><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，<strong>它不是数据结构并不保存数据</strong>，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。<strong>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出</strong>。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。<br>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果；每次转换<strong>原有 Stream 对象不改变</strong>，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。<br>有多种方式生成 Stream Source：<br><strong>从 Collection 和数组：</strong></p><ul><li>Collection.stream()</li><li>Collection.parallelStream()</li><li>Arrays.stream(T array) or Stream.of()</li></ul><p><strong>从 BufferedReader：</strong></p><ul><li>java.io.BufferedReader.lines()</li></ul><p><strong>静态工厂：</strong></p><ul><li>java.util.stream.IntStream.range()</li><li>java.nio.file.Files.walk()</li></ul><p><strong>自己构建：</strong></p><ul><li>java.util.Spliterator</li></ul><p><strong>其它：</strong></p><ul><li>Random.ints()</li><li>BitSet.stream()</li><li>Pattern.splitAsStream(java.lang.CharSequence)</li><li>JarFile.stream()</li></ul><p>一般我们用的比较多的就是第一种吧。</p><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>流的操作类型分为两种：</p><ul><li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。<br>其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。<br>这类操作都是惰性化的（lazy），就是说，<strong>仅仅调用到这类方法，并没有真正开始流的遍历。</strong></li><li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，<strong>当这个操作执行后，流就被使用“光”了，无法再被操作</strong>。<br>所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ul><p>因为转换操作都是 lazy 的，所以<strong>多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成</strong>。<br>我们可以这样简单的理解，Stream 里有个操作函数（把定义的处理方法就叫操作函数吧）的集合，<strong>每次转换操作就是把转换函数放入这个集合中</strong>，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。<br>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p><ul><li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li><li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li></ul><p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。<br>下面就来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">  .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">  .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">  .sum();</span><br></pre></td></tr></table></figure><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据<strong>筛选</strong>和<strong>转换</strong>，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。<br>具体的操作可进行简单的分类：</p><ul><li><strong>Intermediate：</strong><br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li><li><strong>Terminal：</strong><br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li><li><strong>Short-circuiting：</strong><br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</li></ul><p>具体的例子在下一节展示。</p><h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：<br>IntStream、LongStream、DoubleStream。当然我们也可以用 <code>Stream&lt;Integer&gt;</code>、<code>Stream&lt;Long&gt;</code>、<code>Stream&lt;Double&gt;</code>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种<strong>基本数值型</strong>提供了对应的 Stream。<br>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。<br>流的构造和转换的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值流的构造</span></span><br><span class="line">IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流的转换</span></span><br><span class="line"><span class="comment">// 1. Array</span></span><br><span class="line">String[] strArray1 = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 2. Collection</span></span><br><span class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">Set set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 3. String</span></span><br><span class="line">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。<br>然后就来看一些比较经典的栗子吧：</p><h4 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h4><p>map 操作应该是用的比较多的一种了，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素；也就是说是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换大写</span></span><br><span class="line">List&lt;String&gt; output = wordList.stream()</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平方根</span></span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream()</span><br><span class="line">  .map(n -&gt; n * n)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line">  Arrays.asList(<span class="number">1</span>),</span><br><span class="line">  Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">);</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream</span><br><span class="line">  .flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字.</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 留下偶数</span></span><br><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">  Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挑选单词</span></span><br><span class="line">List&lt;String&gt; output = reader.lines()</span><br><span class="line">  .flatMap(line -&gt; Stream.of(line.split(REGEXP)))</span><br><span class="line">  .filter(word -&gt; word.length() &gt; <span class="number">0</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>上面已经用烂了，不多说，关键是它的一些特点：<br>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。<br>当需要为多核系统优化时，可以 <code>parallelStream().forEach()</code>，只是此时<strong>原有元素的次序没法保证</strong>，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算；具有相似功能的 intermediate 操作 peek 可以解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>peek 对每个元素执行操作并返回一个新的 Stream；forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>)</span><br><span class="line"> .filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>)</span><br><span class="line"> .reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。<br>这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><blockquote><p>Optional 这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。<br>使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。<br>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。<br>后面会详细说这一特性。</p></blockquote><h4 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h4><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimitAndSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line">    persons.add(person);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  List&lt;String&gt; personList2 = persons.stream()</span><br><span class="line">    .map(Person::getName).limit(<span class="number">10</span>).skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// limit 和 skip 对 sorted 后的运行次数无影响</span></span><br><span class="line">  List&lt;Person&gt; personList3 = persons.stream()</span><br><span class="line">    .sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName()))</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>limit(10) 就是取前十条，skip(3) 就是跳过前三条咯，果然是更加灵活了。<br>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：<strong>此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样</strong>。<br>在后面的一个例子中，即虽然最后的返回元素数量是 2，但整个管道中的 sorted <strong>表达式执行次数</strong>没有像前面例子相应减少。<br>最后有一点需要注意的是，<strong>对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大</strong>，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream（parallel 用于多核并发操作）。</p><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream()</span><br><span class="line">  .allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream()</span><br><span class="line">  .anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>确实挺方便的，如果你记得的话….</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他的像 <strong>sorted/min/max/distinct</strong> 这些方法就不多说了，想看的可以去 IBM 的原文找下，在参考里；至于它们的优势，比如排序，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。</p><h3 id="总结-amp-归纳"><a href="#总结-amp-归纳" class="headerlink" title="总结&amp;归纳"></a>总结&amp;归纳</h3><ul><li>不是数据结构</li><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。<br>例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li><li><strong>所有 Stream 的操作必须以 lambda 表达式为参数</strong></li><li>不支持索引访问</li><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li><li>很容易生成数组或者 List</li><li>惰性化</li><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li><li>并行能力</li><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li><li>可以是无限的<br>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a><br><a href="https://segmentfault.com/a/1190000009186509" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009186509</a><br><a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html" target="_blank" rel="noopener">http://www.cnblogs.com/IcanFixIt/p/6744973.html</a><br><a href="http://blog.csdn.net/renfufei/article/details/24600507" target="_blank" rel="noopener">http://blog.csdn.net/renfufei/article/details/24600507</a><br><a href="http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood/" target="_blank" rel="noopener">深入探讨Lambda</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很惭愧，关于 Java 8  的特性早就开坑想学，然而….现在都到 Java 9 了依然没填完，这份 MD 文档在桌面也放了半年多了（ :XD 捂脸），一直因为各种原因放在哪里吃灰，今天看了看有必要填坑了！&lt;br&gt;Java 8 新加入的一些特性是很有用的！Spring Framework 5+ 都是基于 Java 8 了，再不学要跟不上了！&lt;br&gt;这篇就说了说 Lambda 表达式和 Stream，发现已经很长了，其他的下次再聊，下篇应该不会太久，大概….
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker化你的应用</title>
    <link href="http://bfchengnuo.com/2018/01/06/Docker%E5%8C%96%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://bfchengnuo.com/2018/01/06/Docker化你的应用/</id>
    <published>2018-01-06T13:21:28.000Z</published>
    <updated>2019-02-26T13:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个<strong>使用 Go 语言开发的开源的应用容器引擎</strong>，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker 的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。<br>记得在公众号科普过 Docker 的一些基本概念，简单可以理解为集装箱，可以把你的程序、环境、配置等等全部装进去，这样在其他机器上达到开箱即用，也就是解决了环境不一致的问题。<br>还有就是每一个 Docker 都是相对隔离的，避免了资源使用上的一些问题。<br><strong>Docker 的思想：标准化、集装箱、隔离，核心有镜像、仓库、容器等概念</strong><a id="more"></a><br>Docker 是容器化技术的一个代表，这项技术并不是很新，在内核中很早之前就已经存在了，不过确实是因为 Docker 才火起来的，在云计算的领域，Docker 可谓是更加的火热，<del>让程序猿和运维的关系更好了</del><br>Docker 你可以粗糙的理解为轻量级的<strong>虚拟机</strong></p><h2 id="走进Docker"><a href="#走进Docker" class="headerlink" title="走进Docker"></a>走进Docker</h2><p>下面来说说核心的三个词：镜像、仓库、容器；仓库就相当于码头，镜像就是集装箱，容器就是运行程序的地方，所以一般的使用步骤就是从仓库（码头）拉取镜像到本地，然后用命令把镜像运行起来。<br>相关的命令：Build（构建镜像）、ship（运输镜像）、run。<br>Docker 仓库的地址：<a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>，如果速度慢，可以尝试国内的 <a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">c.163yun.com</a> ，或者 <a href="https://www.daocloud.io/" target="_blank" rel="noopener">daocloud</a> 也不错。<br>如果我们的镜像比较私密，不想让别人知道，那么可以自己搭一个镜像仓库，就像 Maven 仓库哪样<br>PS：安装 Docker 推荐是在 ubuntu 上，因为本身就是在 ubuntu 上进行开发的，所以支持应该是最好的。<br><img src="http://images2017.cnblogs.com/blog/1307022/201801/1307022-20180106211556893-1773468628.png" alt=""></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>下面介绍几个常用的命令：</p><ul><li>从仓库拉取镜像：<code>docker pull name</code></li><li>查看本机的镜像：<code>docker images</code></li><li>运行镜像：<code>docker run name</code><br>如果需要在后台运行可以使用 <code>-d</code> 参数<br>还可以加 <code>-e</code> 指定用到的环境变量（用 MySQL 的时候可能会用到），指定多个环境变量可使用多次 -e；<br>一般情况，都是加个自定义的名字，这样：<code>docker run --name myName mysql -d mysql:latest</code></li><li>查看本机正在运行的容器：<code>docker ps</code><br>另外，它可以加个 <code>-a</code> 参数来查看所有</li><li>进入容器：<code>docker exec -it [id] bash</code><br>id 由 run 命令（后台启动）返回，或者使用 ps 来查看，并且不需要输入完整，前几位就可以，与 git 比较类似。<br>然后就进入了这个容器，并且是以 bash 这个 shell 的方式，在容器中和 Linux 的操作基本一致，如同一个小型的 Linux 系统，并且是根据需求配置好的。<br>使用 exit 命令即可退出容器</li><li>停止容器：<code>docker stop id</code> ，主要是对于那些后台启动的容器来说。<br>这里的停止并不是删除，区分下镜像和容器的关系。<br>所以，也可以使用 <code>docker start id</code> 来启动容器。</li><li>重启容器：<code>docker restart id</code></li><li>删除镜像：<code>docker rmi id</code><br>注意和 rm 区分，一个是删除镜像，一个是删除容器。</li><li>清除运行过的镜像记录（缓存）：<code>docker rm id</code> ，可以使用 <code>docker ps -a</code> 来查看记录</li></ul><p>如果对命令参数不熟悉，可以查看帮助，如：<code>docker run --help</code> ；可以看出除了 pull 和 run 大部分命令都是依赖于镜像的 id 的；<br><strong>一个镜像可以启动（run）多个容器</strong>，一个容器可以理解为一个虚拟环境。</p><hr><p>如果我们需要将本机的某个文件放到容器里，有个快捷的命令：<br><code>docker cp xxx.html [id]://usr/share/nginx/html</code><br>id 自然指的就是相应的容器了，不过你得熟悉你容器的文件分布情况才行，<strong>这种改动操作是临时的，当容器停止后改动不会被保存</strong><br>如果需要永久保存，需要执行 commit 操作：<br><code>docker commit -m &quot;test&quot; [id] name</code><br>这样就相当于是保存修改了，和 Git 是不是很像？它实际会根据改动生成一个新的镜像，所以要在最后指定新镜像的名字（版本也可以）</p><hr><p>使用 <code>docker tag xxx newName</code> 可以实现镜像的复制….<br>想要 push 自己的镜像除了必要的账号，需要先进行登陆 <code>docker login</code> ，然后 <code>docker push name</code> 就可以了</p><h2 id="Docker中的网络"><a href="#Docker中的网络" class="headerlink" title="Docker中的网络"></a>Docker中的网络</h2><p>Docker 会虚拟出一个运行环境，这个环境当然包括网络、文件等，也是通过 namespace 来进行区分，对于网络，虚拟有三种方式：</p><ul><li>Bridge<br>也就是我们所说的桥接，会虚拟出独立的一套网络配置（网卡），有独立的 ip、端口、iptab 规则等<br>这也是启动 Docker 的默认模式</li><li>Host<br>使用物理机的网卡，和主机共用一套网络配置</li><li>None<br>不配置网络，也就是容器内的程序不会与外界发生通讯</li></ul><p>虚拟的方式是不是和配置虚拟机差不多呢~<br>在配置 Bridge 模式时，通常我们会配置端口映射，简单说就是当我们访问主机的某一个端口时，实际访问的是容器里的某一个端口，这个过程通过 Docker 提供的一个网桥实现（处理请求转发）<br>映射的配置可以在启动时就指定：<br><code>docker run -d -p 8080:80 name</code><br><code>-p</code> 后的第一个是本机的端口，第二个是对应的容器里的端口，上面的命令就实现了把本机 8080  的请求转发到容器的 80 端口上。<br>不放心的话可以使用 <code>netstat -na|grep 8080</code> 看看是不是处于监听的状态了。</p><hr><p>另外一种就是使用 <code>-P</code> 的方式，<strong>是大写的 P</strong>，这种不需要再指定对应的端口，它会在本机开一些随机端口然后映射到容器里对应应用的端口上。</p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>重头戏来了，如何把自己开发的程序打包成一个 Docker 应用呢，就像仓库里的那些一样。<br>用到的是 Dockerfile 和 build 命令，Dockerfile 可以理解为描述了打包流程，然后使用 build 会根据这个流程进行打包。</p><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>是的，Dockerfile 只是一个文本文件，内容才是最重要的，可以直接使用 vim 来编写，名字就叫 Dockerfile，主要包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.设置基础镜像（在某个镜像的基础上）</span><br><span class="line">from tomcat</span><br><span class="line"><span class="meta">#</span> alpine 是针对 Docker 做的一个极小的 linux 环境，也常用做基础镜像</span><br><span class="line"><span class="meta">#</span> from alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2.作者信息,也可以不写</span><br><span class="line">MAINTAINER Kerronex bfchengnuo@gmail.com</span><br><span class="line"><span class="meta">#</span> 官方现在推荐使用 LABEL maintainer="yourname &lt;xxx@xxx.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3.将 war 包放进容器里</span><br><span class="line">COPY xxx.war /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 拓展其他</span><br><span class="line">CMD echo "Hello World!"</span><br></pre></td></tr></table></figure><p>上面是个简单的发布 Java 程序的环境，tomcat 的目录在那是从官网 tomcat 镜像说明页面找到的。<br>然后下面执行 <code>docker build -t appName:latest .</code> 来进行打包就可以了；-t 的作用是可以指定名字和版本，最后一个 <code>.</code> 表示当前目录。<br>然后使用 <code>docker images</code> 命令就可以找到我们自己发布的本地镜像了，运行和其他的一样</p><h3 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h3><p>Docker 是分层存储的，在 Dockerfile 中一行就是一层，每一层都有它唯一的 ID。<br>这些层在 image (镜像)状态都是只读的（RO），当 image 运行为一个容器时，会产生一个容器层 (container layer)，它是可读可写的（RW）。<br>分层的一个好处就是会减轻不少存储压力，多个 image 难免会有许多的相同的命令，分层后就可以实现共用。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>再来看看 Volume 吧，它提供<strong>独立于容器之外</strong>的<strong>持久化</strong>存储。<br>它就可以解决我们在容器内修改不会保存的问题，并且它可以<strong>提供容器与容器之间的共享数据</strong></p><h3 id="映射容器里的目录到本机"><a href="#映射容器里的目录到本机" class="headerlink" title="映射容器里的目录到本机"></a>映射容器里的目录到本机</h3><p>在运行时执行命令：<br><code>docker run -d --name nginx -v /usr/share/nginx/html nginx</code><br>命令里的路径是<strong>容器里</strong>的地址，还给它起了个名字，运行后就会将配置的目录映射到本机（Host）的一个目录下，想要确定这个目录可以使用下面的命令查看容器信息：<br><code>docker inspect nginx</code><br>后面跟的是我们起的那个名字哦，不是镜像名，然后重点看 <strong>Mounts</strong> 下的 Source 和 Destination 是不是正确，就是把容器内的 Destination 地址映射到了本机的 Source 目录下。<br>在本机的 Source 下修改会同步到容器里的 Destination 目录。</p><h3 id="映射主机里的目录到容器"><a href="#映射主机里的目录到容器" class="headerlink" title="映射主机里的目录到容器"></a>映射主机里的目录到容器</h3><p>与上面正好相反，把本机的一个目录映射到容器里，命令：<br><code>docker run -d -v $PWD/html:/usr/share/nginx/html nginx</code><br>这条命令就是把当前目录下的 html 文件夹映射到容器里 nginx 的目录下，这种方式用的比较多，非常的方便</p><h3 id="建立只存数据的容器"><a href="#建立只存数据的容器" class="headerlink" title="建立只存数据的容器"></a>建立只存数据的容器</h3><p>这种情况或者说需求也是比较常见的，使用的命令是：<br><code>docker create -v $PWD/data:/var/mydata --name data_container ubuntu</code><br>这样我们就创建了一个仅仅用来存储数据的新容器 data_container ，它会把当前目录下的 data 文件夹挂载到与之关联的容器的 <code>/var/mydata</code> 目录下，然后我们运行一个新的容器来测试下：<br><code>docker run --volumes-from data_container ubuntu</code><br>volumes-from 的作用就是从另一个容器挂载，这样就实现了当前容器挂载仅有数据容器的目的，主要想体现的是这种仅有数据的容器可以被多个容器挂载使用，用来做数据的共享。</p><h2 id="多容器APP"><a href="#多容器APP" class="headerlink" title="多容器APP"></a>多容器APP</h2><p>玩这个之前需要一个软件就是 docker-compose，在 Mac/Windows 下是自带的。<br>然后需要配置 docker-compose.yml 文件，文件名是固定的，使用的是 yaml 语法，也就是用缩进来表示层次关系，非常流行的一种配置文件格式。</p><blockquote><p>Dockerfile 可以让用户管理一个单独的应用容器；<br>而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等</p></blockquote><p>最后写好 docker-compose 的配置文件后，就可以使用 <code>docker-compose up -d</code> 来运行了，停止就是 stop，rm 是删除；当重新修改配置文件后需要用 <code>docker-compose build</code> 重新来构建。<br>PS：在 docker-compose 配置的名字可以在其他的容器里直接用（比如 nginx 的配置文件里），不需要再配置解析。<br>关于 docker-compose 的使用这里不会多说，具体操作还是蛮复杂的，计划是等用到后再来补充，先暂且知道有这么个多容器的概念，可参考慕课网视频：<a href="https://www.imooc.com/video/15735" target="_blank" rel="noopener">https://www.imooc.com/video/15735</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有时我们需要合并两个镜像，但是这个功能并没有被提供，在 Dockerfile 中也不能使用多次 from，那么有什么好方法呢，可以使用命令先把镜像逆向出来，然后手动合并，镜像 –&gt; Dockerfile 的命令：<br><code>docker history --no-trunc=true image &gt; image1-dockerfile</code><br>但是如果命令中有 ADD、COPY 之类的命令就会有一些问题，因为这些文件并不在你的机器上，需要自行处理了。</p><h2 id="附-Dockerfile示例"><a href="#附-Dockerfile示例" class="headerlink" title="附:Dockerfile示例"></a>附:Dockerfile示例</h2><p>一般是创建一个空目录，然后在这个空目录写 Dockerfile 文件，名字就叫 Dockerfile，这样打包的时候可以放心的用 <code>.</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu</span><br><span class="line">LABEL maintainer="Kerronex &lt;bfchengnuo@gmail.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行命令</span><br><span class="line"><span class="meta">#</span> 替换镜像地址，加速下载，把 archive.ubuntu.com 换成 mirrros.ustc.edu.cn</span><br><span class="line">RUN sed -i 's/archive.ubuntu.com/mirrros.ustc.edu.cn/g' /etc/apt/sources.list</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">COPY index.html /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置容器的入口，会将数组展开来运行</span><br><span class="line"><span class="meta">#</span> 命令的意思是将 nginx 作为前台程序执行，而不是守护进程</span><br><span class="line">ENTRYPOINT ["/usr/sbin/nginx","-g","daemon off;"]</span><br><span class="line"><span class="meta">#</span> 暴露端口</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><p>然后可以使用 <code>curl http://localhost:80</code> 来测试一下。<br>文件中没有用的其他关键字：ADD 也是添加文件，它比 COPY 更加强大，可以添加远程文件；CMD 也是执行命令的意思，可以用于指定容器的入口，也可以使用 ENTRYPOINT 命令</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>WORKDIR</td><td>指定路径</td></tr><tr><td>MAINTAINER</td><td>维护者，现在推荐使用 LABEL maintainer</td></tr><tr><td>ENV</td><td>设定环境变量</td></tr><tr><td>ENTRYPOINT</td><td>容器入口</td></tr><tr><td>USER</td><td>指定用户</td></tr><tr><td>VOLUME</td><td>mount point（容器所挂载的卷）</td></tr></tbody></table><p>当没有指定 ENTRYPOINT 的时候，就用 CMD 来启动容器，如果指定了 ENTRYPOINT 那么 CMD 指定的字串就变成了 <em>argus</em> （参数）</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一个&lt;strong&gt;使用 Go 语言开发的开源的应用容器引擎&lt;/strong&gt;，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker 的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。&lt;br&gt;记得在公众号科普过 Docker 的一些基本概念，简单可以理解为集装箱，可以把你的程序、环境、配置等等全部装进去，这样在其他机器上达到开箱即用，也就是解决了环境不一致的问题。&lt;br&gt;还有就是每一个 Docker 都是相对隔离的，避免了资源使用上的一些问题。&lt;br&gt;&lt;strong&gt;Docker 的思想：标准化、集装箱、隔离，核心有镜像、仓库、容器等概念&lt;/strong&gt;
    
    </summary>
    
      <category term="自我提升" scheme="http://bfchengnuo.com/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="Docker" scheme="http://bfchengnuo.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java定时任务调度工具</title>
    <link href="http://bfchengnuo.com/2018/01/03/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7/"/>
    <id>http://bfchengnuo.com/2018/01/03/Java定时任务调度工具/</id>
    <published>2018-01-03T13:54:37.000Z</published>
    <updated>2018-08-25T09:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是定时任务调度呢？</p><blockquote><p>基于<strong>给定的时间点</strong>，<strong>给定的时间间隔</strong>或者<strong>给定的执行次数</strong>自动执行的任务</p></blockquote><p>Java 中最常见的两款定时任务调度工具就是 Timer 和 Quartz，一般来说 Timer 能解决 60% 的需求，解决不了的就交给大哥 Quartz 了，Timer 是 JDK 自带的，不需要其他依赖，而 Quartz 是开源软件。<a id="more"></a><br>需要注意的是：能用 Timer 实现的就用 Timer，因为大哥的出场费是很贵的….</p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>简单定义：<br>有且只有<strong>一个后台线程</strong>对<strong>多个业务线程</strong>进行<strong>定时定频率的调度</strong>。<br>构件关系：<br>Timer （包含有一个队列和一个后台线程）定时调用 TimerTask</p><p>我记得在上篇文章中我是写过关于 Timer 的，具体内容可以<a href="https://bfchengnuo.com/2017/12/21/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">点击这里</a>回看，这里就简单复习或者补充下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> MyTask(), <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// timer.scheduleAtFixedRate(new MyTask(), 0, 1000);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消所有任务</span></span><br><span class="line">    timer.cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回取消任务的个数</span></span><br><span class="line">    <span class="keyword">int</span> s = timer.purge();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"task run!!"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取最近一次任务执行的时间</span></span><br><span class="line">      System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(scheduledExecutionTime()));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 取消任务</span></span><br><span class="line">      <span class="comment">// cancel();</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是要再次说明：使用 Timer 执行周期性任务时，出现异常后会自动退出（全部任务）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> MyTask, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束线程池正在执行的任务，不再接受新任务，等待当前任务完成</span></span><br><span class="line">scheduledExecutorService.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池里的任务是否全部完成</span></span><br><span class="line">scheduledExecutorService.isTerminated();</span><br></pre></td></tr></table></figure><p>通过上面，知道 Timer 主要的方法有两个 schedule 和 scheduleAtFixedRate；然后来说说他们最大的区别：</p><ul><li>首次执行时间早于当前时间<br>也就是说规定 12:00 执行 task，但是 12:05 的时候才执行到 schedule / scheduleAtFixedRate；<br>对于这种情况，schedule 会以当前时间为准，然后间隔指定时间重复执行；<br>对于 scheduleAtFixedRate 它会尽可能的多执行几次以赶上落下的任务，比如说规定没 2 分钟执行一次，那么它会在执行 scheduleAtFixedRate 后连续执行两次 task 来弥补缺失的“工作量”</li><li>执行耗时超过了间隔时间<br>也就是说规定每隔 3 秒执行一次，但是 task 3 秒还没执行完的情况；<br>对于 scheduleAtFixedRate，当 task 超时后，第二次会很快被执行，它的间隔计算方式是程序开始执行的时间；<br>对于 schedule ，它的间隔计算方式是程序执行完后计时的，也就是说规定每隔 3 秒执行一次，task 耗时 5 秒，task 执行完后再等 3 秒才会执行第二次，从运行开始算的话也就是差了 8 秒</li></ul><p>他们两个方法的主要区别就集中在这两种情况上了，缺点也可以看出来了，因为是单线程所以在处理并发时效果会非常的不理想，基本不会做到并发执行；还有就是抛出异常所有的任务都会终止了。<br>所以在对<strong>时效性要求较高的多任务并发作业</strong>和<strong>对复杂任务的调度</strong>（可能抛出异常）Timer 是不适合的</p><h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>然后就到了介绍大哥的时候了，它的强大就不用说了，你想实现的它基本都能搞定，听说也是作为 Spring 默认的调度框架，并且它的分布式和集群能力也不错。<br>Quartz 的核心有三个：调度器、任务、触发器；可以对应为 Scheduler、Job、Trigger。<br>简单的流程就是：调度器根据触发器来执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloScheduler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建 JobDetail 实例，和 job 类进行绑定</span></span><br><span class="line">    JobDetail jobDetail = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">      .withIdentity(<span class="string">"myJob"</span>, <span class="string">"group1"</span>)</span><br><span class="line">      <span class="comment">// 传入自定义参数</span></span><br><span class="line">      .usingJobData(<span class="string">"msg"</span>,<span class="string">"Loli"</span>)</span><br><span class="line">      .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建一个 trigger 实例，来控制执行的规则</span></span><br><span class="line">    Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">      <span class="comment">// 这里的组和上面的完全不一样，虽然名字一样，但不是在一个类</span></span><br><span class="line">      .withIdentity(<span class="string">"myTrigger"</span>, <span class="string">"group1"</span>)</span><br><span class="line">      <span class="comment">// 传入自定义参数</span></span><br><span class="line">      .usingJobData(<span class="string">"age"</span>, <span class="number">12</span>)</span><br><span class="line">      <span class="comment">// 立即执行</span></span><br><span class="line">      .startNow()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每隔两秒执行一次，直到永远，使用 SimpleSchedule</span></span><br><span class="line">      <span class="comment">// .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span></span><br><span class="line">      <span class="comment">//         .withIntervalInSeconds(2)</span></span><br><span class="line">      <span class="comment">//         .repeatForever())</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 CronTrigger 和 Cron 表达式</span></span><br><span class="line">      .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"* * * * * ? *"</span>))</span><br><span class="line">      </span><br><span class="line">      .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建 Scheduler 实例</span></span><br><span class="line">    SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">    Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line">    scheduler.start();</span><br><span class="line">    <span class="comment">// 按照 trigger 指定的日期执行 jobDetail</span></span><br><span class="line">    <span class="comment">// 它返回最近一次要执行的时间</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起，可以被重启</span></span><br><span class="line">    scheduler.standby();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止，不能被重启，如果传入 true 表示会等待任务结束后才(标记为)终止，默认 false</span></span><br><span class="line">    scheduler.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码结合下面的解释看最好啦，这也仅仅只是一个简单的小例子</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>实现业务逻辑的任务接口，没错它是个接口，非常容易实现，只有一个 execute 方法，相当于 TimerTask 的 run 方法；在里面编写逻辑即可，当任务执行失败时会抛出 JobExecutionException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"当前时间：&#123;0&#125;"</span>, <span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System.out.println("Hello World!");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobExecutionContext.getJobDetail().getKey().getName();</span></span><br><span class="line">    <span class="comment">// jobExecutionContext.getJobDetail().getKey().getGroup();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobExecutionContext.getTrigger().getKey().getName();</span></span><br><span class="line">    <span class="comment">// jobExecutionContext.getTrigger().getKey().getGroup();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自定义的参数</span></span><br><span class="line">    String msg = jobExecutionContext.getJobDetail().getJobDataMap().getString(<span class="string">"msg"</span>);</span><br><span class="line">    Integer age = jobExecutionContext.getTrigger().getJobDataMap().getInt(<span class="string">"age"</span>);</span><br><span class="line">    System.out.println(msg + <span class="string">"::"</span> + age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并后的大 Map,如果有相同的 key 以 Trigger 为准</span></span><br><span class="line">    jobExecutionContext.getMergedJobDataMap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的 Job，只是展示部分常用的，结合下面的说明阅读比较好~</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>每次调度器（Scheduler）调用执行 job 的 execute  方法前会会创建一个新的 job 实例，当调用完成后，关联的 job 实例会被释放，释放的实例就会被 GC 回收</p><h4 id="JobExecutionContext"><a href="#JobExecutionContext" class="headerlink" title="JobExecutionContext"></a>JobExecutionContext</h4><p>当调度器调用一个 Job ，就会将 JobExecutionContext 传递给  job 的 execute  方法；这样 Job 就可以通过 JobExecutionContext 来访问 Quartz 运行时候的环境以及 Job 本身的明细数据。<br>从另一方面 JobExecutionContext  就是为了解决不同 Job 需要不同参数的问题。<br>通过 JobExecutionContext 对象，可以获得 JobDetail 或者 Trigger 设置的自定义参数。</p><h4 id="JobDataMap"><a href="#JobDataMap" class="headerlink" title="JobDataMap"></a>JobDataMap</h4><p>在进行任务调度时，<strong>JobDataMap 存储在 JobExecutionContext  中</strong>，非常方便获取。<br>JobDataMap 可以用来<strong>装载任何可序列化的数据对象</strong>，当 job 实例执行时，这些参数对象会传递给它。<br>JobDataMap 实现了 JDK 的 Map 接口，并添加了一些非常方便的方法用来<strong>存取基本数据类型</strong>。</p><p>关于获取，除了使用 JobExecutionContext ，还有另一种方式，那就是在 Job 的实现类里添加相应的成员变量，并且设置 setter 方法，<strong>默认的 JobFactory 实现类在初始化 Job 实例的时候会自动调用这些 setter 方法</strong>，把 JobDataMap 中相应的值放进去</p><h3 id="JobDetail"><a href="#JobDetail" class="headerlink" title="JobDetail"></a>JobDetail</h3><p>JobDetail 为 job 实例提供了许多设置属性，以及 JobDataMap 成员变量属性，它用来存储<strong>特定的</strong> job 实例的状态信息，<strong>调度器需要借助 JobDetail 对象来添加 Job 实例</strong>。<br>简单说就是 JobDetail 是用来绑定 Job 实例的，并携带一些 Job 实例没有携带的状态信息。<br>下面看看它的一些重要属性：<br>name 和 group ，这两个是必须的，group 的默认值是 <strong>DEFAULT</strong>；还有 jobClass 也是必须的，就是绑定的 Job 类；此外还有一个 JobDataMap ，可简单理解为是来传递数据的。<br>查看可以使用：<code>jd.getKey().getName()/getGroup();</code></p><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>Quartz 中的触发器用来告诉调度程序作业什么时候触发。即 Trigger 对象是用来触发执行 Job 的。<br>触发器的通用属性：</p><ul><li>JobKey<br>表示 Job 实例的标识，触发器被触发时，该指定的 Job 实例会执行</li><li>StartTime<br>触发器的时间表首次被触发的时间，类型是 Date，startAt()</li><li>EndTime<br>指定触发器的不再被触发的时间，类型也是 Date，endAt()，它的优先级比设置的重复执行次数高</li></ul><h4 id="SimpleTrigger"><a href="#SimpleTrigger" class="headerlink" title="SimpleTrigger"></a>SimpleTrigger</h4><p>首先来看它的作用：<br>在一个<strong>指定时间段</strong>内执行<strong>一次</strong>作业任务，或者是在<strong>指定的时间间隔</strong>内<strong>多次</strong>执行作业任务。<br>我们通过 <code>TriggerBuilder.newTrigger()</code> 代码实际上就是生成了一个 SimpleTrigger</p><h4 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h4><p>它的作用：<br><strong>基于日历</strong>的作业调度器，它不像 SimpleTrigger 那样精确的控制，但是更加常用。<br>说到 CronTrigger 就必须得说 Cron 表达式了，熟悉 Linux 的可能接触过，因为 Linux 有一个 crontab 命令来控制计划任务，也是 Cron 表达式。<br>简单说，Cron 表达式是由 7 个子表达式组成的字符串，描述了时间表的详细信息，格式：<br><code>[秒] [分] [小时] [日] [月] [周] [年]</code><br><code>*</code> ：表示“每”的意思，放在第一个位置就是每秒。<br><code>?</code> ：表示不确定，不指定值，就是不关心。<br><code>,</code> ：表示或的意思。<br><code>-</code> ：表示至的意思，就是范围啦。<br><code>/</code> ：表示的也是每的意思，举个例子，如果出现在秒的位置 <code>0/5</code> 就是从 0 秒开始，每隔 5 秒钟。<br><code>#</code> ：表示第，例如在周的位置有 <code>5#3</code> 意思就是第三周的<strong>星期四</strong> 。<br><code>L</code> ：意思是 List，在周位置 3L 就表示最后一周的周二。<br>需要注意的是，<strong>时分秒范围是从 0 开始，日月周就是 1 开始了，年可以省略</strong></p><blockquote><p>在西方，星期天是一个星期的第一天。所以星期天是 1 ，以此类推</p></blockquote><p>掌握了表达式其他的就不是问题了：<br><img src="/image/dev/cron表达式.png" alt="cron表达式.png"></p><p>月周可以使用英文单词的前三个字母，有在线生成 Cron 表达式的工具哦</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度器 Scheduler 可以说是 Quartz 的发动机，它是通过工厂模式来创建的，常用的两个是 StdSchedulerFactory 和 DirectSchedulerFactory。<br><strong>常用的还是 StdSchedulerFactory 因为它允许使用声明式的配置，也就是可以配置到 XML/Properties 文件中</strong>，而 DirectSchedulerFactory 生成的只允许在代码中配置。<br>StdSchedulerFactory 默认会加载工程目录下的 <strong>quartz.properties</strong> ，如果不存在就会去读取自带的配置文件（jar 中），在配置文件中可以配置调度器属性、线程池属性（如线程数）、作业存储位置、插件配置等，可参考 jar 包里的配置。</p><h2 id="Quartz与Spring整合"><a href="#Quartz与Spring整合" class="headerlink" title="Quartz与Spring整合"></a>Quartz与Spring整合</h2><p>Quartz 与 Spring 能够进行完美的整合，用的也是比较多，下面就赶紧来学习一下，首先，必要的一些依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是在 Spring 的配置文件中配置必要的 Bean 了，没办法，总要写配置文件的，或者使用 SpringBoot ？<br>在 Spring 中配置使用 Quartz 有两种方式：<br>MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean，它们主要是来确定要执行的任务的，也就是 Job</p><h3 id="MethodInvokingJobDetailFactoryBean"><a href="#MethodInvokingJobDetailFactoryBean" class="headerlink" title="MethodInvokingJobDetailFactoryBean"></a>MethodInvokingJobDetailFactoryBean</h3><p>使用这种方式，只需要写一个普通的 Bean 即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 相当于设置执行的 Job 为 myBean 的 printMessage 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleJobDetail"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span> <span class="attr">ref</span>=<span class="string">"myBean"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"printMessage"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应执行的 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"myBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"MyBean Executes!"</span> + sf.format(date));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种相对简单的方法，然后都猜得出简单的方式定制性不太高，如果逻辑太复杂可能就无能为力了</p><h3 id="JobDetailFactoryBean"><a href="#JobDetailFactoryBean" class="headerlink" title="JobDetailFactoryBean"></a>JobDetailFactoryBean</h3><p><strong>当需要给作业传递数据，想要更加灵活的话就使用这种方式</strong>，配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"firstComplexJobDetail"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobClass"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value</span>=<span class="string">"com.imooc.springquartz.quartz.FirstScheduledJob"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDataMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"anotherBean"</span> <span class="attr">value-ref</span>=<span class="string">"anotherBean"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Durability"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 firstComplexJobDetail 是通过代码的方式创建的并不是 Spring 容器注入的，启动时可能会报错，提示没有绑定触发器，这里使用的是 Spring 来配置的 trigger，它扫描不到，可以把 Durability 属性设置为 true 表示即使没有绑定触发器也会将其保存在任务容器中。<br>通过 jobClass 来指定 Job 类，对这个类的要求就是要继承 QuartzJobBean，实现 executeInternal 方法，这个还是比较熟悉的，和最开始我们学习时写法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstScheduledJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AnotherBean anotherBean;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherBean</span><span class="params">(AnotherBean anotherBean)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.anotherBean = anotherBean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext arg0)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"FirstScheduledJob Executes!"</span> + sf.format(date));</span><br><span class="line">    <span class="keyword">this</span>.anotherBean.printAnotherMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -----分割线------ */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"anotherBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnotherMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AnotherMessage"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里加了点“难度”，设置自定参数时，我们可以设置对象，通过 value-ref 实现了自动注入，还是挺爽的。</p><h3 id="配置Trigger和Scheduler"><a href="#配置Trigger和Scheduler" class="headerlink" title="配置Trigger和Scheduler"></a>配置Trigger和Scheduler</h3><p>有了任务 Job，Quartz 还差两大核心，下面就来搞一下，完善 Spring 的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 距离当前时间1秒之后执行，之后每隔两秒钟执行一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySimpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>  <span class="attr">ref</span>=<span class="string">"simpleJobDetail"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span>  <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span>  <span class="attr">value</span>=<span class="string">"2000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 每隔5秒钟执行一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCronTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>  <span class="attr">ref</span>=<span class="string">"firstComplexJobDetail"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cronExpression"</span>  <span class="attr">value</span>=<span class="string">"0/5 * * ? * *"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetails"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"simpleJobDetail"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"firstComplexJobDetail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"triggers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mySimpleTrigger"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myCronTrigger"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义 Trigger 的时候也完全活用了上面学习的两种方式，一个使用 SimpleTrigger ，一个使用 CronTrigger；<br>这样当程序启动后就会执行配置的两个 Job 了，simpleJobDetail 使用方式一运行，firstComplexJobDetail 使用方式二运行，还是挺和谐的。<br>上面的也仅仅都是 Quartz 的初级使用，高级的并发、异常处理、持久化等没有涉及，以后有机会再补充吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是定时任务调度呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基于&lt;strong&gt;给定的时间点&lt;/strong&gt;，&lt;strong&gt;给定的时间间隔&lt;/strong&gt;或者&lt;strong&gt;给定的执行次数&lt;/strong&gt;自动执行的任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 中最常见的两款定时任务调度工具就是 Timer 和 Quartz，一般来说 Timer 能解决 60% 的需求，解决不了的就交给大哥 Quartz 了，Timer 是 JDK 自带的，不需要其他依赖，而 Quartz 是开源软件。
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
      <category term="定时任务" scheme="http://bfchengnuo.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE二周目计划（二）</title>
    <link href="http://bfchengnuo.com/2017/12/21/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://bfchengnuo.com/2017/12/21/JavaSE二周目计划（二）/</id>
    <published>2017-12-21T14:29:45.000Z</published>
    <updated>2019-02-26T13:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。<br>这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~<a id="more"></a></p><h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><p>代码中经常接触到日期的操作，我们不喜欢它默认的格式，大多数情况是需要进行格式化的，下面就说下最简单的格式化方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">sf.format(<span class="keyword">new</span> Date());  <span class="comment">// 格式化当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串格式化为 Date 类型</span></span><br><span class="line"><span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-12-20 18:44:00"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时间是否超过五分钟</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOverstepMinute</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">  Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">  Calendar cal1 = Calendar.getInstance();</span><br><span class="line">  cal1.setTime(date);</span><br><span class="line">  cal1.add(Calendar.MINUTE, +<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cal1.compareTo(cal) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以通过 date 对象获取到年月日等信息，但是很遗憾已经过时，所以就有了 Calendar， Calendar 对象用的也很多，可以看看 API；<br>那么他什么用呢？<br>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，分钟? 我们又如何在日期的这些部分<strong>加上或者减去值</strong>呢? 答案是使用Calendar 类。</p><h2 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h2><p>很遗憾我看的视频里并没有讲这个，但是这个却非常的终于，好在现在知道了。<br>Java 中的队列 Queue 在 util 包下，它是个接口，它更倾向于是一种数据结构，也可以理解为集合吧，毕竟 Queue 是 Collection 的一个子接口，与 List、Set 同一级别。<br>首先来认识下什么是队列：</p><blockquote><p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。</p></blockquote><p>简单易懂的介绍，它本来也不是什么难题；<strong>在 Java 中，队列分为 2 种形式，一种是单队列，一种是循环队列</strong> ，循环队列就是为了解决数组无限延伸的情况，让它们闭合起来形成一个圈，这就不会出现角标越界问题了。<br>通常，都是使用数组来实现队列，假定数组的长度为6，也就是队列的长度为6，如果不指定一般默认是 internet 的最大值。<br>因为 LinkedList 实现了 Queue 接口，所以定义一个接口 new 时可以直接使用 LinkedList ，<strong>但它不是同步的！</strong><br>Java 中给了许多的队列实现，甚至有双端（读写）的、按优先级的，普通常用的就是阻塞和非阻塞的一些同步队列</p><h3 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>这样非阻塞也就明白了吧？<br>阻塞队列提供了四种处理方法：</p><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除方法</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><h3 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h3><p><strong>阻塞队列</strong>，当队列为空是取数据阻塞，队列满，插入数据阻塞<br><strong>线程安全的</strong>(批量操作不是) 是否是有界队列需要看具体的实现<br>常用的实现类有：</p><ul><li>ArrayBlockingQueue<br>规定大小的 BlockingQueue,其构造函数<strong>必须</strong>带一个 int 参数来指明其大小.<br>其所含的对象是以FIFO(先入先出)顺序排序的</li><li><strong>LinkedBlockingQueue</strong><br>大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定.<br>其所含的对象是以 FIFO (先入先出)顺序排序的<br><strong>是作为生产者消费者的首选</strong></li><li>SynchronousQueue<br>特殊的 BlockingQueue，对其的操作必须是放和取交替完成的</li><li>PriorityBlockingQueue<br>类似于 LinkedBlockQueue，但其所含对象的排序<strong>不是 FIFO</strong>，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序</li></ul><p>至于它是如何实现同步的，两个 ReentrantLock 读和写。</p><h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><p>不是按照先进先出的顺序，是按照优先级（Comparator 定义或者默认顺序,数字、字典顺序）<br>每次从队列中取出的是具有最高优先权的元素<br>内部通过堆排序实现 transient Object[] queue; 每次新增删除的时候，调整堆</p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>非阻塞队列一般就直接实现自 Queue 了，特点就不说了，对比上面的阻塞队列就行了，下面说说常见的非阻塞队列：<br><strong>ConcurrentLinkedQueue</strong><br>虽然是非阻塞，但也是线程安全的，按照 FIFO 来进行排序，采用CAS操作，来保证元素的一致性</p><blockquote><p>非阻塞算法通过使用低层次的并发原语，比如比较交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。<br>关键字：CAS<br><strong>线程安全就是说多线程访问同一代码，不会产生不确定的结果</strong></p></blockquote><p>ConcurrentLinkedQueue 的 <code>size()</code> 是要遍历一遍集合的，所以尽量要避免用 size 而改用 <code>isEmpty()</code>，以免性能过慢。</p><h3 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h3><p>一般情况下，操作队列不推荐使用 add 和 remove ，因为如果队列为空它就会抛异常；常使用的是 <strong>offer</strong> 和 <strong>poll</strong> 来添加和取出元素，如果此队列为空，则返回 null，如果使用 peek 取出元素则不会移除此元素，对于阻塞的队列，可以使用 put 和 take 来插入和获取。<br>带有 Deque 的一般是双端队列，不细说，我用的起码是非常少的<br>关于遍历队列如果使用 foreach 的方式相当于仅仅是 peek，也就是不会移除元素，如果需要遍历队列并且是取出，那么可以搭配 where 来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历队列</span></span><br><span class="line">  Order order;</span><br><span class="line">  <span class="keyword">while</span> ((order = queue.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    rechargeOrder(order);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个过程注意 size，如果一边放一边遍历的话是没有尽头的</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>同样视频里是没有提到的，只是讲了多线程的一些使用和注意事项，对于线程池，提及的很少，也许是因为 JavaEE 中并不常用，都是交给 Web 应用服务器来维护。<br>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，和连接池是一个道理。<br>Java 中的线程池，最核心的就是 <strong>ThreadPoolExecutor</strong> 了<br>ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br>下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小<br>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。<br>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数<br>这个参数也是一个非常重要的参数，<strong>它表示在线程池中最多能创建多少个线程</strong>；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。<br>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize，即当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize。<br>但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 corePoolSize 时， keepAliveTime 参数也会起作用，直到线程池中的线程数为 0；</li><li>unit：参数 keepAliveTime 的时间单位<br>有7种取值，比如天、时、分、秒、毫秒等</li><li><strong>workQueue：一个阻塞队列，用来存储等待执行的任务</strong><br>这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;<br>LinkedBlockingQueue;<br>SynchronousQueue;<br>ArrayBlockingQueue 和 PriorityBlockingQueue 使用较少，<strong>一般使用 LinkedBlockingQueue 和 Synchronous</strong>。<br>线程池的排队策略与 BlockingQueue 有关。</li><li>threadFactory：线程工厂，主要用来创建线程；</li><li>handler：表示当拒绝处理任务时的策略<br>有以下四种取值：<br>ThreadPoolExecutor.AbortPolicy ：丢弃任务并抛出 RejectedExecutionException 异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><p>上面仅仅是对构造方法参数的一些介绍，相关的几个类或者接口就是 ThreadPoolExecutor、AbstractExecutorService、ExecutorService 和 Executor，名字越短越抽象，最后的 Executor 为顶级接口</p><h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p>下面来了解下关于线程池中定义的几个方法：</p><ul><li>execute()方法<br>实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li><li>submit()方法<br>在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute() 方法不同，<strong>它能够返回任务执行的结果</strong>，去看 submit() 方法的实现，会发现它<strong>实际上还是调用的 execute() 方法</strong>，只不过它利用了 Future 来获取任务执行结果</li><li>shutdown() 和 shutdownNow() 是用来关闭线程池的。</li></ul><p>其他的方法还有 getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount() 等获取与线程池相关属性的方法，详细介绍去看 API 吧</p><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>当创建线程池后，初始时，线程池处于 <strong>RUNNING</strong> 状态；<br>如果调用了 <code>shutdown()</code> 方法，则线程池处于 <strong>SHUTDOWN</strong> 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果调用了 <code>shutdownNow()</code> 方法，则线程池处于 <strong>STOP</strong> 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于 <strong>SHUTDOWN</strong> 或 <strong>STOP</strong> 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 <strong>TERMINATED</strong> 状态。</p><h3 id="线程池的创建-amp-使用"><a href="#线程池的创建-amp-使用" class="headerlink" title="线程池的创建&amp;使用"></a>线程池的创建&amp;使用</h3><p>先来看一个简单使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                         <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">      MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">      executor.execute(myTask);</span><br><span class="line">      System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                         executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 java doc中，并不提倡我们直接使用 ThreadPoolExecutor，而是使用 Executors 类中提供的几个静态方法来创建线程池：</p><ul><li>Executors.newCachedThreadPool();<br>创建一个缓冲池，缓冲池容量大小为 Integer.MAX_VALUE</li><li>Executors.newSingleThreadExecutor();<br>创建容量为 1 的缓冲池</li><li>Executors.newFixedThreadPool(int);<br>创建固定容量大小的缓冲池</li></ul><p>看一下他们三个的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。<br><strong>newFixedThreadPool</strong> 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；<strong>newSingleThreadExecutor</strong> 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；<strong>newCachedThreadPool</strong> 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。</p><h3 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h3><p>一般需要根据任务的类型来配置线程池大小，当然也是仅供参考：<br>如果是 CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU+1<br>如果是 IO 密集型任务，参考值可以设置为 2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>一提到定时任务，首先想到的是使用 Timer，但是使用 Timer 执行周期性任务时，出现异常后自动退出（全部）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。<br>是的，这也是一个线程池，只不过它支持周期任务而已，看到这里对线程池应该也有所了解了，所以定时任务也就不难了</p><p><img src="/image/dev/线程池.png" alt="线程池.png"></p><p>它继承的 ThreadPoolExecutor 那些就不说了，来看看它特有的几个方法：</p><ul><li><strong>Schedule(Runnable command, long delay, TimeUnit unit)</strong><br>elay 指定的时间后，执行指定的 Runnable 任务，可以通过返回的 <code>ScheduledFuture&lt;?&gt;</code> 与该任务进行交互</li><li><strong>schedule(Callable\<v\> callable, long delay, TimeUnit unit)</v\></strong><br><em>delay</em> 指定的时间后，执行指定的 <code>Callable&lt;V&gt;</code> 任务，可以通过返回的 <code>ScheduledFuture&lt;V&gt;</code> 与该任务进行交互。</li><li><strong>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按周期 <em>period</em> 执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，那么第一次执行任务的时间点为 <code>initialDelay</code>，第二次为 <code>initialDelay + period</code>，第三次为 <code>initialDelay + period + period</code>，以此类推。</li><li><strong>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按指定的 <em>delay</em> 延期性的执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，每次任务需要耗时 <code>T(i)</code>（<strong>i</strong> 为第几次执行任务），那么第一次执行任务的时间点为 <code>initialDelay</code>，第一次完成任务的时间点为 <code>initialDelay + T(1)</code>，则第二次执行任务的时间点为 <code>initialDelay + T(1) + delay</code>；第二次完成任务的时间点为 <code>initialDelay + (T(1) + delay) + T(2)</code>，所以第三次执行任务的时间点为 <code>initialDelay + T(1) + delay + T(2) + delay</code>，以此类推。</li></ul><p>简单解释下 scheduleAtFixedRate 和 scheduleWithFixedDelay，前者会开始执行为起始点，如果任务耗时超过了间隔时间，那么在任务完成候第二次会很快（<del>马上</del>）执行，而后者会等待任务执行完后才开始计算周期间隔时间。<br>创建线程池的方式也与上面差不多，都有对应的方法：<br><strong>Executors.newScheduledThreadPool(int corePoolSize)</strong><br><strong>Executors.newSingleThreadScheduledExecutor()</strong></p><p>Apache 的 BasicThreadFactory 或许会更好….待进一步研究</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><code>ScheduledFuture</code> 接口 继承自 <code>Future</code> 接口，所以 <code>ScheduledFuture</code> 和任务的交互方式与 <code>Future</code> 一致。所以通过<code>ScheduledFuture</code>，可以 判断定时任务是否已经完成，获得定时任务的返回值，或者取消任务等<br>关于 <code>Future</code> 后面应该会再进行补充<br>可以先看一下：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">这篇文章</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这个很简单，没什么好说的，简单说就是构造函数的私有化，然后定义一个本类类型的静态变量，通过静态方法进行提供<br>需要注意的是，静态变量的初始化时机，比较一致的观点是：如果你确定这个类肯定要用，那么可以在定义静态变量的时候就直接进行实例化，否则可以放在静态方法中进行实例化（这样会有线程安全问题）比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton is = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是获取的时候实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">    is = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，单例模式需要注意的也就是这里了：<strong>线程安全问题</strong><br>如果你选择了在静态方法中进行实例化，并且使用了多线程技术，那么极有可能它并不是单例的；原因我想大概都知道，当然也有相应的解决方案，一般就从这三种中进行选择：</p><ul><li><p>同步方法<br>这是最简单的方式，如果不考虑性能的情况下是可以使用的，使用同步就意味着可能造成执行效率下降100倍<br><code>public static synchronized getInstance(){}</code></p></li><li><p>急切实例化<br>这个就是上面的第一种方式，在定义的时候就直接实例化<br>在创建运行时负担不重的情况下可以采用</p></li><li><p>双重检查加锁<br>在同步方法中我们发现，其实只需要第一次加锁就可以了，因为第一次创建出 is 后后面都是直接返回的<br>所以，可以进行下面的优化（java5+）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton is;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Test&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">          is = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以大大减少 get 方法的时间消耗，如果确实不考虑性能，使用这个就有点大材小用了。</p><blockquote><p>这个方法表面上看起来很完美，你只需要付出一次同步块的开销，但它依然有问题。<br>除非你声明 is 变量时使用了 volatile 关键字。没有 volatile 修饰符，可能出现 Java 中的另一个线程看到个初始化了一半的 is 的情况，但使用了 volatile 变量后，就能保证先行发生关系（happens-before relationship）<br>参考下面的：无序写入</p></blockquote></li><li><p>静态内部类<br>这也是一种懒汉式的实现，相比双重锁检查，更简单，更高效吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonIniti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonIniti</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonIniti INSTANCE = newSingletonIniti();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonIniti <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>并且外部类可以访问内部类的 private 方法。</p></li></ul><p>单例模式的使用情景并不是太多，并且如果程序有多个类加载器，还是会造成有多个实例的情况，所以如果用到了多个类加载器记得指定使用同一个类加载器</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>关于这个，确实不太常见，很多人以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。<br>Java 语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制。</p><p>对于 synchronized 我们都知道：<br>通过 synchronized 关键字来实现，所有加上 synchronized 和块语句，在多线程访问的时候，同一时刻只能有一个线程能够用 synchronized 修饰的方法 或者 代码块。<br><strong>用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。</strong></p><blockquote><p>在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是 jvm 虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候<strong>变量值信息</strong>。<br>当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值 load 到线程本地内存中，建立一个变量副本，<strong>之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值</strong>，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。<br>这样在堆中的对象的值就产生变化了。</p><p>原文：<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p></blockquote><p>从上面的解释也可以看出 volatile 并不能保证原子性，它的作用就是在每次<strong>使用的时候</strong>获取最新的值</p><h2 id="无序写入"><a href="#无序写入" class="headerlink" title="无序写入"></a>无序写入</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong><br><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong><br>关键原因就是： <code>instance = new Singleton();</code> 不是原子操作。<br>然后从两个方面来看原因：</p><ul><li>有序性：是因为 instance = new Singleton(); 不是原子操作。编译器存在指令重排，从而存在线程1 创建实例后（初始化未完成），线程2 判断对象不为空，但实际对象扔为空，造成错误。</li><li>可见性：是因为线程1 创建实例后还只存在自己线程的工作内存，未更新到主存。线程 2 判断对象为空，创建实例，从而存在多实例错误。</li></ul><p>也就是，要想保证安全，必须保证这句代码的有序性和可见性。<br><strong>volatile 对 singleton 的创建过程的重要性：禁止指令重排序（有序性）。</strong><br>实例化一个对象其实可以分为三个步骤：</p><ol><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ol><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p><ol><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ol><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。<br>因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量，volatile 的禁止重排序保证了操作的有序性。<br>除了这种方案，还有人提出在“构造对象”和“连接引用与实例”之间加上一道内存屏障来保证有序性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//构造与赋值之间随意做点事情保证顺序</span></span><br><span class="line">temp.toString();</span><br><span class="line">instance=temp;</span><br></pre></td></tr></table></figure><p>这想法确实 nice~</p><hr><p>关于可见性，第二次非 null 判断是在加锁以后（也就是说后面的线程在获取锁以后判断 instance 是否为 null 必然是在第一个线程引用赋值完成释放锁以后），则根据这一条，另一个线程一定能看到这个引用被赋值。所以即使没有 volatile，依旧能保证可见性。</p><p><a href="https://www.zhihu.com/question/56606703" target="_blank" rel="noopener">https://www.zhihu.com/question/56606703</a></p><p>PS：据说因为 JVM 的实现不同，volatile 未必能保证绝对的安全，在 HotSpot 应该是没问题的。</p><h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-blocking-queue</a><br><a href="http://blog.csdn.net/xiaohulunb/article/details/38932923" target="_blank" rel="noopener">http://blog.csdn.net/xiaohulunb/article/details/38932923</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a><br><a href="https://segmentfault.com/a/1190000008038848" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008038848</a><br><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">https://blog.csdn.net/chenchaofuck1/article/details/51702129</a><br>拓展：<br><a href="http://www.jianshu.com/p/925dba9f5969" target="_blank" rel="noopener">http://www.jianshu.com/p/925dba9f5969</a><br><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。&lt;br&gt;这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
      <category term="线程池" scheme="http://bfchengnuo.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE二周目计划</title>
    <link href="http://bfchengnuo.com/2017/11/28/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92/"/>
    <id>http://bfchengnuo.com/2017/11/28/JavaSE二周目计划/</id>
    <published>2017-11-28T13:15:45.000Z</published>
    <updated>2019-03-19T03:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>基础不能落下，习惯使用框架后基本功都忘得差不多，是时候复习一波了，跳着看的，重点放在多线程、IO、Socket 上；<br>这一篇是个开头，也正好以前学 SE 的时候还没搭博客所以也没 md 笔记，这次就顺便补上；<br>开头算是个补充，泛型、动态代理、悲观锁/乐观锁的小补充，后面是复习系列的多线程和 IO<br><a id="more"></a></p><h2 id="关于泛型"><a href="#关于泛型" class="headerlink" title="关于泛型"></a>关于泛型</h2><p>泛型还算是很简单的，稍微提一提，用的也很广泛，泛型可以用在方法上也可以用在类上，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用在类上，使用时最好是显式指定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// T stands for "Type"</span></span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">      p1.getValue().equals(p2.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> K key;</span><br><span class="line">  <span class="keyword">private</span> V value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JDK1.7+ 后会自动根据 type inference 进行推导，所以说在调用方法是是可以不写泛型的<br>泛型的定义一般是在类名的后面，或者方法返回值之前，有了泛型，省去了很多的强转，在编译阶段就能发现错误<br>然后说一下比较重要的，泛型的上限和下限：</p><ul><li>上限（<code>&lt;? extends E&gt;</code>）<br>说明传入的可以是 E 或者 E 的子类</li><li>下限（<code>&lt;? super E&gt;</code>）<br>说明传入的值可以是 E 或者 E 的父类</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在 C++ 中采用的方案是当实例化一个泛型会生成一个新类，例如模板类是 List ，然后你用 int ,double,string, Employee 分别去实例化， 那编译的时候，我们就会生成四个新类出来，例如List_int和List_double，List_string, List_Employee。</p><p>而在 Java 中采用的是擦除法，简单来说就是一个参数化的类型经过擦除后会去除参数， 例如 <code>ArrayList&lt;T&gt;</code>  会被擦除为 ArrayList ，既然这样类中使用的泛型怎么办，擦除了岂不是消失了？<br>最终其实泛型都会被替换为 Object，然后还有一个问题，比如 <code>Integer i = list1.get(0);</code> 现在类型被擦除，返回值变成 Object 了， 怎么处理啊？很简单，只需要在编译的时候做点手脚来个强转就行了，因为可以保证类型一致，否则也不会通过编译检测：<code>Integer i = (Integer)list1.get(0);</code></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java 中的两大类型：基本数据类型和引用数据类型，这个很熟悉都知道，在之前的 <a href="https://bfchengnuo.com/2016/09/25/Java%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98/">Java复习之内存</a> 也说的比较清晰了，但是还有一些小的知识点漏掉了，现在就来补上<br>都知道字符串、数组、自定对象之类的都是引用数据类型，会存储在堆内存中，默认会进行初始化，能够赋为 null，我想要说的是，基本数据类型也有可能放在堆中，也会进行初始化，那就是当它被定义为全局变量的时候，所以你能在定义全局变量的时候写：<code>int a;</code> 默认为 0，而在方法内定义时必须要这样写：<code>int a = 0;</code> 给它一个初始值，<strong>但是不能设置为 null</strong>。</p><h2 id="动态代理-amp-ASM"><a href="#动态代理-amp-ASM" class="headerlink" title="动态代理&amp;ASM"></a>动态代理&amp;ASM</h2><p>关于什么是动态代理、如何使用在前面的 Spring 文章和 Java 知识补充中已经说的很详细了，这里来补充一波没提到（写的好分散，忍忍吧，<del>有时间再整理到一起</del>）<br>官方的动态代理基于接口实现（通过反射）<br>CGLib（<strong>Code Generation Library</strong>）采用的是继承的方式实现，CGLIb 为了提高性能，还用了一种叫做FastClass 的方式来直接调用一个对象的方法，而不是通过反射。</p><hr><p>ASM 虽然很低调，但它确实很厉害，Spring , hibernate 的核心都是基于它来实现的，更不要说 AOP 了，以及上面的 CGLib 也是基于 ASM，那么它到底是什么呢？</p><blockquote><p>它可以动态的<strong>修改已经编译过的 class , 还可以动态的生成新的 java class</strong>,  注意我说的动态这个词， 那可以是完全在运行时， 在内存中完成的， 这是一件非常厉害的本事。</p><p>并不是仅仅像 jsp 那样， 使用 JavaComplier 接口在运行时动态的编译一个 java 源代码</p></blockquote><p>名字的由来：<br>C语言中的 <code>__asm__</code> 这个关键字， 可以允许你们在 C 语言中写点汇编，  他就把 ASM 这个关键字挪用了<br>需要注意的是，想使用 ASM 需要非常透彻的理解 Java 虚拟机指令和 Java 虚拟机内部结构，我们常用的 Spring、CGLib 都是进行了高级的封装使用起来更加友好。<br>有很多的语言是利用 ASM 来动态的生成字节码（解释性语言），跑在 JVM 的虚拟机上</p><p>官方提供的文档：<a href="http://download.forge.objectweb.org/asm/asm4-guide.pdf" target="_blank" rel="noopener">http://download.forge.objectweb.org/asm/asm4-guide.pdf</a> </p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>应该是和数据库相关了，但是多少有点联系，也找不到合适的地方就写在这里吧<br><strong>悲观锁：</strong><br>总认为数据会被别人修改，所以就总是给数据加锁，如果持有锁的时间过长，那么用户等待的时间也就越长<br><strong>乐观锁：</strong><br>本质其实是不加锁，但是会在字段的旁边加一个版本记录，读取时获取数值和版本，写入时先检查版本是否一致，如果不一致就重新获取重新计算；<br>这样的话如果冲突很多数据库争用激烈会导致不断的进行重试，反而降低了性能</p><p>Java 中的 Sychronized 可以看作是悲观，CAS（Compare and Swap） 操作可以看作是乐观。<code>java.util.concurrent</code> 包中借助 CAS 实现了区别于 synchronouse 同步锁的一种乐观锁<br>关于 CAS 其实还是蛮复杂的，不在深究，等以后如果用到了再看吧，这里给个网址和一点介绍吧</p><blockquote><p>目前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。<br>CAS 有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做并返回 false。</p><p><a href="http://ifeve.com/compare-and-swap/" target="_blank" rel="noopener">http://ifeve.com/compare-and-swap/</a></p></blockquote><h2 id="匿名内部类-amp-继承"><a href="#匿名内部类-amp-继承" class="headerlink" title="匿名内部类&amp;继承"></a>匿名内部类&amp;继承</h2><p>要使用匿名内部类需要有一个前提条件：<strong>继承某个类或者实现某个接口</strong><br>形式就是在需要某个类对象的时候直接 new 它的父类或者接口，然后去实现或者覆盖某些方法，并且一般需要实现的方法不会超过三个，否则阅读性极差，在回调机制中的用的较多，Android 上应该也有大量使用。<br>特殊的，因为所有的类都继承 object，所以甚至可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"haha"</span>);&#125;</span><br><span class="line">&#125;.show();</span><br></pre></td></tr></table></figure><p>但是不能定义一个 Obj 类型的变量去接收（这就相当于隐式的向上转型了），这样里面的方法就没法调了</p><hr><p>现在我知道了 JVM 在创建子类的时候首先会创建一个父类对象，并且放在子类对象的堆空间里（就是说是子对象的一部分）<br>然后在内存的方法区（分为静态方法区和非静态方法区），将 this 和 super 放在子对象拥有的空间里（和方法在一起），super 指向的就是父对象。<br>父类的 private 方法不能称之为覆盖，因为子类压根不知道有这个方法，称为覆盖不是很合适，就当做是子类的一个普通方法就行了，还有就是构造方法不能覆盖（构造方法和本类名一样，怎么可能覆盖 XD）<br>因为子类在创建时需要先创建父类，如果父类没有空的构造函数，需要在子类的构造函数中的<strong>第一行</strong>手动用 super 指定调用那个构造函数，也能看出一个规律： <strong>this() 和 super() 必须放在第一行</strong></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>先来说说线程的几种状态（还可细分，那就需要 JVM 的知识了）：<strong>创建 、 运行 、 阻塞 、 冻结（睡眠、等待）、 消亡</strong><br>说明一下，阻塞状态是拥有执行资格但是没有执行权；冻结是没有执行资格，也自然没有执行权；运行状态是有执行资格也有执行权（当前正在运行）。</p><p>然后就是重要的线程安全问题了，同步函数（函数上加 synchronized）默认使用的锁是 this，但是当函数被静态修饰的时候使用的不再是 this（这时内存中没有本类对象只有本类的字节码对象），用的是 <code>className.class</code> 字节码对象（相当于是某个类的 class 对象，也就是字节码对象），当其他地方需要用这把锁的时候就需要传入 XX.class 了。<br>在单例模式中的懒汉式，如果使用多线程访问就会存在安全性，但是如果将 get 方法加锁会变的低效，比较好的做法就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例对象必须是 volatile 修饰的，保证在多核处理器安全运行</span></span><br><span class="line"><span class="comment">// 详细的原因可参考 二周目计划（二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XX <span class="title">getXX</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xxx == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(XX.class)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xxx == <span class="keyword">null</span>)&#123;</span><br><span class="line">        xxx = <span class="keyword">new</span> XX();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 get 方法一般是静态的，所以我们使用本类的字节码对象作为锁，并且做双重判断来解决线程安全和同步函数低效的问题，一般还是用饿汉式吧，简单方便；一般来说如果你确定这个对象一定会用到那就肯定用饿汉式</p><p>死锁的出现一般是同步的嵌套，但是用的锁（顺序）不同的情况下，并且死锁并不一定会出现，万一和谐了呢….<br>只要是多个线程在处理同一个资源一般就需要进行加锁，不管这几个线程是不是在一个类中，并且还要保证锁是相同的，这才是线程安全的前提。<br>多个线程在操作共享数据的时候（并且是执行同一个方法）可以采用一个标志位来做等待唤醒机制，达到生产者生产一个，消费者消费一个，即使生产者和消费者有多个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">this</span>.wait();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name + count++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">this</span>.wait();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r;</span><br><span class="line">  Producer(Resource r)&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      r.set(<span class="string">"烤鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r;</span><br><span class="line">  Consumer(Resource r)&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      r.out();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">    Producer pro = <span class="keyword">new</span> Producer(r);</span><br><span class="line">    Consumer con = <span class="keyword">new</span> Consumer(r);</span><br><span class="line"></span><br><span class="line">    Thread t0 = <span class="keyword">new</span> Thread(pro);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(pro);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(con);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(con);</span><br><span class="line">    t0.start();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 set 和 out 方法上加 synchronized 是为了保证不会出现生产一个消费两次，或者生产两个消费一次的情况。<br>就是说多个线程要参与同一件事就需要在 wait 之前循环判断标记（where，不能用 if），防止某个线程唤醒后直接往下走（此时另一个线程已经重新修改了标记）。<br>但是循环判断标记带来的另一个问题就是可能所有的线程都会一直处于 wait 状态（消费者唤醒的是消费者这种情况），就会出现和死锁差不多的情况，所以要使用 notifyAll。</p><p>补充：<code>wait()</code>  、 <code>notify()</code> 这两个方法定义在 Obj 中，<strong>只有锁才能调用这两个方法</strong>，因为任何对象都可以是锁，所以这两个方法就只能定义在 object 中了吧</p><h3 id="使用Locks"><a href="#使用Locks" class="headerlink" title="使用Locks"></a>使用Locks</h3><p>上面的是曾经的写法，在 JDK1.5+ 后出现了新的工具，所以说 1.5 真是里程碑式的升级，新的工具在 <code>java.util.concurrent.locks</code> 包下，最重要的就是 Lock 替代了 synchronized 的使用，Condition 替代了 Object 监视器（wait 、notufy）的使用.</p><blockquote><p>JDK1.5 以后将同步和锁封装成了对象，并将操作锁的隐式方式定义到了该对象中，<strong>将隐式动作变成了显示动作</strong>。<br><strong>Lock 接口：</strong> 替代了同步代码块或者同步函数。将同步的隐式锁操作变成现实锁操作。同时更为灵活。可以<strong>一个锁上加上多组监视器</strong>。<br>lock(): 获取锁。<br>unlock(): 释放锁，通常需要定义 finally 代码块中。<br><strong>Condition接口：</strong>出现替代了 Object 中的 wait 、 notify 、 notifyAll 方法。将这些监视器方法单独进行了封装，变成 Condition 监视器对象。可以与任意锁进行组合。<br>await();<br>signal();<br>signalAll();</p></blockquote><p>使用新特性改造代码，关键是可以绑定多个监视器，就可以指定唤醒对方的某个线程而不是全部唤醒了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 获取锁</span></span><br><span class="line">  <span class="comment">//通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。</span></span><br><span class="line">  Condition producer_con = lock.newCondition();</span><br><span class="line">  Condition consumer_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)</span><br><span class="line">        <span class="keyword">try</span>&#123;producer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.name = name + count++;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者5.0..."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">      flag = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 唤醒对方</span></span><br><span class="line">      consumer_con.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!flag)</span><br><span class="line">        <span class="keyword">try</span>&#123;cousumer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者.5.0......."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 唤醒对方</span></span><br><span class="line">      producer_con.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可能感觉写法上麻烦了一些，但是这样确实是更清晰了</p><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>真正的让线程停下来只有一种方法，那就是 run 方法结束，我们写的 run  方法一般都是循环结构，所以只要控制住循环就能让线程停下来。<br>特殊情况下，线程处于冻结状态（wait 或 sleep）然后没人唤醒的情况下怎么办，不能一直挂在这啊，Thread 类有个方法叫 <strong>interrupt</strong> 方法，作用就是强制唤醒冻结状态的线程，毕竟是强制，所以同时会抛出一个 InterruptedException 异常.<br>可以认为，只要出现了这个异常就说名有人在调用 interrupt 方法，也就是有人想让它停下来，所以直接在 catch  里让自己停下来就行了，比如修改标志</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>简单介绍下什么是守护线程，守护线程在一般情况和用户线程没啥区别，都是在和主线程争夺 CPU ，关键是在结束的时候， <strong>当主线程结束时，守护线程会自动结束，不管有没有执行完</strong> ，有点像依赖关系。<br>设置一个线程为守护线程的方式为（必须要在 start 方法调用之前执行）：<code>t.setDaemon(true)</code> 然后 start 就可以了，然后当程序的线程全是守护线程时，JVM 会自动退出。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>介绍些其他的方法，线程方法还有个 join 方法，作用可以理解为抢夺 CPU 的执行权，例如在主线程执行到了 <code>t1.join();</code> 那么主线程会把执行权让给 t1 ，自己进入<strong>冻结</strong>状态，当 t1 执行完后再恢复执行。<br>设置优先级是：<code>t.setPriority(Thread.MAX_PRIORITY);</code> 优先级就 1-10，其中最明显的 1、5、10 都有常量定义，阅读性好些。<br>当线程执行到 <code>Thread.yield();</code> 时，会自动的交出执行权。</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>JavaSE 中重要的一环，现在来复习一下，总体上可分为两类，字节流和字符流<br>字节流的两个基类：InputStream 和 OutputStream<br>字符流的两个基类：Reader 和 Writer<br><strong>它们都是抽象的</strong>，然后一个一个来看。</p><hr><p>然后除了上面的两大类，还有个桥梁，转换流，如果只有字节流的话就不需要转换了，所以转换流的体系是在字符流中，主要是：InputStreamReader 和 OutputStreamWriter；使用非常的简单，一般直接是扔进字符流的缓冲区包装类就行了，Bufr/Bufw 就都会用了。<br>最佳的测试方法就是用标准输入输出流了，System.in / System.out 它们都属于字节流，为了便于操作一般都将其转换为字符流，这样就用上上面的两个类了。<br>转换流还有一个好用的功能就是可以指定码表，这也许才是本体 2333</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>就以它的一个简单的孩子来看：FileWriter 对象，当它被 new 时会关联一个文件，此时文件会自动创建，如果存在会被覆盖，可通过其他的重载形式传入一个 Boolean（true） 来使用追加模式。<br>为了提高效率，一般都是用缓冲区，Java 提供了两个类来支持缓冲：BufferedWriter、BufferedReader<br>命名也是很有意思的，一般前面是功能描述，后面是所属的类别，比如上面的就是缓冲+字符流，大体就能知道是做什么的了。bufr 最爽的就是能一次读一行了（<strong>返回结果中不包含换行符</strong> ，原理是用数组做缓存，还是一个个读，都存到数组中，遇到回车标记返回整个数组的数据），用的很频繁。<br>调用缓冲区的 close 方法就不需要调用 FileWriter 的 close ，本质上它们是一样的，真正操作文件的还是 fw。<br>缓冲功能的设计其实就是使用了装饰模式，对已有对象的功能进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String data = <span class="string">"xxxxxxxxxxxxx我是数据"</span>;</span><br><span class="line">  FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// true 代表以追加的形式写入，也可以使用一个参数的构造方法（不使用追加）</span></span><br><span class="line">    <span class="comment">// 如果文件不存在此方法会自动创建文件</span></span><br><span class="line">    fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">    fw.write(data);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个读取</span></span><br><span class="line">    <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// 自动查码表</span></span><br><span class="line">      System.out.print((<span class="keyword">char</span>)ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用缓冲区</span></span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">      System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JAVA提供的缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterFileBufr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">    BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      bufw.write(<span class="string">"test + "</span> + i);</span><br><span class="line">      <span class="comment">// 根据系统插入相应的换行</span></span><br><span class="line">      bufw.newLine();</span><br><span class="line">      bufw.flush();  <span class="comment">// 使用缓冲区，记得刷新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadFileBufr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">"tesst.txt"</span>);</span><br><span class="line">    BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">    String len;</span><br><span class="line">    <span class="keyword">while</span> ((len = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并不会读取换行符，所以需要手动换行</span></span><br><span class="line">      System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的仅供参考，最基本的 IO 读写文件的写法吧，使用字符流最后记得调用 flush 刷进去，因为它内部必定是有一小块缓存的，保证至少读完一个字符才写（不同的编码所占的空间不同，底层还是使用字节流来读取），并不是都一个写一个，大体就是这么个意思。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>看过字符流后字节流也基本一致，API 高度相似，最大的区别就是字节流的缓冲数组是 byte 数组，字符流是 char 数组，原因也很好理解<br>单纯使用字节流写入并不需要刷新，字符流中一个中文字符是两个字节（编码不同而不同），所以他必须得先存起来（一个非常小的缓存吧），所以最后需要刷新，字节流没这个问题，可以直接写，毕竟字符流的底层也是用的字节流。<br>下面主要说说字节流缓冲区的使用，其他的和上面基本一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BufferedInputStream bufis = <span class="keyword">null</span>;</span><br><span class="line">  BufferedOutputStream bufos = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    bufis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">    bufos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 先把文件的部分内容读到缓冲区（字节数组），再从缓冲区一个一个的读</span></span><br><span class="line">    <span class="keyword">while</span> ((len = bufis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      bufos.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufis != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bufis.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bufos != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bufos.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于缓冲区的实现原理，大概的代码可以参考：<a href="https://github.com/bfchengnuo/java_learn" target="_blank" rel="noopener">我的Github</a></p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>class 前面没有加任何的访问修饰符，通常称为“默认访问模式”（<strong>default</strong> ），在该模式下，这个类只能被同一个包中的类访问或引用，这一访问特性又称包访问性。<br>一个 .java 文件可以有多个类，但是只能有一个 public 类, 而且如果有 public 类的话，这个文件的名字要和这个类的名字一样，编译的时候会分开生成多个 class 文件</p><p>关于 IO，Java 中有一个 Properties 对象，利用它可以获取系统的“环境变量”，我想表达的就是可以看平台的默认文件编码集设置的是什么，一般中文系统默认是 GBK，所以要想输出其他编码格式的文件不能用 <em>FileWriter</em>，用转换流进行转换才行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = System.getProperties();</span><br><span class="line">prop.list(System.out);</span><br><span class="line"><span class="comment">// new PrintStream("a.txt");</span></span><br></pre></td></tr></table></figure><p>在处理异常的时候的那个对象也和 IO 有点关系，可以看看它的 API，封装的还是挺方便的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础不能落下，习惯使用框架后基本功都忘得差不多，是时候复习一波了，跳着看的，重点放在多线程、IO、Socket 上；&lt;br&gt;这一篇是个开头，也正好以前学 SE 的时候还没搭博客所以也没 md 笔记，这次就顺便补上；&lt;br&gt;开头算是个补充，泛型、动态代理、悲观锁/乐观锁的小补充，后面是复习系列的多线程和 IO&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://bfchengnuo.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://bfchengnuo.com/tags/Java/"/>
    
  </entry>
  
</feed>
