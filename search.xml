<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ECMAScript常用语法整理]]></title>
      <url>http://bfchengnuo.com/2019/09/14/ECMAScript%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>首先集百家之介绍：</p>
<blockquote>
<p>ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMA-262 标准的实现和扩展。</p>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
</blockquote>
<p>目前 ES 已经到达了 ES2018 版本，Google 的 V8 引擎支持率 100%，其他的并不友好，而我们常用 <strong>JavaScript</strong> 稳定版本的实现目前在 ES2016 版本，所以这里主要学习 ES6 的特性了。<a id="more"></a><br>如果真的有什么原因不能使用 ES6 可以使用 Babel 将 ES6 语法转为 ES5.<br>我会把实际中频繁用到的一些特性写出来，致力于用最优雅的写法写出更高质量的代码。</p>
<h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><p>使用 <code>let</code> 声明的变量只在它所在的代码块内有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6，使用 var 则都是 10</span></span><br></pre></td></tr></table></figure>
<p>例如 for 循环就合适使用 let 定义 i</p>
<blockquote>
<p><code>for</code> 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
</blockquote>
<p><code>var</code> 命令会发生“<strong>变量提升</strong>”现象，<strong>即变量可以在声明之前使用</strong>，值为 <code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，<code>let</code> 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<blockquote>
<p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p>
</blockquote>
<p>总之，在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ），不过应该提倡能用 let 的时候尽量别用 var，避免造成作用域的混乱。</p>
<hr>
<p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。<br>这意味着，<code>const</code> 一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效，不提升、存在暂时性死区。</p>
<blockquote>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 ES6 中，对字符串进行了增强，尤其是模板字符串，真是非常的好用！</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义<strong>多行字符串</strong>，或者在字符串中<strong>嵌入变量</strong>或者调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串之中还能调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>
<p>如果模板字符串中的变量没有声明，将报错。如果大括号中的值不是字符串，将按照一般的规则（toString）转为字符串。</p>
<h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>ES5 字符串的实例方法很有限，基本就是 indexOf 了，在 ES6 新加入了一些：</p>
<ul>
<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>
<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
<li>repeat()：返回一个新字符串，表示将原字符串重复 n 次。</li>
</ul>
<p>在 ES2017 和 ES2019 又引入了 <code>padStart()</code> 用于头部补全，<code>padEnd()</code> 用于尾部补全和 <code>trimStart()</code> 和 <code>trimEnd()</code> 这两个方法。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与解构赋值默认值结合使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有提供参数，函数 foo 的参数默认为一个空对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure>
<p>ES6 引入 rest 参数（形式为 <code>...变量名</code>），用于获取函数的多余参数，本质是个数组，跟 Java 很类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>其次还有函数的 <code>name</code> 属性，返回该函数的函数名。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>
<p>怎么说呢，这个其实就是简化的匿名函数，用在回调的地方非常好用。箭头函数有几个使用注意点。</p>
<ol>
<li>函数体内的 <code>this</code> 对象，就是<strong>定义时所在的对象</strong>，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li>
<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<p>其中第一点尤其值得注意。<code>this</code> 对象的指向是可变的，<strong>但是在箭头函数中，它是固定的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p>关于 this 的这个问题，版本对比为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不适用情况</span></span><br><span class="line"><span class="comment">// 对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。<br>在 Vue 很多使用中，如果你使用箭头函数就不需要再在尾部来一个 <code>.bind(this)</code> 了。</p>
<h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>使用 <code>JSON.stringify()</code> 方法可以将对象转为字符串类型的 json 格式。</p>
<hr>
<p>关于 apply 和 call ，ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。<br>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<br>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。<br>一般来说，<strong>它们的作用就是改变 this 的指向，或者借用别等对象的方法</strong>，那么它和 bind 什么区别呢？</p>
<blockquote>
<p>在 EcmaScript5 中扩展了叫 <code>bind</code> 的方法，在低版本的 IE 中不兼容。<br>它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。</p>
</blockquote>
<p>他们的主要区别就是：</p>
<p>bind 方法不会立即执行，而是<strong>返回一个改变了上下文 this 后的函数</strong>。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。<br>在参数传递上，也有一些区别，看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = func.bind(<span class="literal">null</span>,<span class="string">'linxin'</span>);</span><br><span class="line"></span><br><span class="line">func(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);            <span class="comment">// A B C</span></span><br><span class="line">func1(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);           <span class="comment">// linxin A B</span></span><br><span class="line">func1(<span class="string">'B'</span>, <span class="string">'C'</span>);                <span class="comment">// linxin B C</span></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="string">'linxin'</span>);      <span class="comment">// linxin undefined undefined</span></span><br></pre></td></tr></table></figure>
<p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是<strong>在 bind 中参数的基础上再往后排</strong>。</p>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>对于数组的克隆与合并，有了扩展运算符也变得简单多了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>
<p>ES5 中只能使用 concat 函数间接达到目的。<br>字符串也可以被展开：<code>[...&#39;hello&#39;]</code>，还可以用于 Generator 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>现在对象的属性有了更简洁的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单说就是<strong>当 key 和 val 一样时，可以进行简写</strong>。其实，方法也可以进行简写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法会非常的简洁，另外常用的还有 setter 和 getter，就是采用的这种方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的一点就是简洁写法的属性名总是字符串。在对象定义上，也变得更加灵活了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的<strong>原型对象</strong>。</p>
<hr>
<p>另外，对象也有扩展运算符，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ll = &#123;<span class="attr">name</span>:<span class="string">'loli'</span>, <span class="attr">age</span>: <span class="number">12</span>, getVal(val)&#123;<span class="built_in">console</span>.log(val)&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> test = &#123;...User, <span class="attr">dd</span>:<span class="string">'dd'</span>&#125;</span><br><span class="line">test.getVal(test.dd)</span><br></pre></td></tr></table></figure>
<p>简单说就是把对象里的方法进行拷贝，Vuex 中的这种写法算是明白了吧，Vuex 中，我们经常用类似 <code>...mapState({xxx})</code> 的写法，很显然 mapState 函数返回的是一个对象，然后我们使用“展开运算符”将其展开了。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>变量数组或者对象，可以使用 forEach 这个函数（ES5 中也可使用）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(alert);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(item)&#125;)</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 forEach 函数进行遍历时，中途无法跳过或者退出；<br>在 forEach 中的 return、break、continue 是无效的。</p>
<p>see：<a href="https://www.jianshu.com/p/bdf77ee23089" target="_blank" rel="noopener">https://www.jianshu.com/p/bdf77ee23089</a></p>
</blockquote>
<p>然后遍历除了基本的 fori，还有两种：<code>for...in</code> 和 <code>for...of</code> ，那么他们俩有啥区别呢？</p>
<ol>
<li>推荐在循环对象属性的时候，使用 <code>for...in</code>，在遍历数组的时候的时候使用 <code>for...of</code>。</li>
<li><code>for...in</code> 循环出的是 key，<code>for...of</code> 循环出的是 value</li>
<li>注意，<code>for...of</code> 是 ES6 新引入的特性。修复了 ES5 引入的 <code>for...in</code> 的不足</li>
<li><code>for...of</code> <strong>不能循环普通的对象</strong>，需要通过和 <code>Object.keys()</code> 搭配使用</li>
</ol>
<p>下面是一段示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArray = [<span class="string">'a'</span>,<span class="number">123</span>,&#123;<span class="attr">a</span>:<span class="string">'1'</span>,<span class="attr">b</span>:<span class="string">'2'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;aArray[index]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> aArray)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// &#123;a: "1", b: "2"&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 for...of 遍历 Map，它部署了 Iterator 接口</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>作用于数组的 <code>for-in</code> 循环除了遍历数组元素以外，还会遍历自定义属性。<br><code>for...of</code> 循环不会循环对象的 key，只会循环出数组的 value，因此 <code>for...of</code> 不能循环遍历<strong>普通对象</strong>，对普通对象的属性遍历推荐使用 <code>for...in</code></p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>某次，遇到一个做累加的需求，用传统的方式肯定是没问题，但是我想到既然是动态语言，就没有什么骚操作？<br>结果搜了一下，确实有很多骚操作，还有直接用 eval 黑魔法的，不过，我觉得比较优雅的就是 reduce 方法了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev + cur, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>总感觉似曾相识，不知道在哪里用过，也许是 J8 的 Lambda 吧，这样看来 reduce 可以做的东西就多了。</p>
<h2 id="forEach与map"><a href="#forEach与map" class="headerlink" title="forEach与map"></a>forEach与map</h2><p>MDN 上的描述：</p>
<blockquote>
<p><code>forEach()</code>：针对每一个元素执行提供的函数 (executes a provided function once for each array element)。</p>
<p><code>map()</code>：<strong>创建一个新的数组</strong>，其中每一个元素由调用数组中的每一个元素执行提供的函数得来 (creates a new array with the results of calling a provided function on every element in the calling array)。</p>
</blockquote>
<p><code>forEach</code> 方法不会返回执行结果，而是 <code>undefined</code>。也就是说，<code>forEach()</code> 会修改原来的数组。而 <code>map()</code> 方法会得到一个新的数组并返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组中的数据翻倍</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (arr[index] = num * <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doubled = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果都为： [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<p>如果你习惯使用函数是编程，那么肯定喜欢使用 <code>map()</code>。因为 <code>forEach()</code> 会改变原始的数组的值，而 <code>map()</code> 会返回一个全新的数组，原本的数组不受到影响。<br>总之，能用<code>forEach()</code>做到的，<code>map()</code>同样可以。反过来也是如此。<br>一般来说，使用 map 速度会更快，测试地址：<a href="https://jsperf.com/map-vs-foreach-speed-test" target="_blank" rel="noopener">https://jsperf.com/map-vs-foreach-speed-test</a></p>
<h2 id="Class语法"><a href="#Class语法" class="headerlink" title="Class语法"></a>Class语法</h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。<br>基本上，ES6 的 <code>class</code> 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>class</code> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于做静态语言后端的我，果然还是 ES6 的写法更舒服。</p>
<blockquote>
<p>定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
</blockquote>
<p>既然说 class 只是一个语法糖，那么我们就要深入一点看看了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************分割线********************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure>
<p>类的数据类型就是函数，类本身就指向构造函数。<br>构造函数的 <code>prototype</code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面。<br>类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致。<br>生成实例对象如果忘记加上 <code>new</code>，像函数那样调用 <code>Class</code>，将会报错。<br>类不存在变量提升（hoist），也就是没办法先使用后定义。<br>此外还有很多需要注意的点，不过我认为我知道这一部分就足够了，了解更多就去看阮一峰的书吧。</p>
<h2 id="Module语法"><a href="#Module语法" class="headerlink" title="Module语法"></a>Module语法</h2><blockquote>
<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
</blockquote>
<p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<strong>编译时就能确定模块的依赖关系</strong>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是整体加载 <code>fs</code> 模块（即加载 <code>fs</code> 的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。<br>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="comment">// 仅加载三个方法（函数）</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure>
<p>这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。<br>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p><strong>一个模块就是一个独立的文件</strong>。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。<br>下面展示一下几种 export 的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种（推荐）</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, year &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数或者类或者对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出函数自定义名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系，所以你不能直接输出一个值，例如数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure>
<p><code>export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数名</span></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br><span class="line">a.foo = <span class="string">'hello'</span>; <span class="comment">// 合法操作（非常不建议）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="comment">// 通过 别名.函数名 调用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br></pre></td></tr></table></figure>
<p><code>import</code> 命令输入的变量都是只读的，因为它的本质是输入接口。<br>注意，<code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行，同时 <code>.js</code> 后缀可以省略。<br>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>为了给用户提供方便，让他们不用阅读文档就能加载模块（不需要知道名字），就要用到 <code>export default</code> 命令，为模块指定默认输出。<br>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认与非默认方法</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure>
<p>这时 <code>import</code> 命令后面，不使用大括号。显然，一个模块只能有一个默认输出，因此 <code>export default</code> 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 <code>export default</code>命令。<br>本质上，<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字。正是如此所以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>静态化固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。<br>如果 <code>import</code> 命令要取代 Node 的 <code>require</code> 方法，这就形成了一个障碍。<strong>因为 <code>require</code> 是运行时加载模块，<code>import</code> 命令无法取代 <code>require</code> 的动态加载功能</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">'./'</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path);</span><br></pre></td></tr></table></figure>
<p>因此，有一个<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">提案</a>，建议引入 <code>import()</code> 函数，完成动态加载，对于这个import  函数，我就不多进行了解了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于 a 标签默认行为（href 跳转）：<br>常见的阻止默认行为的方式：<code>&lt;a href=&quot;javascript:void(0);&quot;  onclick= &quot;myjs( )&quot;&gt;  Click Me  &lt;/a&gt;</code><br><strong>函数 onclick 要优于 href 执行</strong>，而 void 是一个操作符，<code>void(0)</code> 返回 undefined，地址不发生跳转，使用 <code>javascript:;</code> 也是一样的效果。<br>在 onclick 函数中，如果返回的是 true，则认为该链接发生了点击行为；如果返回为 false，则认为未被点击。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/class</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue核心使用总结]]></title>
      <url>http://bfchengnuo.com/2019/06/02/Vue%E6%A0%B8%E5%BF%83%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>将之前的 Vue 学习笔记进行了整理，即使仅是 Vue 核心的功能发现也还是比较有货的，跟后端的学法都是一样的，关键理解其设计思想，上手使用都不难，关键是能 get 到为什么这样设计，这样设计什么好处，这个有点玄学，全靠自己理解了 o(￣▽￣<em>)ゞ))￣▽￣</em>)o。<a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>vueJS 是一种轻量级的 MVVM 框架，它同时吸收了 react 和 angular 的优点，强调了 react 组件化的概念，可以轻松的实现数据和展现的分离。也吸收了 angular 灵活的指令和页面操作的一些方法。</p>
<p>Vue 引入建议放在头部，避免发生抖屏的现象。<br>Vue 使用后不再需要任何 Dom 操作，Vue 接管了 Dom 的操作。<br><strong>Vue 只会处理挂载点下的内容</strong></p>
<p>当数据发生变化时（比如被函数改变），Vue 会自动去更新页面的数据，整个过程不需要操作 Dom</p>
<blockquote>
<p>关于 MVC、MVP、 MVVM 的介绍：<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>
</blockquote>
<h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><p>首先，来复习下 Vue 最常用的一些东西，基本语法和模式</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>学习 Vue 首先接触的可能是挂载点、模板、Vue 实例等这些词，先来看一段示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-Hans"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 放在头部引用，避免抖屏现象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"num"</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="xml">        // template: "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">          msg: <span class="string">"Hello World!"</span>,</span></span><br><span class="line"><span class="undefined">          num: 123</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">          handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert("test")</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.msg = <span class="string">"Loli"</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是标准的一个 HTML，其中 script 部分是 Vue 的主要施展的部分，通过 <code>new Vue()</code> 出的对象自然就称作是<strong>实例</strong>了。<br>其中，那个 id 为 root 的 div 就可以称作是<strong>挂载点</strong>；也可以说是 Vue 实例中 el 所指向的元素。<br>在挂载点内部的内容，都可以称作是<strong>模板内容</strong>；同时模板也可以写在 Vue 实例中，效果是一样的。</p>
<p>这里补充一个生命周期的图示：</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期"></p>
<h3 id="数据指令及处理"><a href="#数据指令及处理" class="headerlink" title="数据指令及处理"></a>数据指令及处理</h3><p>通过两对花括号的方式取值方式我们称之为“<strong>插值表达式</strong>”.<br>在实例定义的方法中，可以直接通过 <code>this.name</code> 的方式来获取定义的数据对象（data 属性里的），相当于是个别名了，不需要太在意 this 指向，Vue 会进行进一步的处理的，简单理解为代表本组件即可。</p>
<p>指令：</p>
<ul>
<li><p><strong>v-text</strong><br>标签的内容就是 v-text 指向的变量，例如：<code>&lt;p v-text=&quot;num&quot;&gt;&lt;/p&gt;</code><br><strong>特殊字符会被转义</strong></p>
</li>
<li><p><strong>v-html</strong><br>和 v-text 基本一致，区别在于它不会转义那些 HTML 字符</p>
</li>
<li><p><strong>v-on(@)</strong><br>绑定事件函数，比如点击事件（v-on:click），函数的定义可以写在实例的 methods 对象内。<br>其中 <code>v-on:</code> 可以简写为 <code>@</code></p>
</li>
<li><p><strong>v-bind(:)</strong></p>
<p>属性绑定，和双大括号类似，只不过是用在属性里的，例如：<code>&lt;div v-bind:title=&quot;is + title&quot;&gt;Test&lt;/div&gt;</code><br>同样，它可以简写为 <code>:</code></p>
</li>
</ul>
<p>使用了指令后，比如 <code>v-xxx:</code> 之类的形式，后面跟的是一个 js 表达式，也就是说可以使用 js 中的基本表达方式，比如 <code>+</code> 之类的连接符。</p>
<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><p>上面一顿操作都是单向绑定的，也就是说实例的数据决定页面的显示，但是页面的显示不能改变实例中的数据，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">"is Content"</span></span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里就需要使用模板指令：v-mode，使用格式直接是：<code>v-model=&quot;msg&quot;</code></p>
<h3 id="计算属性与侦听器"><a href="#计算属性与侦听器" class="headerlink" title="计算属性与侦听器"></a>计算属性与侦听器</h3><p>计算属性就是某一个属性的结果是其他几个属性值计算得出来的，并且在其他属性没有改变的情况下，再次使用会直接返回缓存值，避免重复计算。<br>侦听器就是监听某一个数据的变化，一旦发生变化就执行相应的逻辑。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#cal"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        firstName: <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="string">""</span>,</span></span><br><span class="line"><span class="undefined">        count: 0</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      computed: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算属性声明</span></span></span><br><span class="line"><span class="javascript">        fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 再次使用 fullName 时，如果这两个变量没有改变会使用缓存值</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 避免重复进行计算</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// get set 的方式</span></span></span><br><span class="line"><span class="undefined">        test: &#123;</span></span><br><span class="line"><span class="undefined">          get () &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          set (newVal) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// do something</span></span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      watch: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 侦听器，也会有缓存</span></span></span><br><span class="line"><span class="javascript">        firstName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        lastName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.count++</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>PS：不要忘记使用 this，要不然找不到，Vue 会自动处理这个“别名”。<br>计算属性 computed 可以使用 get 和 set，用来提供获取和设置的情况。</p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h4 id="显示与隐藏"><a href="#显示与隐藏" class="headerlink" title="显示与隐藏"></a>显示与隐藏</h4><p>来看 <code>v-if</code> 和 <code>v-show</code></p>
<p>他们<strong>控制标签的显示和隐藏</strong>，当为 true 时就显示，false 时就隐藏，他们的区别在于，<strong>v-if 的表现形式是将标签直接删除，v-show 则是通过 display 来实现。</strong></p>
<blockquote>
<p>这可能带来了 dom 复用的问题，例如 input 框不会清空，这种情况下可以使用 key 值来绑定唯一，这样 Vue 就会不复用了。</p>
</blockquote>
<p><strong>性能上来说，频繁更改的话 v-show 更好，如果只是改一次那么 v-if 可能就更好了。</strong><br>其次还支持紧贴 v-if 的 v-else-if 和 v-else</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>然后就是 v-for 用来遍历数据的，举个例子：</p>
<p><code>&lt;li v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;</code></p>
<p>list 就是定义的数组数据，item 是每次遍历的值，index 是索引，使用 <code>:key</code> 可以提高效率，<strong>但是要保证 key 的唯一</strong>；所以这里我加了个 index，如果 item 是唯一的那么可以直接使用 item：</p>
<p><code>&lt;li v-for=&quot;item of list&quot; :key=&quot;item&quot;&gt;&lt;/li&gt;</code></p>
<p>如果还要对其进行排序之类的操作，那么使用 index 也不是很合适了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myClick"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;li v-for="item of list" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        text: <span class="string">"我是内容"</span>,</span></span><br><span class="line"><span class="javascript">        flag: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">        list: [1,2,3]</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        myClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h3><p>关于样式的控制，可以使用 class 对象绑定： <code>:class=&quot;{className: isActivated}&quot;</code> 然后通过控制 isActivated 变量来控制 class 的显示或隐藏。<br>还可以通过 <code>:class=&quot;[activated, className]&quot;</code> 这样通过 activated 这个变量来控制。<br>如果是内联样式（<code>:style</code>），可以直接引用一个 js 对象，在对象里面定义 css 样式就行，同样也可以使用数组来挂载多个对象。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>当某一块的布局复杂后就需要抽取出来，形成了一个模板，模板又分为全局的和局部的，它们的使用也各不相同，这一个个的模板加上一下逻辑就可以当作是一个组件，在下面的代码中可以体现出来。<br>因为模板中取不到外部的属性，所以使用了属性传值的方式来将数据传进去，在模板中接收一下就可以使用了。<br><strong>模板也可以看作是一个实例，可以说在一个 Vue 项目中，是由很多很多 Vue 实例（组件）组成的</strong>。<br>根据“发布-订阅”模型，可以在子组件中向父组件发布消息，然后父组件可以监听子组件的自定义消息，然后调用相应的方法来进行处理：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义全局组件</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'todo-item'</span>, &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收传入的属性</span></span></span><br><span class="line"><span class="javascript">      props: [<span class="string">'content'</span>, <span class="string">'index'</span>],</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 因为模板也是一个实例可以定义事件</span></span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 向外发布一个自定义事件（订阅-发布模型）, 并且将 index 传递过去</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.$emit(<span class="string">'delete'</span>, <span class="keyword">this</span>.index)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义局部组件,必须要在 Vue 实例中声明才能用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> TodoItem = &#123;</span></span><br><span class="line"><span class="xml">      template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span>item<span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// components: &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   // 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   'todo-item': TodoItem</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        mSubmit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        handleDelete: <span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>PS：<strong>模板中要求只能有一个根标签，所以在最外层一般都会套一个 div</strong></p>
<p>总之，当年看到奇奇怪怪的 HTML 标签时，一般就是一个 Vue 组件了，一个组件一般会写在一个 xxx.vue 文件里，通过 ES6 的 import 语法导入进行使用。</p>
<blockquote>
<p>我们导入的组件（component）起的名字一般是跟组件的 name 属性对应的，在 HTML 中使用组件直接用这个名字的标签即可，因为 HTML 对大小写不敏感，所以使用 <code>-</code> 进行转换，例如：<br>name：todoList  =&gt;  <code>&lt;todo-list&gt;&lt;/todo-list&gt;</code></p>
</blockquote>
<h3 id="组件参数校验"><a href="#组件参数校验" class="headerlink" title="组件参数校验"></a>组件参数校验</h3><p>在父子组件之间传值都已经知道了，那么接下来就看看如果子组件要对父组件传递的数据进行校验要怎么办，使用的还是子组件里的 props 属性，只不过这里由本来的字符串数组变成了对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 不是校验的话可以直接用字符串数组来标识</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// content: [Number,String]</span></span><br><span class="line">    content: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'def val'</span>,</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>补充一下这个 props 特性，也就是如果你在子组件的 props 中接收了传递的属性，那么 Vue 在视图渲染的时候就不会再在 HTML 中加上这个属性了。<br>在子组件上绑定的事件默认都是自定义事件，也就是说原生的事件可能会失效，例如在子组件标签里使用 <code>@click</code> 是无效的，不过你可以在子组件的模板里来绑定，这样就不是自定义事件了。<br>触发自定义事件就是手动的调用 emit 了；但是有些时候就想用子组件的原生事件，就想让它生效怎么办，也是有办法的，只需要一点点的改动：<code>@click.native=&quot;fun&quot;</code>。<br>同时，为了解决手机端兼容问题，可以使用类似 <code>@touchstart.prevent</code> 的方式阻止事件的默认行为。</p>
<h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><p>这里主要说的就是非父子组件之间的传值，例如父与子的子、兄弟组件，虽然可以间接完成，但是过于麻烦，由于 Vue 的定义轻量级，它并不具备解决这个问题的能力，但是我们可以借助其他的方案。</p>
<ol>
<li>Vue 官方推荐的 Vuex 框架。</li>
<li>发布-订阅模式，也就是总线机制，可以理解为是观察者模式。</li>
</ol>
<p>一般情况下，都是使用 Vuex，非常简单的项目可以考虑下 bus</p>
<h4 id="总线模式"><a href="#总线模式" class="headerlink" title="总线模式"></a>总线模式</h4><p>这里仅说一下总线的这种方式，其实就是在所有子组件上挂一个 Vue 实例，然后通过这个实例来进行事件的发送与处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 bus</span></span><br><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 子组件的 data 必须是函数</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      selfContent: <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    content: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">"&lt;div @click='handleClick'&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 向总线发送事件</span></span><br><span class="line">      <span class="keyword">this</span>.bus.$emit(<span class="string">"change"</span>, <span class="keyword">this</span>.selfContent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期，挂载时触发</span></span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> this_ = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.bus.$on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      this_.selfContent = val;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>就是通过一个生命周期来完成的。</p>
<blockquote>
<p>在 Vue 中，类似 <code>vm.$xx</code> 这种的调用，后面跟一个 <code>$</code> 符号，意思是调用 Vue 实例的方法。</p>
</blockquote>
<h4 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h4><p>简单说 Vuex 就是一个单向数据的改变流，把需要改变的数据单独存储起来，然后通过指定的流程来进行更改。</p>
<p><img src="https://vuex.vuejs.org/vuex.png" alt=""></p>
<p>一般情况下，我们在单独的一个 js 中设置 Vuex，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: localStorage.name || <span class="string">"xxx"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeName (ctx, name) &#123;</span><br><span class="line">      <span class="comment">// 调用 mutations</span></span><br><span class="line">      ctx.commit(<span class="string">'changeName'</span>, name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity (state, name) &#123;</span><br><span class="line">      state.name = name</span><br><span class="line">      <span class="comment">// 本地存储 (低版本浏览器或者隐身模式可能会抛异常)</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        localStorage.name = name</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在 App 入口 js 中进行引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样在任何子组件中就可以通过 <code>this.$store.state</code> 来获取 Vuex 中 state 的数据啦。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发修改</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'changeName'</span>, name)</span><br><span class="line"><span class="comment">// 如果没有异步获取数据逻辑，可以直接调用 mutations</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'changeName'</span>, name)</span><br></pre></td></tr></table></figure>
<p>其中我们还使用了本地存储 localStorage。</p>
<p>实际中，大多会拆分 index.js 将 state、actions、mutations 单独放在一个文件中。</p>
<hr>
<p>另外，Vuex 还提供了高级 API 允许我们更精简的写代码，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleClick (name) &#123;</span><br><span class="line">    <span class="comment">// 使用 Vuex 改变全局数据</span></span><br><span class="line">    <span class="comment">// this.$store.dispatch('changeName', name)</span></span><br><span class="line">    <span class="keyword">this</span>.changeName(name)</span><br><span class="line">    <span class="comment">// 或者可以直接调用 mutations</span></span><br><span class="line">    <span class="comment">// this.$store.commit('changeName', name)</span></span><br><span class="line">    <span class="comment">// 跳转回首页</span></span><br><span class="line">    <span class="keyword">this</span>.$router.push(<span class="string">'/'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 展开运算符，可以直接调用 changeName 方法了</span></span><br><span class="line">  ...mapActions([<span class="string">'changeName'</span>])</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用 Vuex 的便捷映射, 数组、对象皆可</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    name: <span class="string">'loli'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本的 Vuex 操作就是这些了。</p>
<h3 id="使用插槽"><a href="#使用插槽" class="headerlink" title="使用插槽"></a>使用插槽</h3><p>简单来说，当子组件有一部分内容是由父组件传递过来的 dom 来显示的时候，就可以使用插槽来处理。<br>要解决的问题，之前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'content'</span>],</span><br><span class="line">  <span class="comment">// ES6 语法</span></span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">              &lt;p&gt;Dear&lt;/p&gt;</span></span><br><span class="line"><span class="string">              &lt;div v-html="this.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>之后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;child content="&lt;p&gt;hello&lt;/p&gt;"&gt;&lt;/child&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出子组件里的内容会被 slot 标签插入。<br>如果需要将子组件里内容分片，那么也是可以的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 语法</span></span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"one"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>Dear<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;slot name=<span class="string">"two"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是稍微改变了下，进行了标识。</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>最后来看一下高级用法：作用域插槽，从例子开始：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">show</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 固定写法，template 开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">show</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'show'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">        list: [1,2,3,4]</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined">                &lt;slot </span></span><br><span class="line"><span class="javascript">                  v-<span class="keyword">for</span>=<span class="string">"item of list"</span></span></span><br><span class="line"><span class="undefined">                  :item=item</span></span><br><span class="line"><span class="javascript">                &gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>稍微解释一下，在 template 中，使用 for 来“循环插槽”，将每次循环的数据绑定到了 item 变量，然后视图中通过 slot-scope 来接收。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>这里说的是动态的切换组件，可以手动实现，也可以通过 Vue 提供的 component 标签来实现，例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">'type'</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-one</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-one'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-one</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-two</span> <span class="attr">v-if</span>=<span class="string">"type === 'child-two'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-two</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-one'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child-two'</span>, &#123;</span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">"#root"</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">      type: <span class="string">'child-one'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">      handleClick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.type = <span class="keyword">this</span>.type === <span class="string">'child-one'</span> ? <span class="string">'child-two'</span> : <span class="string">'child-one'</span>;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>component 和下面使用 v-if 控制的标签是一样的，因为每次切换都需要销毁、重新创建，所以性能上会有点损耗，可以在模板上使用 <code>v-once</code> 来将实例放到内存中，这样就省去了创建、销毁的时间。</p>
<h2 id="使用脚手架"><a href="#使用脚手架" class="headerlink" title="使用脚手架"></a>使用脚手架</h2><p>官方提供的安装和初始化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 全局安装 vue-cli</span><br><span class="line">npm install --global vue-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<p>因为是采用的 webpack 的方式，所以方便了很多，直接可以在浏览器中进行预览。<br>这里就可以看出模块化了，其中 Vue 实例都集中放在了 <code>.vue</code> 结尾的文件中，vue  文件分成三部分，模板、js代码、样式。<br>工程的入口是根目录下的 index.html 文件，其中有个 id 为 app 的 div，这就是 Vue 的挂载点了，然后看主要的代码在 src 中。<br>在 main.js 中创建了 Vue 实例，也就是所谓的启动配置，并且定义了模板，导入了相应的子模板，这里就来修改下看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块化语法</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 引入子模板</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>和上面写的差不多，创建了一个 Vue 实例，挂载到 app 这个 id 下面，模板采用的是实例内定义的，里面就是引用了个 <code>&lt;App/&gt;</code> ，也就是 <code>App.vue</code> 中定义的那一堆。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"mSubmit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 根据发布-订阅，监听内部组件的自定义事件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of list"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:key</span>=<span class="string">"index"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">:content</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">delete</span>=<span class="string">"handleDelete"</span></span></span><br><span class="line"><span class="tag">                 &gt;</span><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">'./components/TodoItem'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 相当于子模板的定义区</span></span></span><br><span class="line"><span class="javascript">    name: <span class="string">'App'</span>,</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 声明局部组件，如果键和值相同可以写一个</span></span></span><br><span class="line"><span class="javascript">      <span class="string">'todo-list'</span>: TodoItem</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// vue 文件中 data 只能使用函数来定义</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ES6 简便写法</span></span></span><br><span class="line"><span class="undefined">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">        list: []</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      mSubmit () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.push(<span class="keyword">this</span>.content)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.content = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      handleDelete (index) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.list.splice(index, <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 vue-cli 中，当写一个实例的数据的时候使用的是函数方式，而不再是对象！！<br>然后，App 这个模块中又引入了一个 TodoItem 的模板，就是曾经的子模板，完整的例子到 GitHub 仓库查看。<br>再次说明，Vue 底层会处理 this 的指向，不需要太过担心，指的就是此实例.</p>
<h3 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h3><p>使用路由来根据访问 url 动态切换的目的，在 App 主入口加入 <code>&lt;router-view/&gt;</code> 即可启用，在 <code>src\router\index.js</code> 进行配置路由规则即可。<br>其中路由规则的 url 映射可以使用变量来进行区分，例如：<code>/detail/:id</code> ，然后可以在子组件通过 <code>this.$route.params.id</code> 来获得变量。<br>使用 <code>&lt;router-link to=&quot;/list&quot;&gt;跳转&lt;/router-link&gt;</code> 可进行单页应用的跳转，在跳转过程中不需要请求新的 HTML，但是首屏加载会慢一点，SEO 也不是很好。<br>除了使用标签来路由，在 JS 环境下，可以使用编程式导航：<code>this.$router.push(&#39;/&#39;)</code></p>
<hr>
<p>为了防止路由调整后滚动条不会重置，官方文档的解决方案是在路由的 js 配置中加入下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Home'</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就解决了跳转后滚动条错乱的情况。</p>
<h3 id="使用Axios发送请求"><a href="#使用Axios发送请求" class="headerlink" title="使用Axios发送请求"></a>使用Axios发送请求</h3><p>既然都用 Vue 了，那么基本是前后端分离的架构，于是 ajax 请求必然少不了，一般情况在 Vue 中处理请求都是用 Axios 这个库，直接 npm 安装后导入就可以用了。<br>这里说下基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  getHomeInfo () &#123;</span><br><span class="line">    Axios.get(<span class="string">'/api/index.json?city='</span> + <span class="keyword">this</span>.$store.state.city)</span><br><span class="line">      .then(<span class="keyword">this</span>.getHomeInfoCallback)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">       &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  getHomeInfoCallback (res) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data.ret &amp;&amp; res.data.data) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.data.data</span><br><span class="line">      <span class="keyword">this</span>.swiperList = data.swiperList</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'Fred'</span>,</span><br><span class="line">  lastName: <span class="string">'Flintstone'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>嗯，基本上就是这个样子了，then 表示才成功后回调，catch 表示失败后回调。<br>注意下，成功或者失败的 res 都会给你包一层，<code>res.data</code> 才是真正响应的东西。</p>
<h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>因为一般是前后端分离，有时候后端的接口还没开发完，这时候我们可以改 url，但是这样之后你还得再改回去，特别麻烦，webpack 提供了代理的工具，将我们 Axios 发送的请求按照指定规则进行转发，例如我们可以使用静态文件来模拟数据。<br>一般在 webpack 的配置文件里这样写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">  // Paths</span><br><span class="line">  assetsSubDirectory: 'static',</span><br><span class="line">  assetsPublicPath: '/',</span><br><span class="line">  proxyTable: &#123;</span><br><span class="line">    // 添加 URL 的替换，转发为本地静态文件</span><br><span class="line">    '/api': &#123;</span><br><span class="line">      target: 'http://localhost:8080',</span><br><span class="line">      secure: false,  // 如果是https接口，需要配置这个参数</span><br><span class="line">      changeOrigin: true,  // 是否跨域</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        '^/api': '/static/mock'</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是将 url 重写，然后转发到你对应的地址。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>这里列举下在项目中使用的一些特性或技术，除了动画，其他还是用的非常多的。</p>
<h3 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h3><p>最简单的淡出淡然，可以使用 transition 标签进行包裹，作用简单说就是：<br>在开始前，会给被包裹的标签增加两个 css 样式：<strong>v-enter 和 v-enter-active</strong>，当动画运行到第二帧的时候会去除 v-enter 这个样式，再增加一个 v-enter-to 样式；最后动画结束时去除所有样式。<br>在使用 transition 标签的时候，如果加了 name 属性，那么样式就以你定义的名字作为前缀代替 v。<br>上面说的是显示的动画，隐藏的过度也是类似，只需要把 enter 换成 leave 就可以了。<br>如果想自定义 css 的名字，可以使用 <strong>enter-active-class</strong> 属性来定义，其他同理。</p>
<p>或者可以使用 <code>animated.css</code> 提供的样式，快速开发，使用起来非常简单，引入不要的 css 库，然后利用上面所说来自定义 css 名字，格式就是：<code>animated 动画名</code> 名字可以在官网找，其实就是封装了下 css3 的 @keyframes 特性。</p>
<p>PS：想要初始化的时候就展示动画需要使用 appear 属性来配合。</p>
<hr>
<p>除了使用 css 来做动画，也可以使用 js 实现，在标签中通过 <strong>@before-enter、@enter、@after-enter</strong> 等来绑定方法，会传递一个参数过去，也就是包裹的 dom 元素 el。<br>其中 @enter 会传递两个参数，第一个与上面一样，第二个是个函数引用 done，在动画完成后调用一下它告诉 Vue 动画结束，这样就会再继续执行下面的 after。<br>如果嫌麻烦，可以使用像 <strong>Velocity</strong> 这样的 js 动画库。</p>
<hr>
<p>对于列表动画，可以使用 transition-group 标签来包裹，其实它的作用就是将里面的循环每一个都包裹一个 transition 标签。</p>
<h3 id="优化相关"><a href="#优化相关" class="headerlink" title="优化相关"></a>优化相关</h3><p>使用 <code>&lt;keep-alive&gt;</code> 标签 Vue 会自动帮你进行优化请求，例如 ajax 请求，如果启用了 <code>&lt;keep-alive&gt;</code> 标签，当第二次进行 ajax 请求时，会直接从内存里拿数据（mounted 函数不会执行）。<br>一般就直接在 App.vue 中使用了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启用缓存,重新路由后不再发请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"Detail"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'App'</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后有的数据我们是不想进行缓存的，所以就可以使用 exclude 指定组件的名字（就是 name 属性）进行排除。<br>或者可以使用生命周期函数 activated 来刷新数据（可能需要进行一定的逻辑判断·），这个函数在页面重新加载时执行。</p>
<hr>
<p>默认情况下 webpack-server 是不支持 ip 访问的，如果就想 ip 访问，可以在 <strong>package.json</strong> 文件中的 dev 加一个配置：<code>&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot;</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>使用 v-for 无论是遍历数组还是遍历对象，直接使用下标增加、修改数组 View 不一定会刷新，<strong>想要视图跟着刷新就必须用方法来增加</strong>，例如数组的 pop、push 等方法；对于对象的属性增加，可以使用 Vue 的全局方法 set（<code>Vue.set(obj, key, val)</code> 或者使用实例的 set 方法，<code>vm.$set(obj, key, val)</code>），当然 set 方法也可以用来修改数组 key 就是下标了。</p>
<hr>
<p>使用 v-for 的时候，为了不引入多余的 HTML 结构，可以使用 template 标签占位，在这个标签里使用 v-for 这样渲染后就没有痕迹了。</p>
<hr>
<p>可以通过绑定 class 属性的方式来改变样式，支持对象、数组。</p>
<hr>
<p>解决组件与 HTML5 规范冲突，可以使用 is 属性来标识其真正的组件，例如：<code>&lt;tr is:&quot;row&quot;&gt;&lt;/tr&gt;</code>。<br>使用 Vue 提供的标签也是类似，例如：<code>&lt;router-link tag=&quot;li&quot; :to=&quot;/index/&quot;&gt;</code></p>
<hr>
<p>子组件里，data 属性必须是函数，可以是这个函数返回一个对象，里面包含一些属性；这样也就达到了多个子组件数据互不影响的目的。</p>
<hr>
<p>必要的操作 Dom 时，通过 ref 属性来标识，在事件中可以 <code>this.$refs.name</code> 来获取 Dom 元素；如果 ref 加在了组件上，那么得到的就是这个组件的引用了。<br>特殊情况下，如果 ref 和 v-for 连用，那么使用 <code>:ref=</code> 的形式，并且获取的是数组，需要 <code>name[0]</code> 使用。</p>
<hr>
<p>子组件向父组件传值是通过事件的形式，一般来说在子组件中使用 <code>this.$emit(&#39;name&#39;, data)</code> 来进行手动触发；配合子组件的 HTML 标签中使用 <code>@name=&quot;fun&quot;</code> 来进行监听。</p>
<hr>
<p>在导入语法中，使用 <code>@</code> 来表示 src 目录；在组件样式编写的时候，如果不想影响到其他组件的样式，在 style 标签里加一个 scoped 即可。<br>使用 @import 导入 css 变量域，<code>~</code> 固定前缀：<code>@import &#39;~@style/varibles.styl&#39;</code><br>如果使用 stylus 语法，可以使用 <code>&gt;&gt;&gt;</code> 来做样式穿透。</p>
<hr>
<p>在 webpack 的配置文件里，可以使用 alias 来定义别名，快速引用文件夹，例如默认的 <code>@</code> 表示 src 就是这样设置的。</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法之美-排序]]></title>
      <url>http://bfchengnuo.com/2019/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法可能就是排序，大学里的 C 入门就是写的它吧？排序是非常重要的，但是排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。<br>我这里就只看最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<a id="more"></a></p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
<th>是否基于比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡、插入、选择</td>
<td>O(n^2)</td>
<td>是</td>
</tr>
<tr>
<td>快排、归并</td>
<td>O(nlogn)</td>
<td>是</td>
</tr>
<tr>
<td>桶、计数、基数</td>
<td>O(n)</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）就是特指空间复杂度是 O(1) 的排序算法，可以理解为<strong>不需要开辟很多空间的算法</strong>。</p>
<p>然后还有一个<strong>稳定性</strong>的概念，简单说就是<strong>排序前后，相等的元素还是原来的顺序不变</strong>，这个性质其实很重要，实际中我们都是对对象的某个属性排序，如果还能保证顺序就省事很多。<br>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？<br>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。<br>两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作<strong>相邻的两个数据</strong>。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置</strong>，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">// 表示有数据交换</span></span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<strong>原地排序</strong>算法。</p>
<p>为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是<strong>稳定的</strong>排序算法。</p>
<p>对于一个给定的初始序列，移动操作的次数总是固定的。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>描述下过程就是：首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间；<br>初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。<br>重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 要插入的数</span></span><br><span class="line">    <span class="keyword">int</span> value = arr[i];</span><br><span class="line">    <span class="comment">// 有序区间的末尾</span></span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; value) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    arr[j + <span class="number">1</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 熟练后 for 循环可以简化：</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">  array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">  j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-- ) &#123;</span><br><span class="line">  arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序</strong>算法。</p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的</strong>排序算法。</p>
<p>对于一个给定的初始序列，移动操作的次数总是固定的。</p>
<h3 id="为什么插入更受欢迎"><a href="#为什么插入更受欢迎" class="headerlink" title="为什么插入更受欢迎"></a>为什么插入更受欢迎</h3><p>把他们循环的最多次的代码拿出来比较下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要小看少的这两句语句，在数据量大的时候，就能带来显著的差距，所以尽量做到极致的话当然会选择插入排序，另外，如果喜欢插入排序，可以看看极致的改进版：<strong>希尔排序</strong>，不过它是<strong>非稳定</strong>的。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  <span class="comment">// 只循环到倒数第二个即可，最后一个没数可比</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[i] &gt; data[j]) &#123;</span><br><span class="line">        temp = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要说明一下，选择排序是一种<strong>原地排序</strong>算法，但<strong>不是稳定的</strong>排序算法。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组<strong>从中间分成前后两部分</strong>，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。<br>这就是分治思想，分而治之，跟递归思想有点像。</p>
<p>然后重点说下将两个已经有序的数组拼装起来，我们可以先申请一个临时数组 tmp，大小与原数组 A 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。<br>比较这两个元素 A[i] 和 A[j]，如果 <code>A[i]&lt;=A[j]</code>，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。<br>直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序算法, a是数组，n表示数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mergeSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值</span></span><br><span class="line">    <span class="keyword">int</span> q = p + (r - p) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    mergeSortInternally(a, p, q);</span><br><span class="line">    mergeSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s1, <span class="keyword">int</span> middle, <span class="keyword">int</span> arrEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start1 = s1;</span><br><span class="line">    <span class="keyword">int</span> start2 = middle + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个大小跟a[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arrEnd - s1 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 临时数组的索引</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= middle &amp;&amp; start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[start1] &lt;= arr[start2]) &#123;</span><br><span class="line">        tmp[k++] = arr[start1++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = arr[start2++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据，默认设为第一个剩余</span></span><br><span class="line">    <span class="keyword">int</span> start = start1;</span><br><span class="line">    <span class="keyword">int</span> end = middle;</span><br><span class="line">    <span class="keyword">if</span> (start2 &lt;= arrEnd) &#123;</span><br><span class="line">      <span class="comment">// 改变为第二个剩余</span></span><br><span class="line">      start = start2;</span><br><span class="line">      end = arrEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      tmp[k++] = arr[start++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回a[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> (start1 = <span class="number">0</span>; start1 &lt;= arrEnd - s1; ++start1) &#123;</span><br><span class="line">      arr[s1 + start1] = tmp[start1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是<strong>稳定的</strong>算法，只要保证合并时稳定就好了。<br>它<strong>不是原地排序</strong>算法，所以快排更加出名一些，即使它的最好情况下的时间复杂度要优于快排。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排利用的也是分治思想，乍看和归并差不多，其实思想还是有差别的，快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。<br>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br>当区间缩小为 1 的时候就可以认为它有序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序，a是数组，n表示数组的大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    quickSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">    quickSortInternally(a, p, q - <span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[r];</span><br><span class="line">    <span class="keyword">int</span> left = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = p; right &lt; r; ++right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[right] &lt; pivot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">          a[left++] = a[right];</span><br><span class="line">          a[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换 pivot，返回缩小后区间的最后一个（新 pivot）</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[left];</span><br><span class="line">    a[left] = a[r];</span><br><span class="line">    a[r] = tmp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"i="</span> + left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排并<strong>不是一个稳定的</strong>算法，它<strong>是一个原地排序</strong>算法；<br>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<p>快排 B 站有个视频讲的不错：<a href="https://www.bilibili.com/video/av39093184" target="_blank" rel="noopener">https://www.bilibili.com/video/av39093184</a></p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个<strong>有序的</strong>桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p>他的时间复杂度是 O(n)，只不过对数据的要求比较苛刻。<br>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。<br>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<blockquote>
<p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p>
<p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。<br>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p>
<p>如果数据不能平均分，集中在一个桶里，为了避免时间复杂度的退化，那么你只能继续拆分。</p>
</blockquote>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。<strong>每个桶内的数据值都是相同的</strong>，省掉了桶内排序的时间。<br>计数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，arr 是数组，size 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">      max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个计数数组 countArr，下标大小 [0,max]，初始化为 0</span></span><br><span class="line">  <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 countArr 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    countArr[arr[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    countArr[i] = countArr[i - <span class="number">1</span>] + countArr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组 temp，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = countArr[arr[i]] - <span class="number">1</span>;</span><br><span class="line">    temp[index] = arr[i];</span><br><span class="line">    countArr[arr[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给 arr 数组</span></span><br><span class="line">  System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数（小数就先乘以倍数，负数就先加成正数）。</p>
<p>例如，对 50 万考生的成绩排名，假设满分是 900 最低是 0，数据范围很小，可以搞 901 个桶，然后将这些考试分布进这些桶里，<strong>并不需要排序，只需要扫描，时间复杂度是 O(n)。</strong></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？<br>对于手机号，再用之前的桶排序就不合适了，因为它太大了，刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。<br>借助稳定排序算法，这里有一个巧妙的实现思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。<br>不过要保证在每一位的排序中，<strong>算法要是稳定的</strong>。<br>每一位的排序就可以用上面的桶排序了~这样时间复杂度也是 O(n).</p>
<p>那么对于不等长的数据怎么排序（字符串为例）？我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据 ASCII 码，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p>
<p>基数排序对要排序的数据是有要求的，需要<strong>可以分割出独立的“位”来比较，而且位之间有递进的关系</strong>，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序（O(n)）算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种<strong>原地的</strong>、<strong>不稳定</strong>的、时间复杂度为 O(nlogn) 的排序算法，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好。</p>
<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆是一种特殊的树，只要满足这两点，它就是一个堆：</p>
<ul>
<li>堆是一个完全二叉树；</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li>
</ul>
<p>第一点，堆必须是一个<strong>完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p>
<p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p>
<p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。<br>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。</p>
<p>关于树的介绍，我之前写过一篇，<a href="https://bfchengnuo.com/2017/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/">点我跳转</a></p>
<h3 id="实现一个堆"><a href="#实现一个堆" class="headerlink" title="实现一个堆"></a>实现一个堆</h3><p>完全二叉树比较适合用数组来存储，用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。<br>为了方便计算，通常会把数组的 1 号索引作为根，也就是前面空一个，数组中下标为 i 的节点的左子节点，就是下标为 <code>i∗2</code> 的节点，右子节点就是下标为 <code>i∗2+1</code> 的节点，父节点就是下标为 <code>i/2</code> 的节点。</p>
<p>通过调整，让其满足堆的特性的过程就叫“堆化”，堆化实际上有两种，从下往上和从上往下；<br>例如从下往上的，先插入到数组的最后，然后与父节点比较，不符合规则就交换，然后再跟父节点比较，直到合适为止。<br>删除的话也有一个巧妙的方法，直接把最后一个替换到删除的元素上，然后进行调整。</p>
<h3 id="实现堆排序"><a href="#实现堆排序" class="headerlink" title="实现堆排序"></a>实现堆排序</h3><p>首先，我们需要将数组<strong>原地</strong>建成一个堆，思路这里说一种，假设数组 size 是 10，编号就是 0-9：<br>我们从后面开始，按照规律 8、9 所对应的父节点的索引是 4，所以我们比较 4 是不是比 8 和 9 的数大，如果小就交换最大的；<br>然后继续找 6、7 对应的父节点 3，它们三个再比较，重复上面的步骤，最终就形成了符合规律的树，也就是堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span></span><br><span class="line"><span class="comment">// 需要注意，此算法数组需要空出第一个元素来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i * <span class="number">2</span>]) maxPos = i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i * <span class="number">2</span> + <span class="number">1</span>]) maxPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">  arr[a] = arr[b];</span><br><span class="line">  arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。<br>有点类似删除操作，然后最大的就找出来了，依次往前，最终1就是个从小到大的有序数组了。</p>
<h3 id="总结-amp-应用"><a href="#总结-amp-应用" class="headerlink" title="总结&amp;应用"></a>总结&amp;应用</h3><p>至于说为什么堆排序不如快排效率高，可以从两点来说：<br>堆排序数据访问的方式没有快速排序友好，因为不是顺序访问，Cpu 缓存表示很无奈。<br>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序，就算是原本有序的数组，在堆化过程也会打乱的。</p>
<hr>
<ul>
<li><p><strong>优先级队列</strong><br>在优先级队列中，就不是先进先出了，用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。<br>很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
</li>
<li><p><strong>利用堆求 Top K</strong><br>我们可以维护一个大小为 K 的<strong>小顶堆</strong>，顺序遍历数组，从数组中取出取数据与堆顶元素比较。<br>如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素<strong>插入到</strong>堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。<br>这样每次只需要跟堆顶数比较即可，因为它肯定是全堆最小的。</p>
</li>
<li><p><strong>利用堆求中位数</strong><br>对于静态数据，当然数组求一下最好了，也不会变；如果是动态数据：<br>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。<br>也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。<br>如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。<br>这样，<strong>大顶堆中的堆顶元素就是我们要找的中位数</strong>。</p>
<p>下面就是插入新数据了，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，我们就将这个新数据插入到小顶堆。<br>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况，这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。<br>例如将小顶堆的堆顶元素移动到大顶堆的堆顶。</p>
</li>
</ul>
<p>举几个例子，合并有序小文件的时候，我们可以从很多小文件先取第一个，构建一个小顶堆，每次从堆顶取出最小的放入合并后的文件，再找到这个元素来自那个文件读取下一个。<br>定时任务的时候，为了避免频繁扫描，可以根据时间来构造小顶堆，这样就知道最早执行的时间，避免多余的扫描。</p>
<p>PS：最后中位数说的那个约定：如果 n 是偶数，两个堆中的数据个数都是 n/2；如果 n 是奇数，大顶堆有 n/2+1 个数据，小顶堆有 n/2 个数据。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>例如在 JDK8 中，排序函数并不是仅仅使用一种算法，在元素小于 47 的时候用插入排序，大于 47 小于 286 用双轴快排，大于 286 用 timsort 归并排序，并在 timesort 中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。</p>
<h2 id="娱乐时间"><a href="#娱乐时间" class="headerlink" title="娱乐时间"></a>娱乐时间</h2><p>下面就来给看看猴子排序、睡眠排序、面条排序（太蠢不说 2333），别笑。。。</p>
<h3 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h3><p>构造 n 个线程，它们和这 n 个数一一对应。初始化后，线程们开始睡眠，等到对应的数那么多个时间单位后各自醒来，然后输出它对应的数。这样最小的数对应的线程最早醒来，这个数最早被输出。等所有线程都醒来，排序就结束了。能脑洞大开想出此算法的，绝壁天才啊。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果只需要输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//创建指定长度的线程数组</span></span><br><span class="line">    SortThread[] sortThreads = <span class="keyword">new</span> SortThread[arr.length];  </span><br><span class="line">    <span class="comment">//指定每个线程数组的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i] = <span class="keyword">new</span> SortThread(arr[i]);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//开启每个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortThreads.length; i++) &#123;  </span><br><span class="line">      sortThreads[i].start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SortThread</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.s = s;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">      sleep(s*<span class="number">10</span>+<span class="number">10</span>);  <span class="comment">//睡眠指定的时间</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line"></span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//输出该数</span></span><br><span class="line">    System.out.println(s);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算需要拿到顺序的数组，也有办法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums=&#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    SleepSort.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)</span><br><span class="line">      System.out.printf(<span class="string">"%d   "</span>,n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Sleeper.idx=<span class="number">0</span>;</span><br><span class="line">    Sleeper.output=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      <span class="keyword">new</span> Sleeper(nums[i]).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 主线程需要睡足够的时间，等他们都排好</span></span><br><span class="line">      <span class="comment">// 当然可以使用其他 join、循环检查等方法</span></span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">      nums[i]=Sleeper.output[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] output;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sleep_time;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(<span class="keyword">int</span> sleep_time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sleep_time=sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="keyword">this</span>.sleep_time);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    output[idx++]=<span class="keyword">this</span>.sleep_time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h3><p>随机打乱数组，检查是否排好序，若是，则输出，否则再次打乱，再检查…最佳情况 O(n)，平均 O(n*n!)，最坏可执行直到世界的尽头。<br>无限猴子定理 ：一只猴子随机敲打打字机键盘，如果时间足够长，总是能打出特定的文本，比如莎士比亚全集。<br>用伪代码表示很简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(! isOrdered(nums))</span><br><span class="line">    shuffle(nums);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java性能监控与调优]]></title>
      <url>http://bfchengnuo.com/2019/03/29/Java%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
      <content type="html"><![CDATA[<p>想要有更强的竞争力，这部分一定是得学的，并且小公司的话，你也不太可能只仅仅开发，这些也要全要搞。多了解一些总不是坏事，想要走的更远的话。<br>介绍下 JDK 或者第三方的一些工具来祝你优化你的程序！<a id="more"></a></p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p>首先来了解下 JVM 参数的类型，一般来说，可以分为下面的三大类：</p>
<ul>
<li>标准参数<br>在 JVM 的各个版本中基本不变，比较稳定的。<br>例如：<code>-help</code>、 <code>-server</code>、 <code>-client</code>、 <code>-version</code>、<code>-cp</code>、 <code>-classpath</code></li>
<li>X 参数<br>非标准化参数，有可能会变，但是变化比较小。<br>例如，解释执行：<code>-Xint</code>、第一次使用就编译成本地代码：<code>-Xcomp</code> 、混合模式（默认）：<code>-Xmixed</code></li>
<li>XX 参数<br>使用的最多的一类参数，相对不稳定，主要用于 JVM 调优和 Debug。<br>它还可以再分类，例如：<br>布尔类型：<code>-XX:[+-]&lt;name&gt;</code> 表示启用或者禁用某个属性，启用 G1 垃圾收集器 <code>-XX:+UseG1GC</code>。<br>非布尔类型，也就是 K-V 的形式：<code>-XX:&lt;name&gt;=&lt;val&gt;</code> 就是用来调整属性的。</li>
</ul>
<p>我们见的最多的应该是 -Xms 和 -Xmx 了，然而它俩其实是 XX 参数，是一种简写形式。<br>-Xms 等价于 <code>-XX:InitialHeapSize</code> ；-Xmx 等价于 <code>-XX:MaxHeapSize</code> ；-Xss 等价于 <code>-XX:ThreadStackSize</code></p>
<h3 id="查看JVM运行时参数"><a href="#查看JVM运行时参数" class="headerlink" title="查看JVM运行时参数"></a>查看JVM运行时参数</h3><p>使用到的参数有：</p>
<ul>
<li>-XX:+PrintFlagsInitial<br>查看初始值</li>
<li>-XX:+PrintFlagsFinal<br>查看最终值</li>
<li>-XX:+UnlockExperimentalVMOptions<br>解锁实验参数，有些参数需要解锁后才可以设置。</li>
<li>-XX:+UnlockDiagnosticVMOptions<br>解锁诊断参数</li>
<li>-XX:+PrintCommandLineFlags<br>打印命令行参数</li>
</ul>
<h3 id="PrintFlagsFinal"><a href="#PrintFlagsFinal" class="headerlink" title="PrintFlagsFinal"></a>PrintFlagsFinal</h3><p>打印的值有两类，<code>=</code> 表示默认值；<code>:=</code> 表示被用户或者 JVM 修改后的值。<br>可以在命令行中使用 <code>java -XX:+PrintFlagsFinal -version</code> 来体验一把。</p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>专门用来查看 Java 进程的，跟 Linux 中的 ps 指令类似，可以使用 <code>jps -l</code> 来查看详细信息，更多的参数介绍可以在官方的文档中找到。</p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>可以用来查看正在运行的 JVM 进程的参数，不过需要你知道参数的名字才行，例如：<code>jinfo -flag MaxHeapSize [pid]</code> 、查看垃圾回收器的：<code>jinfo -flag [UseConcMarkSweepGC, UseG1GC] [pid]</code></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>可以查看 JVM 统计信息，例如类装载（-class）、垃圾收集（-gc）、JIT编译信息。<br>举个例子：<code>jstat -class [pid] 1000 10</code> 后面两个是可选的，意思是每隔 1000ms 输出一次，一共输出 10 次。<br>至于输出的是什么，文档里都有写，C 结尾表示的就是总量，U 结尾就是表示的已使用。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>简单起见可以参考这张图：</p>
<p><img src="/image/dev/JVM内存结构.png" alt="JVM内存结构"></p>
<p>非堆区也叫 Metaspace，是 JDK8+ 才有的，它移除了永久代的概念，使用堆外直接内存；其中的 CCS 不一定存在，当启用了指针压缩（64 -&gt; 32）才会有，CodeCache 是跟 JIT 编译相关的，还有一些其他的东西。<br>之前也看到过 64 位的 JVM 跟 32 位的 JVM 其实变化很大的，指针膨胀就是个大问题。</p>
<h2 id="关于内存溢出"><a href="#关于内存溢出" class="headerlink" title="关于内存溢出"></a>关于内存溢出</h2><p>OOM 应该是常见的一种情况了，常见的分析思路就是看 Dump 文件，也就是内存镜像文件，发生 OOM 时自动导出这个文件可以这样配置：<code>-XX:+HeapDumpOnOutOfMemoryError</code> 、<code>-XX:HeapDumpPath=./</code></p>
<p>除了自动导出，还可以使用 jmap 命令来手动导出。<br>例：<code>jmap -dump:format=b,file=heap.hprof [pid]</code> 、<code>jmap -heap [pid]</code></p>
<h3 id="使用MAT分析"><a href="#使用MAT分析" class="headerlink" title="使用MAT分析"></a>使用MAT分析</h3><p>这是 Eclipse 的一个工具，非常好用，官方地址：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a><br>载入 hprof 文件后，主页就会展示内存占用的分布情况，并且猜测那一块会有 OOM 的可能。<br>常用的就两个功能，查看对象的数量和查看对象占用的内存，一般来说只看强引用就行。<br>这个软件的详细用法 Google 一下。</p>
<h2 id="死循环与死锁"><a href="#死循环与死锁" class="headerlink" title="死循环与死锁"></a>死循环与死锁</h2><p>这里要介绍下 jstack 这个命令，它可以看到线程信息，当发现我们的 CPU 飙高，就有可能发生了死循环或者死锁的情况。<br>使用 jstack 输出指定 pid 的情况，然后重定向到一个文件里，拿下来分析就好了。</p>
<p>PS：使用 <code>top -p [pid] -H</code> 命令可以查看某个进程里面的线程情况，使用 <code>printf &quot;%x&quot; xxx</code> 可以将十进制的 pid 转换为 16 进制。</p>
<h2 id="jvisualvm可视化"><a href="#jvisualvm可视化" class="headerlink" title="jvisualvm可视化"></a>jvisualvm可视化</h2><p>jvisualvm 是 JDK 自带的一个工具，使用它可以可视化的监控 Java 程序的运行情况，当然，远程的也是可以进行监控的，不过需要设置了 JMX 才行。<br>然后，它可以安装第三方插件，推荐的两个插件是：VisualGC 和 BtraceWorkbench。</p>
<p>插件地址：<a href="http://visualvm.github.io/pluginscenters.html" target="_blank" rel="noopener">http://visualvm.github.io/pluginscenters.html</a><br>需要先把对应版本的源添加进配置里才可以下载安装。<br>并且官网是有中文版的教程的，可以看一看。</p>
<h2 id="Btrace调试"><a href="#Btrace调试" class="headerlink" title="Btrace调试"></a>Btrace调试</h2><p>它的作用是在我们的应用程序不重启不修改，正在运行的情况下动态修改字节码，达到监控调试的目的。<br>使用步骤按照官方文档，设置个 <strong>BTRACE_HOME</strong> 的环境变量就可以了，运行方式有两种，一种直接命令行：<code>btrace &lt;PID&gt; &lt;trace_script&gt;</code> ，另一种可以使用 jvisualvm 插件来配合实现。<br>脚本代码非常简单，跟我们的 Java 代码也很类似（拦截器），所以不要怕。</p>
<p>至于下载地址，在 Github 上搜就可以了，项目主页：<a href="https://github.com/btraceio/btrace" target="_blank" rel="noopener">https://github.com/btraceio/btrace</a></p>
<p>脚本示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArgSimple</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在那个类，那个方法，什么时候进行拦截</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    method=<span class="string">"arg1"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.ENTRY)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.printArray(args);</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写脚本所依赖的几个 jar 包在你下载的安装包里都有，使用也非常简单，直接跟类名就行，他没有包的概念，并且跟程序是独立的。</p>
<p>使用 -cp 来指定额外的 classpath 依赖第三方的类库。</p>
<h3 id="拦截方法"><a href="#拦截方法" class="headerlink" title="拦截方法"></a>拦截方法</h3><p>包括构造方法也是可以的，使用的是字节码风格 <code>&lt;init&gt;</code>。<br>默认是在入口的时候进行拦截，其他的拦截时机：</p>
<ul>
<li>ENTRY：入口（默认）</li>
<li>RETURN：返回</li>
<li>THROW：异常</li>
<li>Line：行</li>
</ul>
<p>如果你的代码有异常，但是被 try 给吃掉了，那么如何确定代码是否抛异常了呢，可以使用官方提供的一个代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOnThrow</span> </span>&#123;    </span><br><span class="line">  <span class="comment">// store current exception in a thread local</span></span><br><span class="line">  <span class="comment">// variable (@TLS annotation). Note that we can't</span></span><br><span class="line">  <span class="comment">// store it in a global variable!</span></span><br><span class="line">  <span class="meta">@TLS</span> </span><br><span class="line">  <span class="keyword">static</span> Throwable currentException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// introduce probe into every constructor of java.lang.Throwable</span></span><br><span class="line">  <span class="comment">// class and store "this" in the thread local variable.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow</span><span class="params">(@Self Throwable self)</span> </span>&#123;<span class="comment">//new Throwable()</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s)</span> </span>&#123;<span class="comment">//new Throwable(String msg)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow1</span><span class="params">(@Self Throwable self, String s, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(String msg, Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span></span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrow2</span><span class="params">(@Self Throwable self, Throwable cause)</span> </span>&#123;<span class="comment">//new Throwable(Throwable cause)</span></span><br><span class="line">    currentException = self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when any constructor of java.lang.Throwable returns</span></span><br><span class="line">  <span class="comment">// print the currentException's stack trace.</span></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"java.lang.Throwable"</span>,</span><br><span class="line">    method=<span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(Kind.RETURN)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onthrowreturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentException != <span class="keyword">null</span>) &#123;</span><br><span class="line">      BTraceUtils.Threads.jstack(currentException);</span><br><span class="line">      BTraceUtils.println(<span class="string">"====================="</span>);</span><br><span class="line">      currentException = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，你可以判断方法的某行代码是否执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMethod</span>(</span><br><span class="line">    clazz=<span class="string">"com.imooc.monitor_tuning.chapter4.Ch4Controller"</span>,</span><br><span class="line">    <span class="comment">// 支持使用正则表达式： /.*/</span></span><br><span class="line">    method=<span class="string">"exception"</span>,</span><br><span class="line">    location=<span class="meta">@Location</span>(value=Kind.LINE, line=<span class="number">20</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    BTraceUtils.println(pcn+<span class="string">","</span>+pmn + <span class="string">","</span> +line);</span><br><span class="line">    BTraceUtils.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理方法参数类型的时候，你可以使用 AnyType 来接收，也可以使用确定的类型。</p>
<p>生产环境下可以使用，但是要注意，被修改的字节码是不会被还原的，除非重启 JVM。</p>
<h2 id="tomcat调试"><a href="#tomcat调试" class="headerlink" title="tomcat调试"></a>tomcat调试</h2><p>使用 jpda 可以进行远程调试，相关的开启方法自行 Google，在配置文件中设置好端口后，在本地的 IDE 里直接填上就可以了。</p>
<p>tomcat 自带的管理界面比较简陋，更好的方案是使用 <strong>psi-probe</strong> 来监控，可以在 Github 上找到。</p>
<p>优化方面，主要着重的配置是：</p>
<ul>
<li>maxConnections<br>猫能够接受和处理的最大连接数，在 8+ 版本，使用了 NIO 技术，多路复用提高了性能。<br>使用 NIO 的情况下，默认是 10000</li>
<li>acceptCount<br>当连接数超出了最大值，进入一个等待队列，这个属性控制队列的大小，默认 100</li>
<li>maxThreads<br>配置工作线程的个数，默认是 200，同时并发处理的个数。</li>
<li>minSpareThreads<br>最小空闲的工作线程数，不要太小。</li>
<li>enableLookups<br>使用  <code>request.getRemoteHost()</code> 时进行 DNS 查询，建议禁用，8.5 默认禁用。</li>
<li>autoDeploy<br>猫运行时，要不要周期性的检查是不是有新应用需要部署，需要开一个线程来周期性检测，生产环境要关闭，默认开启。</li>
<li>reloadable<br>来监控 <code>/WEB-INF/classes/</code> 和 <code>/WEB-INF/lib</code> 的变化，同理建议禁用，8.5 默认禁用。<br>开发环境，用来支持热加载还是不错的。</li>
<li>protocol<br>在 server.xml 文件中配置，8+ 版本默认的使用 NIO，如果是高并发可以尝试使用 APR ，它使用的是 native 方法，性能会有一定提升。</li>
<li>分布式情况下，如果使用了 SpringSession 类似的解决方案，建议禁用猫的 session，尤其是使用 JSP 的时候。</li>
</ul>
<p>参考文档：docs/config/http.html、docs/config/host.html、docs/config/context.html</p>
<h2 id="nginx优化"><a href="#nginx优化" class="headerlink" title="nginx优化"></a>nginx优化</h2><p>配置文件的解读就不说了，Google 很多，要注意的是，配置反向代理要关闭 selinux，setenforce 0。<br>使用 <code>nginx -V</code> 可以查看编译参数。</p>
<p>使用 nginx 提供的 <strong>ngx_http_stub_status</strong> 配置来监控连接信息，要使用它需要将这个模块加入编译参数才行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = /nginx_status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">  allow 127.0.0.1;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个好用的工具 ngxtop，使用 python 的 pip 包管理直接 install 就好。<br>在 Github 上可以找到它的官方文档（不过这个项目已经不活跃了）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 基本使用</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询状态是 200 的</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -i 'status == 200'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查询访问最多的 ip</span><br><span class="line">ngxtop -c /etc/nginx/nginx.conf -g remote_addr</span><br></pre></td></tr></table></figure>
<p>再来介绍另一款图形化的监控工具：Nginx-rrd，这个是基于 PHP 来做的，所以需要 PHP 的相关依赖，然后需要在 php-fpm 中跟 nginx 统一用户，具体的配置还蛮多的，可以去 Google 一下。<br>它的原理是使用定时任务来扫描，每次都会存储成一张张的图片，最后使用 web 端来进行展示。</p>
<p>PS：这些监控工具都是基于 ngx_http_stub_status 来做的，所以上面那个 location 配置不能少。</p>
<hr>
<p>一些常见的基本的 Nginx 优化：</p>
<ul>
<li>增加工作线程数和并发连接数<br>默认情况下，Nginx 只有一个工作线程，并发数为 1024。</li>
<li>启用长连接<br>默认对客户端使用的是长连接，也可以对反向代理的后端使用长连接。</li>
<li>启用缓存、压缩</li>
<li>操作系统参数优化</li>
</ul>
<p>下面见一个示例的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 配置工作线程，受限于 CPU 的数量，一般配置与 CPU 的数量相等。</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">	# 每一个线程打开的最大连接数，包含 nginx 与客户端和 nginx 与 upstream 之间的连接</span><br><span class="line">	# 受限于操作系统，需要修改操作系统参数，默认 1024</span><br><span class="line">	worker_connections  10240;</span><br><span class="line">	# 可以一次建立多个连接</span><br><span class="line">	multi_accept on;</span><br><span class="line">	use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置与后端的长连接示例</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name loli.com;</span><br><span class="line"></span><br><span class="line">	# 配置反向代理的集群</span><br><span class="line">	upstream server_pool&#123;</span><br><span class="line">    server localhost:8080 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    server localhost:8081 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class="line">    # 300个长连接</span><br><span class="line">    keepalive 300;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	# 配置反向代理</span><br><span class="line">	location / &#123; </span><br><span class="line">		proxy_http_version 1.1;</span><br><span class="line">		proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">		proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">		proxy_pass http://server_poll/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以使用 <code>nginx -t</code> 来测试下配置文件是否正确。<br>开启缓存和压缩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">gzip_comp_level 2;</span><br><span class="line"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span><br><span class="line">gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;</span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"># 禁用IE 6 gzip</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line"># 开启缓存</span><br><span class="line">location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; </span><br><span class="line">    access_log   off; </span><br><span class="line">    expires      30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires      24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">    expires      1h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(eot|ttf|otf|woff|svg)$ &#123;</span><br><span class="line">    access_log   off;</span><br><span class="line">    expires max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 格式</span><br><span class="line"># expires 30s;</span><br><span class="line"># expires 30m;</span><br><span class="line"># expires 2h;</span><br><span class="line"># expires 30d;</span><br></pre></td></tr></table></figure>
<p>操作系统参数优化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /etc/sysctl.conf</span><br><span class="line"><span class="meta">#</span> ipv4 相关优化</span><br><span class="line"><span class="meta">#</span> 防止一个套接字在有过多试图连接到达时引起过载，默认为 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta">#</span> os 的一个等待队列，默认 128，连接队列</span><br><span class="line">sysctl -w net.core.somaxconn = 1024</span><br><span class="line"><span class="meta">#</span> timewait 超时时间，在 tcp 的四次挥手时的状态，此状态下虽然已经断开，但是不能拿来用，没必要太长</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout = 10</span><br><span class="line"><span class="meta">#</span> os 直接使用 timewait 的连接，默认 0 表示关闭</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span> timewait 回收禁用，默认 0，为了不必要的麻烦</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 每个进程打开文件数量的限制</span><br><span class="line"><span class="meta">#</span> /etc/security/limits.conf</span><br><span class="line">* hard nofile 204800</span><br><span class="line">* soft nofile 204800</span><br><span class="line">* soft core unlimited</span><br><span class="line">* soft stack 204800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> nginx 的 TCP 优化</span><br><span class="line">http &#123;</span><br><span class="line"><span class="meta">	#</span> 减少文件在应用和内核之间拷贝</span><br><span class="line">  sendfile           on;</span><br><span class="line"><span class="meta">  #</span> 当数据包达到一定大小再发送</span><br><span class="line">  tcp_nopush         on;</span><br><span class="line"><span class="meta">  #</span> 有数据随时发送</span><br><span class="line">  tcp_nodelay        off;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多详细配置参考：<br><a href="https://wsgzao.github.io/post/sysctl/" target="_blank" rel="noopener">https://wsgzao.github.io/post/sysctl/</a><br><a href="https://imququ.com/post/my-nginx-conf-for-wpo.html" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-wpo.html</a><br><a href="http://sfau.lt/b5DA5u" target="_blank" rel="noopener">http://sfau.lt/b5DA5u</a></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>如何选择垃圾收集器呢？</p>
<ul>
<li>优先调整堆大小，让服务器自己来选择</li>
<li>如果内存小于 100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或者 JVM 自己选</li>
<li>如果允许停顿时间超过 1 秒，选择并行或者 JVM 自己选</li>
<li>如果响应时间很重要，并且不能超过 1 秒，使用并发收集器</li>
</ul>
<p>几种垃圾收集器在之前的笔记里都有介绍，这里只作补充。<br>对于并行的 GC，是有自适应的特性的，就是说你给定几个指标（吞吐量、停顿时间等）它会自动调整堆大小，但这不是最优的方案，因为动态调整也是消耗性能的。<br>对应 Web 应用，我们还是比较关注停顿时间的，所以一般都是用并发的 GC，例如 CMS，这类收集器是对 CPU 敏感的，虽然跟用户线程并发执行，但是用户线程的 cpu 资源就少了，并且会产生浮动垃圾和空间碎片，在 G1 出现之前使用还是非常广泛的，在 J8 中官方推荐使用 G1。</p>
<p>G1 在 JDK7 开始提供，到 J8 已经比较成熟了，适用于大内存、低停顿的场景，在 J9 里 G1 已经成为默认的收集器，并且将 CMS 设置为废弃。<br>在 G1 中，老年代新生代是逻辑上的称呼了，它将堆分为一个个的 Region，还有一些成为 H 区用来存放大对象（超过了 Region 的一半）。<br>G1 中的 YoungGC 和传统的并没有什么区别，但是它没有了 FullGC，多了个 MixedGC，它回收所有 Young 和部分 Old，它也有并发标记的过程，默认堆的占有率达到 45% 就会触发。在每次 YGC 之后和 MGC 之前，会检查垃圾占比是否达到了某一个阀值，只有达到了才会发生 MGC。<br>G1 的相关概念和参数还多得多，这里不再一一举例。</p>
<p>G1 最佳实践：</p>
<ul>
<li>年轻代大小避免使用  -Xmn、 -XX:NewRatio 等显式设置，会覆盖暂停时间目标值</li>
<li>暂停时间目标时间不要太严苛，其吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间，太严苛会直接影响吞吐量。</li>
</ul>
<p>当发生了下面的几种情况，可以考虑切换到 G1 了：</p>
<ul>
<li>50% 以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过了 1 秒</li>
</ul>
<p>调优的过程就是在<strong>吞吐量</strong>和<strong>响应时间</strong>之间找平衡的过程，并且……在 J12 又带来了新的收集器 ZGC….。</p>
<p>参考资料：<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">J8 JVM 规范</a><br><a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">J8文档</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28" target="_blank" rel="noopener">J8 GC选择</a></p>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>既然是分析日志，那么首先得拿到日志，使用这些参数来开启，然后就有日志文件了，直接读也是可以的，不过可视化更方便，可以使用这个<a href="https://gceasy.io/" target="_blank" rel="noopener">在线分析</a>，或者使用 GCViewer（在 Github）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:$CATALINA HOME/logs/gc.log</span><br><span class="line"></span><br><span class="line">## 下面的不用也可以</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure>
<h3 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h3><p>先来看并行的 ParallelGC，指导原则：</p>
<ul>
<li>除非确定，否则不要设置最大堆内存</li>
<li>优先设置吞吐量目标</li>
<li>如果吞吐量目标达不到，调大最大内存，不能让 OS 使用 Swap，如果仍然达不到，降低目标</li>
<li>吞吐量能达到，GC 时间太长，设置停顿时间的目标</li>
</ul>
<p>这些在 Oracle 官方文档里都有写的。<br>关于 G1 的调优，参考上面的 G1 最佳实践规则就可以了。</p>
<p>调优过程要一个参数一个参数的设置，避免不知道是改的那个参数起的作用，然后这是个循序渐进的过程，不太可能一步到位的。<br>这一块的内容，还是去慕课网看视频比较好，文字不太好描述。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JVM 是基于栈的架构，相比经典的基于寄存器的架构来说，它的指令更短，但是指令数量会更多。<br>例如一个经典的问题，i++ 和 ++i 那个效率高，在 fori 循环里是很常用的，可以分析字节码，会发现这两种形式翻译的字节码是一样的，所以他们的效率其实是一样的。<br>然后再看下面的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String s = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    s = <span class="string">"ll"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么到底返回的是那个呢，答案是 hello，通过字节码可以看出，因为字符串是不可变对象，会将 hello 和 ll 同时压入两个本地变量，在走到 return 的时候把第一个也就是 hello 返回，然后又将第二个 ll 赋值给了第一个本地变量。</p>
<hr>
<p>我们知道在使用 + 进行字符串拼接时，默认会转换为 StringBuilder，那么这是绝对的么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">final</span> String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line">  String s2 = s1 + <span class="string">"Loli"</span>;</span><br><span class="line">  String s3 = s1 + s2;</span><br><span class="line">  System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以去分析字节码，这里就直接说结论，当 String 类型为 final 时，是在编译阶段就直接确定了，不会再进行拼接。<br>关于 String，还有一个很有趣的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s.intern();</span><br><span class="line">  String s2 = <span class="string">"1"</span>; </span><br><span class="line">  System.out.print1n(s == s2);</span><br><span class="line"></span><br><span class="line">  String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">  s3.intern();</span><br><span class="line">  String s4 = <span class="string">"11"</span>;</span><br><span class="line">  System.out.print1n(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK7- 和 JDK7+ 结果是不一样的，之前是两个 false，之后变成了 false 、 true，原因就是在 J7 之后字符串常量池移到了堆中，当使用 intern 方法并且常量池没有，堆中有的情况下，会将堆中的这个引用放到常量池中（常量池已经在堆中了），这样 s3 和 s4 就相等了。<br>G1 还有个字符串去重的功能（需要手动开启），也就是我们程序中字符串常量是占了很大比重的，而堆中和常量池中都有的话是很浪费的，当堆中字符串生命周期很长（有个阀值）就会触发去重操作。</p>
<hr>
<p>常见的代码优化：</p>
<ul>
<li>尽量重用对象，不要循环创建对象，比如：for 循环字符串拼接</li>
<li>容器类初始化的时候指定长度（List、Map）</li>
<li>集合遍历尽量减少重复计算（例如条件是不确定的 size）</li>
<li>尽量使用 Entry 来遍历 Map</li>
<li>尽量使用基本类型而不是包装类型</li>
<li>及时消除过期对象的引用，防止内存泄露</li>
<li>尽量使用局部变量，减小变量的作用域</li>
<li>ThreadLocal 缓存线程不安全的对象 SimpleDateFormat（J8 可以直接用新的 API DateTimeFormat 它是线程安全的）</li>
<li>尽量使用延时加载，例如单例模式（内部静态类）</li>
<li>尽量减少使用反射，用的话也尽量加缓存</li>
<li>慎用异常，不要用抛异常来表示正常业务逻辑，因为抛异常是比较重的操作，但是也别为了这个而不用，有些地方该用就得用。</li>
<li>String 操作尽量少用正则</li>
</ul>
<p>又一个有趣的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer a = <span class="number">100</span>;</span><br><span class="line">  Integer b = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">  </span><br><span class="line">  Integer c = <span class="number">1000</span>;</span><br><span class="line">  Integer d = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为 Integer 会自动缓存一个字节的数字，如果在缓存中直接返回，如果不在才 new，其他有的包装类型也有部分有缓存，比如 Long，不过 Double 这种肯定是没有的啦。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[体验ZooKeeper]]></title>
      <url>http://bfchengnuo.com/2019/02/26/%E4%BD%93%E9%AA%8CZooKeeper/</url>
      <content type="html"><![CDATA[<p>Apache ZooKeeper 是 Apache 软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，是主要用于分布式中<strong>一致性处理的框架</strong>。ZooKeeper 曾经是 Hadoop 的一个子项目，但现在是一个独立的顶级项目。<br>ZooKeeper 的架构通过冗余服务实现高可用性。ZooKeeper 节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。<a id="more"></a></p>
<p>Zookeeper 从设计模式角度来理解：是一个<strong>基于观察者模式设计的分布式服务管理框架</strong>，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应。</p>
<blockquote>
<p>所谓的一致性，实际上就是围绕着“看见”来的。谁能看见？能否看见？什么时候看见？<br>也对应着：强一致性、弱一致性、最终一致性。</p>
</blockquote>
<h2 id="ZK特点"><a href="#ZK特点" class="headerlink" title="ZK特点"></a>ZK特点</h2><ul>
<li>一个领导者（Leader），多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有<strong>半数以上（不包括一半）</strong>节点存活，Zookeeper 集群就能正常服务（所以集群最少 3 推荐奇数个）。</li>
<li>全局数据一致：每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致的。</li>
<li>更新请求顺序进行，来自<strong>同一个</strong> Client 的更新请求按其发送顺序依次执行。</li>
<li><strong>数据更新原子性，一次数据更新要么成功，要么失败</strong>。</li>
<li>实时性，在一定时间范围内，Client 能读到最新数据。</li>
</ul>
<p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，<strong>每个 ZNode 都可以通过其路径唯一标识</strong>。</p>
<p>需要注意的是 ZK 的选举过程是非常复杂的，也就是耗时比较长，选举过程整个集群不可用，所以说 ZK 是 CP 的，相对的 Eureka 则是 AP 设计的，他们的比较看<a href="https://bfchengnuo.com/2018/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A2%E7%B4%A2/#CAP%E5%AE%9A%E7%90%86">这里</a>就够了。</p>
<p><strong>为什么要保证半数以上？</strong><br>从概念上来说，ZooKeeper 它所做的就是确保对 Znode 树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，其余的副本最终也会更新到这个状态。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ZK 提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<ul>
<li>统一命名<br>在分布式场景下，经常需要对应用/服务进行统一命名，便于识别，例如 ip 和域名的关系。</li>
<li>统一配置管理<br>分布式中配置文件同步是常见的，一般要求在一个集群中，所有节点的配置是一致的。<br>对某一个节点的配置修改后也会快速同步到其他节点上。<br>因为客户端在监听，一旦 ZNode 中的数据变化，ZK 将通知各个客户端。</li>
<li>统一集群管理<br>分布式中，实时掌握每个节点的状态是必要的，可以根据节点的状态做出一些调整。<br>ZK 会将节点的相关信息一起写入到 ZNode 中。</li>
<li>服务器动态上下线<br>客户端能够实时的洞察服务器的上下线情况。<br>因为服务器注册的时候创建的是临时节点，服务器下线后会自动删除，ZK 会通知监听的客户端，然后客户端会去重新获取列表。</li>
<li>软负载均衡<br>ZK 可以记录每台服务器的访问次数，让访问最少的来处理最新的客户端请求。</li>
</ul>
<h2 id="安装ZK"><a href="#安装ZK" class="headerlink" title="安装ZK"></a>安装ZK</h2><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>windows 版的没啥好说的，就说说 linux 版，正常情况应该是搞集群的，不过测试用机器性能有限，开一个就行了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 解压</span><br><span class="line">tar -zxvf zookeeper-3.x.tar.gz -C /opt/module/</span><br><span class="line"><span class="meta">#</span> 进入 conf 文件夹修改配置文件名</span><br><span class="line"><span class="meta">#</span> 进入配置文件将 dataDir= 修改到指定的目录，需要自己创建文件夹，例如 zkData</span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">bin/zkServer.sh start</span><br><span class="line"><span class="meta">#</span> 查看进程使用 jps</span><br><span class="line"><span class="meta">#</span> 查看状态</span><br><span class="line">bin/zkServer.sh status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动客户端，退出 quit</span><br><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure>
<p>其他常用配置参数：</p>
<ul>
<li>tickTime<br>通信心跳数，Zookeeper 服务器与客户端心跳时间，单位毫秒。<br>它用于心跳机制，并且设置最小的 session 超时时间为两倍心跳时间。</li>
<li>initLimit<br>集群中的 Follower（跟随者）服务器与 Leader（领导者）服务器之间初始连接时能容忍的最多心跳数（总时间就是它乘以 tickTime），用它来限定集群中的 Zookeeper 服务器连接到 Leader 的时限。</li>
<li>syncLimit<br>同步通信时限，集群中 Leader 与 Follower 之间的最大响应时间单位，假如响应超过 syncLimit * tickTime，Leader 认为 Follwer 死掉，从服务器列表中删除 Follwer。</li>
<li>clientPort<br>客户端连接的端口</li>
</ul>
<p>客户端操作的常用命令：</p>
<table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>显示所有操作命令</td>
</tr>
<tr>
<td>ls path [watch]</td>
<td>使用 ls 命令来查看当前 znode 中所包含的内容</td>
</tr>
<tr>
<td>ls2 path   [watch]</td>
<td>查看当前节点数据并能看到更新次数等数据</td>
</tr>
<tr>
<td>create</td>
<td>普通创建   -s  含有序列   -e  临时（重启或者超时消失）</td>
</tr>
<tr>
<td>get path   [watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set</td>
<td>设置节点的具体值</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete</td>
<td>删除节点</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody>
</table>
<h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>解压跟上面一样，如果安装了 rsync 远程同步工具，可以使用 xsync 命令同步过去，然后在设置的数据文件夹目录下创建一个 myid 的文件，在里面写上对应的编号。<br>然后在所有的配置文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#######################cluster##########################</span><br><span class="line">server.2=hostname102:2888:3888</span><br><span class="line">server.3=hostname103:2888:3888</span><br><span class="line">server.4=hostname104:2888:3888</span><br><span class="line"></span><br><span class="line"># server.A=B:C:D</span><br><span class="line"># A 是一个数字，表示这个是第几号服务器，就是 myid 文件里写的那个数字，</span><br><span class="line">#   Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。</span><br><span class="line"># B 是这个服务器的 ip 地址；</span><br><span class="line"># C 是这个服务器与集群中的 Leader 服务器交换信息的端口；</span><br><span class="line"># D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</span><br></pre></td></tr></table></figure>
<p>最后分别启动就可以了，可以使用查看状态来查看。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>客户端使用 get 或者 ls2 命令获取到的信息解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">czxid - 创建节点的事务 zxid</span><br><span class="line">	每次修改 ZooKeeper 状态都会收到一个 zxid 形式的时间戳，也就是 ZooKeeper 事务 ID。</span><br><span class="line">	事务 ID 是 ZooKeeper 中所有修改总的次序。每个修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。</span><br><span class="line"></span><br><span class="line">ctime - znode被创建的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">mzxid - znode最后更新的事务zxid</span><br><span class="line"></span><br><span class="line">mtime - znode最后修改的毫秒数(从1970年开始)</span><br><span class="line"></span><br><span class="line">pZxid - znode最后更新的子节点zxid</span><br><span class="line"></span><br><span class="line">cversion - znode子节点变化号，znode子节点修改次数</span><br><span class="line"></span><br><span class="line">dataversion - znode数据变化号</span><br><span class="line"></span><br><span class="line">aclVersion - znode访问控制列表的变化号</span><br><span class="line"></span><br><span class="line">ephemeralOwner - 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</span><br><span class="line"></span><br><span class="line">dataLength - znode的数据长度</span><br><span class="line"></span><br><span class="line">numChildren - znode子节点数量</span><br></pre></td></tr></table></figure>
<p>主要留意最后两个就好了。</p>
<h2 id="重点内容"><a href="#重点内容" class="headerlink" title="重点内容"></a>重点内容</h2><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>半数机制：集群中半数以上机器存活，集群可用。所以 Zookeeper 适合安装<strong>奇数台服务器</strong>。<br>Zookeeper 虽然在配置文件中并没有指定 Master 和 Slave。但是，Zookeeper 工作时，是有一个节点为 Leader，其他则为 Follower，Leader 是通过内部的选举机制临时产生的。</p>
<p>选举机制简单说就是每个服务都首先选自己，如果超过了集群数量的半数以上，那么选举结果即确定，否则放弃选自己继而选择 id 比自己大的一个。<br>假设集群里有五台服务器，id 编号 1-5，依次启动他们。</p>
<ol>
<li>服务器 1 启动，此时只有它一台服务器启动了，它首先选择自己，但是发出去的报文没有任何响应，所以它的选举状态一直是 LOOKING 状态。</li>
<li>服务器 2 启动，它与最开始启动的服务器 1 进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以 id 值较大的服务器 2 胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是 3)，所以服务器 1、2 还是继续保持 LOOKING 状态。</li>
<li>服务器 3 启动，根据前面的理论分析，服务器 3 成为服务器 1、2、3 中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的 Leader。</li>
<li>服务器 4 启动，根据前面的分析，理论上服务器 4 应该是服务器 1、2、3、4 中最大的，但是由于前面已经有半数以上的服务器选举了服务器 3，所以只能作为 Follower，第五个也是类似。</li>
</ol>
<p>真实的选举机制是非常复杂的，所以耗时长，Leader 选举是保证分布式数据一致性的关键所在，期间还需要对投票是否有效等进行检查，一般会进行多轮投票才会选出。</p>
<p>非初始化的情况下，通常那台服务器上的数据越新（ZXID 会越大），其成为 Leader 的可能性越大，也就越能够保证数据的恢复。如果 ZXID 相同，则 SID 越大机会越大。</p>
<hr>
<p>Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议（Zookeeper Atomic broadcast protocol）。<br>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</p>
<p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。<br>状态同步保证了 leader 和 Server 具有相同的系统状态。</p>
<p>仅靠 Paxos 不能满足 ZooKeeper 需求。ZooKeeper 是一个树形结构，很多操作都要先检查才能确定能不能执行，例如创建 <code>/a/b</code> 之前要先确定 <code>/a</code> 的存在，我们就能从此看出 Paxos 的一致性达不到 ZooKeeper 一致性的要求，所以就有了 Zab 协议，它保证了：</p>
<ul>
<li>同一个 leader 的发起的事务要<strong>按顺序</strong>被 apply，同时还要保证只有先前的 leader 的所有事务都被 apply 之后，新选的 leader 才能在发起事务。</li>
<li>一些已经 Skip 的消息，需要仍然被 Skip。</li>
</ul>
<p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 Server 都恢复到一个正确的状态（包括数据的恢复）。<br>Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的；系统默认的选举算法为 fast paxos。<br>选完 leader 以后，zk 就进入状态同步过程。</p>
<blockquote>
<p>关于恢复模式。</p>
<p>选好新 leader 后它通过一个多数派获得老 leader 提交的最新数据；<br>老 leader 重启后，可能还会认为自己是 leader，可能会继续发送未完成的请求，从而因为两个 leader 同时存在导致算法过程失败；<br>解决办法是把 leader 信息加入每条消息的 id 中，Zookeeper 中称为 zxid 为一 64 位数字，高 32 位为 leader 信息又称为 epoch，每次 leader 转换时递增；低 32 位为消息编号，leader 转换时应该从 0 重新开始编号。<br>通过 zxid，follower 能很容易发现请求是否来自老 leader，从而拒绝老 leader 的请求。新 leader 首先要获得大多数节点的支持，然后从状态最新的节点同步事务，完成后才可正式成为 leader 发起事务。</p>
<ol>
<li>新 Leader 等待 server 连接；</li>
<li>Follower 连接 leader，将最大的 zxid 发送给 leader；</li>
<li>Leader 根据 follower 的 zxid 确定同步点；</li>
<li>完成同步后通知 follower 已经成为 uptodate 状态；</li>
<li>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</li>
</ol>
</blockquote>
<p>详细分析见：<br><a href="https://www.cnblogs.com/binyue/p/4270393.html" target="_blank" rel="noopener">https://www.cnblogs.com/binyue/p/4270393.html</a><br><a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/6107600.html</a><br><a href="https://www.cnblogs.com/sunddenly/p/4138580.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4138580.html</a><br><a href="https://www.jianshu.com/p/e126bb01331c" target="_blank" rel="noopener">https://www.jianshu.com/p/e126bb01331c</a></p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>节点的类型大体可分为两类：</p>
<ul>
<li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</li>
<li>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</li>
</ul>
<p>其中每一种里又细分为两类，目录节点和顺序编号目录节点，就如同名字一类会在后面加一个递增的序号，由父节点负责维护，可以用于排序，记录事件的顺序。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>当 ZK 客户端运行后，会创建两个线程，一个负责网络连接通信（connect）一个负责监听（listener）；<br>通过 connect 线程将注册监听事件发给 ZK，ZK 收到后会将其加入到监听列表，类似 <em>ip:port:监听内容</em> 这样的形式。<br>满足条件后，ZK 就会按照监听列表告诉客户端，然后 listener 线程会回调 process 方法。<br>监听一般分为两类，一种是数据变化的监听，一种是子节点变化的监听。</p>
<h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>首先 Client 向 ZooKeeper 的 Server1 上写数据，发送一个写请求。<br>如果 Server1 不是 Leader，那么 Server1 会把接受到的请求进一步转发给 Leader，这个 Leader 会将写请求广播给各个 Server，各个 Server 写成功后就会通知 Leader。<br>当 Leader 收到大多数 Server 数据写成功了，那么就说明数据写成功了。如果这里三个节点的话，只要有两个节点数据写成功了，那么就认为数据写成功了。<br>认为写成功之后，Leader 会告诉 Server1 数据写成功了，Server1 会进一步通知 Client 数据写成功了，这时就认为整个写操作成功。</p>
<p>所以，你可以知道 Zookeeper 并不保证读取的是最新数据，也就是强一致性，它只能保证最终一致性，同时它具有原子性：更新操作要么成功要么失败，没有中间状态。<br>而只需要一半以上写入完成即可认为成功也就好理解了，首先写操作只能由 Leader 发起，那么它肯定是最新的，后续可以同步给其他的 Follower，即使还没同步 Leader 就挂掉了，那么依然能保证新的 Leader 是有最新数据的，这就是靠 Zab 协议中的恢复模式了。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>使用原生 API 的基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleZkClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 收到事件通知后的回调函数</span></span><br><span class="line">        System.out.println(event.getType() + <span class="string">"---"</span> + event.getPath());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取子节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; children = zkClient.getChildren(<span class="string">"/"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      System.out.println(child);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建数据节点到 zk 中</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数1：要创建的节点的路径 </span></span><br><span class="line">    <span class="comment">// 参数2：节点的数据</span></span><br><span class="line">    <span class="comment">// 参数3：节点的权限</span></span><br><span class="line">    <span class="comment">// 参数4：节点的类型</span></span><br><span class="line">    String nodeCreated = zkClient.create(<span class="string">"/servers"</span>,</span><br><span class="line">                                         <span class="string">"hellozk"</span>.getBytes(),</span><br><span class="line">                                         Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                         CreateMode.PERSISTENT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断节点是否存在</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    Stat stat = zkClient.exists(<span class="string">"/java6"</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat == <span class="keyword">null</span> ? <span class="string">"not exist"</span> : <span class="string">"exist"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点的数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZnode</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">    <span class="comment">// 参数2：指定要删除的版本，-1 表示删除所有版本</span></span><br><span class="line">    zkClient.delete(<span class="string">"/java6"</span>, -<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点数据</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    zkClient.setData(<span class="string">"/java6"</span>, <span class="string">"I Miss you"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">"/java6"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器节点动态上下线示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String connectString = <span class="string">"192.168.169.129:2181,192.168.169.130:2181,192.168.169.131:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  ZooKeeper zkClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributedServer server = <span class="keyword">new</span> DistributedServer();</span><br><span class="line">    server.getConnect();</span><br><span class="line">    <span class="comment">// 利用zk连接注册服务器信息</span></span><br><span class="line">    server.registerServer(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 启动业务功能</span></span><br><span class="line">    server.handleBussiness(args[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建到zk的客户端连接</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zkClient = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向zk集群注册服务器信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerServer</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时序号节点</span></span><br><span class="line">    String create = zkClient.create(parentNode + <span class="string">"/server"</span>,</span><br><span class="line">                                    hostname.getBytes(), </span><br><span class="line">                                    Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                                    CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(hostname + <span class="string">"is online.."</span> + create);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 业务功能</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBussiness</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(hostname + <span class="string">"start working....."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line">  <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取zk连接</span></span><br><span class="line">    DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">    client.getConnect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servers的子节点信息，从中获取服务器信息列表</span></span><br><span class="line">    client.getServerList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务进程启动</span></span><br><span class="line">    client.business();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要再次启动监听</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          getServerList();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取服务器列表信息</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取服务器子节点信息，并且对父节点进行监听</span></span><br><span class="line">    List&lt;String&gt; children = zk.getChildren(parentNode, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.遍历所有节点，获取节点中的主机名称信息</span></span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = zk.getData(parentNode + <span class="string">"/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">      servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(servers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 业务功能</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"client is working ..."</span>);</span><br><span class="line">    Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于集群来说，无论是服务器还是消费端，都是客户端；服务端就是向集群添加信息，消费端就是监听信息。</p>
<h3 id="节点权限"><a href="#节点权限" class="headerlink" title="节点权限"></a>节点权限</h3><p><strong>ZK 的节点有 5 种操作权限：</strong><br>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这 5 种权限简写为 crwda 。<br>注：这 5 种权限中，delete 是指对子节点的删除权限，其它 4 种权限指对自身节点的操作权限。</p>
<p><strong>身份的认证有 4 种方式：</strong><br>world：默认方式，相当于全世界都能访问<br>auth：代表已经认证通过的用户(cli 中可以通过 <code>addauth digest user:pwd</code> 来添加当前上下文中的授权用户)<br>digest：即 <code>用户名:密码</code> 这种方式认证，这也是业务系统中最常用的<br>ip：使用 Ip 地址认证。</p>
<p>Java API 中，<code>Ids.OPEN_ACL_UNSAFE</code> ：默认匿名权限；<code>Ids.READ_ACL_UNSAFE</code> ：只读权限； <code>CREATOR_ALL_ACL</code> ：给创建该 znode 连接所有权限。 事实上这里是采用了 auth 验证模式，使用 sessionID 做验证，所以创建该 znode 的连接可以对该 znode 做任何修改。</p>
<h2 id="关于服务发现"><a href="#关于服务发现" class="headerlink" title="关于服务发现"></a>关于服务发现</h2><p>相比 ZK，现在也有了不少其他优秀的选择，感兴趣的可以了解下 etcd、consul、Eureka。</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Consul</th>
<th>zookeeper</th>
<th>etcd</th>
<th>euerka</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务健康检查</td>
<td>服务状态，内存，硬盘等</td>
<td>(弱)长连接，keepalive</td>
<td>连接心跳</td>
<td>可配支持</td>
</tr>
<tr>
<td>多数据中心</td>
<td>支持</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>kv 存储服务</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>—</td>
</tr>
<tr>
<td>一致性</td>
<td>raft</td>
<td>paxos</td>
<td>raft</td>
<td>—</td>
</tr>
<tr>
<td>CAP</td>
<td>CA</td>
<td>CP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>使用接口(多语言能力)</td>
<td>支持http和dns</td>
<td>客户端</td>
<td>http/grpc</td>
<td>http（sidecar）</td>
</tr>
<tr>
<td>watch支持</td>
<td>全量/支持long polling</td>
<td>支持</td>
<td>支持 long polling</td>
<td>支持 long polling/大部分增量</td>
</tr>
<tr>
<td>自身监控</td>
<td>metrics</td>
<td>—</td>
<td>metrics</td>
<td>metrics</td>
</tr>
<tr>
<td>安全</td>
<td>acl /https</td>
<td>acl</td>
<td>https支持（弱）</td>
<td>—</td>
</tr>
<tr>
<td>SpringCloud集成</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
<td>已支持</td>
</tr>
</tbody>
</table>
<p>真的是百家争鸣 o(￣▽￣<em>)ゞ))￣▽￣</em>)o</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/zero01/2108483" target="_blank" rel="noopener">https://blog.51cto.com/zero01/2108483</a><br><a href="https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/" target="_blank" rel="noopener">https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/</a><br><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/" target="_blank" rel="noopener">https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/</a></p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式中的那把锁]]></title>
      <url>http://bfchengnuo.com/2019/01/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E9%82%A3%E6%8A%8A%E9%94%81/</url>
      <content type="html"><![CDATA[<p>现在的面试，动不动就微服务、分布式、高并发、缓存、并发编程等，不管用不用得到，你反正得会才行，分布式锁也算是很重要的一块，之前我在 <a href="https://github.com/bfchengnuo/MyRecord/issues/22" target="_blank" rel="noopener">Github 的 issues</a> 中写过，现在单独摘出来再总结下，因为真的问的太多了。</p>
<p>分布式锁，是控制分布式系统之间<strong>同步访问共享资源的一种方式</strong>。<a id="more"></a><br>在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要<strong>互斥来防止彼此干扰来保证一致性</strong>，在这种情况下，便需要使用到分布式锁。</p>
<p>传统实现分布式锁的方案一般是利用持久化数据库（如利用 InnoDB 行锁，或事务、乐观锁），大部分时候可以满足大部分人的需求。<br>而如今互联网应用的量级已经几何级别的爆发，利用诸如 zookeeper、redis 等更高效的分布式组件来实现分布式锁，可以提供高可用的更强壮的锁特性，并且支持丰富化的使用场景。</p>
<p>开源实现已有不少比如 Redis 作者基于 Redis 设计的 Redlock、Redission 等。</p>
<p>常见的分布式锁的实现：</p>
<ol>
<li>Memcached 分布式锁<br>利用 Memcached 的 add 命令。此命令是<strong>原子性操作</strong>，只有在 key 不存在的情况下，才能 add 成功，也就意味着线程得到了锁。</li>
<li>Redis 分布式锁<br>和 Memcached 的方式类似，利用 Redis 的 setnx 命令。此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。（setnx 命令并不完善，后续可能会介绍替代方案）</li>
<li>Zookeeper 分布式锁<br>利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。</li>
<li>Chubby<br>Google 公司实现的粗粒度分布式锁服务，底层利用 Paxos 一致性算法。</li>
<li>Etcd<br>后起之秀，从读写性能、可靠性、可用性、安全性和复杂度等方面综合考量，它完全媲美业界 “名宿” ZooKeeper，在有些方面，Etcd 甚至超越了 ZooKeeper。</li>
</ol>
<p>这里也就说说他们实现的原理，具体的代码并不会完整的贴出来。</p>
<h2 id="Memcached实现"><a href="#Memcached实现" class="headerlink" title="Memcached实现"></a>Memcached实现</h2><p>Memcached 是一个自由开源的，高性能，分布式内存对象缓存系统。<br>Memcached 是一种<strong>基于内存的 key-value 存储</strong>，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API 调用或者是页面渲染的结果。<br>Memcached 简洁而强大。它的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题。它的 API 兼容大部分流行的开发语言。本质上，它是一个简洁的 key-value 存储系统。<br>一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<br>分布式锁也就是用了 add 操作原子性的特点，用伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mc.Add(<span class="string">"LockKey"</span>, <span class="string">"Value"</span>, expiredTime))&#123;</span><br><span class="line">  <span class="comment">//得到锁</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//do business function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查超时</span></span><br><span class="line">    <span class="keyword">if</span> (!CheckedTimeOut())&#123;</span><br><span class="line">      mc.Delete(<span class="string">"LockKey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    mc.Delete(<span class="string">"LockKey"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，现在大部分都用 Redis 来搞了。</p>
<h3 id="与Redis比较"><a href="#与Redis比较" class="headerlink" title="与Redis比较"></a>与Redis比较</h3><p>看到这里就不得不说它和 Redis 的区别了：</p>
<ol>
<li>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash, 有序&amp;无序列表 数据结构的存储。</li>
<li>Redis支持数据的备份，即 master-slave 模式的数据备份。</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis 可以实现主从复制，实现故障恢复。</li>
<li>Redis 的 Sharding 技术： 很容易将数据分布到多个 Redis 实例中</li>
<li>Redis 支持服务器端的数据操作</li>
<li>使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。</li>
<li>由于 Redis 只使用单核，而 Memcached 可以使用多核，单实例吞吐量极高，可以达到几十万 QPS，但是平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。</li>
<li>Memcached 是多线程，分为监听线程、worker 线程，引入锁，带来了性能损耗。Redis 使用单线程的 IO 复用模型，将速度优势发挥到最大，也提供了较简单的计算功能 。</li>
</ol>
<p>Redis 中有不少好用的命令，例如 getset，比先 get 然后再 set 来回的网络开销不知道好了多少倍。<br>不过还是要根据实际情况来选择使用。</p>
<blockquote>
<p>为什么 Redis 采用单核单线程？</p>
<p>因为 CPU 不是 Redis 的瓶颈。Redis 的瓶颈最有可能是机器内存或者网络带宽。<br>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>PS：普通笔记本轻松处理每秒几十万的请求</p>
<p><strong>如果万一 CPU 成为你的 Redis 瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？</strong></p>
<p>那也很简单，你多起几个 Redis 进程就好了。Redis 是 key-value 数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。<br>redis-cluster 可以帮你做的更好。</p>
</blockquote>
<h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><blockquote>
<p>参见笔记地址：<a href="https://github.com/bfchengnuo/MyRecord/blob/315f44429d31f73661e617c96b081fad2cbb1e33/%E7%AC%94%E8%AE%B0/Java/Web/%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md" target="_blank" rel="noopener">MyRecord</a></p>
</blockquote>
<p>使用 Redis 实现分布式锁首先要先知道几个 Redis 的命令，分布式锁就是通过这几个命令来实现的</p>
<ul>
<li>setnx<br>只有不存在的时候，setnx 才会设置值成功；<br>可以理解为是否存在和设置值这两条命令的集合版，不过是原子性的。</li>
<li>getset<br>先 get 再 set，也是两条命令的整合，具有原子性。</li>
<li>expire<br>设置有效期</li>
<li>del<br>删除</li>
</ul>
<h3 id="实现原理-流程"><a href="#实现原理-流程" class="headerlink" title="实现原理-流程"></a>实现原理-流程</h3><p>首先使用 setnx 存入一个值，key 为锁名，val 为当前的时间戳加一个超时时间，这是为了防止死锁。</p>
<p><img src="https://user-images.githubusercontent.com/16206117/45962253-02682b80-c053-11e8-8873-06ebe570140f.png" alt="one"></p>
<p>仔细看这个架构好像有点问题，因为我们设置的 val 根本没用，也没有任何的防死锁措施，只是实现比较简单而已，更完善的第二版在这：</p>
<p><img src="https://user-images.githubusercontent.com/16206117/45962340-39d6d800-c053-11e8-8bf1-f073a31debc8.png" alt="two"></p>
<p>当获取锁失败时，为了防止死锁，我们还需要进行一些判断，只要判定时间已经超时，就可以认为可以尝试去得到锁，然后接下来判断新的值写进去了没，只有新的时间戳写进去了才能认为是得到锁了，这样基本就不会出现死锁的情况了，下面来看看具体的代码。</p>
<h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>按照有瑕疵的第一张流程实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">  <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>,<span class="string">"5000"</span>));</span><br><span class="line"></span><br><span class="line">  Long setnxResult = RedisShardedPoolUtil</span><br><span class="line">    .setnx(</span><br><span class="line">    Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">    String.valueOf(System.currentTimeMillis()+lockTimeout)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">    closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    log.info(<span class="string">"没有获得分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 有效期5秒，防止死锁</span></span><br><span class="line">  RedisShardedPoolUtil.expire(lockName,<span class="number">5</span>);</span><br><span class="line">  log.info(<span class="string">"获取&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">           Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">           Thread.currentThread().getName());</span><br><span class="line">  <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil</span><br><span class="line">                              .getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">  orderService.closeOrder(hour);</span><br><span class="line">  <span class="comment">// 删除 key，释放锁</span></span><br><span class="line">  RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  log.info(<span class="string">"释放&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">           Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">           Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这个防不了死锁，我们设置的超时时间也没用到，当执行到 closeOrder 方法之前宕掉的话，那么因为这个 key 没有设置有效期，就会到期其他模块一直进不去。<br>closeOrder 中的设置有效期和执行后的删除键（释放锁）也是双重防死锁，这个有效期需要根据线上运行的实际情况来得出一个合理的时间。</p>
<h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>循序渐进，来看看如何解决死锁问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron=<span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">  <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>,<span class="string">"5000"</span>));</span><br><span class="line">  Long setnxResult = RedisShardedPoolUtil.setnx(</span><br><span class="line">    Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">    String.valueOf(System.currentTimeMillis()+lockTimeout));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>)&#123;</span><br><span class="line">    closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未获取到锁，继续判断，判断时间戳，看是否可以重置并获取到锁</span></span><br><span class="line">    String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    <span class="keyword">if</span>(lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123;</span><br><span class="line">      String getSetResult = RedisShardedPoolUtil.getSet(</span><br><span class="line">        Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">        String.valueOf(System.currentTimeMillis()+lockTimeout));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据返回的旧值，判断是否可以获取锁</span></span><br><span class="line">      <span class="keyword">if</span>(getSetResult == <span class="keyword">null</span></span><br><span class="line">         || (getSetResult != <span class="keyword">null</span> </span><br><span class="line">             &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123;</span><br><span class="line">        <span class="comment">//已真正获取到锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        log.info(<span class="string">"没有获取到分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      log.info(<span class="string">"锁未失效，没有获取到分布式锁:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看上去基本就是万无一失了，前半段并不需要修改，我们在 else 后做了一个超时判断，来觉得是否可以重置锁，这个判断可是不简单呢。<br>首先通过 get 方法来获取 val，用这个 val 和当前时间的时间戳来判断是否超时，然后我们使用 getset 方法重新获取老值，并且重新设置超时时间（原子操作）；<br>根据返回的旧值，判断是否可以获取锁，这里会有三种情况：</p>
<ul>
<li>当 key 没有旧值时，即 key 不存在时，返回 nil 对应 Java 中的 Null 这说明其他分布式程序已经执行完使用 del 删除了键（释放了锁）或者过了 Redis 的生存时间； 这时可以安全获取锁。</li>
<li>当 key 有旧值，并且旧值和之前获取的一致的情况下 这说明这段时间没有程序操作这把锁，并且因为 getset 之后重新设置了有效期，可以保证现在也是安全的，可以获取锁。</li>
<li>当 key 有旧值，并且旧值和之前获取的不一致的情况下 这说明在程序执行期间有其他的分布式模块也操作了这把锁，并且对方比较快，先执行了 getset 这就导致两个旧值对不起来，这种情况下只能放弃，等待下次获取。</li>
</ul>
<h3 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h3><p>先来看看基本的介绍：</p>
<blockquote>
<p>Redisson 是架设在 Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）。<br>充分的利用了 Redis 键值数据库提供的一系列优势，基于 Java 实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，<strong>更进一步简化了分布式环境中程序相互之间的协作。</strong><br>Redisson 采用了基于 NIO 的 Netty 框架，不仅能作为 Redis 底层驱动<strong>客户端</strong>，具备提供对 Redis 各种组态形式的连接功能，对 Redis 命令能以同步发送、异步形式发送、异步流形式发送或管道形式发送的功能，LUA 脚本执行处理，以及处理返回结果的功能，还在此基础上融入了更高级的应用方案。<br>Redisson 生而具有的高性能，分布式特性和丰富的结构等特点恰巧与 Tomcat 这类服务程序对会话管理器（Session Manager）的要求相吻合。利用这样的特点，Redisson 专门为 Tomcat 提供了会话管理器（Tomcat Session Manager）。<br>在此不难看出，Redisson 同其他 Redis Java 客户端有着很大的区别，<strong>相比之下其他客户端提供的功能还仅仅停留在作为数据库驱动层面上</strong>，比如仅针对 Redis 提供连接方式，发送命令和处理返回结果等。像上面这些高层次的应用则只能依靠使用者自行实现。</p>
</blockquote>
<p>可以看出 Redisson 对分布式一些工具做了很好的封装，如今分布式盛行的年代下，越来越多的项目使用 Redisson 作为 Redis 的客户端，使用它可以更方便的使用 Redis 分布式锁，来看第三版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RLock lock = redissonManager</span><br><span class="line">    .getRedisson()</span><br><span class="line">    .getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">  <span class="keyword">boolean</span> getLock = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(getLock = lock.tryLock(<span class="number">0</span>,<span class="number">50</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">      log.info(<span class="string">"Redisson获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">               Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">               Thread.currentThread().getName());</span><br><span class="line">      <span class="keyword">int</span> hour = Integer</span><br><span class="line">        .parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">      orderService.closeOrder(hour);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      log.info(<span class="string">"Redisson没有获取到分布式锁:&#123;&#125;,ThreadName:&#123;&#125;"</span>,</span><br><span class="line">               Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,</span><br><span class="line">               Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">"Redisson分布式锁获取异常"</span>,e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!getLock)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    log.info(<span class="string">"Redisson分布式锁释放锁"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中使用了 Redisson 提供的 RLock 对象来获取、释放锁，这其实是一种<strong>可重入锁</strong>，Redisson 还提供了其他的多种锁，就不多说了；用这个来实现分布式锁原理其实是一样的，只不过被 Redisson 封装后更加的简单了。<br>使用 RLock 的 tryLock 方法来尝试获取锁，可以使用三个参数的构造，第一个是最多等待时间（超时就直接过了），第二个是自动解锁时间，第三个是时间单位。<br>这里的等待时间如果预估不准可以写 0，否则就会出现同时获得锁的情况，也就是程序执行的太快，还没超过等待时间所以又被第二个拿到了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外，关掉 Tomcat 的时候如果你不是直接 kill 掉，而是温柔的杀死他，使用 <em>shutdown</em>，那么可以使用这个注解来保证在它死之前执行 del 删除锁来避免死锁，虽然这很不现实，如果方法执行时间过长很多人也不能忍受。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有类似的好用注解，例如 @PostConstruct 标注 init 方法，会在构造完成后执行这个初始化。</p>
<h2 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h2><p>常见的实现方式又分两种，但总的来说并不常用，因为用数据库的话比较费资源，效率也不高：</p>
<ul>
<li>完全基于数据库表的</li>
<li>基于数据库排它锁</li>
</ul>
<p>参见：<a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1716</a></p>
<h3 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h3><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。<br><strong>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</strong><br>创建这样一张数据库表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<p>当我们想要锁住某个方法时，执行以下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对<code>method_name</code>做了<strong>唯一性约束</strong>，这里如果有多个请求同时提交到数据库的话，<strong>数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁</strong>，可以执行方法体内容。<br>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<p>上面这种简单的实现有以下几个问题：</p>
<ol>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是<strong>非阻塞</strong>的，因为数据的 insert 操作，一旦插入失败就会直接报错。<br>没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是<strong>非重入</strong>的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<p>当然，我们也可以有其他方式解决上面的问题。</p>
<ul>
<li>数据库是单点？<br>搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li>
<li>没有失效时间？<br>只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li>
<li>非阻塞的？<br>搞一个 while 循环，直到 insert 成功再返回成功。</li>
<li>非重入的？<br>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><p>除了可以通过增删操作数据表中的记录以外，其实还可以<strong>借助数据中自带的锁来实现分布式的锁</strong>。<br>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于 MySql 的 InnoDB 引擎，可以使用以下方法来实现加锁操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        result = <span class="string">"select * from methodLock where method_name=xxx for update"</span>;</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁。</p>
<blockquote>
<p>这里再多提一句，InnoDB 引擎在加锁的时候，<strong>只有通过索引进行检索的时候才会使用行级锁</strong>，<strong>否则会使用表级锁</strong>。<br>这里我们希望使用行级锁，就要给 method_name 添加索引，值得注意的是，这个索引<strong>一定要创建成唯一索引</strong>，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。<br>当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p>
</blockquote>
<p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>connection.commit()</code>操作来释放锁。<br>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p>
<ul>
<li>阻塞锁？<br><code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li>
<li>锁定之后服务宕机，无法释放？<br>使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li>
</ul>
<p>但是还是无法直接解决数据库单点和可重入问题。</p>
<blockquote>
<p>这里还可能存在另外一个问题，虽然我们对 method_name 使用了唯一索引，并且显示使用 <code>for update</code> 来使用行级锁。<br>但是，MySql 会对查询进行优化，即便在条件中使用了索引字段，但<strong>是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的</strong>，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p>
</blockquote>
<p><strong>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下使用数据库来实现分布式锁的方式，这两种方式<strong>都是依赖数据库的一张表</strong>，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p>
<ul>
<li><strong>优点</strong><br>直接借助数据库，容易理解。</li>
<li><strong>缺点</strong><br>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。<br>操作数据库需要一定的开销，性能问题需要考虑。<br>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</li>
</ul>
<p>关于其他的各种锁，参加  <a href="https://github.com/bfchengnuo/MyRecord/issues/5" target="_blank" rel="noopener">issues</a>，整理中…</p>
<h2 id="Zookeeper实现"><a href="#Zookeeper实现" class="headerlink" title="Zookeeper实现"></a>Zookeeper实现</h2><p>基于 zookeeper 临时有序节点可以实现的分布式锁。<br>大致思想即为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点，操作完成后断开自动删除。<br>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个（非阻塞情况下，直接判断有没有节点就好了）。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。<br>来看下 Zookeeper 能不能解决前面提到的问题。</p>
<ul>
<li>锁无法释放？<br>使用 Zookeeper 可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在 ZK 中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session 连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li>
<li>只能是非阻塞锁？<br>使用 Zookeeper 可以实现阻塞的锁，客户端可以通过在 ZK 中<strong>创建顺序节点</strong>，并且在节点上<strong>绑定监听器</strong>，一旦节点有变化，Zookeeper 会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li>
<li>不可重入？<br>使用 Zookeeper 也可以有效的解决不可重入的问题，客户端在创建节点的时候，<strong>把当前客户端的主机信息和线程信息直接写入到节点中</strong>，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。<br>如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li>
<li>单点问题？<br>使用 Zookeeper 可以有效的解决单点问题，ZK 是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ul>
<p>可以直接使用 zookeeper 第三方库 <a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a> 客户端，这个客户端中封装了一个可重入的锁服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    interProcessMutex.release();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    log.error(e.getMessage(), e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), </span><br><span class="line">                             delayTimeForClean,</span><br><span class="line">                             TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Curator 提供的 InterProcessMutex 是分布式锁的实现。acquire 方法用户获取锁，release 方法用于释放锁。</p>
<h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><p>使用 ZK 实现的分布式锁好像完全符合了我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper 实现的分布式锁其实存在一个缺点，那就是<strong>性能上可能并没有缓存服务那么高</strong>。<br>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同不到所有的 Follower 机器上。</p>
<hr>
<p>其实，使用 Zookeeper 也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可能和 ZK 集群的 session 连接断了，那么 zk 以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。<br>就可能产生并发问题。这个问题不常见是因为 zk 有重试机制，一旦 zk 集群检测不到客户端的心跳，就会重试， Curator 客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。<br>所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>优点</strong><br>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。<br>实现起来较为简单。</li>
<li><strong>缺点</strong><br>性能上不如使用缓存实现分布式锁。<br>需要对 ZK 的原理有所了解。</li>
</ul>
<h2 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h2><p>上面几种方式，哪种方式都无法做到完美。就像 CAP 一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>
<ul>
<li><strong>从理解的难易程度角度（从低到高）</strong><br>数据库 &gt; 缓存 &gt; Zookeeper</li>
<li><strong>从实现的复杂性角度（从低到高）</strong><br>Zookeeper &gt;= 缓存 &gt; 数据库</li>
<li><strong>从性能角度（从高到低）</strong><br>缓存 &gt; Zookeeper &gt;= 数据库</li>
<li><strong>从可靠性角度（从高到低）</strong><br>Zookeeper &gt; 缓存 &gt; 数据库</li>
</ul>
<p>目前来说，一提到分布式锁很多人第一反应就是 Redis，但是分布式锁本质是一个 CP 需求，基于 Redis 的实现的是一个 AP 需求，不过脱离业务场景来谈架构都是耍流氓。<br>例如，业务是金融交易这种需要强锁的情况下，Redis 就不太行了，需要 CP 的实现，例如 etcd 等。</p>
<blockquote>
<p>一个<strong>分布式计算系统来说</strong>，不可能同时满足以下三点：</p>
<ul>
<li><strong>一致性（Consistency）</strong><br>等同于所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong><br>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</li>
<li><strong>分区容错性（Partition tolerance）</strong><br>以实际效果而言，分区相当于对通信的时限要求。<br>系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li>
</ul>
<p><strong>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项</strong>。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>其他没有说到的就自己搜索探寻吧！</p>
<p><a href="https://gitbook.cn/books/5bb037728f7d8b7e900ff2d7/index.html" target="_blank" rel="noopener">想了解 etcd 的点这</a><br><a href="http://catkang.github.io/2017/09/29/chubby.html" target="_blank" rel="noopener">想了解 Chubby 的点这</a></p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初探SpringCloud]]></title>
      <url>http://bfchengnuo.com/2018/09/23/%E5%88%9D%E6%8E%A2SpringCloud/</url>
      <content type="html"><![CDATA[<p>如期而至，关于什么是 SpringCloud 这里不多说，之前的<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Web/SpringCloud%E7%94%9F%E6%80%81%E5%9C%88.md" target="_blank" rel="noopener">笔记</a>已经把 SpringCloud 生态的主要技术都做了解释，但是这里对笔记进行补充一下，关于微服务、微服务架构，以及 SpringBoot 与 Cloud、Dubbo 之间微妙的关系做个简单的解释~<a id="more"></a><br>然后就是实践部分，先搞一个简单的 Demo 出来试试~</p>
<p>微服务：一种架构风格，重点在个体，拆分为单个的模块，具体的一个服务，仅关注自己负责的，比如现在流行使用 SpringBoot 来构建。<br>微服务架构：重点在整体，关注各个微服务之间的关系，如何治理好这些微服务，她要求各个微服务独立部署，能拥有“独立的空间（例如独立的数据库）”，现在流行使用 SpringCloud 提供的一站式解决方案构建。<br>微服务目前业内还没有一个准确的概念，<del>上面的是我瞎说的</del> o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br>说到微服务架构就必须要分布式了，其中涉及的还有服务注册发现中心、服务调用方式（轻量级网络协议交互，REST、RPC）、服务监控、断路器、服务网关、分布式配置、服务跟踪、服务总线、数据流、批量任务等等。</p>
<p>可以看出，SpringCloud 作为全局的服务治理框架，它依赖于 SpringBoot，而与 Dubbo 的最显著区别就是 SpringCloud 使用 REST；Dubbo 使用 RPC。<br>使用 REST 更加灵活，并且语言无关，但是没有 RPC 的效率高，同时 RPC 也存在一些自身的问题。</p>
<blockquote>
<p>当前由于 RPC 协议，注册中心元数据不匹配等问题，在面临微服务基础架构选型时，Dubbo 和 SpringCloud 只能二选一，所以才会出现两者的比较。<br>Dubbo 负责人表示之后会积极寻求适配到 SpringCloud 生态</p>
</blockquote>
<p>如果 Dubbo 不停更 5 年的话，说不定又是另一番景象呢。</p>
<h2 id="微服务搭建"><a href="#微服务搭建" class="headerlink" title="微服务搭建"></a>微服务搭建</h2><p>这个不是重点，但是确实前提条件，所以需要先用 SpringBoot 搭出至少两个微服务，一个做服务提供，一个做服务消费，然后在这个基础上加 SpringCloud。<br>关于 SpringCloud 的生态圈涉及的技术太多了，看了不少视频和资料，大部分都是对主要的几个技术来做介绍，实际上也大部分都是用这些技术，其他的也就不多说了，感兴趣的可以去官方或者<a href="https://springcloud.cc/" target="_blank" rel="noopener">中文网</a>逛逛，挺全的。</p>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>使用 Eureka 来实现服务的注册与发现，介绍之前说过了不多说，它分为客户端和服务端，一般会新建一个项目（微服务）作为服务端，这里就需要加入 SpringCloud 的依赖管理来负责做版本仲裁，然后也需要加入 EureKa 服务端的依赖，注意是以结尾的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在启动类使用注解开启功能，这个是 SpringCloud 的通用套路，先加依赖，然后在启动类添加 @EnableXXX 开启相关配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明这是一个Eureka服务</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，配置一下相关参数就可以启动测试了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中，本身就是,所以无需注册</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Eureka客户端与Eureka服务端进行交互的地址</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>
<p>访问一下就可以看到相关的系统信息了，下面就可以把之前创建的微服务服务方注册到 Eureka 中了，如果某个微服务确定没有其他的微服务依赖它，那可以不用注册进来；<br>方法和之前的套路一样，加入 SpringCloud 的依赖管理，加入 Eureka 的依赖（可以是客户端也可以是服务端，推荐客户端），然后关键的地方就是配置文件的修改了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span> </span><br><span class="line">    <span class="comment"># 指定服务名，非常重要</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-item</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中，默认为 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息，默认为true</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line">  <span class="comment"># 将自己的 ip 地址注册到 Eureka 服务中</span></span><br><span class="line"><span class="attr">  instance:</span> </span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 可以手动指定地址，可以可以通过表达式来获取</span></span><br><span class="line">    <span class="comment"># $&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></span><br><span class="line"><span class="attr">    ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>最后，在主启动类上加入 <code>@EnableDiscoveryClient</code> 注解，表名这是个客户端即可。<br>另一个作为消费端的微服务也是一样，唯一不同的是配置文件里就不需要将自己注册到 Eureka 服务中了，也不需要设置了 instance 了。<br>具体使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">queryItemById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    String serviceId = <span class="string">"microService-item"</span>;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.discoveryClient.getInstances(serviceId);</span><br><span class="line">    <span class="keyword">if</span>(instances.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了演示，在这里只获取一个实例</span></span><br><span class="line">    ServiceInstance serviceInstance = instances.get(<span class="number">0</span>);</span><br><span class="line">    String url = serviceInstance.getHost() + <span class="string">":"</span> + serviceInstance.getPort();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://"</span> + url + <span class="string">"/item/"</span> + id, Item.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果导入的是服务端依赖，某些版本的 SpringCloud 会响应 XML 格式的数据，而我们希望它是 JSON，破坏了 SpringMVC 的默认配置，可以在 eureka server 的依赖中排除 jackson-dataformat-xml。<br>对于 eureka 来说，这两个微服务都属于客户端，所以还是建议只导客户端依赖就好。<br>另外，你还可以开启 Eureka 的身份认证，需要导入相应的依赖，一旦开启，需要在客户端配置好凭证。</p>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>Eureka 的集群非常好搭建，为了避免单点故障，集群是很有必要的，只要启动多个 Eureka 服务并且让这些服务之间彼此进行注册即可实现。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中,这次选择 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址，选择另一台 Eureka 服务端</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://loli:pwd@127.0.0.1:6869/eureka/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############## 第二台服务端 ################</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6869</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microService-eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到 Eureka 服务中,这次选择 true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从Eureka中获取注册信息</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="comment"># Eureka 客户端与 Eureka 服务端进行交互的地址，选择另一台 Eureka 服务端</span></span><br><span class="line"><span class="attr">    serviceUrl:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">security:</span> </span><br><span class="line"><span class="attr">  basic:</span> </span><br><span class="line">    <span class="comment"># 开启基于 HTTP basic 的认证</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">  user:</span> </span><br><span class="line"><span class="attr">    name:</span> <span class="string">loli</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">pwd</span></span><br></pre></td></tr></table></figure>
<p>他们的 defaultZone 互相指向对方，通过端口来区分，而微服务名字都是保持一致的，这样服务端的集群就搭建好了，而客户端注册的时候需要同时向这两台来注册，地址之间使用逗号分割。</p>
<h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>之前说过，Eureka 和 ZK 的一个区别，ZK 是按照 CP 原则来构建的，而 Eureka 是 AP 来做的。<br>默认情况下，如果 Eureka Server 在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server 将会移除该实例。但是当网络分区故障发生时，微服务与 Eureka Server 之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。<br>当 Eureka Server 节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server 就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该 Eureka Server 节点会自动退出自我保护模式。<br>Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，<strong>对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</strong><br>我们在单机测试的时候很容易满足心跳失败比例在 15 分钟之内低于 85%，这个时候就会触发 Eureka 的保护机制，一旦开启了保护机制，则服务注册中心维护的服务实例就不是那么准确了，此时我们可以使用<code>eureka.server.enable-self-preservation=false</code>来关闭保护机制，这样可以确保注册中心中不可用的实例被及时的剔除（<strong>不推荐</strong>）。</p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>这里再以 properties 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#================================服务端==============================</span><br><span class="line">#应用名称</span><br><span class="line">spring.application.name=eureka-server-v1</span><br><span class="line">#应用端口</span><br><span class="line">server.port=7000</span><br><span class="line">#=======eureka中心配置=======</span><br><span class="line">#主机名</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line"># 注册时显示ip</span><br><span class="line">#eureka.instance.prefer-ip-address=true</span><br><span class="line">#是否注册为服务</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">#是否检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line">#eureka默认空间的地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br><span class="line">#关闭自我保护(生产时打开该选项)</span><br><span class="line">eureka.server.enable-self-preservation=false</span><br><span class="line">#扫描失效服务的间隔时间（缺省为60*1000ms）</span><br><span class="line">eureka.server.eviction-interval-timer-in-ms=5000</span><br><span class="line"></span><br><span class="line">#================================客户端==============================</span><br><span class="line">#端口号</span><br><span class="line">server.port=8081</span><br><span class="line">#服务名</span><br><span class="line">spring.application.name=produce-service-v1</span><br><span class="line">#=======eureka配置========</span><br><span class="line">#注册到eureka中心，获取到配置服务</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:7000/eureka/</span><br><span class="line">#设置实例的ID为ip:port</span><br><span class="line">eureka.instance.instance-id=$&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;</span><br><span class="line">#========续约配置=========</span><br><span class="line"># 心跳时间，即服务续约间隔时间（缺省为30s）</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=5</span><br><span class="line"># 发呆时间，即服务续约到期时间（缺省为90s）</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=10</span><br><span class="line"># 开启健康检查（依赖spring-boot-starter-actuator）</span><br><span class="line">eureka.client.healthcheck.enabled=true</span><br></pre></td></tr></table></figure>
<p>这些应该够用了吧…..</p>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>使用 Ribbon 实现<strong>客户端负载均衡</strong>，说到负载均衡，可以简单分为两类：</p>
<ul>
<li>集中式<br>消费方和服务方中间使用独立的 LB 设施，例如 F5、nginx 这类就是。</li>
<li>进程内<br>一般集成到消费方，Ribbon 就是如此。</li>
</ul>
<p>使用前的老一套不说了，导入依赖（eureka-server 中已经包含了 Ribbon 的依赖），在主启动类使用 @RibbonClient （简单使用可以不加）进行配置工具类。<br>然后，在 Config 创建 RestTemplate 对象上设置 <code>@LoadBalanced</code> 注解就表示已经启用负载均衡啦！</p>
<blockquote>
<p>开启后，在执行请求前会经过 <code>org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor</code> 这个拦截器，并且通过 <code>org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</code> 的时候会根据 serverId 查找服务地址，然后在去做真正的请求；<br>所以 RestTemplate 请求的 URL 可以直接使用服务名，而不需要手动获取地址了。</p>
</blockquote>
<p>Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、 配置中心、 API 网关那样需要独立部署， 但是它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。 因为微服务间的调用，API 网关的请求转发等内容实际上都是通过Ribbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon实现的工具。<br>SpringCloud 服务调用的方式一般就是两种：</p>
<ul>
<li>Ribbon + RestTemplate</li>
<li>Feign</li>
</ul>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>Ribbon 自带了七中负载均衡的算法。默认轮询，当想选择其他算法时，在配置类里使用 @Bean 声明需要的官方提供的 IRule 其他实现类即可，这是 SpringBoot 自动配置的知识了。<br>也正是因为这个原因，如果我们想自己实现负载均衡算法，除了需要在启动类使用 @RibbonClient 注解指定服务名和负载均衡算法具体实现类（需要在 @Configuration 下）外，<strong>还要求这个类不能在包扫描范围内</strong>。<br>首先，可以自定义负载均衡规则，可以在配置文件里设置也可以使用注解：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">microService-consumer:</span>  </span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>
<p>在启动类上设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">// 在启动该微服务的时候就能去加载我们的自定义 Ribbon 配置类，从而使配置生效</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name=<span class="string">"MICROSERVICECLOUD-DEPT"</span>,configuration=MySelfRule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是实现自己的负载均衡算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 随机使用 RoundRobinRule();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestLB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLB</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，默认的轮询就已经够用了。</p>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>使用 Feign 实现声明式的 REST 调用，是为了简化 RestTemplate 的使用，让我们的代码更优雅，添加依赖就不多说了，主启动类加上 <code>@EnableFeignClients</code> 注解，这也是加在客户端（消费端）的。<br>然后声明一个接口，然后可以像写 SpringMVC 哪样来定义这个接口的方法啦！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明这是一个Feign客户端，并且指明服务 id</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"microService-item"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemFeignClient</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里定义了类似于SpringMVC用法的方法，就可以进行RESTful的调用了</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/item/&#123;id&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Item <span class="title">queryItemById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 多参数构造-1</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">get1</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id, @<span class="title">RequestParam</span><span class="params">(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line">  <span class="comment">// 多参数构造-2</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">get2</span><span class="params">(@RequestParam Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Feign 使用，简单说：创建一个接口（使用 @FeignClient 标注），在上面使用 SpringMVC 注解即可；相当于封装了 RestClient。<br>只需要定义接口就可以完成调用，很显然是用了动态代理，在 FeignClient 中的定义方法以及使用了 SpringMVC 的注解，Feign 就会根据注解中的内容生成对应的 URL，然后<strong>基于 Ribbon 的负载均衡去调用 REST 服务</strong>。</p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>使用 Hystrix 的熔断机制保护应用，在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。<br>它是在服务端（服务提供方）使用的技术，使用起来非常简单，除了必要的依赖、在主启动类使用 <code>@EnableHystrix</code> 注解开启功能，只需要在 Service 的方法上加上 <code>@HystrixCommand(fallbackMethod
= &quot;fallbackMethod&quot;)</code> 注解就可以了，其中 fallbackMethod 是具有类似方法签名的备用方法，当此方法的调用不可用时就会走这个备用方法。<br>但是这里会有一个问题，如果一个核心方法对应一个备用方法，很容易就会造成方法膨胀，耦合性还很高，这样也太不优雅了，所以可以使用 AOP 的思想来解决这个问题嘛~其实这样可以做服务降级，配合 Feign 来使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该接口下哪个方法抛异常，会调 fallbackFactory</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"MICROSERVICECLOUD-DEPT"</span>,fallbackFactory=MyFallbackFactory.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeptClientService</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">DeptClientService</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以达到容错的目的了，说到这里，不得不提涉及的两个概念，服务降级和服务熔断。</p>
<blockquote>
<ul>
<li><p>服务熔断<br>主逻辑因短期内多次失败（也有可能是由于自我保护机制），而被暂时性的忽略，不再尝试使用，这种叫熔断。</p>
</li>
<li><p>服务降级:<br>主逻辑失败采用备用逻辑的过程叫做降级（<del>也就是服务降级发生在服务熔断之后</del>）。<br>当整体资源快消耗殆尽的时候（例如内存、CPU等），将某些服务临时关掉一大部分以释放资源（一般留下一个来维持运行返回给用户友好的提示），减轻主模块的压力，待资源恢复可用再开启。</p>
</li>
</ul>
<p>看上去熔断和降级是非常相似的，都是调用失败后调用备用方法；但是他们的着重点是不同的。<br>不管是服务降级还是熔断，他们的目的都是为了保证程序的健壮性，对于一些非核心服务，如果出现大量的异常，可以通过技术手段，对服务进行降级并提供有损服务，保证服务的柔性可用，避免引起雪崩效应。<br>开启熔断之后，如何实现自动恢复？<br>每隔一段时间，会释放一个请求到服务端进行探测，如果后端服务已经恢复，则自动恢复。</p>
</blockquote>
<p>此外，Hystrix 还具有服务监控的功能，它提供了准实时的调用监控 HystrixDashboard，是可视化界面，可以进行实时监测。<br>这个监控使用非常简单，新建一个微服务，加入相关依赖，在启动类上加上 <code>@EnableHystrixDashboard</code> 就可以用啦！</p>
<h2 id="SpringCloudZuul"><a href="#SpringCloudZuul" class="headerlink" title="SpringCloudZuul"></a>SpringCloudZuul</h2><p>因为之前笔记有，介绍咱们还是略过，简单理解为它相当于是个过滤器或者拦截器就好了，继续新建一个微服务，导入相关依赖，在主启动类加入 <code>@EnableZuulProxy</code> 注解。<br>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供 REST API 的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能，将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。<br>从上面的介绍可以看出，它还需要 Eureka 等依赖加强功能，让后面的微服务专心做自己的事情。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6677</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-api-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span> </span><br><span class="line"><span class="attr">  ignored-services:</span> <span class="string">"*"</span></span><br><span class="line"><span class="attr">  prefix:</span> <span class="string">/atguigu</span></span><br><span class="line"><span class="attr">  routes:</span> </span><br><span class="line">    <span class="comment"># 名字可以随意起</span></span><br><span class="line"><span class="attr">    item-service:</span></span><br><span class="line">      <span class="comment"># 配置请求 URL 的请求规则</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/item-service/**</span></span><br><span class="line">      <span class="comment"># 真正的微服务地址，可以使用 url ，也可以指定 Eureka 注册中心中的服务 id</span></span><br><span class="line">      <span class="comment"># url: http://127.0.0.1:8081</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">microservice-item</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否注册自己，默认为true</span></span><br><span class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span> </span><br><span class="line">    <span class="comment"># 将自己的ip地址注册到Eureka服务中</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="string">app.name:</span> <span class="string">microcloud</span></span><br><span class="line">  <span class="string">company.name:</span> <span class="string">www.bfchengnuo.com</span></span><br><span class="line">  <span class="string">build.artifactId:</span> <span class="string">$project.artifactId$</span></span><br><span class="line">  <span class="string">build.version:</span> <span class="string">$project.version$</span></span><br></pre></td></tr></table></figure>
<p>同时，Zuul 还支持正则匹配、拦截器、路由前缀等功能，由于是入门，这里就不多说了。</p>
<h2 id="SpringCloudConfig"><a href="#SpringCloudConfig" class="headerlink" title="SpringCloudConfig"></a>SpringCloudConfig</h2><p>使用 SpringCloudConfig 统一管理微服务的配置，可以让我们统一管理配置文件，以及实时同步更新，并不需要重新启动应用程序，默认使用 Git 存储配置文件内容。<br>同样，它也分为客户端和服务端，服务端可以新建一个微服务，加入相应的依赖，在主启动类加上 <code>@EnableConfigServer</code> 注解就可以使用了，当然还是要写一点配置的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6688</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-config-server</span></span><br><span class="line"><span class="attr">  cloud:</span>  </span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span> </span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://172.16.55.138:10080/bfchengnuo/config-server.git</span></span><br><span class="line">          <span class="comment">#username: loli</span></span><br><span class="line">          <span class="comment">#password: 123456</span></span><br></pre></td></tr></table></figure>
<p>还是推荐使用 SSH 密钥认证的方式，这样就可以通过 SpringCloudConfig 直接访问 Git 上的配置文件，同时它支持 properties 和 yml 的互相转换，通过请求地址的后缀实现。<br>客户端的使用也是类似，导入没有 server 后缀的依赖，另外为了避免地址的硬编码，可以将服务端使用 @EnableDiscoveryClient 也注册到 Eureka 中，然后在客户端使用服务名来访问。<br>需要新建配置文件：<code>bootstrap.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line">      <span class="comment"># 对应的配置服务中的应用名称</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">microservice</span></span><br><span class="line">      <span class="comment"># uri: http://127.0.0.1:6869/</span></span><br><span class="line">      <span class="comment"># 对应配置服务中的 &#123;profile&#125;</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      discovery:</span> </span><br><span class="line">      	<span class="comment"># 启用发现服务功能</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 指定服务名称</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">microservice-config-server</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>bootstrap.yml</code> 优先与 <code>application.yml</code> 加载（先读取了配置才能启动啊），所以把发现服务配置在 bootstrap 里。<br>然后你可以使用 @Value 来注入配置，就是和配置文件在本地是一样使用。<br>为了能够让配置自动更新，还需要为 Config Client 添加 refresh 支持，就是导入一个 <code>spring-boot-starter-actuator</code> 依赖，然后在配置类对应的实体类上加上 <code>@RefreshScope</code> 注解（测试可以临时把 actuator 安全认证关掉 <code>management.security.enabled</code>）。<br>然后就可以使用 post 请求 <code>/refresh</code> 地址来更新配置内容了。<br>更新后还需要手动访问下这个地址未免太麻烦了，所以，可以借助 git 的 webhook（web 钩子）实现自动更新。</p>
<h2 id="SpringCloudBus"><a href="#SpringCloudBus" class="headerlink" title="SpringCloudBus"></a>SpringCloudBus</h2><p>消息总线 Spring Cloud Bus 也是很重要的，例如它可以更优雅的完成自动更新配置文件，简单的你可以理解为它就是个消息的交换机，所有的微服务模块都监听它，所以可以实现配置、缓存等的更新。<br>以 RabbitMQ 为例，就先在 ConfigServer 中来加入吧，导入 spring-cloud-starter-bus-amqp 依赖，在 application.yml 添加 rabbitmq 的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:6868/eureka/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">microservice</span></span><br><span class="line">      <span class="comment"># uri: http://127.0.0.1:6869/</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      discovery:</span> </span><br><span class="line">        <span class="comment"># 启用发现服务功能</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">microservice-config-server</span></span><br><span class="line">  <span class="comment"># RabbitMQ 相关的配置</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>
<p>然后，会自动注册一个 <code>/bus/refresh</code> 的请求，这个请求就是由消息总线来处理的，那么我们可以设置当配置更新后 web 钩子向统一配置服务器发送 <code>/bus/refresh</code> 请求，然后配置服务器会将消息发送到 springCloudBus 的交换机，由于其他微服务的队列也绑定到交换机，所以也就都获取到了更新的通知，然后去 ConfigServer 获取最新的数据。<br>需要注意，其他的微服务（客户端）这个 bus 配置是要写在 bootstrap.yml 中的，保证优先加载。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/3463571febc2" target="_blank" rel="noopener">https://www.jianshu.com/p/3463571febc2</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式中数据一致性探索]]></title>
      <url>http://bfchengnuo.com/2018/09/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<p>关于这个，在面试中好像出境频率挺高的，现在都搞微服务、分布式（至于项目适不适合搞，嘿嘿）不懂一点确实说不过去，关于这点其实以前看过，但是当别人问起还是一脸萌逼，查了查资料感觉以前看过，然后过段时间再问，再懵逼…..这就必须得做笔记了！<a id="more"></a><br>这篇基本都是概念性的东西，原理懂了下面的就好办了，基础最重要嘛~</p>
<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>首先，来看一下著名的 CAP 定理：</p>
<blockquote>
<p>在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个<strong>分布式计算系统来说</strong>，不可能同时满足以下三点：</p>
<ul>
<li><strong>一致性（Consistency）</strong><br>等同于所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong><br>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</li>
<li><strong>分区容错性（Partition tolerance）</strong><br>以实际效果而言，分区相当于对通信的时限要求。<br>系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li>
</ul>
<p><strong>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项</strong>。</p>
</blockquote>
<p>如果我们选择的是<strong>可用性(Availability，简称 A)</strong>， 就是系统能提供服务就好， 数据不一致可以忍受。<br>在网络节点之间无法通信的情况下,  和数据复制相关的功能， 要么选择可用性(A) , 要么选择一致性(C)， 不能同时选择两者。<br>如果选择了可用性(A) + 分区容错性(P) ,  就要放弃一致性(C)。<br>如果选在一致性(C) + 分区容错性(P) , 就得放弃可用性(A) 。<br>在选择 CP 的情况下，虽然系统的有些功能是不能使用的（放弃了 A）， 因为需要等待数据的同步， <strong>但是那些和数据同步无关的功能还是可以访问的 ， 相当于系统做了功能的降级。</strong><br>既然有 AP 和 CP,    会不会出现仅仅是 CA（一致性+可用性）这种组合呢？ 就是没有分区容错性， 只保留可用性和一致性？ 仔细想想， 这种情况其实就退化成了单机应用， 没有意义了。<br>然后，既然要做分布式，P 是肯定的，那么只能从 C 和 A 里再选择一个了，常见的有：<br><img src="/image/dev/CAP.png" alt=""><br>其中，常用的 Zookeeper 保证的是 CP，而 Eureka 则是 AP</p>
<blockquote>
<p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接 down 掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。<br>但是 zk 会出现这样一种情况，当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间太长，30 ~ 120s, 且选举期间整个 zk 集群都是不可用的，这就导致在选举期间注册服务瘫痪。<br>在云部署的环境下，因网络问题使得 zk 集群失去 master 节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<hr>
<p>Eureka 看明白了这一点，因此在设计时就优先保证可用性。Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。<br>而 Eureka 的客户端在向某个 Eureka 注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台 Eureka 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p>
<ol>
<li>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </li>
<li>Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
</blockquote>
<p>因此， Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper 那样使整个注册服务瘫痪。<br>Eureka 作为单纯的服务注册中心来说要比 zookeeper 更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况。不过 Eureka 目前 1.X 版本的实现是基于 servlet 的 java web 应用，它的极限性能肯定会受到影响。期待正在开发之中的 2.X 版本能够从 servlet 中独立出来成为单独可部署执行的服务（虽然闭源了）。</p>
<h2 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h2><p>XA 是由 X/Open 组织提出的分布式事务的规范。XA 规范主要定义了（全局）事务管理器（Transaction Manager）和（局部）资源管理器（Resource Manager）之间的接口。<br>XA 接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。<br>XA 引入的事务管理器充当上文所述全局事务中的“协调者”角色。事务管理器控制着全局事务，管理事务生命周期，并协调资源。资源管理器负责控制和管理实际资源（如数据库或 JMS 队列）。<br>目前，Oracle、Informix、DB2、Sybase 和 PostgreSQL 等各主流数据库都提供了对 XA 的支持。</p>
<h2 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h2><blockquote>
<p>Java 事务 API（Java Transaction API，简称 JTA ） 是一个 Java 企业版 的应用程序接口，在 Java 环境中，允许完成跨越多个 XA 资源的分布式事务。JTA 是在 Java 社区过程下制定的规范，编号 JSR 907。</p>
</blockquote>
<p>作为 Java 平台上事务规范 JTA（Java Transaction API）也定义了对 XA 事务的支持，实际上，<strong>JTA 是基于 XA 架构上建模的</strong>。<br>在 JTA 中，事务管理器抽象为 <code>javax.transaction.TransactionManager</code> 接口，并通过底层事务服务（即 Java Transaction Service）实现。像很多其他的 Java 规范一样，<strong>JTA 仅仅定义了接口，具体的实现则是由供应商(如 J2EE 厂商)负责提供</strong>，目前 JTA 的实现主要有以下几种：</p>
<ul>
<li>J2EE 容器所提供的 JTA 实现(如JBoss)。</li>
<li>独立的 JTA 实现：如 JOTM（Java Open Transaction Manager），Atomikos。<br>这些实现可以应用在那些不使用 J2EE 应用服务器的环境里用以提供分布事事务保证。</li>
</ul>
<p>JTA 的使用示例（伪代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UserTransaction userTx = <span class="keyword">null</span>;</span><br><span class="line">Connection connA = <span class="keyword">null</span>;</span><br><span class="line">Connection connB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  userTx = getContext().lookup(<span class="string">"java:comp/userTransaction"</span>);</span><br><span class="line">  <span class="comment">// connA = 从数据库 A 获取连接</span></span><br><span class="line">  <span class="comment">// connB = 从数据库 B 获取连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动分布式事务</span></span><br><span class="line">  userTx.begin();</span><br><span class="line">  <span class="comment">// 在数据库 A 中执行操作</span></span><br><span class="line">  <span class="comment">// 在数据库 B 中执行操作</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  userTx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">  <span class="comment">// 回滚</span></span><br><span class="line">  userTx.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JTA 并没有取得像 JDBC 那样的广泛应用，分布式事务伴随着大量节点的通信交换， 协调者要确定其他节点是否完成， 加上网络带来的超时，导致 JTA 性能低下， 在高并发和高性能的场景下举步维艰。<br>很多应用服务器 Websphere , Weblogic 等都支持 JTA， 可是使用者确是寥寥无几， 都快成摆设了。<br>这个标准太理想化，完全不符合实情，总是想着让两个数据库保证实时的一致性（强一致性）， 为了达到这个目标，JTA 付出的代价太高了。</p>
<h2 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h2><p>事务我们非常熟悉，特性 ACID，回滚非常的好用，但是一般只对单个数据库有用，如果需要夸数据库就会比较尴尬。</p>
<hr>
<p>在计算机网络以及数据库领域内，二阶段提交（英语：Two-phase Commit）是指，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。<br>通常，<strong>二阶段提交也被称为是一种协议(Protocol)</strong>。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。<br>当一个事务跨越多个节点时，为了保持事务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终<strong>指示这些节点是否要把操作结果进行真正的提交</strong>(比如将更新后的数据写入磁盘等等)。<br>因此，二阶段提交的算法思路可以概括为： <strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<blockquote>
<p>需要注意的是，二阶段提交(英文缩写：2PC)不应该与并发控制中的二阶段锁(英文缩写：2PL)进行混淆。<br>wiki：<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4</a></p>
</blockquote>
<hr>
<p>两阶段提交协议：<br>由于涉及到多个分布式的数据库， 我们特设一个全局的事务管理器，它来负责协调各个数据库的事务提交， 为了实现分布式事务，需要两个阶段：</p>
<ul>
<li><strong>阶段一</strong><br>全局的事务管理器向各个数据库发出准备消息。 各个数据库需要在本地把一切都准备好，执行操作，锁住资源， 记录 redo/undo 日志， 但是并不提交。<br>总而言之，要进入一个时刻准备提交或回滚的状态， 然后向全局事务管理器报告是否准备好了。</li>
<li><strong>阶段二</strong><br>如果所有的数据库都报告说准备好了， 那全局的事务管理器就下命令： 提交！这时候各个数据库才真正提交，由于之前已经万事具备，只欠东风，只需要快速完成本地提交即可。<br>如果有任何一个数据库报告说没准备好， 事务管理器就下命令： 放弃！这时候各个数据库要执行回滚操作， 并且释放各种在阶段1锁住的资源。</li>
</ul>
<p><img src="/image/dev/二阶段提交.png" alt=""></p>
<p>阶段1就是让大家都准备好，阶段2就是迅速提交。<br>但是，一旦涉及到分布式，事情就不会那么简单，任何地方都有失败的可能。<br>比如在第二阶段，那个事务管理器要是出了问题怎么办？ 人家各个数据库还在等着你发命令呢？ 你迟迟不发命令，大家都阻塞在那里，不知所措，到底是提交呢？还是不提交呢， 我这里还锁着资源呢， 迟迟不能释放，多耽误事啊 ！<br>还是第二阶段，事务管理器发出的提交命令由于网络问题，数据库１收到了，数据库２没收到，这两个数据库就处于不一致状态了， 该怎么处理？</p>
<blockquote>
<p>拓展：<br>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型，或者叫 XA 规范， X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。<br><strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是根据这一思想衍生出来的。</p>
</blockquote>
<h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><blockquote>
<p>三阶段提交（英语：Three-phase commit），也叫三阶段提交协议（英语：Three-phase commit protocol），是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。</p>
<p><strong>三阶段提交是为解决两阶段提交协议的缺点而设计的。</strong></p>
</blockquote>
<p>与两阶段提交不同的是，三阶段提交是<strong>“非阻塞”协议</strong>。三阶段提交在两阶段提交的第一阶段与第二阶段<strong>之间插入了一个准备阶段</strong>，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<hr>
<p>与 2PC 想比，3PC 主要有两个改动点：</p>
<ol>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的</li>
</ol>
<h3 id="第一阶段CanCommit"><a href="#第一阶段CanCommit" class="headerlink" title="第一阶段CanCommit"></a>第一阶段CanCommit</h3><p>这一阶段和 2PC 的准备阶段很像：</p>
<ol>
<li><strong>事务询问</strong><br>协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li>
<li><strong>响应反馈</strong><br>参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No</li>
</ol>
<h3 id="第二阶段PreCommit"><a href="#第二阶段PreCommit" class="headerlink" title="第二阶段PreCommit"></a>第二阶段PreCommit</h3><p>协调者根据参与者的反应情况来决定是否可以执行事务的 PreCommit 操作。根据响应情况，有以下两种可能。<br><strong>假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</strong></p>
<ol>
<li><strong>发送预提交请求</strong><br>协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。</li>
<li><strong>事务预提交</strong><br>参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。</li>
<li><strong>响应反馈</strong><br>如果参与者成功的执行了事务操作，<strong>则返回 ACK 响应</strong>，同时开始等待最终指令。</li>
</ol>
<hr>
<p><strong>假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<ol>
<li><strong>发送中断请求</strong><br>协调者向所有参与者发送 abort 请求。</li>
<li><strong>中断事务</strong><br>参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
<h3 id="第三阶段doCommit"><a href="#第三阶段doCommit" class="headerlink" title="第三阶段doCommit"></a>第三阶段doCommit</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。<br><strong>执行提交：</strong></p>
<ol>
<li><strong>发送提交请求</strong><br>协调接收到参与者发送的 ACK 响应（第二阶段发送的），那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</li>
<li><strong>事务提交</strong><br>参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li>
<li><strong>响应反馈</strong><br>事务提交完之后，<strong>向协调者发送 ACK 响应</strong>。</li>
<li><strong>完成事务</strong><br>协调者接收到所有参与者的 ACK 响应之后，完成事务。</li>
</ol>
<hr>
<p><strong>中断事务</strong> 协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p>
<ol>
<li><strong>发送中断请求</strong><br>协调者向所有参与者发送 abort 请求</li>
<li><strong>事务回滚</strong><br>参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li>
<li><strong>反馈结果</strong><br>参与者完成事务回滚之后，<strong>向协调者发送 ACK 消息</strong></li>
<li><strong>中断事务</strong><br>协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。</li>
</ol>
<blockquote>
<p>在 doCommit 阶段，如果参与者无法及时接收到来自协调者的 doCommit 或者 rebort 请求时，会在等待超时之后，会继续进行事务的提交。<br>其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了 PreCommit 请求，那么协调者产生 PreCommit 请求的前提条件是他在第二阶段开始之前，收到所有参与者的 CanCommit 响应都是  Yes。<br>一旦参与者收到了 PreCommit，意味他知道大家其实都同意修改了；<br>所以，一句话概括就是，<strong>当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到 commit 或者 abort 响应，但是他有理由相信：成功提交的几率很大。</strong></p>
</blockquote>
<h3 id="与2PC的区别"><a href="#与2PC的区别" class="headerlink" title="与2PC的区别"></a>与2PC的区别</h3><p>相对于 2PC，3PC <strong>主要解决的单点故障问题，并减少阻塞</strong>，因为一旦参与者无法及时收到来自协调者的信息之后，<strong>他会默认执行 commit</strong>。而不会一直持有事务资源并处于阻塞状态。<br><strong>但是这种机制也会导致数据一致性问题</strong>，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。<br>了解了 2PC 和 3PC 之后，我们可以发现，<strong>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</strong><br>Google Chubby 的作者 Mike Burrows 说过：</p>
<blockquote>
<p>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos. </p>
</blockquote>
<p>意即<strong>世上只有一种一致性算法，那就是 Paxos</strong>，所有其他一致性算法都是 Paxos 算法的不完整版。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>知道了上面的知识，我们可以退一步，也就是我们可以忍受一段时间的不一致，只有最终一致就行。 比方说 A 给 B 转 100 元， A 中的钱已经扣除， 但是 B 中不会实时地增加，过段时间能保证增加就行了。</p>
<blockquote>
<p>“ 假设两个账户（吕秀才和郭芙蓉）在两个独立的数据库中， 我们原来设计的 JTA 是要求从吕秀才账户减去 100 两银子， 然后在郭芙蓉账户加上 100 两银子， 这两个操作要么全部做完，要么全部不做， 但是在网络的环境下， 这是不大容易做到的， 或者说在高并发的情况下做到的代价太高。”</p>
</blockquote>
<p><img src="/image/dev/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A71.png" alt=""></p>
<p>我们想从吕秀才账户转 100 两银子给郭芙蓉， 需要在数据库 1 发起一个事务， 从吕秀才账户扣除 100 两， 然后还得向消息队列插入一条给郭芙蓉账号增加 100 两的消息， 然后这个数据库 1 的事务就结束了！<br>消息队列中的消息会在某一刻被读取出来，进行处理，给郭芙蓉的账号增加 100 两。<br>至于这个加钱的操作什么时候执行，这个时间不确定， 就看具体怎么实现了， 比如有个后台程序定期运行，读取消息来处理，消息队列的数据都是持久化到硬盘上的， 不用怕宕机会丢失。<br>假设数据库 2 down 机了， 对郭芙蓉有两种选择：<br>一种是由于系统原因，转账操作完全不能操作；<br>另外一种是可以转账，但是钱稍后到账；<br>你说郭芙蓉会选哪一种？<br>这就是最终一致性，数据在某些时候看起来不一致，但是同步内容都在消息队列中暂存着，等数据处理完成，数据还是一致的。<br>第一种情况是完全不可用， 第二种只是是部分可用，对于高并发的场景，转账的时候扣完钱， 向消息队列插入消息，事务就结束了，根本不用什么两阶段提交，性能很好。</p>
<hr>
<p>上面的方案看似非常完美，但是，还隐藏有一个重大问题：</p>
<blockquote>
<p>这个事务同时操作了数据库和一个消息队列， 这两个东西是完全不同的， 怎么实现？难道再用 JTA？<br>JTA 不仅仅可以支持数据库， 只要是支持XA协议的数据源都可以。</p>
</blockquote>
<p>解决方案：<br><img src="/image/dev/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A72.png" alt=""></p>
<p>在这里，我们可以添加一个“<strong>事件表</strong>”， 转账开始的时候，把吕秀才的 100 两银子扣除， 同时还向事件表插入一行记录： 需要向郭芙蓉转 100 两， <strong>由于这两个表是在同一个数据库中，所以直接使用本地事务就行</strong>。不用什么分布式事务。<br>而那个定时运行程序就是个定时任务，它会定期从事件表中取出记录， 向 MQ 写入消息， 然后把记录的状态改成 “DONE”， 这样下次就不用再去取去处理了。<br>这里还有一个坑，读数据后，向消息队列写入了消息， 如果还没来得及把事件表的 status 改为 “DONE” 就崩溃了，等到定时运行程序重启以后，<strong>会再次读取， 再次向 MQ 写入消息</strong>，这样整个系统就不一致了。所以必须要做到幂等性。</p>
<blockquote>
<p>当你对一个事物操作的时候，<strong>可以一直重复地操作，那个事物不受影响</strong>， 例如对郭芙蓉的账号你查询一千次，一万次，账户余额还是那么多，不会变化。<br>转账操作就不是一个幂等性操作，每次操作都会导致账号的变化。<br>简单理解：read 是幂等的， modify 不是幂等的</p>
</blockquote>
<p>也就是那个定时运行的程序可以出错，<strong>可以向消息队列写入多次重复消息</strong> ， 但是消费方那边在执行的时候， 肯定也要判断之前是否执行过了， 如果没有的话就执行， 如果执行过了就简单的抛弃这个消息即可。<br>所以消费方在判断是否已经执行过的时候（可以设置一个 id 来进行区分），<strong>也需要查询之前的执行记录</strong>， 这就意味着之前执行过的也需要用一个表保存下来才行。</p>
<blockquote>
<p>有人说，可以消息内容直接为账户值 + 100，这样，无论任务操作多少次，郭芙蓉账户都是账户值 +100。<br>但是这样首先要保证顺序，并且还是得标记这个事儿已经做过了，并且对于日志不是很友好，采用的不是很多吧。</p>
</blockquote>
<p>如果遇到是对方账号输入错误，钱老是转不进去，也就是消息无法消费，只能使用补偿机制了（手动 or 自动？）。<br>这些都是建立在 MQ 是稳定、高可用的前提下。。。。<br>这种方法也就是 BASE 模型，BASE 模型反 ACID 模型，完全不同 ACID 模型，牺牲高一致性，获得可用性或可靠性。</p>
<h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p>首先来看一段解释，虽然未必看得懂…..</p>
<blockquote>
<p>Paxos算法是莱斯利·兰伯特（英语：Leslie Lamport）于1990年提出的一种<strong>基于消息传递</strong>且<strong>具有高度容错特性的一致性算法</strong>。<br>为描述 Paxos 算法，Lamport 虚拟了一个叫做 Paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。<br>所以无论是议员，议长或者传递纸条的服务员<strong>都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间</strong>。<br>但是这里假设没有拜占庭将军问题（Byzantine failure，即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息）；只要等待足够的时间，消息就会被传到。<br>另外，Paxos 岛上的议员是不会反对其他议员提出的决议的。</p>
</blockquote>
<p>主要目的是通过这个算法，让参与分布式处理的每个参与者逐步达成一致意见。用好理解的方式来说，就是在一个选举过程中，让不同的选民最终做出一致的决定（少数服从多数）。<br>paxos 是个分布式一致性协议，它的事件需要多个节点共同参与，一个事件完成是指<strong>多个节点上均完成了自身负责的单机子事件</strong>(就让我门把这样的事件称为”分布式事件”)，这样的分布式事件可以看作是多个单机子事件的复合，但是<strong>即不能从两个分布式事件的先后推导出某个节点上它们的单机子事件的先后，也不能根据某个节点上两个单机子事件的先后断言它们对应的分布式事件的先后</strong>。<br>自 Paxos 问世以来就持续垄断了分布式一致性算法，Paxos 这个名词几乎等同于分布式一致性。<br>Google 的很多大型分布式系统都采用了 Paxos 算法来解决分布式一致性问题，如 Chubby、Megastore 以及 Spanner 等。开源的 ZooKeeper，以及 MySQL 5.7 推出的用来取代传统的主从复制的 MySQL Group Replication 等纷纷采用 Paxos 算法解决分布式一致性问题。<br>然而，Paxos 的最大特点就是难，不仅难以理解，更难以实现。</p>
<hr>
<p>Paxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了 2F+1 的容错能力，即 2F+1 个节点的系统最多允许 F 个节点同时出现故障。<br>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos 算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。<br>Paxos 将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</p>
<ul>
<li><strong>倡议者（Proposer）</strong>：倡议者可以提出提议（数值或者操作命令）以供投票表决</li>
<li><strong>接受者（Acceptor）</strong>：接受者可以对倡议者提出的提议进行投票表决，提议有超半数的接受者投票即被选中</li>
<li><strong>学习者（Learner）</strong>：学习者无投票权，只是从接受者那里获知哪个提议被选中</li>
</ul>
<hr>
<p>花费一晚上来看 Paxos ，本来想简单写写这个算法的原理，但是发现太难了！并且我也不确定是否真正看懂了，不过找到了两篇感觉比较好的文章放在了最后，有能力的请去看原作者论文。。。<br><img src="/image/dev/Paxos.png" alt="Paxos"></p>
<h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p>不同于 Paxos 算法直接从分布式一致性问题出发推导出来，Raft 算法则是从多副本状态机的角度提出，用于管理多副本状态机的日志复制。<br>Raft 实现了和 Paxos 相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft 算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32052223</a></p>
<h2 id="NWR模型"><a href="#NWR模型" class="headerlink" title="NWR模型"></a>NWR模型</h2><p>引用一句话：</p>
<blockquote>
<p><strong>要想让数据有高可用性，就得写多份数据。</strong><br><strong>写多份的问题会导致数据一致性的问题。</strong><br><strong>数据一致性的问题又会引发性能问题</strong><br>这就是软件开发，按下了葫芦起了瓢。</p>
</blockquote>
<p>一致性模型：</p>
<ul>
<li><strong>Weak 弱一致性</strong>：<br>当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。</li>
<li><strong>Eventually 最终一致性</strong>：<br>当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。</li>
<li><strong>Strong 强一致性</strong>：<br>新的数据一旦写入，在任意副本任意时刻都能读到新值。</li>
</ul>
<p>NWR 模型是 Amazon Dynamo 系统中提出的一个概念，非常的有意思，也值得学习分布式系统的人进行好好的思考。所谓 NWR 模型，N 代表 N 个备份，W 代表要写入至少 W 份才认为成功，R 表示至少读取 R 个备份。<br><strong>配置的时候要求 W+R&gt;N</strong>。因为 W+R&gt;N，所以 R&gt;N-W，这指的是<strong>读取的份数一定要比总备份数减去确保写成功的倍数的差值要大</strong>。也就是说，每次读取，都至少读取到一个最新的版本。<br>当我们需要高可写的环境的时候，我们可以配置 W=1，这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。<br>如果我们要求读的高效率，我们可以配置 W=N，R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。<br>NWR 模型的一些设置会造成脏数据的问题，因为这很明显不是像 Paxos 一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。所以，Amazon Dynamo <strong>引入了数据版本的设计</strong>。<br>也就是说，如果你读出来数据的版本是 v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了 v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。但是，对于分布式和 NWR 模型来说，版本也会有恶梦的时候 — 就是版本冲的问题，不过这里不多探讨了。<br>Amazon Dynamo 的 <strong>NWR</strong> 模型，把 <strong>CAP</strong> 的选择权交给了用户，让用户自己选择 CAP 中的哪两个。</p>
<ul>
<li>如果 W+R&gt;N ，是可以保证强一致性的。<br>因为 W+R &gt; N， 所以 R &gt; N-W，什么意思呢？<br>就是读取的份数必须要大于未成功写的份数，这样至少能读到一份最新值。</li>
<li>如果 W+R&lt;=N，则能够保证最终一致性。</li>
<li>如果我们要高可写的环境，我们可以配置 W=1，R=N。<br>这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。</li>
<li>如果我们要求读的高效率，我们可以配置 W=N，R=1。<br>这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</li>
</ul>
<hr>
<ul>
<li><strong>优化写性能(AP)</strong><br>当我们需要优化写性能（写多读少）的时候，可以配置 W = 1 （写完一个副本就成功，其他的副本就异步去慢慢复制）；<br>如果 N=3，那么根据公式 W+R&gt;N，则 R = 3（读取数据的时候需要读 3 个副本以判断数据是否有冲突）。<br>这种情况只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。</li>
<li><strong>优化读性能(CP)</strong><br>当我们需要优化读性能（读多写少）的时候，可以配置 W=N（写完所有的副本才成功，只能同步复制）；<br>根据公式 W+R&gt;N，则 R=1（只需读一个副本即可）。<br>这种情况任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</li>
<li><strong>平衡读写性能(AC)</strong><br>当我们数据不多，单台能搞定，且不需要容错和扩展性的时候，可以配置 N=1（只有一份数据）；<br>根据公式 W+R&gt;N，则 W=1，R=1。这种情况就简化为单机问题了。</li>
</ul>
<h2 id="数据库中的事务"><a href="#数据库中的事务" class="headerlink" title="数据库中的事务"></a>数据库中的事务</h2><p>要谈到事务的实现方式，最重要的要属 Undo 日志了，简单来聊一聊就是：<br>事务开始后，<strong>在做具体的操作之前</strong>，会先写入日志，例如来一个经典的转账例子：</p>
<blockquote>
<p>[事务T1,  旺财原有余额 ， 200]<br>[事务T1, 小强原有余额， 50 ] </p>
</blockquote>
<p>如果事务执行到一半，就断电了，那数据库重启以后可根据 undo 的日志文件来恢复。<br>并且，记录的日志是可以做到幂等性的，也就是可以一直做恢复，恢复过程中断电也不怕，只要把恢复做完就行。<br>恢复数据的时候， 那你怎么才能知道一个事务没有完成呢？</p>
<blockquote>
<p>[开始事务 T1]<br>[事务T1, 旺财原有余额，200]<br>[事务T1, 小强原有余额，50]<br>[提交事务 T1]</p>
</blockquote>
<p>Undo 日志文件中不仅仅只有余额， <strong>事务的开始和结束也会记录</strong>，如果我在日志文件中看到了 【提交事务 T1】，或者 【回滚事务 T1】， 我就知道这个事务已经结束，不用再去理会它了， 更不用去恢复。 如果我只看到 【开始事务 T1】, 而找不到提交或回滚，那我就得恢复。<br>特别是，恢复以后， 需要在日志文件中加上一行 【回滚事务 T1】 ， 这样下一次恢复就不用再考虑 T1 这个事务了。</p>
<hr>
<p>Undo 日志文件会面临和数据文件一样的问题， 都是需要加载到内存才能读写， 要不然会太慢。  那要是连日志文件还没写好就断电了呢？<br>要解决这个问题，也不难，只需要遵守两条规则就好：</p>
<ul>
<li>操作之前要把对应的日志写入硬盘的日志文件</li>
<li>像“提交事务”这样的日志，一定要在操作完成后写入到硬盘</li>
</ul>
<p>通常把日志记录也放到了内存的 Undo 日志缓冲区，伺机写入硬盘。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/J1WH4ZYyVWGgXx9g2siocw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/J1WH4ZYyVWGgXx9g2siocw</a><br><a href="https://mp.weixin.qq.com/s/59iztoTssmIVri7UkZeGzw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/59iztoTssmIVri7UkZeGzw</a><br><a href="https://mp.weixin.qq.com/s/92SghOorf10dm3pM0DWzIg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/92SghOorf10dm3pM0DWzIg</a><br><a href="http://www.hollischuang.com/archives/681" target="_blank" rel="noopener">http://www.hollischuang.com/archives/681</a><br><a href="http://blog.xiaohansong.com/2016/09/30/Paxos/" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/09/30/Paxos/</a><br><a href="https://segmentfault.com/a/1190000013478009" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013478009</a><br><a href="http://lemon0910.github.io/%E7%B3%BB%E7%BB%9F/2016/04/29/distributed-summary.html" target="_blank" rel="noopener">http://lemon0910.github.io/%E7%B3%BB%E7%BB%9F/2016/04/29/distributed-summary.html</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot进阶]]></title>
      <url>http://bfchengnuo.com/2018/08/26/SpringBoot%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>看了下之前的做的 SpringBoot 笔记连入门都算不上，顶多是个体验，然后外加现在 SpringBoot 这么火，还是有记录一下的价值的，也是为了更进一步了解 SpringBoot，同时也是为之后的 SpringCloud 做铺垫；<a id="more"></a><br>这次的笔记基于 1.x 的版本，后续打算会跟进 2.x 版本，对于这一点，SpringBoot 比较任性，2.x 和 1.x 的版本有很大的改动，虽然原理是差不多的，但是方法说删就删…..之后有机会再总结吧，在那篇体验里也介绍过一些 2.x 的特性，慢慢来~</p>
<h2 id="主程序入口"><a href="#主程序入口" class="headerlink" title="主程序入口"></a>主程序入口</h2><p>使用 SpringBoot 必须在 pom 文件中配置父工程，父工程中定义了大量的 JavaEE 常用库的版本号（用来做“版本仲裁”），这个大家都知道，就不多说了；然后我们知道在启动类上标注 @SpringBootApplication 注解，然后在 main 方法中运行：<code>SpringApplication.run(HelloWorldMainApplication.class,args);</code> 就可以让 web 工程跑起来（当然需要在 pom 中配置相关依赖，比如各种方便好用的各种 starter）</p>
<blockquote>
<p>为简化部署，SpringBoot 提供了 spring-boot-maven-plugin 的 Maven 插件，使用后可以直接通过 <code>Java -jar</code> 命令来运行 jar 包。</p>
</blockquote>
<p>SpringBoot 要求 run 方法第一个参数必须是  @SpringBootApplication 注解标注的类，既然这样就来看看这个注解是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>一个一个来看，首先是 <strong>@SpringBootConfiguration</strong> 这个注解，从名字可以看出是 SpringBoot 的配置类，它其实继承了 @Configuration 注解，也就间接的继承了 @Component 注解，官方建议在 SpringBoot 应用中优先使用 @SpringBootConfiguration 注解。<br>再来看 <strong>@EnableAutoConfiguration</strong> 这个注解，从名字来看是开启自动配置，自动配置应该是 SpringBoot 的一大核心了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此注解继承了 @AutoConfigurationPackage ，也就是自动配置包，它里面重要的一句代码是：<code>@Import(AutoConfigurationPackages.Registrar.class)：</code> ，Spring 的底层注解 @Import 应该很熟悉了，主要是给容器中导入一个组件，这个类如果读源码的话，<strong>主要的作用就是将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器</strong>，这就可以解释一些问题了！<br>然后接下来看导入的 <strong>EnableAutoConfigurationImportSelector</strong> 这个类，从名字来看是来决定导入那些组件的选择器，它会将所有需要导入的组件以全类名的方式返回；这些组件（其实是自动配置类）就会被添加到容器中；<br>经过上面的操作，将会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；他们的作用就是根据当前环境的依赖配置好这些组件。<br>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。<br>Spring Boot 在启动的时候从类路径下的 <code>META-INF/spring.factories</code> 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，在特定的环境下帮我们进行自动配置工作；</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>号称无配置的 SpringBoot 其实就是给我们做了常见的自动配置，如上面所解释，避免淹没在无尽的配置文件中，但自动配置不可能符合每个项目的需求，所以 SpringBoot 必定要提供定制的方法，如果继续采用传统的 XML 文件来配置，那显得还是太复杂了，properties 是个不错的选择，同时，还支持一种新型的流行配置语法 yaml！<br>YAML 以数据为中心，比 json、XML 等更适合做配置文件。</p>
<h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><p>基本语法：形如 <code>K:(空格)V</code> 这样的形式。<br>以空格的缩进来控制层级关系，<strong>空格多少无所谓，只要左对齐就行</strong> ，同时，它的属性和值是大小写敏感的。<br>对于值的写法，可分为下面几种形式：</p>
<ul>
<li><p>字面量<br>数字、字符串、布尔 直接写就可以了；<br>特殊的，双引号和单引号，<strong>双引号内的特殊字符会转义</strong>，比如 <code>\n</code> ；单引号内的字符串不会被转义。</p>
</li>
<li><p>对象、Map<br>另起一行写属性，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还支持行内写法</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">&#123;name:</span> <span class="string">zhansan,age:</span> <span class="number">20</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>两种写法效果一样，看个人喜好咯。</p>
</li>
<li><p>集合<br>用 <code>-</code> 表示数组中的一个元素，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog]</span></span><br></pre></td></tr></table></figure>
<p>两种写法的效果也是一致的。</p>
</li>
</ul>
<h3 id="配置文件的值注入"><a href="#配置文件的值注入" class="headerlink" title="配置文件的值注入"></a>配置文件的值注入</h3><p>将配置文件中配置的属性映射到 bean 中，使用 <code>@ConfigurationProperties(prefix=&quot;&quot;)</code> 注解实现。<br>需要注意的是，<strong>这个 bean 必须在 spring 容器中才行</strong>；其支持松散绑定，也就是说你可以使用驼峰、下划线分割（测试日期格式使用 2018/08/12 的格式是可正确注入），都会正确的识别，还支持 JSR303 校验规则，可以使用相关的校验注解，只需要在类上加个 @Validated 就好。<br><strong>这个注解默认从全局配置文件中获取值。</strong><br>要使用 @ConfigurationProperties 最好导入这个依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当时测试如果在 @Configuration 标注的类上无法注入，原因就是缺少这个依赖，当然在普通 Bean 是没有问题的，迷….<br>你甚至可以直接把它标注在 @Bean 的方法上，比如数据源，可以直接注入到返回的 Bean 中，不用在调用那么多 setter 方法了。<br>除了使用 @ConfigurationProperties  注解，还可以使用 <code>@Value</code> 注解注入单个值，类似我们 xml 中 bean 标签里的 property 的 Value，所以它支持几种写法：</p>
<ul>
<li>字面量</li>
<li>${配置文件属性}</li>
<li>SPEL 表达式：{spel}</li>
</ul>
<p>还可以做一些简单的运算，可以说定制性很高了，至于他们的比较：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303 数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>不管配置文件是 yml 还是 properties 他们都能获取到值；<br>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用 @Value；<br>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用 @ConfigurationProperties；</p>
<hr>
<p>有时候，我们并不希望把所有配置都写在主配置文件中，而是希望指定从那个配置文件中加载，那么就可以使用 @PropertySource 注解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br></pre></td></tr></table></figure>
<p>通常，他们都是搭配使用的。</p>
<blockquote>
<p>1.5 以前的版本，那么可以通过 ConfigurationProperties 注解的 locations 指定 properties 文件的位置 ；<br>但是 1.5 版本后就没有这个属性了，需要添加 @Configuration 和 @PropertySource()后才可以读取</p>
</blockquote>
<p>SpringBoot 还有另一个导入配置文件的注解 @ImportResource：导入Spring 的配置文件，让配置文件里面的内容生效；这个导的是原始 Spring 的 XML 配置文件，可以写在 SpringBoot 配置类上，比如 SpringBoot 的启动类，但是官方是不推荐的，建议使用 Java 配置的方式（@Configuration）。</p>
<h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><p>在 SpringBoot 的配置文件中，是可以使用 <code>${xx}</code> 这种表达式的，比如可以使用它来获取随机数：<code>${random.value}</code>、<code>${random.int}</code>、<code>${random.long}</code>、<code>${random.int(10)}</code>、<code>${random.int[1024,65536]}</code> ；<br>也可以使用它引用之前配置的值：<code>${person.hello:hello}</code> 通过冒号可以设置默认值。</p>
<h3 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h3><p>在 Maven 中是支持多环境的，操作有点繁琐，SpringBoot 默认就集成了这个功能，它以文件名进行区分不同的环境：<code>application-{profile}.properties/yml</code> .<br>如果使用的是 yaml 文件，还可以使用 <code>---</code> 来进行划分：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure>
<p>至于激活那个环境，除了在主配置文件里配置，还有很多方式，比如命令行参数（<code>--spring.profiles.active=dev</code>）、JVM 参数（<code>-Dspring.profiles.active=dev</code>）</p>
<h3 id="配置文件的加载"><a href="#配置文件的加载" class="headerlink" title="配置文件的加载"></a>配置文件的加载</h3><p>springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件：</p>
<ul>
<li>当前项目下的 Config 文件夹（<code>file:./config/</code>）</li>
<li>当前项目下（<code>file:./</code>）</li>
<li>类加载路径下的 Config 文件夹（<code>classpath:/config/</code>）</li>
<li>类加载路径下（<code>classpath:/</code>）</li>
</ul>
<p>优先级由高到底，高优先级的配置会<strong>覆盖</strong>低优先级的配置；<strong>互补配置</strong> ；<br>另外，我们还可以通过在命令行指定 <code>spring.config.location</code> 来改变默认的配置文件位置，同样也是互补配置。<br>至于加载顺序，以及会扫描加载那些外部配置，官方定义了很多路径，这里就不说了，有需要的可以看官方文档，地址在这：<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">官方文档</a></p>
<p>配置文件能配的属性全都在这了：<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">官网直达</a></p>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>关于自动配置，简单来讲，通过前面的主程序入口解析，我们知道 SpringBoot 在启动的时候会加载包下指定文件夹下的文件，然后导入了一堆的自动配置类；<br>这些自动配置类都是一样的套路，与之配套的还有一个 xxxProperties 类，这个类的作用就是通过 @ConfigurationProperties 注入配置文件中配置的属性，然后自动配置类中就可以使用这些值了；当然自动配置类还有一些 Conditional 注解来控制根据当前环境加载某些配置，最后就通过默认配置创建出了一个个的 Bean，而不需要我们再显式的声明了。<br>虽然文件中指定加载了一堆的自动配置类，但是很多的自动配置类都需要一些条件才能生效，所以并不是所有的功能都会生效的。</p>
<h2 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h2><p>SpringBoot 中默认使用的日志是 SLF4J + logback，然而 Spring 使用的是 JCL，日志统一是个问题。<br>关于 SLF4J 的使用，应该是都比较熟悉了，SpringBoot 中的 <code>spring-boot-starter</code> 中默认导入了一个 <code>spring-boot-starter-logging</code> ，它的作用就是来处理日志框架不统一的问题，使用各种 over 来转换成 SLF4J。<br>正是因为有它，所以 SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，<strong>只需要把这个框架依赖的日志框架排除掉即可</strong>。<br>并且，SpringBoot 会给我们默认配置日志的输出格式，也可以在配置文件中微调，或者直接将配置文件复制到 Resources 文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置等级，可以具体到包</span><br><span class="line">logging.level.com.bfchengnuo=trace</span><br><span class="line"></span><br><span class="line"># 不指定路径在当前项目下生成springboot.log日志</span><br><span class="line"># 可以指定完整的路径；</span><br><span class="line">#logging.file=G:/springboot.log</span><br><span class="line"></span><br><span class="line"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span><br><span class="line">logging.path=/spring/log</span><br><span class="line"></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure>
<p>SpringBoot 默认设置的日志等级是 info，滚动输出，最大文件 10M</p>
<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>(none)</td>
<td>-</td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody>
</table>
<p>如果使用配置文件，多种文件名都可以被识别，例如 <code>logback-spring.xml</code> 和 <code>logback.xml</code> ，后者直接被日志框架所识别，而前者是由 Spring 来进行处理，所以它可以支持一些更强大的功能，例如 springProfile 标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面举个例子 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且，你还可以切换日志框架，例如像从 slf4j 切换到 log2j2，只需要导入 <code>spring-boot-starter-log4j2</code> 这个依赖即可；因为和 <code>spring-boot-starter-logging</code> 是二选一的关系，所以记得排除依赖。<br>使用 <code>spring-boot-starter-log4j2</code> 也会有相应的默认配置，官方文档中写的还是很详细的。</p>
<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><p>如果看 SpringBoot web 的自动配置，会发现默认的静态资源映射支持 webjars，就是将所有 <code>/webjars/**</code> 的请求映射到 <code>classpath:META-INF/resources/webjars</code> 下。</p>
<blockquote>
<p>webjars 简单说就是可以将 js、css 等前端使用的库通过 jar 包的方式导入到项目中，支持使用 Maven 管理，默认打包在 <code>classpath:META-INF/resources/webjars</code> 文件夹下。</p>
</blockquote>
<p>当请求没人处理时，会交给一个 <code>/**</code> 全局映射，默认从下面几个路径中寻找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure>
<p>还贴心的设置了欢迎页：静态资源文件夹下的所有叫 index.html 的页面；被 “/<strong>“ 映射。<br>所有的 </strong>/favicon.ico  都是在静态资源文件下找，可以来设置自己喜欢的网站图标。<br>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebMvcAuotConfiguration</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(</span><br><span class="line">      registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">      .addResourceLocations(</span><br><span class="line">        <span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">      .setCachePeriod(cachePeriod));</span><br><span class="line">  &#125;</span><br><span class="line">  String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">  <span class="comment">//静态资源文件夹映射</span></span><br><span class="line">  <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">    customizeResourceHandlerRegistration(</span><br><span class="line">      registry.addResourceHandler(staticPathPattern)</span><br><span class="line">      .addResourceLocations(</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">      .setCachePeriod(cachePeriod));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置欢迎页映射</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line">                                       <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">    mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">                                               faviconRequestHandler()));</span><br><span class="line">    <span class="keyword">return</span> mapping;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">    requestHandler</span><br><span class="line">      .setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">    <span class="keyword">return</span> requestHandler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就处理了静态文件的映射规则。<br>当然我们也可以自定义路径规则，使用 <code>spring.resources.static-locations=classpath:/hello/,classpath:/test/</code> ，但是这样 SpringBoot 的那些默认配置就失效了。</p>
<h3 id="模板引擎Thymeleaf"><a href="#模板引擎Thymeleaf" class="headerlink" title="模板引擎Thymeleaf"></a>模板引擎Thymeleaf</h3><p>SpringBoot 推荐的 Thymeleaf 虽然效率上经常被人黑，也确实很低，不过对于前后端解耦是比较友好的，要使用首先要引入依赖，对于 SpringBoot 直接加一个 starter 就好：<code>spring-boot-starter-thymeleaf</code><br>另外，你可以指定你要引入的版本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Thymeleaf 的自动配置中，设置的默认前缀是 <code>classpath:/templates/</code> 默认后缀是 <code>.html</code> ，也就是说只要我们把 HTML 页面放在这个路径下，thymeleaf 就能自动渲染。<br>然后在 HTML 导入名称空间（为了有代码提示）：<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code><br>如何使用参考<a href="https://www.thymeleaf.org/index.html" target="_blank" rel="noopener">官方文档</a>例子很详细，我也考虑写一个笔记放在 Github。<br>简单来说就是他支持 OGNL 表达式，可以直接使用 <code>th:任意html属性</code> 替换原生 html 属性，如果直接打开，定义的这些属性就不会解析，如果使用模板引擎就替换为了 <code>th:text</code> 中的变量，前后端非常和谐。</p>
<h3 id="SpringMVC的自动配置"><a href="#SpringMVC的自动配置" class="headerlink" title="SpringMVC的自动配置"></a>SpringMVC的自动配置</h3><p>在 SpringBoot 的官方文档中有比较详细的描述，<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">地址在这</a>。<br>自动配置的关键就在 WebMvcAutoConfiguration 这个类中，根据文档描述，主要做了下面几件事情：</p>
<ul>
<li>自动配置了 ViewResolver （视图解析器，根据返回值得到具体的视图对象，视图对象决定如何渲染，例如是转发还是重定向）</li>
<li>使用 ContentNegotiatingViewResolver 组合所有的视图解析器，只要在容器中配一个试图解析器，就会自动组合进来。</li>
<li>静态资源文件夹路径。比如上面所说的 webjars、静态首页、图标等。</li>
<li>自动注册了 <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> 等 bean.<br>转换器：请求参数与实体类之间的类型转换使用的就是 Converter；<br>格式化器：例如日期格式化的注解，自己添加的格式化器转换器，我们只需要放在容器中即可；</li>
<li>自动注册消息转换器<br>例如 HttpMessageConverter 将实体对象转换成 json 等，自定义的方式也和上面一样。<br>另外还有定义错误代码生成规则的 MessageCodesResolver 等。</li>
</ul>
<p>相应扩展 SpringMVC 的配置，只需要<strong>编写一个配置类（@Configuration），是 WebMvcConfigurerAdapter 类型（继承它）；不标注 @EnableWebMvc（加上了就不会进行默认配置了，也就是说全面接管 MVC）</strong><br>之前我们通常在 SpringMVC中 中配置 HiddenHttpMethodFilter 来使其支持 RESTful，现在 SpringBoot 也给自动配置好了，只需要在前台创建一个 input 项（一般设置为隐藏），<code>name=&quot;_method&quot;</code> 值就是我们指定的请求方。</p>
<h3 id="修改SpringBoot默认配置"><a href="#修改SpringBoot默认配置" class="headerlink" title="修改SpringBoot默认配置"></a>修改SpringBoot默认配置</h3><p>一般套路为：</p>
<ul>
<li>SpringBoot 在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；<br>有些组件（例如 ViewResolver）可以将用户配置的和自己默认的组合起来；</li>
<li>在SpringBoot中会有非常多的 xxxConfigurer 帮助我们进行扩展配置</li>
<li>在 SpringBoot 中会有很多的 xxxCustomizer 帮助我们进行定制配置</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>SpringBoot 有默认的错误处理机制，在浏览器访问的时候返回的是错误页面，其他客户端返回的是 JSON 格式的错误信息。<br>至于原理，其实是根据请求头来不同的处理，可以在 <strong>ErrorMvcAutoConfiguration</strong> 这个错误处理的自动配置类中看看具体是怎么实现的。它主要给容器添加了下面几个组件：</p>
<ul>
<li><p><strong>DefaultErrorAttributes</strong><br>主要是帮我们在页面共享信息，通过一个 getErrorAttributes 方法来组装了错误页面需要的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">  errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">  addStatus(errorAttributes, requestAttributes);</span><br><span class="line">  addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">  addPath(errorAttributes, requestAttributes);</span><br><span class="line">  <span class="keyword">return</span> errorAttributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ErrorAttributes 我们可以进行自定义。</p>
</li>
<li><p><strong>BasicErrorController</strong><br>它处理默认 <code>/error</code> 请求，我们可以通过 <code>server.error.path</code> 来自定义，它会根据请求头信息，来决定走那个方法，相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">      request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">    ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">    Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">                                                  isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ErrorPageCustomizer</strong><br><strong>系统出现错误以后</strong>，让其来到 error 请求进行处理，可以说是错误的入口类了。</p>
</li>
<li><p><strong>DefaultErrorViewResolver</strong><br>可以说，它是来觉定走那个视图的，源码写的很明白：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">  String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">  TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">    .getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line">  <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">  <span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板引擎中可以使用 OGNL 之类的表达式来取值，静态资源（例如 static 文件夹下）就不行啦</p>
</li>
</ul>
<p>下面来总结下：<br>一但系统出现 4xx 或者 5xx 之类的错误；ErrorPageCustomizer 就会生效（可定制错误的响应规则）；默认就会来到 <code>/error</code> 请求；就会被 <strong>BasicErrorController</strong> 处理；<br>响应去哪个页面是由 <strong>DefaultErrorViewResolver</strong> 解析得到的，有模板引擎的情况下；<code>error/状态码</code>【将错误页面命名为  <code>错误状态码.html</code> 放在模板引擎文件夹里面的 error 文件夹下】，发生此状态码的错误就会来到对应的页面。<br>我们可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先。<br>页面能获取的信息有：</p>
<ul>
<li>timestamp：时间戳</li>
<li>status：状态码</li>
<li>error：错误提示</li>
<li>exception：异常对象</li>
<li>message：异常消息</li>
<li>errors：JSR303 数据校验的错误都在这里</li>
</ul>
<p>模板引擎和静态资源文件夹都没有错误页面，就是默认来到 SpringBoot 默认的错误提示页面。</p>
<h3 id="定制错误数据"><a href="#定制错误数据" class="headerlink" title="定制错误数据"></a>定制错误数据</h3><p>统一处理异常还是用 SpringMVC 的知识，首先写一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">    map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种呢，没有自适应效果（不能区分浏览器和其他客户端），然后改进了一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">  Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程，因为forward默认 200</span></span><br><span class="line">  request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">  map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">  map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">  <span class="comment">// 转发到 /error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样自适应是有了（靠 SpringBoot 来实现），但是我们自定义的数据如何传递过去又是个问题了，错误请求最终会被 BasicErrorController 处理，响应出去可以获取的数据是由 getErrorAttributes 得到的（是AbstractErrorController（ErrorController）规定的方法，所以我们可以编写一个 ErrorController 的实现类【或者是编写 AbstractErrorController 的子类】，放在容器中。<br>但是重新编写实现类太麻烦了，收集这些信息是通过 <code>DefaultErrorAttributes.getErrorAttributes()</code> 这个方法完成的，所以有更简便的方法就是写一个 ErrorAttributes。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的 ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">    map.put(<span class="string">"company"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们自定义了 ErrorAttributes 后，SpringBoot 就不再加载默认的 ErrorAttributes 而是使用容器中已存在的，这样就可以取到我们自定义的数据了。</p>
<h3 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h3><p>SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容器，我们可以通过配置文件来进行定制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line">server.context-path=/crud</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br><span class="line"></span><br><span class="line"># 通用的Servlet容器设置</span><br><span class="line">server.xxx</span><br><span class="line"># Tomcat的设置</span><br><span class="line">server.tomcat.xxx</span><br></pre></td></tr></table></figure>
<p>还可以编写一个<strong>EmbeddedServletContainerCustomizer</strong> 嵌入式的 Servlet 容器的定制器来进行定制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line">    <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">      container.setPort(<span class="number">8083</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实配置文件的方式 ServerProperties 本质也是 EmbeddedServletContainerCustomizer。<br>你也可以换用其他容器，步骤就是先把 Tomcat 排除，然后导入相关的依赖即可，支持 Jetty （长连接比较好）和 Undertow （NIO，并发不错）。<br>嵌入式容器默认并不支持 JSP，并且定制性复杂，还是要视情况而定。<br>如果使用外置 Servlet 容器，除了打包方式改成 war，将内置的 Tomcat 排除后（可使用 provided），必须编写一个 <strong>SpringBootServletInitializer</strong> 的子类，并调用 configure 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">    <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就会把 SpringBoot 应用给带起来了，这多亏了 servlet3.0 规范的支持。</p>
<h3 id="注册三大组件"><a href="#注册三大组件" class="headerlink" title="注册三大组件"></a>注册三大组件</h3><p>SpringBoot 给我们提供了简便的方法注册三大组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 servlet</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Filter</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">  FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">  registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">  registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册监听器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">  <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动配置的 SpringMVC 也是这样配置前端控制器的，看源码可得知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">  ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">    dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">  <span class="comment">// 默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">  <span class="comment">// 可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">  registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">  registration.setLoadOnStartup(</span><br><span class="line">    <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">    registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ApacheCommons常用工具类使用]]></title>
      <url>http://bfchengnuo.com/2018/07/24/ApacheCommons%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Apache Commons 项目包含了很多工具，并且非常好用，能提高我们的开发效率，在很多开源框架中使用广泛，所以….如果项目中引入了这些依赖，能用就用吧，起码 Apache 的应该是比自己写的强多了。。<a id="more"></a><br>另外，Google 的 Guava 也是非常好用的，也做了笔记，<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Guava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">地址在这里</a>。<br>常用工具一览表：</p>
<table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>功能介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BeanUtils</strong></td>
<td>提供了对于JavaBean进行各种操作，克隆对象,属性等等.</td>
</tr>
<tr>
<td>Betwixt</td>
<td>XML与Java对象之间相互转换.</td>
</tr>
<tr>
<td><strong>Codec</strong></td>
<td>处理常用的编码方法的工具类包 例如 DES、SHA1、MD5、Base64 等.</td>
</tr>
<tr>
<td><strong>Collections</strong></td>
<td>java集合框架操作.</td>
</tr>
<tr>
<td>Compress</td>
<td>java提供文件打包压缩类库.</td>
</tr>
<tr>
<td>Configuration</td>
<td>一个java应用程序的配置管理类库.</td>
</tr>
<tr>
<td>DBCP</td>
<td>提供数据库连接池服务.</td>
</tr>
<tr>
<td>DbUtils</td>
<td>提供对jdbc 的操作封装来简化数据查询和记录读取操作.</td>
</tr>
<tr>
<td>Email</td>
<td>java 发送邮件对 javamail 的封装.</td>
</tr>
<tr>
<td>FileUpload</td>
<td>提供文件上传功能.</td>
</tr>
<tr>
<td>HttpClien</td>
<td>提供 HTTP 客户端与服务器的各种通讯操作. 现在已改成 HttpComponents</td>
</tr>
<tr>
<td><strong>IO</strong></td>
<td>io 工具的封装.</td>
</tr>
<tr>
<td><strong>Lang</strong></td>
<td>Java 基本对象方法的工具类包 如：StringUtils，ArrayUtils 等等.</td>
</tr>
<tr>
<td>Logging</td>
<td>提供的是一个 Java 的日志接口.</td>
</tr>
<tr>
<td>Validator</td>
<td>提供了客户端和服务器端的数据验证框架.</td>
</tr>
</tbody>
</table>
<h2 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h2><p>提供了对于 JavaBean 进行各种操作，比如对象，属性复制等等。 </p>
<p><strong>克隆对象：</strong> <code>Person person2 =  (Person)BeanUtils.cloneBean(person);</code></p>
<blockquote>
<p>需要注意的是，cloneBean 方法拷贝对象只是浅拷贝，如果想深拷贝，可参考下面的代码</p>
<p>经测试，这种克隆效率很低，并且不是很稳定，推荐优先使用 Spring 的 BeanUtils 通过属性 copy 的方式来“克隆对象”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeanCopier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Returns a deeply cloned java bean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromBean java bean to be cloned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a new java bean cloned from fromBean.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">copy</span><span class="params">(Object fromBean)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    XMLEncoder out = <span class="keyword">new</span> XMLEncoder(bos);</span><br><span class="line">    out.writeObject(fromBean);</span><br><span class="line">    out.close();</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">    XMLDecoder in = <span class="keyword">new</span> XMLDecoder(bis);</span><br><span class="line">    Object toBean = in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> toBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>将一个 Map 对象转化为一个 Bean：</strong><br>首先这个 Map 对象的 key 必须与 Bean 的属性相对应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"tom"</span>);</span><br><span class="line">map.put(<span class="string">"email”,”1@1.com"</span>);</span><br><span class="line">map.put(<span class="string">"age”,”21"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将map转化为一个Person对象</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">BeanUtils.populate(person,map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// web 中示例</span></span><br><span class="line">Enumeration params = request.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (params.hasMoreElements())&#123;</span><br><span class="line">  String name = (String) params.nextElement();</span><br><span class="line">  map.put(name, request.getParameter(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean 转 map</span></span><br><span class="line">Map map = BeanUtils.describe(person);</span><br></pre></td></tr></table></figure>
<p>使用场景嘛…..如果不使用 web 层框架，还记得被 request.getParameter 支配的恐惧….</p>
<hr>
<p><strong>bean 的属性拷贝：</strong></p>
<p>在拼装 VO 或者 DTO 的时候非常有用吧：<code>BeanUtils.copyProperties(source, target);</code></p>
<blockquote>
<p>需要注意的是，除了属性名要一致，属性拷贝同时也会将值为 null 的属性拷贝，所以，这行代码放的位置很重要！</p>
</blockquote>
<hr>
<p><strong>其他常用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="keyword">new</span> Book());</span><br><span class="line"><span class="comment">// 使用beanUtils给对象的属性赋值</span></span><br><span class="line">BeanUtils.setProperty(p, <span class="string">"username"</span>, <span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用beanUtils获取对象的属性值</span></span><br><span class="line">System.out.println(BeanUtils.getProperty(p, <span class="string">"username"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// beanUtils 支持属性链赋值与获得值,不过赋值前 book 要先实例化</span></span><br><span class="line">BeanUtils.setProperty(p, <span class="string">"book.name"</span>, <span class="string">"历史小说"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(BeanUtils.getProperty(p, <span class="string">"book.name"</span>));</span><br><span class="line">System.out.println(p.getBook().getName());</span><br></pre></td></tr></table></figure>
<h2 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h2><p><code>commons-codec</code>是 Apache 开源组织提供的用于摘要运算、编码的包。在该包中主要分为四类加密：BinaryEncoders、DigestEncoders、LanguageEncoders、NetworkEncoders。<br>最常用的类有两个：</p>
<ul>
<li>DigestUtils<br>主要包括 MD5、SHA1、SHA256 算法等实现静态方法</li>
<li>Base64<br>主要包含 Base64 编码和解码静态方法</li>
</ul>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecTest</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * MD5散列算法实现(长度有16位和32位,常用32位的)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMD5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String md5String = DigestUtils.md5Hex(data);</span><br><span class="line">    System.out.println(md5String);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * SHA1散列算法实现(长度为40位)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSHA1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String sha1String = DigestUtils.sha1Hex(data);</span><br><span class="line">    System.out.println(sha1String.length());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * SHA256散列算法实现(长度为64位)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSHA256</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String data = <span class="string">"hello"</span>;</span><br><span class="line">    String sha256String = DigestUtils.sha256Hex(data);</span><br><span class="line">    System.out.println(sha256String.length());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 摘要算法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDigestAlgorithms</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 摘要算法在 MessageDigestAlgorithms 下有列出</span></span><br><span class="line">    <span class="comment">// public static final String MD2 = "MD2";</span></span><br><span class="line">    <span class="comment">// public static final String MD5 = "MD5";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_1 = "SHA-1";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_256 = "SHA-256";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_384 = "SHA-384";</span></span><br><span class="line">    <span class="comment">// public static final String SHA_512 = "SHA-512";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备注:都是基于 HASH 算法实现的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64类进行编码和解码,注意其可以转换二进制数据到字符串(比如图片转字符串)</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 如果是小图片的话,可以使用Base64编码来存储,只是可以并不是推荐使用。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String encodeString = Base64.encodeBase64String(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">    System.out.println(encodeString);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(encodeString);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64将图片编码为字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">image2String</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"e:/test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将输入流转为子节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] imageBytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    String imageString = Base64.encodeBase64String(imageBytes);</span><br><span class="line"></span><br><span class="line">    System.out.println(imageString);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Base64将字符串解码为图片</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">string2Image</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"e:/test.jpg"</span>);</span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将输入流转为子节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] imageBytes = IOUtils.toByteArray(inputStream);</span><br><span class="line">    String imageString = Base64.encodeBase64String(imageBytes);</span><br><span class="line"></span><br><span class="line">    FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"e:/testCopy.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(imageString);</span><br><span class="line">    <span class="comment">// 借助Commons IO 组件的IOUtils静态方法将字节数组转为输出流</span></span><br><span class="line">    IOUtils.write(bytes, outputStream);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再补充一个 URL 的编码和解码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testURLCodec</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"==============URLCodec================"</span>);</span><br><span class="line">   URLCodec codec = <span class="keyword">new</span> URLCodec();</span><br><span class="line">   String data = <span class="string">"啦啦啦"</span>;</span><br><span class="line">   String encode = codec.encode(data, <span class="string">"UTF-8"</span>);</span><br><span class="line">   System.out.println(encode);</span><br><span class="line">   System.out.println(codec.decode(encode, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>对 Java 中的集合类进行了一定的补充，定义了一些全新的集合，当然也是实现了 Collection 接口的，比如<code>Bag，BidiMap</code>。<br>同时拥有新版本的原有集合，比如 <code>FastArrayList</code>。最后，更为重要的是一系列 utils 类，提供了我们常用的集合操作，可以大大方便我们的日常编程。</p>
<h3 id="Bag"><a href="#Bag" class="headerlink" title="Bag"></a>Bag</h3><p>Bag 定义了一种集合：收集一个对象出现的次数。<br>例如 Bag：{a,a,b,c} 调用 <code>bag.getCount(a)</code> 返回 2，意味着里面有 2 个 a。 调用 <code>bag.uniqueSet()</code> 则返回一个 set，值为 {a,b,c}。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">HashBag bag = <span class="keyword">new</span> HashBag();</span><br><span class="line">bag.add(<span class="string">"rabbit"</span>,<span class="number">1</span>);</span><br><span class="line">bag.add(<span class="string">"fox"</span>,<span class="number">1</span>);</span><br><span class="line">bag.add(<span class="string">"rabbit"</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// rabbit count</span></span><br><span class="line">System.out.print(bag.getCount(<span class="string">"rabbit"</span>));</span><br><span class="line"><span class="comment">// how many animals</span></span><br><span class="line">System.out.print(bag.uniqueSet().size());</span><br></pre></td></tr></table></figure>
<p>除了 HashBag，还有 SynchronizedBag、TreeBag，自行了解哈….</p>
<h3 id="BidiMap"><a href="#BidiMap" class="headerlink" title="BidiMap"></a>BidiMap</h3><p>BidiMap 定义了一种 map，不仅可以通过 key 得到 value，还可以通过 value 得到 key。<br>Bidi 意思是 bidirectional，双向使用的 map。<br>除了传统 Map 的操作，还加入了一些新”技能“：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BidiMap bidi = <span class="keyword">new</span> DualHashBidiMap();</span><br><span class="line">bidi.put(<span class="string">"k1"</span>,<span class="string">"v1"</span>);</span><br><span class="line">bidi.put(<span class="string">"k2"</span>,<span class="string">"v2"</span>);</span><br><span class="line"></span><br><span class="line">bidi.get(<span class="string">"k2"</span>); <span class="comment">// return v2</span></span><br><span class="line">bidi.getKey(<span class="string">"v2"</span>); <span class="comment">// return k2</span></span><br><span class="line"></span><br><span class="line">bidi.inverseBidiMap(); <span class="comment">// 反转 bidi，原先的 value 作为 key</span></span><br></pre></td></tr></table></figure>
<p>作为代价，BidiMap 必须要求 k 和 v 是一一对应的，在上述代码之后，无法做到 <code>bidi.put(&quot;k2&quot;,&quot;v1&quot;);</code>，因为这样就无法实现响应操作。 现实中如学号和身份证号做对应就是这样一种关系，可以视情况使用。<br>同样，除了 DualHashBidiMap，还有 TreeBidiMap 等</p>
<h3 id="有用的工具类"><a href="#有用的工具类" class="headerlink" title="有用的工具类"></a>有用的工具类</h3><p>这是 collections 包中最有价值的一个部分，介绍 <code>ListUtils</code> 和 <code>CollectionUtils</code>。</p>
<h4 id="ListUtils-列表工具类"><a href="#ListUtils-列表工具类" class="headerlink" title="ListUtils 列表工具类"></a>ListUtils 列表工具类</h4><ul>
<li>ListUtils.intersection(list1, list2)<br>取交集；</li>
<li>ListUtils.subtract(list1, list2)<br>返回 list1 和 list2 的差。这里和 <code>list1.removeAll(list2)</code> 的差别在于：<br>前者不改变任何一个集合；<br>如果 list1 中有 2 个 a，list2 中有一个a：removeAll 会将 list1 中所有的 a 都抹去，而 subtract 结果 list1 仍然会剩下一个 a。</li>
<li>ListUtils.union(list1, list2)<br>取并集；</li>
<li>ListUtils.removeAll(list1, list2)<br>不改变 list 的情况下做 removeAll</li>
</ul>
<h4 id="CollectionUtils-通用的集合工具类"><a href="#CollectionUtils-通用的集合工具类" class="headerlink" title="CollectionUtils 通用的集合工具类"></a>CollectionUtils 通用的集合工具类</h4><ul>
<li>CollectionUtils.union(c1, c2)，CollectionUtils.intersection(c1,c2)<br>不再解释</li>
<li>CollectionUtils.disjunction(c1, c2)<br>返回两者的不相交部分的并集，没想到一个现实场景。。</li>
<li>CollectionUtils.containsAny(c1, c2)<br>只要 c1 包含任何一个 c2 的元素，返回 true</li>
<li><strong>CollectionUtils.find(c, predicate)</strong><br>重要方法：借助 Predicate 达到神一般的效果，从此减少一半 for 循环。返回第一个找到的元素</li>
<li><strong>CollectionUtils.filter(c, predicate)</strong><br>重要方法：同上，直接改变容器 c。</li>
<li>CollectionUtils.transform(c, transformer)<br>重要方法：还是神器，但是在 jdk8 中等同于 foreach 方法效果。如果 jdk&lt;8，可以用这个方法代替</li>
<li>CollectionUtils.countMatches(c,predicate)<br>根据 predicate 返回有多少元素满足预言，返回值 int。</li>
<li>CollectionUtils.select(c,predicate)<br>根据 predicate 找出满足的元素，组成新的 collection 并返回</li>
<li>CollectionUtils.select(c,predicate,outputCollection)<br>根据 predicate 找出满足的元素，加入到 outputCollection 中。</li>
<li><strong>CollectionUtils.isEmpty(c)</strong><br>简单实用，是否为 null 或者空集合</li>
</ul>
<h4 id="补充：predicate"><a href="#补充：predicate" class="headerlink" title="补充：predicate"></a>补充：predicate</h4><p>既然上面用到了还是说一说，感觉自从 JDK8 来了后，能省一大部分工具类了。。。<br>预言，这个类主要结合 <code>CollectionUtils.find,CollectionUtils.filter</code> 来使用。<br>他的作用类似于『断言』，其中只有一个方法：<code>public boolean evaluate(Object object);</code><br>这个方法用于判断一个对象是否满足某种标准，感觉和 JDK8 中的 stream + map 差不多呢~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line">Predicate predicate = <span class="keyword">new</span> Predicate&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyUtils.getSimpleProperty(object,<span class="string">"age"</span>) &gt;<span class="number">50</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Predicate predicate2 = <span class="keyword">new</span> Predicate&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyUtils.getSimpleProperty(object,<span class="string">"id"</span>) == <span class="number">12306</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除不满足条件的结果</span></span><br><span class="line">CollectionUtils.filter(list,predicate);</span><br><span class="line"><span class="comment">//返回第一个满足的元素</span></span><br><span class="line">Object obj = CollectionUtils.find(list,predicate2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new AndPredicate(predicate1,predicate2);</span></span><br></pre></td></tr></table></figure>
<p>同时，Predicate 可以进行谓词连接，借助于：AndPredicate、OrPredicate、AnyPredicate、NotPredicate 这些类。</p>
<h2 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h2><p>提供了很多安全操作和工具类，避免我们编码校验各种的 null；<br>JDK8+ 后，对空值处理有了加强，但是嘛，国内用的人…..</p>
<ul>
<li>ArrayUtils:<br>数组工具类，提供数组拷贝、查找、反转等功能</li>
<li>StringUtils:<br>提供字符串操作，对 null 是安全的，字符串查找、替换、分割、去空格等操作；<br>isEmpty 和 isBlank 的区别在于 isEmpty 不会忽略空格，而isBlank会认为是空,isBlank更常用</li>
<li>ObjectUtils:<br>对 null 进行安全处理</li>
<li>RandomUtils:<br>随机数工具类，获得随机整数、小数、字符串等</li>
<li>NumberUtils:<br>数值工具类，数值类型转换等操作</li>
<li>DateUtils:<br>日期工具类</li>
<li>EnumUtils:<br>枚举工具类</li>
<li>ClassUtils<br>判断是否有内部类、是否可以转型、获取包名、类名等</li>
<li>ReflectionToStringBuilder/ToStringBuilder:<br>重写 toString 方法</li>
<li>EqualsBuilder/HashCodeBuilder:<br>提供了方便的方法来覆盖 equals() 和 hashCode() 方法  </li>
</ul>
<p>然后给一些示例代码吧，比如 Builder 系列，虽然一般我们都是工具自动生成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ToStringBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ToStringBuilder(<span class="keyword">this</span>).append(<span class="keyword">this</span>.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername()).toString();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 以上输出格式为  Test@1270b73[&lt;null&gt;,&lt;null&gt;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashCodeBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> HashCodeBuilder.reflectionHashCode(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(<span class="keyword">this</span>).append(<span class="keyword">this</span>.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername()).hashCode();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EqulasBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (obj.getClass() == Test.class) &#123;  </span><br><span class="line">    Test test = (Test) obj;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().append(<span class="keyword">this</span>.getId(), test.getId())  </span><br><span class="line">      .append(<span class="keyword">this</span>.getUsername(), test.getUsername()).isEquals();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> EqualsBuilder.reflectionEquals(<span class="keyword">this</span>, obj);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// CompareToBuilder  </span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Test o)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> CompareToBuilder.reflectionCompare(<span class="keyword">this</span>, o);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Test o)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CompareToBuilder().append(<span class="keyword">this</span>.getId(), o.getId())  </span><br><span class="line">    .append(<span class="keyword">this</span>.getUsername(), o.getUsername()).toComparison();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面列举的，还有很多工具类，大部分也不说了，看一下方法基本就会用了，非常简单，看例子可去参考的第二个链接。<br>然后是日期，稍微提一下，也不常用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Date day1 = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于 Aache 的 DateUtils 和 DateFormatUtils 并没有 Joda 强大,  </span></span><br><span class="line"><span class="comment">     *  所以在这里只作简单的示例  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一天</span></span><br><span class="line">    DateUtils.addDays(day1, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 减少一年</span></span><br><span class="line">    DateUtils.addYears(day1, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化时间,第三参数为国际化,表示按美国时间显示</span></span><br><span class="line">    DateFormatUtils.format(day1, <span class="string">"yyyy-MM-dd"</span>, Locale.UK);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>看名字也知道，这是用来操作文件的工具类，工具类包括 FileUtils、IOUtils、FilenameUtils 和 FileSystemUtils，前三者的方法并没有多大的区别，只是操作的对象不同；<br>故名思议：FileUtils 主要操作 File 类，IOUtils 主要操作 IO 流，FilenameUtils 则是操作文件名，FileSystemUtils 包含了一些 JDK 没有提供的用于访问文件系统的实用方法。当前，只有一个用于读取硬盘空余空间的方法可用。<br>果然还是例子最能说明问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtilsTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拷贝文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File destFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    FileUtils.copyFile(srcFile, destFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File delFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    FileUtils.forceDelete(delFile);</span><br><span class="line">    <span class="comment">//FileUtils.forceMkdir(delFile);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 比较文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompareFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File destFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> result = FileUtils.contentEquals(srcFile, destFile);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移动文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoveFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"b.txt"</span>);</span><br><span class="line">    File destDir = <span class="keyword">new</span> File(basePath + <span class="string">"move"</span>);</span><br><span class="line">    FileUtils.moveToDirectory(srcFile, destDir, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读取文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    String content = FileUtils.readFileToString(srcFile);</span><br><span class="line">    List&lt;String&gt; contents = FileUtils.readLines(srcFile);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String string : contents) &#123;</span><br><span class="line">      System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 写入文件内容</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    FileUtils.writeStringToFile(srcFile, <span class="string">"\nyes文件"</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemUtilsTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取磁盘空余空间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFreeSpace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 以字节为单位</span></span><br><span class="line">    System.out.println(FileSystemUtils.freeSpace(<span class="string">"c:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    System.out.println(FileSystemUtils.freeSpace(<span class="string">"d:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 以k为单位</span></span><br><span class="line">    System.out.println(FileSystemUtils.freeSpaceKb(<span class="string">"e:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    System.out.println(FileSystemUtils.freeSpaceKb(<span class="string">"f:\\"</span>) / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineIteratorTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试行迭代器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    LineIterator li = FileUtils.lineIterator(file);</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">      System.out.println(li.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">    LineIterator.closeQuietly(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空内容文件过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEmptyFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    String[] files = dir.list(EmptyFileFilter.NOT_EMPTY);</span><br><span class="line">    <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">      System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名称后缀过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuffixFileFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    String[] files = dir.list(<span class="keyword">new</span> SuffixFileFilter(<span class="string">"a.txt"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">      System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String basePath = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    basePath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"\\file\\"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名称比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNameFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = NameFileComparator.NAME_COMPARATOR.compare(f1, f2);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件路径比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPathFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File f1 = <span class="keyword">new</span> File(basePath + <span class="string">"a.txt"</span>);</span><br><span class="line">    File f2 = <span class="keyword">new</span> File(basePath + <span class="string">"c.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = PathFileComparator.PATH_COMPARATOR.compare(f1, f2);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合比较器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeFileComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(basePath);</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    CompositeFileComparator cfc = <span class="keyword">new</span> CompositeFileComparator(</span><br><span class="line">      DirectoryFileComparator.DIRECTORY_COMPARATOR,</span><br><span class="line">      NameFileComparator.NAME_COMPARATOR);</span><br><span class="line">    cfc.sort(files);</span><br><span class="line">    System.out.println(<span class="string">"*****after sort*****"</span>);</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      System.out.println(file.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的还是刚上来工具类的那些，精简一下，最多的就是复制文件/文件夹：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制文件夹（文件夹里面的文件内容也会复制），file1和file2平级。</span></span><br><span class="line"><span class="comment">// 参数1：文件夹； 参数2：文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectory</span><span class="params">( file1 , file2 )</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件夹到另一个文件夹。 file1是file2的子文件夹.</span></span><br><span class="line"><span class="comment">// 参数1：文件夹； 参数2：文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectoryToDirectory</span><span class="params">( file1 , file2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件夹，带有文件过滤功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyDirectory</span><span class="params">(File srcDir, File destDir, FileFilter filter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***********复制文件**************</span></span><br><span class="line"><span class="comment">// 复制文件到另外一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(<span class="keyword">final</span> File srcFile, <span class="keyword">final</span> File destFile)</span></span>;</span><br><span class="line"><span class="comment">// 复制文件到输出流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">long</span> <span class="title">copyFile</span><span class="params">(<span class="keyword">final</span> File input, <span class="keyword">final</span> OutputStream output)</span></span>;</span><br><span class="line"><span class="comment">// 复制文件到一个指定的目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyFileToDirectory</span><span class="params">( file1 , file2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把输入流里面的内容复制到指定文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyInputStreamToFile</span><span class="params">( InputStream source, File destination)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把URL 里面内容复制到文件。可以下载文件。</span></span><br><span class="line"><span class="comment">// 参数1：URL资源 ； 参数2：目标文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyURLToFile</span><span class="params">(<span class="keyword">final</span> URL source, <span class="keyword">final</span> File destination)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把URL 里面内容复制到文件。可以下载文件。</span></span><br><span class="line"><span class="comment">// 参数1：URL资源 ； 参数2：目标文件；参数3：http连接超时时间 ； 参数4：读取超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyURLToFile</span><span class="params">(<span class="keyword">final</span> URL source, <span class="keyword">final</span> File destination,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">final</span> <span class="keyword">int</span> connectionTimeout, <span class="keyword">final</span> <span class="keyword">int</span> readTimeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>先暂时贴这么多吧，更多参考：<a href="https://blog.csdn.net/zhaoyanjun6/article/details/54972773" target="_blank" rel="noopener">https://blog.csdn.net/zhaoyanjun6/article/details/54972773</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c3c3ab2bad8d" target="_blank" rel="noopener">https://www.jianshu.com/p/c3c3ab2bad8d</a><br><a href="http://www.voidcn.com/article/p-ahnjkqaf-wo.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ahnjkqaf-wo.html</a><br><a href="https://blog.csdn.net/u011179993/article/details/46743521" target="_blank" rel="noopener">https://blog.csdn.net/u011179993/article/details/46743521</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dubbo学习笔记]]></title>
      <url>http://bfchengnuo.com/2018/07/07/Dubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>关于 Dubbo 以前也用过几次，都是浅度学习，也没做笔记，今天看了下官网竟然改版了，手册更新了，借这个契机来复习下，并且做下笔记，内容大部分来自官方手册。<br>官网：<a href="https://dubbo.incubator.apache.org" target="_blank" rel="noopener">https://dubbo.incubator.apache.org</a><br>旧版的用户使用手册：<a href="https://www.gitbook.com/book/dubbo/dubbo-user-book" target="_blank" rel="noopener">https://www.gitbook.com/book/dubbo/dubbo-user-book</a><a id="more"></a><br>官方文档开始的背景介绍写的挺不错的，可以去参考下，曾经的 ORM、MVC，到现在的分布式 RPC 和 SOA。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>个人感觉 Dubbo 的架构设计是很不错的，官网的文档也解释的很详细：<img src="https://dubbo.incubator.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"> </p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Provider</code></td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td><code>Consumer</code></td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td><code>Container</code></td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p><strong>调用关系说明</strong></p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者<strong>地址列表</strong>给消费者，如果有变更，注册中心将<strong>基于长连接</strong>推送变更数据给消费者。</li>
<li><strong>服务消费者</strong>，从提供者地址列表中，<strong>基于软负载均衡算法</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。<br>我认为 Dubbo 适用于比较大、复杂的服务调用需求的系统，一般的中小型使用通过配置服务的 URL 地址进行调用，通过 F5 等硬件进行负载均衡（或者通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务 ）这样就足够了。</p>
<h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，<strong>服务提供者和消费者只在启动时与注册中心交互</strong>，注册中心不转发请求，压力较小</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后<strong>每分钟一次发送到监控中心</strong>服务器，并以报表展示</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>
<li>服务消费者向注册中心获取服务提供者<strong>地址列表</strong>，并<strong>根据负载算法直接调用提供者，同时汇报调用时间到监控中心</strong>，此时间包含网络开销</li>
<li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li>
<li>注册中心通过长连接感知服务提供者的存在，<strong>服务提供者宕机，注册中心将立即推送事件通知消费者</strong></li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，<strong>消费者在本地缓存了提供者列表</strong></li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>
</ul>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，<strong>注册中心仍能通过缓存提供服务列表查询</strong>，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li><strong>服务提供者无状态，任意一台宕掉后，不影响使用</strong></li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并<strong>无限次重连等待服务提供者恢复</strong></li>
</ul>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><ul>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>仿照官方文档，最简单的代码示例放在了我 Github 上的 <a href="https://github.com/bfchengnuo/java_learn/tree/master/ExampleCode/Dubbo" target="_blank" rel="noopener">Java_lean</a> 仓库里，自取…..配置了 xml 版和注解版（推荐），<strong>Dubbo 采用全 Spring 配置方式，能基于 Spring 的 Schema 扩展进行加载</strong>，Dubbo 宣称能与 Spring（SpringBoot） 无缝整合，不能浪费。<br>就是添加了 Dubbo 的依赖，根据传递性，就自动导入了 Spring 相关依赖，所以测试的话只需要一个 Dubbo、zookeeper 、zkclient 和你定义的接口就可以了！<br>另外就是 Dubbo 底层用的是 netty 做通讯，所以效率会较高。<br>在搭建测试的时候终究还是踩了不少坑，记录在<a href="https://github.com/bfchengnuo/MyRecord/blob/e181f5c9e609a2a58a08894358510d512dc41e60/FixException/Maven%2BDubbo%E5%85%A5%E9%97%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91.md" target="_blank" rel="noopener">这里</a>附上了解决方案。在使用注解方式时，尤其注意 <code>&lt;dubbo:annotation&gt;</code> 在 2.5.8 之后的版本不再支持了！请使用 @Configuration  大法解决。</p>
<hr>
<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>关于 XML 的基本配置，主要是服务的提供方和消费方，配置非常类似：<br>服务提供方（remote-provider.xml）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 提供方应用信息(当前应用名称)，用于计算依赖关系 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-provider"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用 dubbo 协议，在 20880 端口暴露服务 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置需要提供远程服务的对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxServiceImpl”</span> /&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 增加暴露远程服务配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务消费方（remote-consumer.xml）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"dubbo-consumer"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用zookeeper广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 增加引用远程服务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">“xxxService”</span> <span class="attr">interface</span>=<span class="string">“com.xxx.XxxService”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和本地服务一样使用远程服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“xxxAction”</span> <span class="attr">class</span>=<span class="string">“com.xxx.XxxAction”</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“xxxService”</span> <span class="attr">ref</span>=<span class="string">“xxxService”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上就是最简单的纯 XML 方式使用 Dubbo，用的不多了吧，毕竟 XML 太繁琐了。<br>另外就是所有标签都支持自定义参数（通过子标签 <code>&lt;dubbo:parameter key=&quot;queue&quot; value=&quot;your_queue&quot; /&gt;</code>），用于不同扩展点实现的特殊配置 。<br>引用缺省是延迟初始化的，只有引用被注入到其它 Bean，或被 <code>getBean()</code> 获取，才会初始化，如需立即实例化，可配置：<code>&lt;dubbo:reference ... init=&quot;true&quot; /&gt;</code><br>对于相同的属性，例如 timeout 查找（优先级）顺序是： <code>referenceMethod --&gt;  serviceMethod --&gt; reference --&gt;  service --&gt; consumer --&gt; provider</code></p>
<hr>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>需要 <code>2.5.7</code> 及以上版本支持，使用注解的方式配置：<br>使用 javaconfig 形式配置公共模块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于 &lt;dubbo:application&gt;</span></span><br><span class="line">    ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">    applicationConfig.setName(<span class="string">"provider-test"</span>);</span><br><span class="line">    <span class="keyword">return</span> applicationConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于 &lt;dubbo:registry&gt;</span></span><br><span class="line">    RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">    registryConfig.setAddress(<span class="string">"zookeeper://127.0.0.1:2181"</span>);</span><br><span class="line">    registryConfig.setClient(<span class="string">"curator"</span>);</span><br><span class="line">    <span class="keyword">return</span> registryConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对于消费方，还可以配一个 consumerConfig</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConsumerConfig <span class="title">consumerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConsumerConfig consumerConfig = <span class="keyword">new</span> ConsumerConfig();</span><br><span class="line">    consumerConfig.setTimeout(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> consumerConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定 Dubbo 的扫描路径，就是自动扫描，提供方和消费方都是一样的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span>(basePackages = <span class="string">"com.alibaba.dubbo.test.service.impl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderTestApp</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次强调，2.5.8 之后 <code>&lt;dubbo:annotation&gt;</code> 不再可用！<br>服务提供方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(timeout = <span class="number">5000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateServiceImpl</span> <span class="keyword">implements</span> <span class="title">AnnotateService</span> </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于 XML 中的 <code>&lt;dubbo:service /&gt;</code> 用来暴露服务。<br>服务消费方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConsumeService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 就是自动注入了</span></span><br><span class="line">  <span class="meta">@Reference</span></span><br><span class="line">  <span class="keyword">public</span> AnnotateService annotateService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="properties配置"><a href="#properties配置" class="headerlink" title="properties配置"></a>properties配置</h3><p>在比较简单的情况下，例如没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，Dubbo 将自动加载 classpath 根目录下的 <code>dubbo.properties</code>，可以通过 JVM 启动参数 <code>-Ddubbo.properties.file=xxx.properties</code> 改变缺省配置位置。<br>将 XML 配置的标签名，加属性名，用点分隔，多个属性拆成多行：</p>
<ul>
<li>比如：<code>dubbo.application.name=foo</code>等价于<code>&lt;dubbo:application name=&quot;foo&quot; /&gt;</code></li>
<li>比如：<code>dubbo.registry.address=10.20.153.10:9090</code>等价于<code>&lt;dubbo:registry address=&quot;10.20.153.10:9090&quot; /&gt;</code></li>
</ul>
<p>如果 XML 有多行同名标签配置，可用 id 号区分，如果没有 id 号将对所有同名标签生效：</p>
<ul>
<li>比如：<code>dubbo.protocol.rmi.port=1234</code>等价于<code>&lt;dubbo:protocol id=&quot;rmi&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;</code></li>
<li>比如：<code>dubbo.registry.china.address=10.20.153.10:9090</code>等价于<code>&lt;dubbo:registry id=&quot;china&quot; address=&quot;10.20.153.10:9090&quot; /&gt;</code></li>
</ul>
<p>下面是 dubbo.properties 的一个典型配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=foo</span><br><span class="line">dubbo.application.owner=bar</span><br><span class="line">dubbo.registry.address=10.20.153.10:9090</span><br></pre></td></tr></table></figure>
<p>关于优先级，JVM 启动参数 -D 最优先，其次是 XML 的配置，最后是 properties 文件。</p>
<h2 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h2><p>Dubbo 缺省会在<strong>启动时检查依赖</strong>的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成 ，默认 <code>check=&quot;true&quot;</code>。 所以说，启动是有顺序的，默认下必须要服务方先启动。<br>check 属性可以加在 dubbo:reference  、dubbo:consumer  、dubbo:registry  标签中，分别控制的是：<br>某个服务的启动时检查（没有提供者时报错 ）、所有服务的启动时检查、注册中心启动时检查（注册订阅失败时报错）。<br>优先级是 reference &gt; consumer ，还可以设置全局参数，例如：<code>dubbo.reference.check=false</code> 、 <code>dubbo.consumer.check=false</code> 等</p>
<h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。 </p>
<p><img src="https://dubbo.incubator.apache.org/docs/zh-cn/user/sources/images/cluster.jpg" alt="cluster"> </p>
<p>根据上面的架构图，理下各节点关系：</p>
<ul>
<li>这里的 <code>Invoker</code> 是 <code>Provider（服务提供方）</code> 的一个可调用 <code>Service</code> 的抽象，<code>Invoker</code> 封装了 <code>Provider</code> 地址及 <code>Service</code> 接口信息。</li>
<li><code>Directory</code> 代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更。</li>
<li><code>Cluster（集群）</code> 将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code>，<strong>对上层透明</strong>，伪装过程包含了容错逻辑，调用失败后，重试另一个。</li>
<li><code>Router</code> 负责从多个 <code>Invoker</code> 中按路由规则<strong>选出子集</strong>，比如读写分离，应用隔离等。</li>
<li><code>LoadBalance</code> 负责从多个 <code>Invoker</code> 中<strong>选出具体的一个</strong>用于本次调用，选的过程包含了<strong>负载均衡算法</strong>，调用失败后，需要重选。</li>
</ul>
<h3 id="容错模式"><a href="#容错模式" class="headerlink" title="容错模式"></a>容错模式</h3><p>Dubbo 提供的容错模式有：</p>
<ul>
<li><strong>Failover Cluster</strong><br>默认的故障转移模式，就是失败自动切换，当出现失败，重试其它服务器 。<strong>通常用于读操作</strong>，但重试会带来更长延迟。<br>可通过 <code>retries</code> 属性来指定重试的次数（不含第一次）</li>
<li><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe Cluster</strong><br>失败安全（指不会抛出异常），出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。通常<strong>用于消息通知</strong>操作。</li>
<li><strong>Forking Cluster</strong><br><strong>并行调用</strong>多个服务器，只要一个成功即返回。通常<strong>用于实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</li>
<li><strong>Broadcast Cluster</strong><br>广播调用<strong>所有</strong>提供者，<strong>逐个调用</strong>，任意一台报错则报错。通常用于<strong>通知所有提供者更新缓存或日志等</strong>本地资源信息。</li>
</ul>
<p>集群配置模式（以 XML 为例）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failsafe"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务消费方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failsafe"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。可以自行扩展负载均衡策略。</p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><ul>
<li><strong>Random LoadBalance</strong><br><strong>随机</strong>，按<strong>权重</strong>设置随机概率。<br>在一个截面上碰撞的概率高，但<strong>调用量越大分布越均匀</strong>，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
<li><strong>RoundRobin LoadBalance</strong><br><strong>轮循</strong>，按公约后的权重设置轮循比率。<br>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li><strong>LeastActive LoadBalance</strong><br><strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。<br><strong>使慢的提供者收到更少请求</strong>，因为越慢的提供者的调用前后计数差会越大。</li>
<li><strong>ConsistentHash LoadBalance</strong><br><strong>一致性 Hash</strong>，<em>相同参数的请求总是发到同一提供者。</em><br>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<br>缺省只对第一个参数 Hash （由 <code>hash.arguments</code> 参数控制）。<br>缺省用 160 份虚拟节点（由 <code>hash.nodes</code> 参数控制）。</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>示例为基于 XML 的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方法级别调用配在 &lt;dubbo:method&gt; 中 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="直连提供者"><a href="#直连提供者" class="headerlink" title="直连提供者"></a>直连提供者</h2><p>在开发及测试环境下，经常需要<strong>绕过注册中心，只测试指定服务提供者</strong>，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。<br>通过 XML 来配置直接的提供者，在 <code>&lt;dubbo:reference&gt;</code> 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开：<code>&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.alibaba.xxx.XxxService&quot; url=&quot;dubbo://localhost:20890&quot; /&gt;</code><br>除外，还可以通过 -D 参数来指定：<code>java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890</code><br>配置的服务如果较多，可采用文件（properties）映射。</p>
<h2 id="只订阅-amp-注册"><a href="#只订阅-amp-注册" class="headerlink" title="只订阅&amp;注册"></a>只订阅&amp;注册</h2><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。<br>可以让服务<strong>提供者</strong>开发方，<strong>只订阅服务</strong>(开发的服务可能依赖其它服务)，而<strong>不注册正在开发的服务</strong>，通过直连测试正在开发的服务。<br>配置方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> <span class="attr">register</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090?register=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于只注册的情况，例如让服务<strong>提供者方只注册服务到某一注册中心</strong>，而消费方不从另外的注册中心订阅服务。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">subscribe</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"hzRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.153.10:9090"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"qdRegistry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090?subscribe=false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="多协议"><a href="#多协议" class="headerlink" title="多协议"></a>多协议</h2><p>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</p>
<h3 id="不同服务不同协议"><a href="#不同服务不同协议" class="headerlink" title="不同服务不同协议"></a>不同服务不同协议</h3><p>不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"registry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"hello1234"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dubbo协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用rmi协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.DemoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多协议暴露服务"><a href="#多协议暴露服务" class="headerlink" title="多协议暴露服务"></a>多协议暴露服务</h3><p>需要与 http 客户端互操作</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"world"</span>  /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">"registry"</span> <span class="attr">address</span>=<span class="string">"10.20.141.150:9090"</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"hello1234"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多协议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"hessian"</span> <span class="attr">port</span>=<span class="string">"8080"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用多个协议暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">protocol</span>=<span class="string">"dubbo,hessian"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，Dubbo 也支持多注册中心。</p>
<h3 id="Dubbo协议"><a href="#Dubbo协议" class="headerlink" title="Dubbo协议"></a>Dubbo协议</h3><p>默认协议，也是推荐的协议，这里就只说它，关于 <code>dubbo://</code> 的基本介绍：</p>
<blockquote>
<p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。<br>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
</blockquote>
<p>特性：</p>
<ul>
<li>连接个数：单连接</li>
<li>连接方式：长连接</li>
<li>传输协议：TCP</li>
<li>传输方式：NIO 异步传输</li>
<li>序列化：Hessian 二进制序列化</li>
<li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</li>
<li>适用场景：常规远程服务方法调用</li>
</ul>
<p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。<br>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。<br>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p>
<h2 id="服务分组-amp-多版本"><a href="#服务分组-amp-多版本" class="headerlink" title="服务分组&amp;多版本"></a>服务分组&amp;多版本</h2><p>当一个接口有多种实现时，可以用 group 区分。<br>XML 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"feedback"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">group</span>=<span class="string">"member"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"feedbackIndexService"</span> <span class="attr">group</span>=<span class="string">"feedback"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"memberIndexService"</span> <span class="attr">group</span>=<span class="string">"member"</span> <span class="attr">interface</span>=<span class="string">"com.xxx.IndexService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 任意组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">group</span>=<span class="string">"*"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。 XML 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务提供者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务消费者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果不需要区分版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"*"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>官方给的版本迁移建议：</p>
<ol>
<li>在低压力时间段，先升级一半提供者为新版本</li>
<li>再将所有消费者升级为新版本</li>
<li>然后将剩下的一半提供者升级为新版本</li>
</ol>
<h2 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h2><p>用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量 。</p>
<h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><ul>
<li><code>lru</code><br>基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。</li>
<li><code>threadlocal</code><br>当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。</li>
<li><code>jcache</code><br>与 <a href="http://jcp.org/en/jsr/detail?id=107%27" target="_blank" rel="noopener">JSR107</a> 集成，可以桥接各种缓存实现。</li>
</ul>
<p>XML 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">cache</span>=<span class="string">"lru"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findBar"</span> <span class="attr">cache</span>=<span class="string">"lru"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。<br>首先，在 XML 中开启异步支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"fooService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.foo.FooService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findFoo"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.bar.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findBar"</span> <span class="attr">async</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码中进行异步调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">fooService.findFoo(fooId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此调用会立即返回null</span></span><br><span class="line">barService.findBar(barId);</span><br><span class="line"><span class="comment">// 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future</span></span><br><span class="line">Future&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此时findFoo和findBar的请求同时在执行，客户端不需要启动多线程来支持并行，而是借助NIO的非阻塞完成</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果foo已返回，直接拿到返回值，否则线程wait住，等待foo返回后，线程会被notify唤醒</span></span><br><span class="line">Foo foo = fooFuture.get(); </span><br><span class="line"><span class="comment">// 同理等待bar返回</span></span><br><span class="line">Bar bar = barFuture.get(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果foo需要5秒返回，bar需要6秒返回，实际只需等6秒，即可获取到foo和bar，进行接下来的处理。</span></span><br></pre></td></tr></table></figure>
<p>是否等待消息发出（配置在 dubbo:method 中即可）：</p>
<ul>
<li><code>sent=&quot;true&quot;</code> 等待消息发出，消息发送失败将抛出异常。</li>
<li><code>sent=&quot;false&quot;</code> 不等待消息发出，将消息放入 IO 队列，即刻返回。</li>
</ul>
<p>如果你只是想异步，完全忽略返回值，可以配置 <code>return=&quot;false&quot;</code>，以减少 Future 对象的创建和管理成本<br>其中，<strong>异步方式总是不等待返回</strong>。</p>
<h2 id="并发-amp-连接控制"><a href="#并发-amp-连接控制" class="headerlink" title="并发&amp;连接控制"></a>并发&amp;连接控制</h2><p>通过在 dubbo:service 标签中设置 executes  属性来控制服务器端并发执行（或占用线程池线程数）不能超过的个数。<br>通过设置 actives 属性（可在 dubbo:reference/service 中设置）来控制每客户端并发执行（或占用连接的请求数）不能超过的个数。<br>如果 <code>&lt;dubbo:service&gt;</code> 和 <code>&lt;dubbo:reference&gt;</code> 都配了actives，<code>&lt;dubbo:reference&gt;</code> 优先。</p>
<h3 id="Load-Balance-均衡"><a href="#Load-Balance-均衡" class="headerlink" title="Load Balance 均衡"></a>Load Balance 均衡</h3><p>配置服务的客户端的 <code>loadbalance</code> 属性为 <code>leastactive</code>，此 Loadbalance 会调用并发数最小的 Provider（Consumer端并发数）。 可在 dubbo:reference/service 中设置。</p>
<hr>
<p>连接控制分为服务端的连接控制和客户端的连接控制，XML 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 限制服务器端接受的连接不能超过 10 个,两种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span> <span class="attr">accepts</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">accepts</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 限制客户端服务使用连接不能超过 10 个，两种方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">connections</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">connections</span>=<span class="string">"10"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>&lt;dubbo:service&gt;</code> 和 <code>&lt;dubbo:reference&gt;</code> 都配了 connections，<code>&lt;dubbo:reference&gt;</code> 优先.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>列举下没用过，但是可能会用到的，所以这些并不全，最全的还要去官网的示例看：</p>
<ul>
<li>分组聚合<br>接口一样，但有多种实现，用 group 区分，现在消费方需从每种 group 中调用一次返回结果，合并结果返回。</li>
<li>回声测试<br>回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。<br>所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可调用 <code>$echo(&quot;OK&quot;)</code> 方法看看是否返回 OK</li>
<li>上下文信息<br>上下文中存放的是当前调用过程中所需的环境信息（获取提供方 IP、判断是否为消费端等）。所有配置信息都将转换为 URL 的参数；<br>RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。</li>
<li>隐式参数<br>通过 RpcContext 上的 <code>setAttachment</code> 和 <code>getAttachment</code> 在服务消费方和提供方之间进行参数的隐式传递。<br>例如：<code>RpcContext.getContext().set/getAttachment()</code></li>
<li>本地调用<br>本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。</li>
<li><strong>参数回调&amp;事件通知</strong><br>参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。<br>在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。</li>
<li>延迟连接<br>延迟连接用于减少长连接数。当有调用发起时，再创建长连接。</li>
</ul>
<h2 id="推荐用法"><a href="#推荐用法" class="headerlink" title="推荐用法"></a>推荐用法</h2><p>在 Provider（提供方） 上尽量多配置 Consumer（消费方） 端属性：</p>
<ul>
<li>作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等</li>
<li>在 Provider 配置后，Consumer 不配置则会使用 Provider 的配置值，即 Provider 配置可以作为 Consumer 的缺省值。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 不可控的，并且往往是不合理的。<br><strong>覆盖规则：Consumer 端配置优于 Provider 配置，优于全局配置</strong></li>
</ul>
<p>这样可以让 Provider 实现者一开始就思考 Provider 服务特点、服务质量的问题。<br>常见的配置有：</p>
<ul>
<li>timeout 方法调用超时</li>
<li>retries 失败重试次数，缺省是 2（会调用 3 次）</li>
<li>loadbalance 负载均衡算法，缺省是随机 random。还可以有轮询 roundrobin、最不活跃优先 leastactive</li>
<li>actives 消费者端，最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会 Wait 直到超时 在方法上配置 <code>dubbo:method</code> 则并发限制针对方法，在接口上配置 <code>dubbo:service</code>，则并发限制针对服务</li>
</ul>
<p>Provider 上可以配置的 Provider 端属性有：</p>
<ul>
<li><code>threads</code> 服务线程池大小</li>
<li><code>executes</code> 一个服务提供者并行执行请求上限，即当 Provider 对一个服务的并发调用到上限后，新调用会 Wait，这个时候 Consumer可能会超时。在方法上配置 <code>dubbo:method</code> 则并发限制针对方法，在接口上配置 <code>dubbo:service</code>，则并发限制针对服务。</li>
</ul>
<p>XML 配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retry</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.WorldService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retry</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">retries</span>=<span class="string">"9"</span> <span class="attr">loadbalance</span>=<span class="string">"leastactive"</span> <span class="attr">actives</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Provider 上配置合理的 Provider 端属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">threads</span>=<span class="string">"200"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">executes</span>=<span class="string">"200"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">executes</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>配置管理信息：<br>目前有负责人信息和组织信息用于区分站点。有问题时便于的找到服务的负责人，至少写两个人以便备份。负责人和组织的信息可以在注册中心的上看到，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 应用配置负责人、组织 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> <span class="attr">organization</span>=<span class="string">”intl”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- service 配置负责人 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- reference 配置负责人 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">owner</span>=<span class="string">”ding.lid,william.liangf”</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>配置 Dubbo 缓存文件（在提供者方设置列表缓存文件）:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">file</span>=<span class="string">”$&#123;user.home&#125;/output/dubbo.cache”</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>文件的路径，应用可以根据需要调整，保证这个文件不会在发布过程中被清除。<br>如果有多个应用进程注意不要使用同一个文件，避免内容被覆盖。<br>这个文件会缓存注册中心的列表和服务提供者列表。</p>
<hr>
<p>对于监控，推荐使用固定端口暴露服务，而不要使用随机端口，这样在注册中心推送有延迟的情况下，消费者通过缓存列表也能调用到原地址，保证调用成功。<br>最后就是不要使用 <code>dubbo.properties</code> 文件配置，推荐使用对应 XML 配置</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> RPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式总结]]></title>
      <url>http://bfchengnuo.com/2018/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>看完了 Head First 设计模式，收获还是蛮多的，这么多设计模式总算有了个了解，距离实用还有一定距离，毕竟是个经验活，不得不说设计模式中的思想真是太棒了！后面有几种模式没时间拿出来单独研究了，在这里就都战略性总结一下吧，啊哈哈~~<a id="more"></a><br>希望我也能写出一手漂亮的代码！</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>一览表：</p>
<table>
<thead>
<tr>
<th>设计原则名称</th>
<th>定 义</th>
<th>使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则 (Single Responsibility Principle, SRP)</td>
<td>一个类只负责一个功能领域中的相应职责</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>开闭原则 (Open-Closed Principle, OCP)</td>
<td>软件实体应对扩展开放，而对修改关闭</td>
<td>★★★★★</td>
</tr>
<tr>
<td>里氏代换原则 (Liskov Substitution Principle, LSP)</td>
<td>所有引用基类对象的地方能够透明地使用其子类的对象</td>
<td>★★★★★</td>
</tr>
<tr>
<td>依赖倒转原则 (Dependence Inversion Principle, DIP)</td>
<td>抽象不应该依赖于细节，细节应该依赖于抽象</td>
<td>★★★★★</td>
</tr>
<tr>
<td>接口隔离原则 (Interface Segregation Principle, ISP)</td>
<td>使用多个专门的接口，而不使用单一的总接口</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>合成复用原则 (Composite Reuse Principle, CRP)</td>
<td>尽量使用对象组合，而不是继承来达到复用的目的</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>迪米特法则 (Law of Demeter, LoD)</td>
<td>一个软件实体应当尽可能少地与其他实体发生相互作用</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h3 id="基本的设计原则"><a href="#基本的设计原则" class="headerlink" title="基本的设计原则"></a>基本的设计原则</h3><p>上面的表中都是专业的说法，但是貌似并不怎么好理解，反正我是看的比较懵逼，然后就用普通的语言来进行描述下，首先是下面总结的几条，应该是大纲级别的了</p>
<ul>
<li>封装变化<br>找出应用中可能需要变化的部分，把它们独立出来；不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>多用组合，少用继承</li>
<li>为交互对象之间的松耦合设计而努力</li>
</ul>
<p>这样设计类才能更好的利用 OO 的特性，也是基础：抽象、封装、继承、多态；<br>良好的 OO 设计必须具备：可复用、可扩充、可维护三个特性</p>
<p>对上面不太好理解的地方补充：<br><strong>松耦合：</strong><br>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节；也就是说，如果改变其中一方并不会影响到另一方，因为两者是松耦合的，所以只有它们之间的接口仍被遵守，那么我们就可以自由的改变它们（接口的重要性）<br><strong>松耦合的设计之所以能建立起富有弹性的 OO 系统，能够应对变化，是因为对象之间的互相依赖降到了最低。</strong></p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>从表中也可以看出，这个使用的非常频繁，开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则；它规定：类应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。<br>我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为；装饰模式就是遵守的这个原则的体现（硬要说，观察者模式也是遵循的）<br>当然，并不是让每个地方都遵循开闭原则（这回增加代码的复杂度），我们要把注意力集中在最有可能改变的地方，然后应用开闭原则</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>规定的是：要依赖抽象，而不是依赖具体的类；emmm，和“针对接口编程，而不是针对实现编程”貌似是差不多的<br>它说明：不能让高层组件依赖低层组件，而且，不管高层或者低层组件，两者都应该依赖于抽象！</p>
<blockquote>
<p>所谓高层组件，是由其他低层组件定义其行为的类。<br>就比如人类是高层组件，男人就是低层组件，它的部分行为是由男人定义的（差不多就这个意思，不要太纠结）</p>
</blockquote>
<p>那么，究竟是哪里“倒置”了呢，低层组件会依赖高层的抽象，高层组件也依赖相同的抽象<br><del>（假定男人拥有一个抽象，那么相对于具体实现这个抽象是“高层”的，高层组件也依赖这个抽象）</del><br>我们一般的思维是从顶端开始，然后往下到具体的类，倒置你的想法就是别从顶端开始，首先想的是甭管什么样的男人都需要一个共同的抽象类，然后人类也会依赖这个抽象类，这样想其实就已经倒置了！大概…..<br>然后是几个指导方针：</p>
<ul>
<li>变量不可以持有具体类的引用</li>
<li>不要让类派生自具体类</li>
<li>不要覆盖基类中已经实现的方法</li>
</ul>
<p>但毕竟是指导作用，不可避免的在某些条件下要违反，只是尽量的遵守罢了；我们实例化字符串的时候都是 new 啊，违反了方针啊，但完全可以，因为字符串不可能改变，所以说要灵活<br>工厂模式就是这个原则的代表吧</p>
<h3 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h3><p>单一职责原则（SRP）<br>开放封闭原则（OCP）<br>里氏替换原则（LSP）<br>依赖倒置原则（DIP）<br>接口隔离原则（ISP）</p>
<h3 id="OO原则"><a href="#OO原则" class="headerlink" title="OO原则"></a>OO原则</h3><p>下面列出了基本的原则：</p>
<ul>
<li>封装变化</li>
<li>多用组合，少用继承</li>
<li>针对接口编程，不针对实现编程</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>类应该对修改关闭，对扩展开放</li>
<li>依赖抽象，不依赖具体类</li>
<li>只和“朋友”交谈（减少对象之间的交互）</li>
<li>别找（调用）我，我会找（调用）你</li>
<li>类应该只有一个改变的理由</li>
</ul>
<h2 id="设计模式一览"><a href="#设计模式一览" class="headerlink" title="设计模式一览"></a>设计模式一览</h2><p>这里只是列出了常用的一些模式，并不是全部，每一种模式只是做了简单的解释，具体的实践需要看以前的文章。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>定义算法族，分别封装起来，让它们之间可以互相替换；此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>
<p>比如，提供一些 setter 方法设置相应的“策略”，详细解释：<a href="https://bfchengnuo.com/2017/05/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E8%80%85%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p>在对象之间定义一对多依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并且自动更新。</p>
</blockquote>
<p>当有多个观察者时，不要依赖他们的通知次序，因为是不确定的。详细解释：<a href="https://bfchengnuo.com/2017/05/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote>
<p>动态的将责任附加到对象上；想要扩展功能，装饰者提供有别于继承的另一种选择。</p>
</blockquote>
<p>符合开闭原则，在动态代理中应用广泛。<br>装饰者一般对组件的客户是透明的，装饰者会导致设计中出现许多小对象，过度使用会使系统变的复杂。<br>通常，我们会在调用真正的原始对象方法之前或者之后做一些动作。详细解释：<a href="https://bfchengnuo.com/2017/05/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>工厂方法模式：定义了一个创建对象的接口，但子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。<br>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
</blockquote>
<p>我们常用的是简单工厂模式，而工厂方法模式相对复杂一些，另外还有抽象工厂模式；他们都是属于工厂模式。<br>其中使用到了依赖倒置原则。详细解释：<a href="https://bfchengnuo.com/2016/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava/">飞机</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>确保一个类只有一个实例，并提供全局访问点。</p>
</blockquote>
<p>最广泛的模式之一了吧，考察它的也相当多，写法也比较简单。<br>不过需要注意多线程并发的问题，懒汉式和饿汉式，使用双重判断的弊端、原子性和一致性，指令重排等，内容还是比较多的。<br>注意使用多个类加载器也会导致生成多实例。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><blockquote>
<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。<br>命令模式也支持可撤销的操作。</p>
</blockquote>
<p>让请求调用者和请求接受者解耦，解耦的两者是通过命令对象进行沟通的，封装了其动作。<br>其中可能会使用“空对象模式”，它可以实现队列请求、日志请求等需求（实现日志系统和事务系统）。<br>宏命令是一种简单的延伸。详细解释：<a href="https://bfchengnuo.com/2017/09/14/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="适配器-amp-外观模式"><a href="#适配器-amp-外观模式" class="headerlink" title="适配器&amp;外观模式"></a>适配器&amp;外观模式</h3><blockquote>
<p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
</blockquote>
<p>比如 JDK 中的枚举和迭代器？<br>其中其实还包含有另一个模式：外观模式，它让接口更简单（改变接口的原因），也将客户从组件的子系统解耦。<br>适配器的意图：“改变”接口符合客户的期望。<br>外观模式的意图：提供子系统的一个简化接口。</p>
<blockquote>
<p>提供了一个统一的接口，用来访问子系统中的一群接口。|外观定义了一个高层接口，让子系统更容易使用。</p>
</blockquote>
<p>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。<br>适配器：将一个对象包装起来以改变其接口。<br>装饰者：将一个对象包装起来增加新的行为和责任。<br>外观：将一群对象“包装”起来简化其接口。<br>详细解释：<a href="https://bfchengnuo.com/2017/09/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><blockquote>
<p>在一个方法中，定义一个算法骨架，而将一些步骤延迟到子类中。<br>模板方法使子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>
<p>其中可以使用钩子，钩子控制根据某些条件是否执行某部分算法。<br>还使用了好莱坞原则：别调用我们，我们会调用你。<br>模板方法可以是一种代码复用的技巧，可以定义具体方法、抽象方法、钩子（可以选择要不要覆盖）。<br>为了防止子类改变模板方法中的算法，可以定义为 final，并且可以说工厂方法是模板方法的一种特殊版本。<br>详细解释：<a href="https://bfchengnuo.com/2017/09/29/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">飞机</a></p>
<h3 id="迭代器-amp-组合模式"><a href="#迭代器-amp-组合模式" class="headerlink" title="迭代器&amp;组合模式"></a>迭代器&amp;组合模式</h3><blockquote>
<p>迭代器：<br>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。<br>组合：<br>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p>
</blockquote>
<p>他们两个往往能拼在一起使用， 使用组合我们能把相同的操作应用在组合和个别对象上（叶子节点），他们通常有（或者提取出）共同的接口，也就是说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别（只不过有的可能是空实现）。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>策略模式（主动）和状态模式是双胞胎，在出生时才分开。</p>
<blockquote>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
</blockquote>
<p>通常，状态模式用类代表状态；Context 会将行为委托给当前的状态对象，状态类可以被多个 Context 实例共享。<br>同样，使用状态模式通常会导致设计中的类数量大大增加。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p>为另一个对象提供一个替身或占位符以控制对这个对象的访问。<br>被代理的对象可以是远程的对象（远程代理）、创建开销大的对象（虚拟代理）或需要安全控制的对象（保护代理）。</p>
</blockquote>
<p>代理模式要做的主要就是：控制和管理访问，在 AOP 中使用广泛吧。。。<br>Java 中的 RMI 就是一个典型的例子，远程代理是一般代理模式的一种实现。<br>虚拟代理：只有当我们真正需要一个对象的时候才创建它，对象创建后代理就会将请求直接委托给对象（显示图片前的“加载中”）。<br>为了让客户使用代理而不是真正的对象，一般是创建一个工厂，由工厂返回代理对象。<br><strong>因为实际的代理类是运行时创建的，我们称这个 Java 技术为动态代理。</strong><br>衍生类还有很多，比如防火墙代理、缓存代理、智能引用代理、同步代理等。<br>代理在结构上类似装饰者，但是目的不同；装饰者模式是为对象加上行为；而代理是控制访问。<br>Java 中内置代理支持，代理同样会造成你设计中类的数目增加。</p>
<h3 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h3><blockquote>
<p>符合模式结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题。</p>
</blockquote>
<p>MVC 是典型的复合模式，其实控制器使用了策略模式（控制器是视图的策略）、模型使用了观察者模式、视图使用了组合模式。<br>Web 的开发人员对 MVC 进行适配，使它符合 B/S 模型，我们称这样的适配为 Model 2。</p>
<h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><blockquote>
<p>模式是在某情景（Context）下，针对某问题的某种解决方案。<br>情景：就是应用某个模式的情况。这应该是会不断出现的情况。<br>问题：你想在某情景下达到的目标，但也可以是某情景下的约束。<br>解决方案：就是你所追求的一个通用的设计。</p>
</blockquote>
<p>当然你可以改变模式。像设计原则一样，模式不是法律或准则，它只是指导方针，你可以改变模式来符合你的需要。</p>
<ul>
<li>架构模式</li>
<li>应用模式<br>三层架构、C/S 系统以及 Web 服务中</li>
<li>桥接模式<br>不只改变你的实现，也改变你的抽象；会增加复杂度</li>
<li>生成器模式<br>封装一个产品的构造过程，并允许按步骤构造。隐藏内部表现，产品的实现可以被替换，被用来创建组合结构。</li>
<li>责任链模式<br>当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式。<br>如果没有任何对象处理它，那它就可能不会被处理。</li>
<li>蝇量模式<br>如果想要某个类的一个实例能用来提供许多“虚拟实例”，就使用此模式。</li>
<li>解释器模式</li>
<li>中介者模式<br>使用中介者模式来集中相关对象之间复杂的沟通和控制方式。设计不当，本身会过于复杂</li>
<li>备忘录模式<br>当你需要让对象返回之前的状态时（比如撤销操作），用于存储状态。<br>存储和恢复的过程比较耗时，Java 中使用序列化</li>
<li>原型模式<br>当创建给定类的实例过程很昂贵或者很复杂时，就使用原型模式</li>
<li>访问者模式<br>当你想要为一个对象的组合增加新的能力，并且封装不重要时</li>
</ul>
<h2 id="与设计模式相处"><a href="#与设计模式相处" class="headerlink" title="与设计模式相处"></a>与设计模式相处</h2><ul>
<li>保持简单<br>你的目标应该是<strong>简单</strong>，而不是如何才能应用上模式；正确的说法是：为了让你的设计简单且有弹性，有时候使用模式是最好的方法。</li>
<li>考虑模式带来的后果</li>
<li>知道何时使用<br>这更多的是一种经验，要考虑后果，模式往往是在重构中加入的。<br>找出你设计中会改变的区域，通常这是需要模式的迹象。</li>
<li>利用模式进行重构<br>比如：你的代码中充满了 if 语句，那么可能需要状态模式；或者意味着工厂模式将这些具体的依赖消除掉。</li>
<li>拿掉不需要的模式<br>当你的系统变得非常复杂，并且不需要预留任何弹性的时候，就不要使用模式。</li>
<li>现在不需要，就别做<br>你不确定这一块以后会不会变化就别“过度优化”</li>
</ul>
<p>有些模式可能并不适合当前的情况，<strong>可以对其改编使其适合</strong>。<br>不应急切于使用模式，而是致力于最能解决问题的<strong>简单方案</strong>。<br><strong>设计模式也会在你的设计中加入更多的层，这不但增加复杂性，而且效率下降。</strong><br>并且可以适当了解下反模式（看起来是个好模式，真正采用后就会带来麻烦）</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shiro学习笔记]]></title>
      <url>http://bfchengnuo.com/2018/02/08/Shiro%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Apache Shiro（读作“sheeroh”，即日语“城”）是一个开源安全轻量级框架，提供身份验证、授权、密码学和会话管理。Shiro 框架直观、易用，同时也能提供健壮的安全性。<br>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。<a id="more"></a><br>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>在学习之前，先了解几个名词，对于权限管理来说，最重要的就是（用户）认证和（用户）授权。<br><strong>认证</strong>是为了确保你是个合法用户，常见的形式有账号+密码的方式，或者指纹、数字证书等。<br><strong>授权</strong>就是用来控制（认证后）用户访问资源的，确保对应的用户只能访问指定的资源。<br>一般情况，当用户或者程序访问资源时，系统先判断该资源是否允许匿名访问，如果不允许就会检查该用户是否通过认证，没有就要求进行认证，也就是一般最常见的输入用户名和密码登陆。<br>认证通过后就会进入权限控制，就是检查当前的用户是否拥有权限操作该资源，如果没有就直接拒绝访问。</p>
<hr>
<p>所以在设计的时候就有了这几个词：<strong>用户、权限、资源</strong>；为了方便一般会加入一个<strong>角色</strong>达到管理一堆权限的目的。<br>数据库设计中，一般就需要六张表：<strong>用户、权限、角色、资源、用户角色关系、角色权限关系</strong>。<br>用户与角色、角色与权限之间是多对多关系；权限与资源是多对一关系。<strong>因为权限都是针对资源来说的，资源在系统中都是固定的</strong>，所以一个资源（比如用户列表）对应多个权限（查看用户列表、修改用户列表）。<br>一般为了方便，会把资源和权限合并为一张表（资源名称、权限名称、资源地址）。</p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>关于权限的控制，主要可分为两类：</p>
<ul>
<li><strong>基于角色的访问控制</strong><br>代码中是以角色为判断条件来控制的，当用户（角色）的权限需求变更时，只能修改对应的代码。<br>比如类似：<code>if(user.hasRole(&quot;管理员&quot;)){....}</code></li>
<li><strong>基于资源的访问控制</strong><br>代码中是以权限为判断条件来控制的，当用户（角色）的权限需求变更时，只需要修改对应角色中的权限即可，不需要改变代码。<br>比如类似：<code>if(user.hasPermission(&quot;查看用户列表&quot;)){......}</code></li>
</ul>
<p>可以看出，<strong>第一种的扩展性很差，不利于系统维护</strong>，因为角色是针对人的，而人是活的（资源是死的）；第二种只需要修改对应的角色权限列表即可，就是修改数据库的内容而已，完全可以通过 web 端应用做到，所以用的比较多。</p>
<h2 id="权限管理的解决方案"><a href="#权限管理的解决方案" class="headerlink" title="权限管理的解决方案"></a>权限管理的解决方案</h2><p>一般情况也是分为两种：</p>
<ul>
<li>粗颗粒权限管理<br>对<strong>资源类型</strong>的权限管理，比如菜单、用户信息等。<br>具体的例子有：管理员可以访问用户信息等页面，部门管理员可查看用户信息。</li>
<li>细颗粒权限管理<br>对<strong>资源实例</strong>的权限管理，就是<strong>资源类型的具体化</strong>，比如 XX 菜单、XX 用户信息。<br>具体的例子有：部门经理只能查看本部门的员工信息，用户只能查看自己的菜单。</li>
</ul>
<p>然后下面就该谈实现了，对于粗颗粒来说是比较简单的，因为代码可以进行抽取，放<strong>在系统架构级别上统一处理</strong>，比如 SpringMVC 的拦截器就可以做到授权，基本上只需要判断下是否有权限就可以了。<br>但是对于细颗粒来说抽取就比较复杂了，<strong>在数据级别上是没有共性可言的</strong>，可以说是业务逻辑的一部分了（不单单是判断是否有权限那么简单了），在业务层去处理会比较简单，如果抽取到系统架构层面就非常麻烦，并且扩展性也很差，所以，<strong>一般情况下细颗粒的控制都是在业务层去实现。</strong></p>
<hr>
<p>下面来看具体的做法，一般情况下对于粗颗粒可以使用一些优秀的权限管理框架来做，比如 Shiro ，能够提高开发效率；如果不想用可以自己实现，方法一般用拦截器或者过滤器进行 url 的拦截（基于 url 拦截方式）。<br>如果自己实现的话，需要两个拦截器，一个负责用户认证的拦截（前面），一个负责用户权限（授权）的拦截。<br>可匿名访问的地址和公共地址一般是可配置的，也就是写在 prop 文件中，在写拦截器或者过滤器的时候读取这个文件来检查。<br>PS：自己实现的时候管理资源的 URL 是最头疼的，每一个页面里都有很多链接，都需要配置，确实麻烦；所以就有人想出来使用标识符来统一管理（数据库中增加一个标志字段）。</p>
<h2 id="初识Shiro"><a href="#初识Shiro" class="headerlink" title="初识Shiro"></a>初识Shiro</h2><p>最开始当然是先看看它能做什么，可以用一幅图来描述：</p>
<p><img src="/image/dev/shiro作用.png" alt="shiro作用.png"></p>
<ul>
<li><strong>Authentication</strong>：<br>身份认证 / 登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：<br>授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情<br>常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session Manager</strong>：<br>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li>
<li><strong>Cryptography</strong>：<br>加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：<br>Web 支持，可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong>：<br>缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong>：<br>shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：<br>提供测试支持；</li>
<li><strong>Run As</strong>：<br>允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：<br>记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<p><strong>记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。</strong></p>
<h2 id="Shiro架构"><a href="#Shiro架构" class="headerlink" title="Shiro架构"></a>Shiro架构</h2><p>同样，还是根据图来学习，这是官方提供的架构图：</p>
<p><img src="/image/dev/Shiro架构.png" alt="Shiro架构.png"></p>
<ul>
<li><strong>Subject</strong>：主体<br>可以看到主体可以是任何可以与应用交互的 “用户”；也就是说可以是人的操作也可以是程序的操作。</li>
<li><strong>SecurityManager</strong>：安全管理器<br>相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li>
<li><strong>Authenticator</strong>：认证器<br><strong>负责主体认证的</strong>，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li>
<li><strong>Authrizer</strong>：授权器<br>或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>Realm</strong>：域、领域<br>可以有 1 个或多个 Realm，可以认为是安全实体<strong>数据源</strong>，即用于获取安全实体（认证、授权相关数据）；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；<strong>由用户提供</strong>；在 realm 中存储授权和认证逻辑。<br>注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li>
<li><strong>SessionManager</strong>：会话管理器<br>主要用来管理 Session 的生命周期，Web 应用一般是用 Web 容器（比如 Tomcat）来管理。<br>Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li>
<li><strong>SessionDAO</strong><br>通过 SessionDAO 管理 Session 数据，<strong>针对个性化的 Session 数据存储使用 SessionDAO</strong>。<br>DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</li>
<li><strong>CacheManager</strong>：缓存管理器<br>来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能。<br>Shiro 只提供了缓存逻辑，还需要具体的缓存实现，比如和 ehcache 整合。</li>
<li><strong>Cryptography</strong>：密码模块<br>Shiro 提高了一些常见的加密组件用于如密码加密 / 解密、散列的。</li>
</ul>
<h2 id="认证入门程序"><a href="#认证入门程序" class="headerlink" title="认证入门程序"></a>认证入门程序</h2><p>下面的入门代码是基于 SE 的，Realm 使用的是 ini 配置文件，就是说用户的认证信息都在 ini 配置文件里了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、获取 SecurityManager 工厂，此处使用 ini 配置文件初始化 SecurityManager</span></span><br><span class="line">  Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2、得到 SecurityManager 实例</span></span><br><span class="line">  SecurityManager securityManager = factory.getInstance();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、把 securityManager 绑定给 SecurityUtils（设置到当前的运行环境）</span></span><br><span class="line">  SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4、得到 Subject 及创建用户名/密码身份验证 Token（即用户身份/凭证）</span></span><br><span class="line">  Subject subject = SecurityUtils.getSubject();</span><br><span class="line">  UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//5、登录，即身份验证</span></span><br><span class="line">    subject.login(token);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// isAuthenticated 判断是否通过验证</span></span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, subject.isAuthenticated()); <span class="comment">//断言用户已经登录</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//6、退出</span></span><br><span class="line">  subject.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖什么的就不说了，太简单了，尤其是用了 Maven 后，然后还有 ini 的配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="number">123</span></span><br><span class="line"><span class="attr">wang</span>=<span class="number">123</span></span><br><span class="line"><span class="section">[roles]</span></span><br></pre></td></tr></table></figure>
<p>用 ini 而不用 properties 的一个原因就是 ini 中可以对数据进行分组。<br>下面来简单捋一下：<br>SecurityManager 负责真正的身份验证逻辑；它会<strong>委托给 Authenticator 进行身份验证</strong>；Authenticator 才是真正的身份验证者，Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 <strong>ModularRealmAuthenticator</strong> 会调用 AuthenticationStrategy 进行多 Realm 身份验证；Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息。<br>这是稍微详细一点的执行流程（序号不是很对应）：</p>
<ol>
<li>首先通过 IniSecurityManagerFactory 并指定一个 ini 配置文件来创建一个 SecurityManager 工厂；</li>
<li>接着获取 SecurityManager 并绑定到 SecurityUtils，这是一个全局设置，设置一次即可；</li>
<li>通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；然后获取身份验证的 Token，如用户名 / 密码；</li>
<li>调用 <code>subject.login()</code> 方法进行登录，其会自动委托给 <code>SecurityManager.login()</code> 方法进行登录；</li>
<li>SecurityManager 最终由 <strong>ModularRealmAuthenticator</strong> 进行认证（本例），ModularRealmAuthenticator 会调用 IniRealm 去配置文件查找用户信息。<br>如果查到用户信息就给 ModularRealmAuthenticator 返回用户信息。（本例的账号、密码）<br>如果查不到用户信息就给 ModularRealmAuthenticator  返回 null。</li>
<li>ModularRealmAuthenticator  接收到 IniRealm 返回的 Authenticator  信息，如果是 null 就抛出 UnknownAccountException。<br>其他的可能抛出的 AuthenticationException 或其子类常见的如：<br>DisabledAccountException（禁用的帐号）<br>LockedAccountException（锁定的帐号）<br>UnknownAccountException（错误的帐号）<br>ExcessiveAttemptsException（登录失败次数过多）<br>IncorrectCredentialsException （错误的凭证）<br>ExpiredCredentialsException（过期的凭证）等</li>
<li>（拓展）SecurityManager 接着会委托给 Authorizer（<strong>ModularRealmAuthorizer</strong>）进行授权，也就是执行 realm 中的授权方法进行查询权限。</li>
<li>（拓展）权限信息返回给 ModularRealmAuthorizer 后会通过 <strong>PermissionResolver</strong> 把字符串转换成相应的 Permission 实例，然后进行对比，如果没有权限就抛出异常。</li>
<li>最后可以调用 <code>subject.logout()</code> 退出，其会自动委托给 <code>SecurityManager.logout()</code> 方法退出。</li>
</ol>
<p>对于页面的错误消息展示，最好使用如 “用户名 / 密码错误” 而不是 “用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库.</p>
<h2 id="关于授权"><a href="#关于授权" class="headerlink" title="关于授权"></a>关于授权</h2><p>授权的流程和认证差不多，只不过用的是 hasRole（判断是否具有某个角色） 而已，就不多说了。<br>授权的验证一般有三种形式，编程式（不推荐）、注解式、JSP/GSP 标签：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程式，测试时可以用</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(“admin”)) &#123;</span><br><span class="line">  <span class="comment">//有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//无权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注解式</span></span><br><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)</span><br><span class="line"><span class="comment">// @RequiresPermissions("user:add")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 有权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签用法</span></span><br><span class="line">&lt;shiro:hasRole name=<span class="string">"admin"</span>&gt;</span><br><span class="line"><span class="comment">// &lt;!—- 有权限 -—&gt;</span></span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure>
<p>响应的在 ini 配置文件中也需要做出配置，主要是配角色：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># 规则：用户名=密码,角色1，角色2</span></span><br><span class="line"><span class="attr">zhang</span>=<span class="number">123</span>,role1,role2</span><br><span class="line"><span class="attr">wang</span>=<span class="number">123</span>,role1</span><br><span class="line"><span class="comment"># 角色</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role1</span>=user:create,user:update</span><br><span class="line"><span class="attr">role2</span>=user:create,user:delete</span><br></pre></td></tr></table></figure>
<p>角色的配置规则是：<code>资源:操作:实例</code> ，上面的例子中就是对 user 这个资源的所有实例进行 create 操作，写两段就意味着是 <code>user:create:*</code>，所以说是可以使用通配符 <code>*</code> 的；多个规则用逗号分割。<br>下面是两个测试用例，一般分为两种，基于角色的授权和基于资源的授权；参考一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于资源的授权，根据资源标识符判断</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIsPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-permission.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//判断拥有权限：user:create</span></span><br><span class="line">  Assert.assertTrue(subject().isPermitted(<span class="string">"user:create"</span>));</span><br><span class="line">  <span class="comment">//判断拥有权限：user:update and user:delete</span></span><br><span class="line">  Assert.assertTrue(subject().isPermittedAll(<span class="string">"user:update"</span>, <span class="string">"user:delete"</span>));</span><br><span class="line">  <span class="comment">//判断没有权限：user:view</span></span><br><span class="line">  Assert.assertFalse(subject().isPermitted(<span class="string">"user:view"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>(expected = UnauthorizedException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckPermission</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-permission.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:create</span></span><br><span class="line">  subject().checkPermission(<span class="string">"user:create"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:delete and user:update</span></span><br><span class="line">  subject().checkPermissions(<span class="string">"user:delete"</span>, <span class="string">"user:update"</span>);</span><br><span class="line">  <span class="comment">//断言拥有权限：user:view 失败抛出异常</span></span><br><span class="line">  subject().checkPermissions(<span class="string">"user:view"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于角色的授权，根据角色名来判断</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHasRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-role.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//判断拥有角色：role1</span></span><br><span class="line">  Assert.assertTrue(subject().hasRole(<span class="string">"role1"</span>));</span><br><span class="line">  <span class="comment">//判断拥有角色：role1 and role2</span></span><br><span class="line">  Assert.assertTrue(subject().hasAllRoles(Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>)));</span><br><span class="line">  <span class="comment">//判断拥有角色：role1 and role2 and !role3</span></span><br><span class="line">  <span class="keyword">boolean</span>[] result = subject().hasRoles(Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>, <span class="string">"role3"</span>));</span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, result[<span class="number">0</span>]);</span><br><span class="line">  Assert.assertEquals(<span class="keyword">true</span>, result[<span class="number">1</span>]);</span><br><span class="line">  Assert.assertEquals(<span class="keyword">false</span>, result[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span>(expected = UnauthorizedException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckRole</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  login(<span class="string">"classpath:shiro-role.ini"</span>, <span class="string">"zhang"</span>, <span class="string">"123"</span>);</span><br><span class="line">  <span class="comment">//断言拥有角色：role1</span></span><br><span class="line">  subject().checkRole(<span class="string">"role1"</span>);</span><br><span class="line">  <span class="comment">//断言拥有角色：role1 and role3 失败抛出异常</span></span><br><span class="line">  subject().checkRoles(<span class="string">"role1"</span>, <span class="string">"role3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isXXX 方法会返回布尔值，checkXXX 失败会抛出异常；篇幅限制，更多的内容去参考里的 wiki 看吧，因为项目中未使用，等用到了再进行补充。</p>
<h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><p><img src="/image/dev/realm继承.png" alt="realm继承.png"></p>
<p>这是 Realm 的继承体系，自定义 Realm 可以直接继承自 Realm 这个顶级接口，也可以选择它的孩子;<br>一般，选择 <strong>AuthorizingRealm</strong>（授权）即可；其继承了 AuthenticatingRealm（即身份验证），而且也间接继承了 CachingRealm（带有缓存实现），只需要实现验证和授权这两个方法逻辑就可以了。<br>顶级 Realm 接口定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个唯一的Realm名字</span></span><br><span class="line"><span class="function">String <span class="title">getName</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断此Realm是否支持此Token</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span> <span class="params">(AuthenticationToken token)</span></span>;</span><br><span class="line"><span class="comment">//根据Token获取认证信息</span></span><br><span class="line"><span class="function">AuthenticationInfo <span class="title">getAuthenticationInfo</span> <span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br></pre></td></tr></table></figure>
<p>自定义 Realm 使用继承 AuthorizingRealm 的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">implements</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置 realm 的名称，可省略</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.setName(<span class="string">"MyRealm"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于认证</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span> <span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// 从 token 得到用户名</span></span><br><span class="line">    String username = (String) token.getPrincipal();</span><br><span class="line">    <span class="comment">// String password = new String((char[])token.getCredentials()); //得到密码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据用户名查找密码，比如从数据库中；假如已经查到</span></span><br><span class="line">    String pwd = <span class="string">"123456"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果查不到信息，用户不存在；假设这种情况 pwd 为 null</span></span><br><span class="line">    <span class="keyword">if</span>(pwd == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果身份认证验证成功，返回一个 AuthenticationInfo 实现；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, pwd, <span class="keyword">this</span>.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于授权</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span> <span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 principals 获取身份信息</span></span><br><span class="line">    <span class="comment">// 强转为认证的时候填充到 SimpleAuthenticationInfo 中的第一个参数类型</span></span><br><span class="line">    String username = (String) principals.getPrimaryPrincipal();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据身份信息查询权限信息，比如从数据库中</span></span><br><span class="line">    List&lt;String&gt; permissions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    permissions.add(<span class="string">"user:create"</span>);</span><br><span class="line">    permissions.add(<span class="string">"user:update"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造 SimpleAuthorizationInfo 返回授权信息</span></span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    <span class="comment">// authorizationInfo.setRoles(userService.findRoles(username));</span></span><br><span class="line">    authorizationInfo.setStringPermissions(permissions);</span><br><span class="line">    <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查到的密码和 token 里的密码不符调用方就会抛出 IncorrectCredentialsException；如果返回 null 就会抛出 UnknownAccountException。<br>最后别忘了配置下 ini 文件，把自定义的 Realm 写进去，要不然 Shiro 也不识别：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="comment"># 声明一个 realm</span></span><br><span class="line"><span class="attr">myRealm</span>=com.bfchengnuo.shiro.realm.MyRealm</span><br><span class="line"><span class="comment"># 指定 securityManager 的 realms 实现</span></span><br><span class="line"><span class="comment"># 也就是把自定义的 realm 设置到 securityManager </span></span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure>
<p>其他的代码和入门程序一样，就是把配置文件改改就可以了。</p>
<h2 id="编码和加密"><a href="#编码和加密" class="headerlink" title="编码和加密"></a>编码和加密</h2><p>Shiro 还提供了一些关于常用的编码、加密。散列工具，使用也非常的简单，下面来看看简单的使用</p>
<h3 id="编码-amp-解码"><a href="#编码-amp-解码" class="headerlink" title="编码&amp;解码"></a>编码&amp;解码</h3><p>Shiro 提供了 base64 和 16 进制字符串编码 / 解码的 API 支持，方便一些编码解码操作。Shiro 内部的一些数据的存储 / 表示都使用了 base64 和 16 进制字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base64 操作</span></span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String base64Encoded = Base64.encodeToString(str.getBytes());</span><br><span class="line">String str2 = Base64.decodeToString(base64Encoded);</span><br><span class="line">Assert.assertEquals(str, str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16 进制字符串编码 / 解码操作</span></span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String base64Encoded = Hex.encodeToString(str.getBytes());</span><br><span class="line">String str2 = <span class="keyword">new</span> String(Hex.decode(base64Encoded.getBytes()));</span><br><span class="line">Assert.assertEquals(str, str2);</span><br></pre></td></tr></table></figure>
<p>还有一个可能经常用到的类 CodecSupport，提供了 toBytes(str,”utf-8”) / toString(bytes,”utf-8”) 用于在 byte 数组 /String 之间转换。</p>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐）防止暴力破解，盐有时是随机的（需要记录）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">String salt = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">// 第一个参数：原文，明文</span></span><br><span class="line"><span class="comment">// 第二个参数：盐值</span></span><br><span class="line"><span class="comment">// 第三个参数：散列的次数，比如 2 就相当于：md5(md5(str))</span></span><br><span class="line">String md5 = <span class="keyword">new</span> Md5Hash(str, salt, <span class="number">1</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 SHA-256</span></span><br><span class="line">String sha1 = <span class="keyword">new</span> Sha256Hash(str, salt).toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 SimpleHash 方式</span></span><br><span class="line"><span class="comment">// 内部使用 MessageDigest</span></span><br><span class="line">String simpleHash = <span class="keyword">new</span> SimpleHash(<span class="string">"SHA-1"</span>, str, salt, <span class="number">1</span>).toString();</span><br></pre></td></tr></table></figure>
<p>SimpleHash 可以指定散列算法，其内部使用了 Java 的 MessageDigest 实现。<br>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现。使用例子见参考。</p>
<h3 id="加密-amp-解密"><a href="#加密-amp-解密" class="headerlink" title="加密&amp;解密"></a>加密&amp;解密</h3><p>Shiro 还提供对称式加密 / 解密算法的支持，如 AES、Blowfish 等；<strong>当前还没有提供对非对称加密 / 解密算法支持</strong>，未来版本可能提供。<br>下面是一个使用 AES 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AesCipherService aesCipherService = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">aesCipherService.setKeySize(<span class="number">128</span>); <span class="comment">//设置key长度</span></span><br><span class="line"><span class="comment">// 生成 key</span></span><br><span class="line">Key key = aesCipherService.generateNewKey();</span><br><span class="line">String text = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line">String encrptText = </span><br><span class="line">  aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">String text2 =</span><br><span class="line">  <span class="keyword">new</span> String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(text, text2);</span><br></pre></td></tr></table></figure>
<p>Shiro 还提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。<br>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现 PasswordMatcher 及 HashedCredentialsMatcher（更强大）。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>具体在 Shiro 中使用（也就是在 Realm 中）一般是先定义好 ini 文件，设置好使用什么，比如散列 md5，然后定义好散列几次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="comment"># 定义凭证匹配器</span></span><br><span class="line"><span class="attr">credentialsMatcher</span>=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line"><span class="comment"># 散列算法</span></span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line"><span class="comment"># 散列次数</span></span><br><span class="line">credentialsMatcher.hashIterations=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#credentialsMatcher.storedCredentialsHexEncoded=true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myRealm</span>=com.bfchengnuo.shiro.realm.myRealm</span><br><span class="line"><span class="comment"># 将凭证匹配器设置到 Realm</span></span><br><span class="line">myRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure>
<p>然后在自定义的 Realm 里返回身份信息的时候稍微改造一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SimpleAuthenticationInfo ai = </span><br><span class="line">  <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt)); <span class="comment">//盐可以是用户名+随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">SimpleAuthenticationInfo ai2 = </span><br><span class="line">  <span class="keyword">new</span> SimpleAuthenticationInfo(username, password, ByteSource.Util.bytes(salt), getName());</span><br></pre></td></tr></table></figure>
<p>其他的和上面自定义 Realm 的代码一致，不需要更改。<br>这里的 pwd 和 salt 是从数据库获取的（假设存储介质是数据库），程序会拿着 token 中的密码和 salt 进行 md5 处理，然后和 pwd 进行对比。<br>PS：这里针对是的散列的验证，用于认证；上面说的是生成，可放在注册或者修改密码逻辑中。</p>
<h2 id="与Spring整合"><a href="#与Spring整合" class="headerlink" title="与Spring整合"></a>与Spring整合</h2><p>单独使用 Shiro 或者 SE 中用的情况其实不多，最多的还是 web 项目中用，自然就少不了要和 Spring 进行整合，首先准备工作当然是导入相应的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro核心jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro对web的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- shiro与spring整合jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ehcache 核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ehcache 与 Shiro 的整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就需要在 web.xml 中配置过滤器了，毕竟权限的管理主要还是靠过滤器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro过滤器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置true由servlet容器控制filter的生命周期 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的关键是配 DelegatingFilterProxy，达到让 Spring 管理的 Bean 具有 Filter 的能力。<br>下面就是正式开始配置 Shiro 的配置了，可以建一个 <strong>spring-shiro.xml</strong> 文件，注意：一定要配置在 Spring 这个父容器，如果配置在 SpringMVC 子容器里是没用的，前面也提到过关于这父子容器的关系。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Shiro 整合包里的 Web 过滤器，id 对应 web.xml 中指定的 targetBeanName --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 请求此地址将由下面配置的formAuthenticationFilter进行表单认证 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.action"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 认证成功统一跳转到 first.action，建议不配置，shiro 认证成功自动到上一个请求路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/first.action"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 通过 unauthorizedUrl 指定没有权限操作时跳转页面--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.jsp"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自定义 filter 配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"authc"</span> <span class="attr">value-ref</span>=<span class="string">"formAuthenticationFilter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 过虑器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对静态资源设置匿名访问 --&gt;</span></span><br><span class="line">      /images/** = anon</span><br><span class="line">      /js/** = anon</span><br><span class="line">      /styles/** = anon</span><br><span class="line">      <span class="comment">&lt;!-- 验证码，可匿名访问 --&gt;</span></span><br><span class="line">      /validatecode.jsp = anon</span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 请求 logout.action地址，shiro去清除session，此地址可以是不存在的--&gt;</span></span><br><span class="line">      /logout.action = logout</span><br><span class="line">      <span class="comment">&lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- /items/queryItems.action = perms[item:query]</span></span><br><span class="line"><span class="comment">            /items/editItems.action = perms[item:edit] --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置记住我或认证通过可以访问的地址 --&gt;</span></span><br><span class="line">      /index.jsp  = user</span><br><span class="line">      /first.action = user</span><br><span class="line">      /welcome.jsp = user</span><br><span class="line">      <span class="comment">&lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt;</span></span><br><span class="line">      /** = authc</span><br><span class="line">      <span class="comment">&lt;!-- /** = anon所有url都可以匿名访问 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- securityManager安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入缓存管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注入session管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeManager"</span> <span class="attr">ref</span>=<span class="string">"rememberMeManager"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义 realm --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customRealm"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.shiro.realm.CustomRealm"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将凭证匹配器设置到realm中，realm按照凭证匹配器的要求进行散列 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缓存管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:shiro-ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- session的失效时长，单位毫秒 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"600000"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 删除失效的session --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteInvalidSessions"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义form认证过虑器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.bfchengnuo.shiro.CustomFormAuthenticationFilter "</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单中账号的input名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单中密码的input名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我input的名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeParam"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookie"</span> <span class="attr">ref</span>=<span class="string">"rememberMeCookie"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 记住我cookie --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- rememberMe是cookie的名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 记住我cookie生效时间30天 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"2592000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内容比较多，需要注意的确实也不少，基本都是按最初没有使用 Spring 需要的那些对象来的，只要把那些对象搞定就 OK 了，比如 securityManager ，牵扯出了一系列的 Bean …..<br>使用了 authc 当用户没有认证时会跳转到指定页面，提交表单后凭证会传送给 FormAuthenticationFilter 进行验证（实际上最终会传给 Realm 进行查找凭证），如果没有找到或者凭证不正确会向 request 域填充异常信息（默认 key 为 shiroLoginFailure）。<br>然后可以在  controller 中从 request 取出这个异常信息判断是什么原因导致，值是异常的全路径，可以使用 <code>xxx.class.getName().equals()</code> 比较。<br>认证成功后 Controller 不需要处理，直接还是返回 login 页面即可，Shiro 会进行处理，默认是跳转到上一个页面。<br>在使用注解授权方式时，三层中都可以，但是推荐在 controller 中使用，比较直观，毕竟是入口；因为注解使用的是 AOP 代理的方式，所以还需要在 SpringMVC 的配置文件中开启 AOP 的支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启aop，对类代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启shiro注解支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配在 mvc 配置文件中的一个原因就是因为注解是加在 controller 上的，controller 的扫描是配在这的，所以放一起吧。<br>注解一般用 RequiresPermissions，而不用基于角色的。举几个例子：<code>@RequiresPermissions(value=&quot;XXX&quot;)</code> or <code>@RequiresPermissions(&quot;XXX&quot;)</code> or <code>@RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)</code> 拥有 <code>user:a</code> 或 <code>user:a</code> 权限。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>shiro 中提供了认证信息（上面已经配过了，更高级的如果需要用到 Redis 之类的保存 Session，那就研究下 SessionDAO）和授权信息的缓存.<br>注意: <strong>shiro 默认关闭认证信息缓存, 但是对于授权信息的缓存默认是开启的.</strong><br>由于 Shiro 只提供了缓存的处理逻辑，并没有实现具体的缓存逻辑（其实也有提供简单的实现），这里使用 <strong>ehcache</strong> 作为缓存的实现了，前面已经导入了相关的依赖，Spring 配置文件中也配好了，还缺一个 eh 缓存的配置文件 <strong>shiro-ehcache.xml</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--diskStore：缓存数据持久化的目录 地址  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"F:\develop\ehcache"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">eternal</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">overflowToDisk</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参数就不解释了，以前也用过，在新版本中，无论用户正常退出还是非正常退出<strong>缓存都会自动清空。</strong><br>但是，当管理员修改了用户的权限，但是该用户还没有退出，在默认情况下，修改的权限无法立即生效。需要手动进行编程实现：在权限修改后调用 realm 的 clearCache 方法清除缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">  <span class="keyword">super</span>.clearCache(principals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的方法放在自定义的 Realm 中，在修改权限的 Service 中调用即可，但是我觉得这样只会清除当前用户的缓存，还有相关的一些代码贴在 github，等日后要仔细研究下，TODO。</p>
<blockquote>
<p>clearCache 其同时调用 clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo，意为清空 AuthenticationInfo 和 AuthorizationInfo。<br>UserRealm 还提供了 clearAllCachedAuthorizationInfo、clearAllCachedAuthenticationInfo、clearAllCache，用于清空整个缓存。</p>
<p>principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。<br>一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号</p>
</blockquote>
<h2 id="默认拦截器"><a href="#默认拦截器" class="headerlink" title="默认拦截器"></a>默认拦截器</h2><p>Shiro 内置了很多默认的拦截器，比如身份验证、授权等相关的。<br>默认拦截器可以参考 <code>org.apache.shiro.web.filter.mgt.DefaultFilter</code> 中的枚举拦截器：</p>
<h3 id="身份验证相关的"><a href="#身份验证相关的" class="headerlink" title="身份验证相关的"></a>身份验证相关的</h3><p>包名太长，所以省略前面相同的 <code>org.apache.shiro.web.filter.authc</code> ；说明栏中的括号里的内容是默认值。</p>
<table>
<thead>
<tr>
<th>默认拦截器名</th>
<th>拦截器类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>authc</strong></td>
<td>FormAuthenticationFilter</td>
<td>基于表单的拦截器；如 <code>/**=authc</code>，如果没有登录会跳到相应的登录页面登录；<br>主要属性：<br>usernameParam：表单提交的用户名参数名（ username）；<br>passwordParam：表单提交的密码参数名（password）； <br>rememberMeParam：表单提交的密码参数名（rememberMe）；<br>loginUrl：登录页面地址（/login.jsp）；<br>successUrl：登录成功后的默认重定向地址；<br>failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）；</td>
</tr>
<tr>
<td><strong>authcBasic</strong></td>
<td>BasicHttpAuthenticationFilter</td>
<td>Basic HTTP 身份验证拦截器<br>主要属性： <br>applicationName：弹出登录框显示的信息（application）；</td>
</tr>
<tr>
<td><strong>logout</strong></td>
<td>LogoutFilter</td>
<td>退出拦截器<br>主要属性：redirectUrl：退出成功后重定向的地址（<strong>/</strong>）; 示例 ：<code>/logout=logout</code></td>
</tr>
<tr>
<td><strong>user</strong></td>
<td>UserFilter</td>
<td>用户拦截器，用户已经身份验证或记住我登录的都可；示例 ：<code>/**=user</code></td>
</tr>
<tr>
<td><strong>anon</strong></td>
<td>AnonymousFilter</td>
<td>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；<br>示例 <code>/static/**=anon</code></td>
</tr>
</tbody>
</table>
<p>另外还提供了一个 <code>org.apache.shiro.web.filter.authz.HostFilter</code>，即主机拦截器，比如其提供了属性：<br>authorizedIps：已授权的 ip 地址<br>deniedIps：表示拒绝的 ip 地址；不过目前还没有完全实现，不可用。</p>
<p>这些默认的拦截器会自动注册，可以直接在 ini 配置文件中通过 <code>拦截器名.属性</code> 设置其属性.</p>
<h3 id="授权相关的"><a href="#授权相关的" class="headerlink" title="授权相关的"></a>授权相关的</h3><p>包名太长，所以省略前面相同的 <code>org.apache.shiro.web.filter.authz</code> ；说明栏中的括号里的内容是默认值。</p>
<table>
<thead>
<tr>
<th>默认拦截器名</th>
<th>拦截器类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>roles</strong></td>
<td>RolesAuthorizationFilter</td>
<td>角色授权拦截器，验证用户是否拥有<strong>所有角色</strong>；<br>主要属性：<br>loginUrl：登录页面地址（/login.jsp）；<br>unauthorizedUrl：未授权后重定向的地址；示例 ：<code>/admin/**=roles[admin]</code></td>
</tr>
<tr>
<td><strong>perms</strong></td>
<td>PermissionsAuthorizationFilter</td>
<td>权限授权拦截器，验证用户是否拥有<strong>所有权限</strong>；属性和 roles 一样；<br>示例 ：<code>/user/**=perms[&quot;user:create&quot;]</code></td>
</tr>
<tr>
<td><strong>port</strong></td>
<td>PortFilter</td>
<td>端口拦截器，主要属性：port（80）：可以通过的端口；<br>示例 ：<code>/test= port[80]</code>，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径 / 参数等都一样</td>
</tr>
<tr>
<td><strong>rest</strong></td>
<td>HttpMethodPermissionFilter</td>
<td>rest 风格拦截器，自动根据请求方法构建权限字符串<br>（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）<br>示例 ：<code>/users=rest[user]</code>，会自动拼出“user:read,user:create,user:update,user:delete” 权限字符串进行权限匹配（所有都得匹配，isPermittedAll ）</td>
</tr>
<tr>
<td><strong>ssl</strong></td>
<td>SslFilter</td>
<td>SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样；</td>
</tr>
</tbody>
</table>
<p>此外，还有一个 <strong>noSessionCreation</strong>（org.apache.shiro.web.filter.session.NoSessionCreationFilter）不创建会话拦截器，调用 <code>subject.getSession(false)</code> 不会有什么问题，但是如果 <code>subject.getSession(true)</code> 将抛出 DisabledSessionException 异常。</p>
<p>其他的 JSP 标签之类的看 wiki 吧，实在是太长了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>需要验证验证码的就需要自定义 FormAuthenticationFilter 了，因为它是负责表单验证的，写一个类继承 FormAuthenticationFilter ，然后重写它的 onAccessDenied 方法，先从 Session 获取验证码和输入的比对，如果错误直接返回 true 终止执行，最好往 shiroLoginFailure 里加一下异常，便于 controller 的判断，通过则调用 super 的方法进行表单验证。<br>记得在配置文件里配一下自定义的验证器，上面其实已经配过了。</p>
<hr>
<p>使用 Shiro 的记住我功能时需要把相关的 bean 设置为可序列化的，然后再在配置文件中配置 CookieRememberMeManager。<br>然后就可以使用 User 过滤器来指定那些 URL 是可以认证或者通过记住我就可以访问的。<br>也就是说 authc 拦截器即使使用了 记住我 也不会放行，user 可以。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/shiro/overview.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/shiro/overview.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-shiro/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-shiro/</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB学习笔记]]></title>
      <url>http://bfchengnuo.com/2018/01/29/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的<strong>开源</strong>数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为 WEB 应用提供<strong>可扩展</strong>的高性能数据存储解决方案。<br><strong>MongoDB 将数据存储为一个文档，数据结构由键值 (key =&gt; value ) 对组成。</strong>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<a id="more"></a><br>作为 NoSQL 里的著名项目，它比其他 NoSQL 数据库的优势之一是它强大的、基于文档的查询语言，由于查询非常容易转换(将 SQL 语句转换成 MongoDB 查询函数调用)，这使得从关系数据库到 MongoDB 的过渡变得简单，并且官方提供了完善的驱动支持，<del>它的目的就是替代传统的 SQL 数据库。</del></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>无数据结构限制<br>mongo 没有”表”的概念,也不用设计表。<br>它使用”集合”存储 多个”键值对”,取代表的功能；想像一下 JSON 这种数据类型。</li>
<li>支持完全索引</li>
<li>支持复制和故障恢复</li>
<li>快速、高扩展性(分片扩展)</li>
<li>mongo有数据库的概念,但可以不经创建,直接使用。</li>
</ul>
<p>当然它是不保证实时一致性，并且不支持事务的，绝大多数的 NoSQL 好像都是不支持的，带来的好处就是快！更好的性能！<br>mongo 没有mysql中”记录”的概念,mongo使用”文档”存储任意数量的”键值对”信息；<br>mongo 无需手动设置”主键”,系统会自动为每一个”文档”自动添加”_id”键值对,保证数据的唯一性.</p>
<table>
<thead>
<tr>
<th>mysql</th>
<th>mongodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>表(table)</td>
<td>集合(collection)</td>
</tr>
<tr>
<td>记录(row)</td>
<td>文档(document)</td>
</tr>
<tr>
<td>主键(primary key) <code>手动设置</code></td>
<td>_id <code>自动生成</code></td>
</tr>
</tbody>
</table>
<p>然后再来说说以前写过的 Redis，同样是 NoSQL ，区别在那？具体的就不展开了，说主要的：Redis 是内存型数据库，常用于做缓存；MongoDB 是持久化存储的也就是存硬盘的，易用性不错，也更加的灵活，毕竟目标是取代 SQL 数据库的，性能也不俗，这或许是 NoSQL 的一大特点。<br>Redis 最大的优点就是快，快，还 TMD 是快！</p>
<blockquote>
<p>MongoDB 为什么比 MySQL 快？<br>写操作 MongoDB 比传统数据库快的根本原因是 Mongo 使用的内存映射技术 ：<br>写入数据时候只要在内存里完成就可以返回给应用程序，这样并发量自然就很高。而保存到硬体的操作则在后台异步完成。<br>读操作MongoDB快的原因是：<br>1）MongoDB 的设计要求你常用的数据（working set) 可以在内存里装下。这样大部分操作只需要读内存，自然很快。<br>2）文档性模式设计一般会是的你所需要的数据都相对集中在一起（内存或硬盘），大家知道硬盘读写耗时最多是随机读写所产生的磁头定位时间，数据集中在一起则减少了关系性数据库需要从各个地方去把数据找过来（然后Join）所耗费的随机读时间。<br>再有就是分布式集群的水平扩展所带来的压力分担。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我是在 Linux 上做测试，所以就简单说说 linux 下的安装，直接从官网下载二进制包，使用 <code>tar -zxvf</code> 解压，移到 <code>/usr/local</code> 即可。<br>接下来你可以配置下环境变量(比如编辑当前用户目录下的 <code>.bash_profile</code> 文件的方式)，然后使用 mongod  命令启动 mongodb 的服务。<br>执行 <code>./bin/mongod</code> 服务默认会在前台执行，如果数据目录不是 <code>/data/db</code> 那么可以手动指定目录，启动命令为：<code>./bin/mongod --dbpath=/usr/mongo_data MongoDB</code> 数据库服务的默认端口是 <strong>27017</strong> .<br>无论指定目录还是使用默认目录都需要手动进行创建。</p>
<p>其实还可以进行下简单的配置:<br>进入到 bin 目录下，编辑 <code>mongodb.conf</code> 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbpath = /data/db #数据文件存放目录</span><br><span class="line">logpath = /data/logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017  #端口</span><br><span class="line">fork = true  #以守护程序的方式启用，即在后台运行</span><br><span class="line"></span><br><span class="line"># 通过访问http://IP:28017/可以查看到mongodb启动的一些信息，同时也对mongodb运行</span><br><span class="line"># 的统计情况进行监控。在使用mongodb过程中，我们可以使用参数将该功能禁用掉。</span><br><span class="line"># 修改配置文件 mongodb.conf，增加参数选项：nohttpinterface = true 即可。</span><br><span class="line"># 3.6+ 版本中已经被删除</span><br><span class="line">nohttpinterface = true</span><br></pre></td></tr></table></figure>
<p>执行<code>./mongod -f mongodb.conf</code>命令表示启动 MongoDB.</p>
<blockquote>
<p>相关配置说明：<br>–dbpath 数据库路径(数据文件)<br>–logpath 日志文件路径<br>–master 指为主机器<br>–slave 指定为从机器<br>–source 指定主机器的IP地址<br>–pologSize 指定日志文件大小不超过 64M. 因为 resync 是非常操作量大且耗时，最好通过设置一个足够大的oplogSize来避免resync(默认的 oplog大小是空闲磁盘大小的5%)。<br>–logappend 日志文件末尾添定加<br>–port 启用端口号<br>–fork 在后台运行<br>–only 指定只复制哪一个数据库<br>–slavedelay 指从复制检测的时间间隔<br>–auth 是否需要验证权限登录(用户名和密码)</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行<code>mongo</code>命令表示表示进入到 MongDB 的控制台，进入到控制台之后，我们输入<code>db.version()</code>命令，如果能显示出当前 MongoDB 的版本号，说明安装成功了。<br>默认情况下，连接地址是 127.0.0.1:27017，连接的数据库是 test 数据库，我们也可以手动指定连接地址和连接的数据库：<br><code>mongo 127.0.0.1:27017/admin</code><br>如果是 3.0+ 的版本，可能会提示下面这样的错误：</p>
<blockquote>
<p>WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’.<br>We suggest setting it to ‘never’<br>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’.<br>We suggest setting it to ‘never’</p>
</blockquote>
<p>解决方案：<br>执行下面的两句命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure>
<p>弊端是重启后会失效，所以可以加入到开机启动里面，编辑 <code>/etc/rc.local</code> 追加下面的代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if test -f /sys/kernel/mm/transparent_hugepage/enabled; then</span><br><span class="line">   echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">fi</span><br><span class="line">if test -f /sys/kernel/mm/transparent_hugepage/defrag; then</span><br><span class="line">   echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>这样就一劳永逸了，那么这个警告的原因是什么？<br>原因就是 HDFS 会因为这个性能严重受影响。设置以后就是允许 hugepage 可以动态分配，而不是系统启动时预先分配，看上去对内存消耗很大的服务都不喜欢它。感觉这是一个 lazy loading 的设计思想。</p>
<h3 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h3><p>在客户端里使用 <code>db.shutdownServer()</code> 命令可以关闭到 MongoDB 服务，但是这个命令的执行要在 admin 数据库下，所以先切换到 admin (<code>use admin</code>)</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查看所有数据库：<code>show dbs</code><br>删除当前数据库：<code>db.dropDatabase()</code><br>PS：默认是不需要手动创建数据库的，mongodb 会自动根据需要来创建。<br>查看当前使用的数据库：<code>db.getName()</code><br>查看当前数据库中的表（集合）：<code>show tables</code> or <code>show collections</code></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在 MongoDB 中，数据以集合的形式存储。如果需要，您可以分割文档。下面创建一个文档并把它存储到一个名为 “colors” 的新集合中（Json 格式）：<br><code>db.colors.save({name:&quot;red&quot;,value:&quot;FF0000&quot;});</code><br>通过查询数据库来验证文档已保存( findOne 可以返回一条数据)：<br><code>db.colors.find();</code><br>默认会查出所有的记录。MongoDB 中的文档以 BSON（二进制 JSON）形式存储。<br>因为 Mongodb 支持 Js 语法，所以可以使用 for 来批量插入：<br><code>for(i=1;i&lt;=10;i++)db.demo.insert({index:i});</code><br>还可以进行计数操作：<br><code>db.demo.find().count();</code><br>使用 skip、limit、sort 操作(<code>1</code>：升序；<code>-1</code>：降序)：<br><code>db.demo.find().skip(2).limit(3).sort({index:1})</code><br>上面插入数据使用了两种方式，一种是 save，另一种是 insert，它们的区别是：<br><strong>insert：</strong>当主键 “_id” 在集合中存在时，不做任何处理。<br><strong>save：</strong>当主键 “_id” 在集合中存在时，进行更新。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新数据同样使用的是 update 关键字：<br><code>db.demo.update({index:1},{index:100})</code><br>如果只需要更新部分字段，那么就需要使用 set 操作符：<br><code>db.colors.update({name:&quot;red&quot;},{$set:{value:&quot;red&quot;}})</code><br>当记录不存在时，插入一条数据：<br><code>db.demo.update({index:1},{index:100},true)</code><br>有时候查询会查到多条数据，默认只会更新第一条，如果需要批量更新那么可以使用：<br><code>db.colors.update({name:&quot;red&quot;},{$set:{value:&quot;red&quot;}},false,true)</code><br>和第二条类似，批量更新只支持 set 方式，第三个参数就是不存在时是否创建，第四个就是是否更新全部数据（默认false）</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>与更新不同，删除默认会删除所有查到的数据，关键字为 remove ，参数不允许为空：<br><code>db.demo.remove({index:100})</code><br>删除表（集合）使用的是 drop 关键字：<br><code>db.demo.drop()</code></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>find 已经用过了，很简单，默认查出所有的数据，或者你需要一条用 findOne，配合 skip 和 limit 是非常有用的。<br>如果是查找单条数据可以 <code>find({x:1})</code> ，就是说如果你记得其中的属性的话，配合索引速度会更快。<br>或者根据某个属性是否存在来查询：<code>find({m:{$exists:false}})</code> ；<br>强制使用索引查询：<code>find({m:{$exists:false}}).hint(&quot;name&quot;)</code> 。<br>更多强大的查找功能参考拓展里，如果我用到或许会来进行补充。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的作用就是为了加快查询速度，这个都是一样的，3.0+ 的版本创建索引使用 createIndex，查看索引使用 getIndexes。<br><code>db.demo.createIndex({index:1})</code><br>和排序类似，1 代表正向，-1 代表反向。<br>PS：索引可以重复创建，不会报错，第二次会直接返回成功。<br>上面通过 createIndex 给 index 创建了索引（单键索引），如果我们插入的数据是：<code>{index:[1,2,3,4]}</code> 这样的形式，那么系统就会自动创建一个多键索引，并不需要显示的创建。</p>
<blockquote>
<p>MongoDB automatically creates a multikey index if any indexed field is an array; you do not need to explicitly specify the multikey type.</p>
</blockquote>
<p>如果要根据多个字段来创建索引那就是所谓的<strong>复合索引</strong>了：<br><code>db.demo.createIndex({index:1,name:1})</code><br>删除索引可以通过 dropIndex(name) 的形式，name 指的是索引名，可以通过 getIndexes() 获得。</p>
<h3 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h3><p>这个就非常有用了，比如可以存用户的登陆信息、日志等，因为它的特性是：<strong>超过设定的时间后索引被删除，同时相应的数据也会被清除。</strong><br>创建也非常的简单，只需要加一个时间参数：<br><code>db.demo.createIndex({time:1},{expireAfterSeconds:10})</code><br>这样数据 10 秒后就会被删除。<br><code>db.demo.insert({time:new Date()})</code><br>以这个例子来说，time 字段必须是 ISODate 或者 ISODate 数组（按照最小的时间进行删除），不能使用时间戳，否则不能被自动删除。<br>过期索引不能是复合索引，因为无法根据两个日期来进行删除。<br>删除的时间是不精确的，删除过程是由后台程序每 60s 跑一次，而且删除也需要一些时间，所以存在误差。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>看名字应该就知道是什么意思了，主要用在搜索上，根据某些关键字就能搜出相应的数据，创建全文索引的方式有下面几种：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> key-字段名，value-固定字符串text</span><br><span class="line">db.articles.createIndex(&#123;key:"text"&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在多个字段上创建全文索引</span><br><span class="line">db.articles.createIndex(&#123;key1:"text",key2:"text"&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 给所有字段创建全文索引</span><br><span class="line">db.articles.createIndex(&#123;"$**":"text"&#125;)</span><br></pre></td></tr></table></figure>
<p>然后就是使用了，根据建立的全文索引来查询：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查询包含 coffee 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"coffee"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>（或查询）查询包含 aa 或 bb 或 cc 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"aa bb cc"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -为排除包含有 cc 内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:"aa bb -cc"&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>（与查询）加查询内容前后用""包含，查询既包含 aa 又包含 bb cc 的内容的文档</span><br><span class="line">db.article.find(&#123;$text:&#123;$search:'"aa" "bb" "cc"'&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用 $meta 操作符来查看相似度，并根据相似度来排序</span><br><span class="line">db.imooc_2.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;)</span><br><span class="line">db.imooc_2.find(&#123;$text:&#123;$search:"aa bb"&#125;&#125;,&#123;score:&#123;$meta:"textScore"&#125;&#125;).sort(&#123;score:&#123;$meta:"textScore"&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在 MongoDB 中<strong>每个数据集合只能创建一个全文索引</strong>, 所以使用全文索引进行查询时不会起冲突.<br>在 3.2+ 的版本中支持了对中文的全文搜索。英文搜索中是按单词来匹配，也就是说内容有空格进行区分，如果是混在一起的字符串，那效果也非常的差。<br>注意事项：</p>
<ul>
<li>每次查询，只能指定一个 <code>$text</code> 查询</li>
<li><code>$text</code> 查询不能出现在 <code>$nor</code> 查询中</li>
<li>查询中如果包含了 <code>$text</code>, hint 不再起作用</li>
</ul>
<p>全文索引会导致 mongodb 写入性能下降，因为所有字符串都要拆分，存储到不同地方。<br>还有就是虽然支持了中文，但是效果并不好，并且只有在企业版中才可以使用 rlp 之类，并且整句的话关键词搜索还是不好，解决方案现在有使用 Elastic Search 同步 mongodb，或者使用分词工具把分词存为单独的一个 tags。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>创建索引的时候系统会默认生成一个名字，为了可读性，我们可以手动定义生成索引的名字，就像这样：<br><code>db.articles.createIndex({x:1},{name:&quot;test&quot;})</code><br>就是说可以传入第二个参数，这里是 name 作为例子，其他的还有 unique（是否唯一）、sparse （稀疏性，默认 false）。<br>开启稀疏后当记录不存在索引字段时就不会创建索引，减少了磁盘的占用，但是带来的问题是强制使用索引查询（hint）时会出错（不存在）。</p>
<hr>
<p>然后就是地理位置索引，目前感觉用不到，简单提提，根据平面（X/Y 坐标）或者球面来定位，比如查找距离某个点 一定距离的点，包含在某区域内的点。</p>
<hr>
<p>评判索引构建情况（是否合理）的几种方式：</p>
<ul>
<li>mongostat 工具<br>自带的查看运行状态的工具，使用方法：<code>mongostat -h 127.0.0.1:27017</code> 有用户名密码的话再加 <code>-u x -p x</code><br>具体的状态说明，自行搜索（因为我没用到过，关注 qr/qw/idx miss）</li>
<li>profile 集合<br>查看状态：<code>db.getProfilingStatus()</code> ，一个是级别，另一个 slowms 是慢查询的阀值。<br>查看/设置等级：<code>db.get/setProfilingLevel()</code> 同时 set 也算是开启 profile ；<br>等级有三种，加一个关闭状态：<br>0：不开启；1：记录慢命令，默认为大于100ms；2：记录所有命令；3、查询 profiling 记录。</li>
<li>日志<br>配置文件里可以加入 berbose 来控制级别，数值在 1-5 个 V 之间。</li>
<li>explain 分析<br>使用：<code>db.demo.find({x:100}).explain()</code><br>用来查看设置索引后是否起作用。</li>
</ul>
<p>一些补充：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">db.system.profile.find()</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  "op" : "query",--操作类型</span><br><span class="line">  "ns" : "imooc.system.profile", --查询的命名空间，;databasename.collectionname'</span><br><span class="line">  "query" : &#123; "query" : &#123;  &#125;, --查询条件</span><br><span class="line">  "orderby" : &#123; "$natural" : -1 &#125; &#125;, --约束条件</span><br><span class="line">  "ntoreturn" : 1, --返回数据条目</span><br><span class="line">  "ntoskip" : 0,  --跳过的条目</span><br><span class="line">  "nscanned" : 1, --扫描的数目含索引</span><br><span class="line">  "nscannedObjects" : 1, --扫描的数据数目</span><br><span class="line">  "keyUpdates" : 0,  --</span><br><span class="line">  "numYield" : 0, --其他情况</span><br><span class="line">  "lockStats" : &#123;  --锁状态</span><br><span class="line">    "timeLockedMicros" : &#123; --锁占用时间（毫秒）</span><br><span class="line">      "r" : NumberLong(82), --读锁</span><br><span class="line">      "w" : NumberLong(0)   --写锁</span><br><span class="line">    &#125;,</span><br><span class="line">    "timeAcquiringMicros" : &#123;</span><br><span class="line">      "r" : NumberLong(2), "w" : NumberLong(2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "nreturned" : 1, </span><br><span class="line">  "responseLength" : 651,   --返回长度</span><br><span class="line">  "millis" : 0, --查询时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线上环境不推荐开启 profile ，上线前的观察可以使用。</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>设置用户名密码是最常用的保护措施，虽然安全性不是很高，但是方便；开启权限认证有两种方法：<br>auth（配置文件里加 <code>auth = true</code> 即可） 或者 keyfile。<br>然后还需要创建用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> use admin</span><br><span class="line"><span class="meta">&gt;</span> db.createUser(</span><br><span class="line">...   &#123;</span><br><span class="line">...     user: "dba",</span><br><span class="line">...     pwd: "dba",</span><br><span class="line">...     roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ]</span><br><span class="line">...   &#125;</span><br><span class="line">... )</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 角色说明</span><br><span class="line">Built-In Roles（内置角色）：</span><br><span class="line">1. 数据库用户角色：read、readWrite;</span><br><span class="line">2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；</span><br><span class="line">3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</span><br><span class="line">4. 备份恢复角色：backup、restore；</span><br><span class="line">5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span><br><span class="line">6. 超级用户角色：root  </span><br><span class="line">  // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</span><br><span class="line">7. 内部角色：__system</span><br><span class="line"></span><br><span class="line">Read：</span><br><span class="line">允许用户读取指定数据库</span><br><span class="line"></span><br><span class="line">readWrite：</span><br><span class="line">允许用户读写指定数据库</span><br><span class="line"></span><br><span class="line">dbAdmin：</span><br><span class="line">允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</span><br><span class="line"></span><br><span class="line">userAdmin：</span><br><span class="line">允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</span><br><span class="line"></span><br><span class="line">clusterAdmin：</span><br><span class="line">只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</span><br><span class="line"></span><br><span class="line">readAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的读权限</span><br><span class="line"></span><br><span class="line">readWriteAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的读写权限</span><br><span class="line"></span><br><span class="line">userAdminAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</span><br><span class="line"></span><br><span class="line">dbAdminAnyDatabase：</span><br><span class="line">只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</span><br><span class="line"></span><br><span class="line">root：</span><br><span class="line">只在admin数据库中可用。超级账号，超级权限</span><br><span class="line"></span><br><span class="line">db.system.users.find();</span><br></pre></td></tr></table></figure>
<p><strong>帐号是跟着库走的，所以在指定库里授权，必须也在指定库里验证，账号信息存放在 admin 数据库中</strong>。<br>开始时没进行登陆可以使用 <code>db.auth(&#39;name&#39;,&#39;pwd&#39;)</code> 来进行授权，返回 1 表示成功。<br>就说到这吧，虽然是最简单的一些操作。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>更多内容参见：<br><a href="https://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-mongodb4/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-mongodb4/</a></p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8新特性学习（二）]]></title>
      <url>http://bfchengnuo.com/2018/01/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java 8 为 Java 语言、编译器、类库、开发工具与 JVM（ Java 虚拟机）带来了大量新特性。<br>上一篇了解了最重要的 Stream 和 Lambda 表达式（或者说闭包，虽然不是很恰当），或者可以理解为 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。<br>这篇就补全剩下的部分，默认方法啦、方法引用（双冒号运算符）、新的类库，当然这些也是不全的，我认为经常用的就这些了，全部的新特性可以见参考的链接。<a id="more"></a></p>
<h2 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h2><p>Java 8 用默认方法与静态方法这两个新概念来扩展接口的声明。<br>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，如果接口定义了默认方法，那么必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">  <span class="comment">// may not implement (override) them.</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要实现默认方法 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以覆盖默认方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">  Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line"></span><br><span class="line">  defaulable = DefaulableFactory.create( OverridableImpl::<span class="keyword">new</span> );</span><br><span class="line">  System.out.println( defaulable.notRequired() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JVM中，<strong>默认方法的实现是非常高效的</strong>，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的 Java 接口，而同时能够保障正常的编译过程。<br>这方面好的例子是大量的方法被添加到 <code>java.util.Collection</code> 接口中去：stream()，parallelStream()，forEach()，removeIf()，……<br>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。</p>
<h3 id="为什么要有默认方法"><a href="#为什么要有默认方法" class="headerlink" title="为什么要有默认方法"></a>为什么要有默认方法</h3><p>在 java 8 之前，接口与其实现类之间的 <strong>耦合度</strong> 太高了（<strong>tightly coupled</strong>），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。<br>这个 forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类。</p>
<h3 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h3><p>和其它方法一样，接口默认方法也可以被继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写默认方法并将它重新声明为抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceD</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InterfaceB() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceC() &#123;&#125;.foo(); <span class="comment">// 打印：“InterfaceC foo”</span></span><br><span class="line">    <span class="keyword">new</span> InterfaceD() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InterfaceD foo"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.foo(); <span class="comment">// 打印：“InterfaceD foo”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 lambda 表达式</span></span><br><span class="line">    ((InterfaceD) () -&gt; System.out.println(<span class="string">"InterfaceD foo"</span>)).foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口默认方法的继承分三种情况（分别对应上面的 <code>InterfaceB</code> 接口、<code>InterfaceC</code> 接口和 <code>InterfaceD</code> 接口）：</p>
<ul>
<li>不覆写默认方法，直接从父接口中获取方法的默认实现。</li>
<li>覆写默认方法，这跟类与类之间的覆写规则相类似。</li>
<li>覆写默认方法并将它重新声明为抽象方法，这样新接口的子类必须再次覆写并实现这个抽象方法。</li>
</ul>
<hr>
<p>然后来考虑下多继承的问题，是的，默认方法在接口里，接口可以继承，接口可以多实现，那么自然就带来了默认方法多继承的问题；但是 Java 使用的是单继承、多实现的机制，为的是避免多继承带来的调用歧义的问题。当接口的子类同时拥有具有相同签名的方法时，就需要考虑一种解决冲突的方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceC bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在冲突</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，存在冲突</span></span><br><span class="line"><span class="comment">//class ClassB implements InterfaceB, InterfaceC &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceB 的 bar 方法</span></span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.bar(); <span class="comment">// 调用 InterfaceC 的 bar 方法</span></span><br><span class="line">    System.out.println(<span class="string">"ClassB bar"</span>); <span class="comment">// 做其他的事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ClassB 类中，它实现的 InterfaceB 接口和 InterfaceC 接口中都存在相同签名的 foo 方法，需要手动解决冲突。覆写存在歧义的方法，并可以使用 <code>InterfaceName.super.methodName();</code> 的方式手动调用需要的接口默认方法。</p>
<hr>
<p>下面来看特殊情况：接口继承行为发生冲突时的解决规则。<br>比如，出现了下面的这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        InterfaceA.super.foo(); // 错误</span></span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 InterfaceB 接口继承了 InterfaceA 接口，那么 InterfaceB 接口一定包含了所有 InterfaceA 接口中的字段方法，因此一个同时实现了 InterfaceA 接口和 InterfaceB 接口的类与一个只实现了 InterfaceB 接口的类完全等价。<br>这很好理解，就相当于 <code>class SimpleDateFormat extends DateFormat</code> 与 <code>class SimpleDateFormat extends DateFormat</code>, Object 等价（如果允许多继承）。<br>而覆写意味着对父类方法的屏蔽，这也是 <strong>Override</strong> 的设计意图之一。因此在实现了 InterfaceB 接口的类中无法访问已被覆写的 InterfaceA 接口中的 foo 方法。<br>这是当接口继承行为发生冲突时的规则之一，即 <strong>被其它类型所覆盖的方法会被忽略</strong>。<br>如果想要调用 InterfaceA 接口中的 foo 方法，只能通过自定义一个新的接口同样继承 InterfaceA 接口并显示地覆写 foo 方法，在方法中使用 <code>InterfaceA.super.foo();</code> 调用 InterfaceA 接口的 foo 方法，最后让实现类同时实现 InterfaceB 接口和自定义的新接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceB foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceC</span> <span class="keyword">extends</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceB</span>, <span class="title">InterfaceC</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceB.<span class="keyword">super</span>.foo();</span><br><span class="line">    InterfaceC.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意！ 虽然 InterfaceC 接口的 foo 方法只是调用了一下父接口的默认实现方法，但是这个覆写 <strong>不能省略</strong>，否则 InterfaceC 接口中继承自 InterfaceA 接口的隐式的 foo 方法同样会被认为是被 InterfaceB 接口覆写了而被屏蔽，会导致调用 <code>InterfaceC.super.foo()</code> 时出错。<br>通过这个例子，应该注意到在使用一个默认方法前，一定要考虑它是否真的需要。因为 <strong>默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误</strong>。滥用默认方法可能给代码带来意想不到、莫名其妙的错误。</p>
<h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>当接口继承行为发生冲突时的另一个规则是，<strong>类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InterfaceA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AbstractClassA bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InterfaceA.<span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassA classA = <span class="keyword">new</span> ClassA();</span><br><span class="line">    classA.foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    classA.bar(); <span class="comment">// 打印：“AbstractClassA bar”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassA 类中并不需要手动覆写 bar 方法，因为优先考虑到 ClassA 类继承了的 AbstractClassA 抽象类中存在对 bar 方法的实现，同样的因为 AbstractClassA 抽象类中的 foo 方法是抽象的，所以在 ClassA 类中必须实现 foo 方法。<br>虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 <strong>不可相互代替的</strong>：</p>
<ul>
<li>接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。</li>
<li>接口中没有 <code>this</code> 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 <strong>状态</strong>（<strong>state</strong>），抽象方法中可以。</li>
<li>抽象类不能在 java 8 的 lambda 表达式中使用。</li>
<li>从设计理念上，接口反映的是 <strong>“like-a”</strong> 关系，抽象类反映的是 <strong>“is-a”</strong> 关系。</li>
</ul>
<p>顺便复习了下接口和抽象类的知识点~~</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>补充下其他的知识点：</p>
<ul>
<li><code>default</code> 关键字只能在接口中使用（以及用在 <code>switch</code> 语句的 <code>default</code> 分支），不能用在抽象类中。</li>
<li>接口默认方法不能覆写 <code>Object</code> 类的 <code>equals</code>、<code>hashCode</code> 和 <code>toString</code> 方法。</li>
<li>接口中的静态方法必须是 <code>public</code> 的，<code>public</code> 修饰符可以省略，<code>static</code> 修饰符不能省略。</li>
<li>即使使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依赖 IDE。</li>
</ul>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>其实就是上篇所说的双冒号操作，不知道还有没有印象，即 <code>目标引用::方法</code> ，下面就来看看具体的几种用法。<br>方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象的方法或构造器。与 lambda 联合使用（一般是不能独立使用的），方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>下面来看看 Java 支持的这四种不同的方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">  &#125;              </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种</span></span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种</span></span><br><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>
<p>这四类可以定义为：</p>
<ol>
<li>类名::new</li>
<li>类名::静态方法名</li>
<li>类名::实例方法名<br>这种方法引用有些特殊之处：当使用这种方式时，<strong>一定是 lambda 表达式所接收的第一个参数来调用实例方法，如果lambda表达式接收多个参数，其余的参数作为方法的参数传递进去。</strong><br>参考：<a href="http://sfau.lt/b5ZD16" target="_blank" rel="noopener">http://sfau.lt/b5ZD16</a></li>
<li>对象::实例方法名</li>
</ol>
<p>下面就来解释下上面例子里的四种方式，说的都是在本例的情况下。<br>第一种方法引用是构造器引用，它的语法是 <code>Class::new</code>，或者更一般的 <code>Class&lt; T &gt;::new</code>。new 不就是调用构造函数嘛~请注意构造器没有参数。<br>第二种方法引用是静态方法引用，它的语法是 <code>Class::static_method</code> ，请注意这个方法接受一个 Car 类型的参数。<br>第三种方法引用是特定类的任意对象的方法引用，它的语法是 <code>Class::method</code>。请注意，这个方法没有参数，并且是非静态。<br>最后，第四种方法引用是特定对象的方法引用，它的语法是 <code>instance::method</code>。请注意，这个方法接受一个 Car 类型的参数</p>
<h2 id="类库新特性"><a href="#类库新特性" class="headerlink" title="类库新特性"></a>类库新特性</h2><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 公司著名的 <strong>Guava</strong> 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。<br>受到 Google Guava 的启发，Optional 类已经成为 Java 8 类库的一部分。<br>Optional 实际上<strong>是个容器</strong>：它可以保存类型 T 的值，或者仅仅保存 null。Optional 提供很多有用的方法，这样我们就不用显式进行空值检测。在 Javadoc 中的描述翻译过来就是：<br><em>这是一个可以为 null 的容器对象。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。</em><br>下面就来看看它的几个方法（在前面说 stream 的时候大量使用了 Optional ）：</p>
<ul>
<li>of<br>为<strong>非 null</strong> 的值创建一个 Optional。<br>of 方法通过工厂方法<strong>创建</strong> Optional 类。需要注意的是，创建对象时传入的参数不能为 null。如果传入参数为 null，则抛出 NPE。</li>
<li>ofNullable<br>为指定的值<strong>创建</strong>一个 Optional，如果指定的值为 null，则返回一个空的 Optional。</li>
<li>empty<br>此方法用于创建一个没有值的 Optional 对象；如果对 emptyOpt 变量调用 isPresent() 方法会返回 false，调用 get() 方法抛出 NullPointerException 异常。</li>
<li><strong>isPresent</strong><br>如果值存在返回 true，否则返回 false。</li>
<li><strong>ifPresent</strong><br>如果 Optional 实例有值则为其调用 consumer（比如 lambda 表达式），否则不做处理</li>
<li>get<br>如果 Optional 有值则将其返回，否则抛出 NoSuchElementException。</li>
<li>orElse<br>如果有值则将其返回，否则返回指定的其它值(默认值)。<br><code>empty.orElse(&quot;There is no value present!&quot;);</code></li>
<li>orElseGet<br>orElseGet 与 orElse 方法类似，区别在于得到的默认值。<br>orElse 方法将传入的字符串作为默认值，orElseGet 方法可以接受 Supplier 接口的实现用来生成默认值。<br><code>empty.orElseGet(() -&gt; &quot;Default Value&quot;);</code></li>
<li>orElseThrow<br>如果有值则将其返回，否则抛出 supplier 接口创建的异常。<br>在 orElseThrow 中我们可以传入一个 lambda 表达式或方法，如果值不存在来抛出异常。<br><code>empty.orElseThrow(ValueAbsentException::new);</code></li>
<li>map<br>如果有值，则对其执行调用 mapping 函数得到返回值。<br>如果返回值不为 null，则创建包含 mapping 返回值的 Optional 作为 map 方法返回值，否则返回空 Optional。<br><code>Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</code></li>
<li>flatMap<br>如果有值，为其执行 mapping 函数返回 Optional 类型返回值，否则返回空 Optional。<br>flatMap 与 map（Funtion）方法类似，区别在于 flatMap 中的 mapper 返回值必须是 Optional。<br>调用结束时，flatMap 不会对结果用 Optional 封装。<br><code>upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</code></li>
<li>filter<br>如果有值并且满足断言条件返回包含该值的 Optional，否则返回空 Optional。<br>对于 filter 函数我们应该传入实现了 Predicate 接口的 lambda 表达式。<br><code>Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6);</code></li>
</ul>
<blockquote>
<p>要理解 ifPresent 方法，首先需要了解 Consumer 类。<br>简答地说，Consumer 类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。<br>Java8 支持不用接口直接通过 lambda 表达式传入参数。</p>
</blockquote>
<p>在 Java 9 中，对 Optional 还进行了增强，多加了几个方法，感兴趣的可以去：<a href="http://sfau.lt/b5KDt8" target="_blank" rel="noopener">http://sfau.lt/b5KDt8</a><br>最后通过一个例子来综合的展示下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></span><br><span class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Sanaulla"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></span><br><span class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></span><br><span class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//调用get()返回Optional值。</span></span><br><span class="line">      System.out.println(name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></span><br><span class="line">      System.out.println(empty.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifPresent方法接受lambda表达式参数。</span></span><br><span class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></span><br><span class="line">    name.ifPresent((value) -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></span><br><span class="line">    System.out.println(empty.orElse(<span class="string">"There is no value present!"</span>));</span><br><span class="line">    System.out.println(name.orElse(<span class="string">"There is some value!"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></span><br><span class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></span><br><span class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"Default Value"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//orElseThrow与orElse方法类似，区别在于返回值。</span></span><br><span class="line">      <span class="comment">//orElseThrow抛出由传入的lambda表达式/方法生成异常。</span></span><br><span class="line">      empty.orElseThrow(ValueAbsentException::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map方法通过传入的lambda表达式修改Optonal实例默认值。 </span></span><br><span class="line">    <span class="comment">//lambda表达式返回值会包装为Optional实例。</span></span><br><span class="line">    Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase());</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。</span></span><br><span class="line">    <span class="comment">//map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。</span></span><br><span class="line">    <span class="comment">//但是flatMap方法的lambda返回值总是Optional类型。</span></span><br><span class="line">    upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</span><br><span class="line">    System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filter方法检查Optiona值是否满足给定条件。</span></span><br><span class="line">    <span class="comment">//如果满足返回Optional实例值，否则返回空Optional。</span></span><br><span class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一个示例，Optional值不满足给定条件。</span></span><br><span class="line">    Optional&lt;String&gt; anotherName = Optional.of(<span class="string">"Sana"</span>);</span><br><span class="line">    Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(shortName.orElse(<span class="string">"The name is less than 6 characters"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 提倡函数式编程，新增的许多 API 都可以用函数式编程表示，<code>Optional</code>类也是其中之一。这里有几条关于<code>Optional</code>使用的建议：</p>
<ol>
<li>尽量避免在程序中直接调用<code>Optional</code>对象的<code>get()</code>和<code>isPresent()</code>方法(活用 orElse 系列)；</li>
<li>避免使用<code>Optional</code>类型声明实体类的属性；</li>
</ol>
<p>第一条建议中直接调用<code>get()</code>方法是很危险的做法，如果<code>Optional</code>的值为空，那么毫无疑问会抛出 NPE 异常，而为了调用<code>get()</code>方法而使用<code>isPresent()</code>方法作为空值检查，这种做法与传统的用 if 语句块做空值检查没有任何区别。<br>第二条建议避免使用 Optional 作为实体类的属性，它在设计的时候就没有考虑过用来作为类的属性，如果你查看 Optional 的源代码，你会发现它没有实现 <code>java.io.Serializable</code> 接口，这在某些情况下是很重要的（比如你的项目中使用了某些序列化框架），使用了 Optional 作为实体类的属性，意味着他们不能被序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">  <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化 if-else</span></span><br><span class="line">User user = ...</span><br><span class="line">  Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user.map(User::getUserName)</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>当你很确定一个对象不可能为 null 的时候，应该使用 <code>of()</code> 方法，否则，尽可能使用 <code>ofNullable()</code> 方法</p>
<h3 id="新的时间和日期API"><a href="#新的时间和日期API" class="headerlink" title="新的时间和日期API"></a>新的时间和日期API</h3><p>Java 8 另一个新增的重要特性就是引入了新的时间和日期 API，它们被包含在 <code>java.time</code> 包中。借助新的时间和日期 API 可以以更简洁的方法处理时间和日期。<br>在 Java 8 之前，所有关于时间和日期的 API 都存在各种使用方面的缺陷，主要有：</p>
<ol>
<li>Java 的 <code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，并且是可变的，也就意味着他们都不是线程安全的；</li>
<li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个 SimpleDateFormat 对象来处理日期格式化，并且 DateFormat 也是非线程安全，这意味着如果你在多线程程序中调用同一个 DateFormat 对象，会得到意想不到的结果。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，这意味着从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li>
</ol>
<p>由于以上这些问题，出现了一些三方的日期处理框架，例如 <strong>Joda-Time</strong>，data4j 等开源项目。<br>但是，Java 需要一套标准的用于处理时间和日期的框架，于是 Java 8 中引入了新的日期 API。新的日期 API 是 <a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">JSR-310</a> 规范的实现，Joda-Time 框架的作者正是 JSR-310 的规范的倡导者，所以能从 Java 8 的日期 API 中看到很多 Joda-Time 的特性。<br>常用的几个类就是 LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration 等.<br>下面通过几个示例代码来快速学会使用新版的日期时间 API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Today's Local date : "</span> + today); <span class="comment">// 2014-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="keyword">int</span> year = today.getYear();</span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue();</span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth();</span><br><span class="line">System.out.printf(<span class="string">"Year : %d  Month : %d  day : %d t %n"</span>, year, month, day);</span><br><span class="line"><span class="keyword">int</span> length = today.lengthOfMonth();  <span class="comment">// 月份的天数</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = today.isLeapYear();  <span class="comment">// 是否为闰年</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理特定日期（只需要传入年月日）</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(<span class="string">"Your Date of birth is : "</span> + dateOfBirth); <span class="comment">//  2010-01-14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否相等</span></span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span>(date1.equals(today))&#123;</span><br><span class="line">  System.out.printf(<span class="string">"Today %s and date1 %s are same date %n"</span>, today, date1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查像生日这种周期性事件,类似的还有 YearMonth</span></span><br><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">2010</span>, <span class="number">01</span>, <span class="number">14</span>);</span><br><span class="line">MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">MonthDay currentMonthDay = MonthDay.from(today);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Many Many happy returns of the day !!"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"Sorry, today is not your birthday"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间（这次不是日期是时间）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"local time now : "</span> + time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取日期和时间，还可以进行拼接，或者 toLocalDate 拆分</span></span><br><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间的操作（因为是不可变对象，所以操作后的是新实例）</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">LocalTime newTime = time.plusHours(<span class="number">2</span>); <span class="comment">// adding two hours</span></span><br><span class="line">System.out.println(<span class="string">"Time after 2 hours : "</span> +  newTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期的操作，通过 withMonth 等方法可修改指定日期</span></span><br><span class="line">LocalDate nextWeek = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);  <span class="comment">// 可处理天，周，月</span></span><br><span class="line">System.out.println(<span class="string">"Today is : "</span> + today);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 week : "</span> + nextWeek);</span><br><span class="line"></span><br><span class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS);  <span class="comment">// 处理年</span></span><br><span class="line">System.out.println(<span class="string">"Date before 1 year : "</span> + previousYear);</span><br><span class="line">LocalDate nextYear = today.plus(<span class="number">1</span>, YEARS);</span><br><span class="line">System.out.println(<span class="string">"Date after 1 year : "</span> + nextYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否早于或者晚于一个日期</span></span><br><span class="line">LocalDate tomorrow = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">if</span>(tommorow.isAfter(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Tomorrow comes after today"</span>);</span><br><span class="line">&#125;</span><br><span class="line">LocalDate yesterday = today.minus(<span class="number">1</span>, DAYS);</span><br><span class="line"><span class="keyword">if</span>(yesterday.isBefore(today))&#123;</span><br><span class="line">  System.out.println(<span class="string">"Yesterday is day before today"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理时区</span></span><br><span class="line">ZoneId america = ZoneId.of(<span class="string">"America/New_York"</span>);</span><br><span class="line">LocalDateTime localtDateAndTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );</span><br><span class="line">System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + dateAndTimeInNewYork);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个日期之间的天数和月数</span></span><br><span class="line">LocalDate java8Release = LocalDate.of(<span class="number">2014</span>, Month.MARCH, <span class="number">14</span>);</span><br><span class="line">Period periodToNextJavaRelease = Period.between(today, java8Release);</span><br><span class="line">System.out.println(<span class="string">"Months left between today and Java 8 release : "</span></span><br><span class="line">                   + periodToNextJavaRelease.getMonths() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);  <span class="comment">// 第一个参数秒，第二个纳秒</span></span><br><span class="line">System.out.println(<span class="string">"What is value of this instant "</span> + timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化工具，第一个为字符串转日期，第二个日期转字符串</span></span><br><span class="line">String goodFriday = <span class="string">"Apr 18 2014"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);</span><br><span class="line">  LocalDate holiday = LocalDate.parse(goodFriday, formatter);</span><br><span class="line">  System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocalDateTime arrivalDate  = LocalDateTime.now();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy  hh:mm a"</span>);</span><br><span class="line">  String landing = arrivalDate.format(format);</span><br><span class="line">  System.out.printf(<span class="string">"Arriving at :  %s %n"</span>, landing);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">  System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate);</span><br><span class="line">  ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所用的 API 大部分都是不可变的，也就是说是线程安全的，可放心食用！<br>Instant 用于表示一个时间戳，它与我们常使用的 <code>System.currentTimeMillis()</code> 有些类似，不过 Instant 可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code> 方法只精确到毫秒（Milli-Second）。<br>类似的还有 Duration、Period 它们通过 between 方法来确定一段时间。</p>
<h3 id="Base64的API"><a href="#Base64的API" class="headerlink" title="Base64的API"></a>Base64的API</h3><p>在 JDK1.6 之前，JDK 核心类一直没有 Base64 的实现类，有人建议用 Sun/Oracle JDK 里面的 <code>sun.misc.BASE64Encoder</code> 和 <code>sun.misc.BASE64Decoder</code>，使用它们的优点就是不需要依赖第三方类库，缺点就是可能在未来版本会被删除（用 maven 编译会发出警告），而且性能不佳，性能测试见最后的参考链接。<br>JDK1.6 中添加了另一个 Base64 的实现，<code>javax.xml.bind.DatatypeConverter</code> 两个静态方法 parseBase64Binary 和  printBase64Binary，隐藏在 <code>javax.xml.bind</code> 包下面，不被很多开发者知道。<br>在 Java 8 在 <code>java.util</code> 包下面实现了 BASE64 编解码 API，而且性能不俗，API 也简单易懂，下面展示下这个类的使用例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic编码：是标准的BASE64编码，用于处理常规的需求 */</span></span><br><span class="line"><span class="comment">// 编码</span></span><br><span class="line">String asB64 = Base64.getEncoder().encodeToString(<span class="string">"some string"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(asB64); <span class="comment">// 输出为: c29tZSBzdHJpbmc=</span></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">byte</span>[] asBytes = Base64.getDecoder().decode(<span class="string">"c29tZSBzdHJpbmc="</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(asBytes, <span class="string">"utf-8"</span>)); <span class="comment">// 输出为: some string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* URL编码：使用下划线替换URL里面的反斜线“/”  */</span></span><br><span class="line">String urlEncoded = Base64.getUrlEncoder().encodeToString(<span class="string">"subjects?abcd"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">System.out.println(<span class="string">"Using URL Alphabet: "</span> + urlEncoded);</span><br><span class="line"><span class="comment">// 输出为: Using URL Alphabet: c3ViamVjdHM_YWJjZA==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MIME编码：使用基本的字母数字产生BASE64输出，而且对MIME格式友好：每一行输出不超过76个字符，而且每行以“\r\n”符结束。 */</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">10</span>; ++t) &#123;</span><br><span class="line">  sb.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] toEncode = sb.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">String mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);</span><br><span class="line">System.out.println(mimeEncoded);</span><br></pre></td></tr></table></figure>
<p>之前我们常用的第三方工具有：<br>Apache Commons Codec library 里面的 <code>org.apache.commons.codec.binary.Base64</code> ；<br>Google Guava 库里面的 <code>com.google.common.io.BaseEncoding.base64()</code> 这个静态方法；<br><code>net.iharder.Base64</code> ，这个 jar 包就一个类；<br>号称 Base64 编码速度最快的 MigBase64，而且是 10 年前的实现.<br>关于他们之间的性能测试去参考里面的最后一个链接查看，总之，用 Java 8 自带的就足足够了！</p>
<h2 id="JVM新特性"><a href="#JVM新特性" class="headerlink" title="JVM新特性"></a>JVM新特性</h2><p>PermGen 空间被移除了，取而代之的是 Metaspace（JEP 122）。<br>JVM 选项 <code>-XX:PermSize</code> 与 <code>-XX:MaxPermSize</code> 分别被 <code>-XX:MetaSpaceSize</code> 与 <code>-XX:MaxMetaspaceSize</code> 所代替。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://ebnbin.com/2015/12/20/java-8-default-methods/" target="_blank" rel="noopener">http://ebnbin.com/2015/12/20/java-8-default-methods/</a><br><a href="http://www.importnew.com/11908.html" target="_blank" rel="noopener">http://www.importnew.com/11908.html</a><br><a href="http://www.importnew.com/6675.html" target="_blank" rel="noopener">http://www.importnew.com/6675.html</a><br><a href="http://www.importnew.com/15637.html" target="_blank" rel="noopener">http://www.importnew.com/15637.html</a><br><a href="https://lw900925.github.io/java/java8-newtime-api.html" target="_blank" rel="noopener">https://lw900925.github.io/java/java8-newtime-api.html</a><br><a href="http://www.importnew.com/14961.html" target="_blank" rel="noopener">http://www.importnew.com/14961.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8新特性学习]]></title>
      <url>http://bfchengnuo.com/2018/01/17/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>很惭愧，关于 Java 8  的特性早就开坑想学，然而….现在都到 Java 9 了依然没填完，这份 MD 文档在桌面也放了半年多了（ :XD 捂脸），一直因为各种原因放在哪里吃灰，今天看了看有必要填坑了！<br>Java 8 新加入的一些特性是很有用的！Spring Framework 5+ 都是基于 Java 8 了，再不学要跟不上了！<br>这篇就说了说 Lambda 表达式和 Stream，发现已经很长了，其他的下次再聊，下篇应该不会太久，大概….<a id="more"></a></p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>简单说，Lambda 表达式是用来简化匿名类的一种写法，使用它有个条件就是，<strong>匿名类实现的接口中只能有一个方法</strong>，也就是只有一个需要实现的方法，并且它的写法有很多种，各种个样的简化。<br>其实 Lambda 表达式的本质只是一个”<a href="http://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96" target="_blank" rel="noopener"><strong>语法糖</strong></a>“，由编译器推断并帮你转换包装为常规的代码，因此你可以使用更少的代码来实现同样的功能。<br>Lambda 表达式赋予了 Java 程序员相较于其他函数式编程语言缺失的特性，结合虚拟扩展方法之类的特性，Lambda 表达式能写出一些极好的代码。<br>Lambda 表达式的加入，使得 Java 拥有了函数式编程的能力。<br>建议不要乱用，因为这就和某些很高级的黑客写的代码一样，简洁，难懂，难以调试，维护人员想骂娘。<br>Java SE 8 添加了 2 个对集合数据进行批量操作的包:  <code>java.util.function</code> 包以及 <code>java.util.stream</code> 包。<br>流 (stream) 就如同迭代器 (iterator),但附加了许多额外的功能。 总的来说，lambda 表达式和 stream 是自 Java 语言添加泛型(Generics)和注解(annotation)以来最大的变化。<br>简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>
<p>上面的这些是最最基本的，下面继续来看看还有那些骚操作吧</p>
<h3 id="基本的Lambda例子"><a href="#基本的Lambda例子" class="headerlink" title="基本的Lambda例子"></a>基本的Lambda例子</h3><p>比如我们要遍历一个 List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String[] atp = &#123;<span class="string">"Rafael Nadal"</span>, <span class="string">"Novak Djokovic"</span>,</span><br><span class="line">                <span class="string">"Stanislas Wawrinka"</span>,</span><br><span class="line">                <span class="string">"David Ferrer"</span>,<span class="string">"Roger Federer"</span>,</span><br><span class="line">                <span class="string">"Andy Murray"</span>,<span class="string">"Tomas Berdych"</span>,</span><br><span class="line">                <span class="string">"Juan Martin Del Potro"</span>&#125;;</span><br><span class="line">List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前的循环方式</span></span><br><span class="line"><span class="keyword">for</span> (String player : players) &#123;</span><br><span class="line">  System.out.print(player + <span class="string">"; "</span>);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lambda 表达式以及函数操作(functional operation)</span></span><br><span class="line">players.forEach((player) -&gt; System.out.print(player + <span class="string">"; "</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Java 8 中使用双冒号操作符(double colon operator)</span></span><br><span class="line">players.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>常用的还有使用 lambdas 来实现 Runnable接口，以及实现自定义排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1使用匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2使用 lambda expression</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello world !"</span>)).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1使用匿名内部类</span></span><br><span class="line">Runnable race1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2使用 lambda expression</span></span><br><span class="line">Runnable race2 = () -&gt; System.out.println(<span class="string">"Hello world !"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用 run 方法(没开新线程哦!)</span></span><br><span class="line">race1.run();</span><br><span class="line">race2.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 使用 lambda expression 排序 players</span></span><br><span class="line">Comparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2));</span><br><span class="line">Arrays.sort(players, sortByName);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3.2 也可以采用如下形式:</span></span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));</span><br></pre></td></tr></table></figure>
<p>这样一看，还是挺爽的。</p>
<blockquote>
<p>使用 <code>::</code> 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。</p>
</blockquote>
<h3 id="使用Lambdas和Streams"><a href="#使用Lambdas和Streams" class="headerlink" title="使用Lambdas和Streams"></a>使用Lambdas和Streams</h3><p>Stream 是对集合的包装,通常和 lambda 一起使用。 使用 lambdas 可以支持许多操作，如 map, filter, limit, sorted, count, min, max, sum, collect 等等。<br>同样，Stream 使用<strong>懒运算</strong>，他们并不会真正地读取所有数据，遇到像 getFirst() 这样的方法就会结束链式语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; javaProgrammers = <span class="keyword">new</span> ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Elsdon"</span>, <span class="string">"Jaycob"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">43</span>, <span class="number">2000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Tamsen"</span>, <span class="string">"Brittany"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">23</span>, <span class="number">1500</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Floyd"</span>, <span class="string">"Donny"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="number">1800</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Sindy"</span>, <span class="string">"Jonie"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">32</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Vere"</span>, <span class="string">"Hervey"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">22</span>, <span class="number">1200</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Maude"</span>, <span class="string">"Jaimie"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">27</span>, <span class="number">1900</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Shawn"</span>, <span class="string">"Randall"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">30</span>, <span class="number">2300</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Jayden"</span>, <span class="string">"Corrina"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">35</span>, <span class="number">1700</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Palmer"</span>, <span class="string">"Dene"</span>, <span class="string">"Java programmer"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="number">2000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Addison"</span>, <span class="string">"Pam"</span>, <span class="string">"Java programmer"</span>, <span class="string">"female"</span>, <span class="number">34</span>, <span class="number">1300</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; phpProgrammers = <span class="keyword">new</span> ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Jarrod"</span>, <span class="string">"Pace"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">34</span>, <span class="number">1550</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Clarette"</span>, <span class="string">"Cicely"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">23</span>, <span class="number">1200</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Victor"</span>, <span class="string">"Channing"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">32</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Tori"</span>, <span class="string">"Sheryl"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">21</span>, <span class="number">1000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Osborne"</span>, <span class="string">"Shad"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">32</span>, <span class="number">1100</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Rosalind"</span>, <span class="string">"Layla"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">25</span>, <span class="number">1300</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Fraser"</span>, <span class="string">"Hewie"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">36</span>, <span class="number">1100</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Quinn"</span>, <span class="string">"Tamara"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">21</span>, <span class="number">1000</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Alvin"</span>, <span class="string">"Lance"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"male"</span>, <span class="number">38</span>, <span class="number">1600</span>));</span><br><span class="line">    add(<span class="keyword">new</span> Person(<span class="string">"Evonne"</span>, <span class="string">"Shari"</span>, <span class="string">"PHP programmer"</span>, <span class="string">"female"</span>, <span class="number">40</span>, <span class="number">1800</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有程序员的姓名:"</span>);  </span><br><span class="line">javaProgrammers.forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  </span><br><span class="line">phpProgrammers.forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName())); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"给程序员加薪 5% :"</span>);  </span><br><span class="line">Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / <span class="number">100</span> * <span class="number">5</span> + e.getSalary());  </span><br><span class="line">javaProgrammers.forEach(giveRaise);  </span><br><span class="line">phpProgrammers.forEach(giveRaise); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"下面是月薪超过 $1,400 的PHP程序员:"</span>);</span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">  .filter((p) -&gt; (p.getSalary() &gt; <span class="number">1400</span>))  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName())); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 filters  </span></span><br><span class="line">Predicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; <span class="number">25</span>);  </span><br><span class="line">Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; <span class="number">1400</span>);  </span><br><span class="line">Predicate&lt;Person&gt; genderFilter = (p) -&gt; (<span class="string">"female"</span>.equals(p.getGender()));  </span><br><span class="line">System.out.println(<span class="string">"下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:"</span>);  </span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">  .filter(ageFilter)  </span><br><span class="line">  .filter(salaryFilter)  </span><br><span class="line">  .filter(genderFilter)  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));  </span><br><span class="line"><span class="comment">// 重用filters  </span></span><br><span class="line">System.out.println(<span class="string">"年龄大于 24岁的女性 Java programmers:"</span>);  </span><br><span class="line">javaProgrammers.stream()  </span><br><span class="line">  .filter(ageFilter)  </span><br><span class="line">  .filter(genderFilter)  </span><br><span class="line">  .forEach((p) -&gt; System.out.printf(<span class="string">"%s %s; "</span>, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure>
<p>上面展示了一些对于集合的“新操作”，这都是平常用的最多的，使用了语法糖后，真是更爽了。</p>
<h3 id="Lambda表达式的结构"><a href="#Lambda表达式的结构" class="headerlink" title="Lambda表达式的结构"></a>Lambda表达式的结构</h3><p>让我们了解一下 Lambda 表达式的结构。</p>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li>
<li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，<strong>函数式接口是只包含一个抽象方法声明的接口</strong>。<br><code>java.lang.Runnable</code> 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 <code>void run()</code> ；每个 Lambda 表达式都能隐式地赋值给函数式接口，当不指明函数式接口时，编译器会自动解释这种转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">  () -&gt; System.out.println(<span class="string">"hello world"</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>
<p><code>@FunctionalInterface</code> 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你标注的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误.<br>需要记住的一件事是：<strong>默认方法（default）与静态方法并不影响函数式接口的契约</strong>，可以任意使用。</p>
<h3 id="双冒号操作符"><a href="#双冒号操作符" class="headerlink" title="双冒号操作符"></a>双冒号操作符</h3><p>双冒号（<code>::</code>）操作符是 Java 中的<strong>方法引用</strong>。 当们使用一个方法的引用时，目标引用放在 <code>::</code> 之前，目标引用提供的方法名称放在 <code>::</code> 之后，即 <code>目标引用::方法</code>。比如：<code>Person::getAge;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 getAge 方法的 Function 对象</span></span><br><span class="line">Function&lt;Person, Integer&gt; getAge = Person::getAge;</span><br><span class="line"><span class="comment">// 传参数调用 getAge 方法</span></span><br><span class="line">Integer age = getAge.apply(p);</span><br></pre></td></tr></table></figure>
<p>目标引用的参数类型是 <code>Function&lt;T,R&gt;</code>，<code>T</code> 表示传入类型，<code>R</code> 表示返回类型。<br>比如，表达式 <code>person -&gt; person.getAge();</code>，传入参数是 <code>person</code>，返回值是 <code>person.getAge()</code>，那么方法引用 <code>Person::getAge</code> 就对应着 <code>Function&lt;Person,Integer&gt;</code> 类型。<br>“::” 称之为定界符，当我们使用它的时候，<strong>只是用来引用要使用的方法，而不是调用方法</strong>，所以不能在方法后面加 ()。<br><strong>你不能直接调用方法引用</strong>，只是用来替代 Lambda 表达式，所以，哪里使用 Lambda 表达式了，哪里就可以使用方法引用了。</p>
<h3 id="Lambda与匿名类"><a href="#Lambda与匿名类" class="headerlink" title="Lambda与匿名类"></a>Lambda与匿名类</h3><p>使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写入 Lambda 的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String firstName = <span class="string">"Tom"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; addSurname = surname -&gt; &#123;</span><br><span class="line">      <span class="comment">// equivalent to this.firstName</span></span><br><span class="line">      <span class="keyword">return</span> firstName + <span class="string">" "</span> + surname;  <span class="comment">// or even,   </span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8 之前必须显示调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String firstName = <span class="string">"Jerry"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anotherExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; addSurname = <span class="keyword">new</span> Function&lt;String,  </span><br><span class="line">    String&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String surname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Example.<span class="keyword">this</span>.firstName + <span class="string">" "</span> + surname;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式与匿名类的另一不同在于两者的编译方法。Java 编译器编译 Lambda 表达式并将他们转化为类里面的<strong>私有函数</strong>，它使用 Java 7 中新加的 invokedynamic 指令<strong>动态绑定</strong>该方法.<br>还有一点 Lambda 表达式的<strong>代码块</strong>不允许调用接口中定义的默认方法，但是 Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中集成的默认方法。<br>Lambda 表达式不需要每次都要被实例化，对于 Java 来说，带来巨大的好处。不像实例化匿名类，对内存的影响可以降到最小。</p>
<h2 id="Java8中的forEach"><a href="#Java8中的forEach" class="headerlink" title="Java8中的forEach"></a>Java8中的forEach</h2><p><strong>forEach</strong> 方法是 JAVA 8 中在集合父接口 <code>java.lang.Iterable</code> 中新增的一个 <strong>default</strong> 实现方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(action);</span><br><span class="line">  <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">    action.accept(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，forEach 方法接受一个在 JAVA 8 中新增的 <code>java.util.function.Consumer</code> 的消费行为或者称之为动作 (Consumer action )类型；然后将集合中的每个元素作为消费行为的 accept 方法的参数执行。<br>那么自然我们就可以自定义消费行为动作 Consumer，只需要实现 Consumer 接口的 accept 方法。</p>
<h2 id="Java8中的Stream"><a href="#Java8中的Stream" class="headerlink" title="Java8中的Stream"></a>Java8中的Stream</h2><p>Stream 作为 Java 8 的一大亮点，<strong>它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念</strong>。<br>它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。<br><strong>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</strong><br>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。<br>通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 <code>java.util.stream</code> 是一个<strong>函数式语言+多核时代综合影响的产物</strong>。</p>
<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。<br>而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。<br>下面比较下在 Java 7 与 Java 8 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7:</span></span><br><span class="line">List&lt;Transaction&gt; groceryTransactions = <span class="keyword">new</span> Arraylist&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: transactions)&#123;</span><br><span class="line"> <span class="keyword">if</span>(t.getType() == Transaction.GROCERY)&#123;</span><br><span class="line"> groceryTransactions.add(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(groceryTransactions, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Transaction t1, Transaction t2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;Integer&gt; transactionIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: groceryTransactions)&#123;</span><br><span class="line"> transactionsIds.add(t.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">List&lt;Integer&gt; transactionsIds = transactions.parallelStream()</span><br><span class="line"> .filter(t -&gt; t.getType() == Transaction.GROCERY)</span><br><span class="line"> .sorted(comparing(Transaction::getValue).reversed())</span><br><span class="line"> .map(Transaction::getId)</span><br><span class="line"> .collect(toList());</span><br></pre></td></tr></table></figure>
<p>Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快.</p>
<h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，<strong>它不是数据结构并不保存数据</strong>，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。<strong>而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出</strong>。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。<br>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果；每次转换<strong>原有 Stream 对象不改变</strong>，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。<br>有多种方式生成 Stream Source：<br><strong>从 Collection 和数组：</strong></p>
<ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()</li>
</ul>
<p><strong>从 BufferedReader：</strong></p>
<ul>
<li>java.io.BufferedReader.lines()</li>
</ul>
<p><strong>静态工厂：</strong></p>
<ul>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
</ul>
<p><strong>自己构建：</strong></p>
<ul>
<li>java.util.Spliterator</li>
</ul>
<p><strong>其它：</strong></p>
<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
<p>一般我们用的比较多的就是第一种吧。</p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>流的操作类型分为两种：</p>
<ul>
<li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。<br>其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。<br>这类操作都是惰性化的（lazy），就是说，<strong>仅仅调用到这类方法，并没有真正开始流的遍历。</strong></li>
<li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，<strong>当这个操作执行后，流就被使用“光”了，无法再被操作</strong>。<br>所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<p>因为转换操作都是 lazy 的，所以<strong>多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成</strong>。<br>我们可以这样简单的理解，Stream 里有个操作函数（把定义的处理方法就叫操作函数吧）的集合，<strong>每次转换操作就是把转换函数放入这个集合中</strong>，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。<br>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。<br>下面就来看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">  .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">  .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">  .sum();</span><br></pre></td></tr></table></figure>
<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据<strong>筛选</strong>和<strong>转换</strong>，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。<br>具体的操作可进行简单的分类：</p>
<ul>
<li><strong>Intermediate：</strong><br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li>
<li><strong>Terminal：</strong><br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li>
<li><strong>Short-circuiting：</strong><br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</li>
</ul>
<p>具体的例子在下一节展示。</p>
<h3 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h3><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：<br>IntStream、LongStream、DoubleStream。当然我们也可以用 <code>Stream&lt;Integer&gt;</code>、<code>Stream&lt;Long&gt;</code>、<code>Stream&lt;Double&gt;</code>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种<strong>基本数值型</strong>提供了对应的 Stream。<br>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。<br>流的构造和转换的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值流的构造</span></span><br><span class="line">IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流的转换</span></span><br><span class="line"><span class="comment">// 1. Array</span></span><br><span class="line">String[] strArray1 = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 2. Collection</span></span><br><span class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">Set set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 3. String</span></span><br><span class="line">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。<br>然后就来看一些比较经典的栗子吧：</p>
<h4 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h4><p>map 操作应该是用的比较多的一种了，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素；也就是说是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换大写</span></span><br><span class="line">List&lt;String&gt; output = wordList.stream()</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平方根</span></span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream()</span><br><span class="line">  .map(n -&gt; n * n)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一对多</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line">  Arrays.asList(<span class="number">1</span>),</span><br><span class="line">  Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">  Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">);</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream</span><br><span class="line">  .flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>
<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字.</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 留下偶数</span></span><br><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">  Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挑选单词</span></span><br><span class="line">List&lt;String&gt; output = reader.lines()</span><br><span class="line">  .flatMap(line -&gt; Stream.of(line.split(REGEXP)))</span><br><span class="line">  .filter(word -&gt; word.length() &gt; <span class="number">0</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>上面已经用烂了，不多说，关键是它的一些特点：<br>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。<br>当需要为多核系统优化时，可以 <code>parallelStream().forEach()</code>，只是此时<strong>原有元素的次序没法保证</strong>，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算；具有相似功能的 intermediate 操作 peek 可以解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>peek 对每个元素执行操作并返回一个新的 Stream；forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>)</span><br><span class="line"> .filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>)</span><br><span class="line"> .reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure>
<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。<br>这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>
<blockquote>
<p>Optional 这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。<br>使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。<br>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。<br>后面会详细说这一特性。</p>
</blockquote>
<h4 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h4><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimitAndSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line">    persons.add(person);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  List&lt;String&gt; personList2 = persons.stream()</span><br><span class="line">    .map(Person::getName).limit(<span class="number">10</span>).skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// limit 和 skip 对 sorted 后的运行次数无影响</span></span><br><span class="line">  List&lt;Person&gt; personList3 = persons.stream()</span><br><span class="line">    .sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName()))</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>limit(10) 就是取前十条，skip(3) 就是跳过前三条咯，果然是更加灵活了。<br>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：<strong>此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样</strong>。<br>在后面的一个例子中，即虽然最后的返回元素数量是 2，但整个管道中的 sorted <strong>表达式执行次数</strong>没有像前面例子相应减少。<br>最后有一点需要注意的是，<strong>对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大</strong>，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream（parallel 用于多核并发操作）。</p>
<h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream()</span><br><span class="line">  .allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream()</span><br><span class="line">  .anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure>
<p>确实挺方便的，如果你记得的话….</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其他的像 <strong>sorted/min/max/distinct</strong> 这些方法就不多说了，想看的可以去 IBM 的原文找下，在参考里；至于它们的优势，比如排序，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。</p>
<h3 id="总结-amp-归纳"><a href="#总结-amp-归纳" class="headerlink" title="总结&amp;归纳"></a>总结&amp;归纳</h3><ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。<br>例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li><strong>所有 Stream 的操作必须以 lambda 表达式为参数</strong></li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的<br>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a><br><a href="https://segmentfault.com/a/1190000009186509" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009186509</a><br><a href="http://www.cnblogs.com/IcanFixIt/p/6744973.html" target="_blank" rel="noopener">http://www.cnblogs.com/IcanFixIt/p/6744973.html</a><br><a href="http://blog.csdn.net/renfufei/article/details/24600507" target="_blank" rel="noopener">http://blog.csdn.net/renfufei/article/details/24600507</a><br><a href="http://droidyue.com/blog/2015/11/28/article-java-8-lambdas-a-peek-under-the-hood/" target="_blank" rel="noopener">深入探讨Lambda</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker化你的应用]]></title>
      <url>http://bfchengnuo.com/2018/01/06/Docker%E5%8C%96%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Docker 是一个<strong>使用 Go 语言开发的开源的应用容器引擎</strong>，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker 的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。<br>记得在公众号科普过 Docker 的一些基本概念，简单可以理解为集装箱，可以把你的程序、环境、配置等等全部装进去，这样在其他机器上达到开箱即用，也就是解决了环境不一致的问题。<br>还有就是每一个 Docker 都是相对隔离的，避免了资源使用上的一些问题。<br><strong>Docker 的思想：标准化、集装箱、隔离，核心有镜像、仓库、容器等概念</strong><a id="more"></a><br>Docker 是容器化技术的一个代表，这项技术并不是很新，在内核中很早之前就已经存在了，不过确实是因为 Docker 才火起来的，在云计算的领域，Docker 可谓是更加的火热，<del>让程序猿和运维的关系更好了</del><br>Docker 你可以粗糙的理解为轻量级的<strong>虚拟机</strong></p>
<h2 id="走进Docker"><a href="#走进Docker" class="headerlink" title="走进Docker"></a>走进Docker</h2><p>下面来说说核心的三个词：镜像、仓库、容器；仓库就相当于码头，镜像就是集装箱，容器就是运行程序的地方，所以一般的使用步骤就是从仓库（码头）拉取镜像到本地，然后用命令把镜像运行起来。<br>相关的命令：Build（构建镜像）、ship（运输镜像）、run。<br>Docker 仓库的地址：<a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a>，如果速度慢，可以尝试国内的 <a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">c.163yun.com</a> ，或者 <a href="https://www.daocloud.io/" target="_blank" rel="noopener">daocloud</a> 也不错。<br>如果我们的镜像比较私密，不想让别人知道，那么可以自己搭一个镜像仓库，就像 Maven 仓库哪样<br>PS：安装 Docker 推荐是在 ubuntu 上，因为本身就是在 ubuntu 上进行开发的，所以支持应该是最好的。<br><img src="http://images2017.cnblogs.com/blog/1307022/201801/1307022-20180106211556893-1773468628.png" alt=""></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>下面介绍几个常用的命令：</p>
<ul>
<li>从仓库拉取镜像：<code>docker pull name</code></li>
<li>查看本机的镜像：<code>docker images</code></li>
<li>运行镜像：<code>docker run name</code><br>如果需要在后台运行可以使用 <code>-d</code> 参数<br>还可以加 <code>-e</code> 指定用到的环境变量（用 MySQL 的时候可能会用到），指定多个环境变量可使用多次 -e；<br>一般情况，都是加个自定义的名字，这样：<code>docker run --name myName mysql -d mysql:latest</code></li>
<li>查看本机正在运行的容器：<code>docker ps</code><br>另外，它可以加个 <code>-a</code> 参数来查看所有</li>
<li>进入容器：<code>docker exec -it [id] bash</code><br>id 由 run 命令（后台启动）返回，或者使用 ps 来查看，并且不需要输入完整，前几位就可以，与 git 比较类似。<br>然后就进入了这个容器，并且是以 bash 这个 shell 的方式，在容器中和 Linux 的操作基本一致，如同一个小型的 Linux 系统，并且是根据需求配置好的。<br>使用 exit 命令即可退出容器</li>
<li>停止容器：<code>docker stop id</code> ，主要是对于那些后台启动的容器来说。<br>这里的停止并不是删除，区分下镜像和容器的关系。<br>所以，也可以使用 <code>docker start id</code> 来启动容器。</li>
<li>重启容器：<code>docker restart id</code></li>
<li>删除镜像：<code>docker rmi id</code><br>注意和 rm 区分，一个是删除镜像，一个是删除容器。</li>
<li>清除运行过的镜像记录（缓存）：<code>docker rm id</code> ，可以使用 <code>docker ps -a</code> 来查看记录</li>
</ul>
<p>如果对命令参数不熟悉，可以查看帮助，如：<code>docker run --help</code> ；可以看出除了 pull 和 run 大部分命令都是依赖于镜像的 id 的；<br><strong>一个镜像可以启动（run）多个容器</strong>，一个容器可以理解为一个虚拟环境。</p>
<hr>
<p>如果我们需要将本机的某个文件放到容器里，有个快捷的命令：<br><code>docker cp xxx.html [id]://usr/share/nginx/html</code><br>id 自然指的就是相应的容器了，不过你得熟悉你容器的文件分布情况才行，<strong>这种改动操作是临时的，当容器停止后改动不会被保存</strong><br>如果需要永久保存，需要执行 commit 操作：<br><code>docker commit -m &quot;test&quot; [id] name</code><br>这样就相当于是保存修改了，和 Git 是不是很像？它实际会根据改动生成一个新的镜像，所以要在最后指定新镜像的名字（版本也可以）</p>
<hr>
<p>使用 <code>docker tag xxx newName</code> 可以实现镜像的复制….<br>想要 push 自己的镜像除了必要的账号，需要先进行登陆 <code>docker login</code> ，然后 <code>docker push name</code> 就可以了</p>
<h2 id="Docker中的网络"><a href="#Docker中的网络" class="headerlink" title="Docker中的网络"></a>Docker中的网络</h2><p>Docker 会虚拟出一个运行环境，这个环境当然包括网络、文件等，也是通过 namespace 来进行区分，对于网络，虚拟有三种方式：</p>
<ul>
<li>Bridge<br>也就是我们所说的桥接，会虚拟出独立的一套网络配置（网卡），有独立的 ip、端口、iptab 规则等<br>这也是启动 Docker 的默认模式</li>
<li>Host<br>使用物理机的网卡，和主机共用一套网络配置</li>
<li>None<br>不配置网络，也就是容器内的程序不会与外界发生通讯</li>
</ul>
<p>虚拟的方式是不是和配置虚拟机差不多呢~<br>在配置 Bridge 模式时，通常我们会配置端口映射，简单说就是当我们访问主机的某一个端口时，实际访问的是容器里的某一个端口，这个过程通过 Docker 提供的一个网桥实现（处理请求转发）<br>映射的配置可以在启动时就指定：<br><code>docker run -d -p 8080:80 name</code><br><code>-p</code> 后的第一个是本机的端口，第二个是对应的容器里的端口，上面的命令就实现了把本机 8080  的请求转发到容器的 80 端口上。<br>不放心的话可以使用 <code>netstat -na|grep 8080</code> 看看是不是处于监听的状态了。</p>
<hr>
<p>另外一种就是使用 <code>-P</code> 的方式，<strong>是大写的 P</strong>，这种不需要再指定对应的端口，它会在本机开一些随机端口然后映射到容器里对应应用的端口上。</p>
<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>重头戏来了，如何把自己开发的程序打包成一个 Docker 应用呢，就像仓库里的那些一样。<br>用到的是 Dockerfile 和 build 命令，Dockerfile 可以理解为描述了打包流程，然后使用 build 会根据这个流程进行打包。</p>
<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>是的，Dockerfile 只是一个文本文件，内容才是最重要的，可以直接使用 vim 来编写，名字就叫 Dockerfile，主要包括：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.设置基础镜像（在某个镜像的基础上）</span><br><span class="line">from tomcat</span><br><span class="line"><span class="meta">#</span> alpine 是针对 Docker 做的一个极小的 linux 环境，也常用做基础镜像</span><br><span class="line"><span class="meta">#</span> from alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2.作者信息,也可以不写</span><br><span class="line">MAINTAINER Kerronex bfchengnuo@gmail.com</span><br><span class="line"><span class="meta">#</span> 官方现在推荐使用 LABEL maintainer="yourname &lt;xxx@xxx.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3.将 war 包放进容器里</span><br><span class="line">COPY xxx.war /usr/local/tomcat/webapps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 拓展其他</span><br><span class="line">CMD echo "Hello World!"</span><br></pre></td></tr></table></figure>
<p>上面是个简单的发布 Java 程序的环境，tomcat 的目录在那是从官网 tomcat 镜像说明页面找到的。<br>然后下面执行 <code>docker build -t appName:latest .</code> 来进行打包就可以了；-t 的作用是可以指定名字和版本，最后一个 <code>.</code> 表示当前目录。<br>然后使用 <code>docker images</code> 命令就可以找到我们自己发布的本地镜像了，运行和其他的一样</p>
<h3 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h3><p>Docker 是分层存储的，在 Dockerfile 中一行就是一层，每一层都有它唯一的 ID。<br>这些层在 image (镜像)状态都是只读的（RO），当 image 运行为一个容器时，会产生一个容器层 (container layer)，它是可读可写的（RW）。<br>分层的一个好处就是会减轻不少存储压力，多个 image 难免会有许多的相同的命令，分层后就可以实现共用。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>再来看看 Volume 吧，它提供<strong>独立于容器之外</strong>的<strong>持久化</strong>存储。<br>它就可以解决我们在容器内修改不会保存的问题，并且它可以<strong>提供容器与容器之间的共享数据</strong></p>
<h3 id="映射容器里的目录到本机"><a href="#映射容器里的目录到本机" class="headerlink" title="映射容器里的目录到本机"></a>映射容器里的目录到本机</h3><p>在运行时执行命令：<br><code>docker run -d --name nginx -v /usr/share/nginx/html nginx</code><br>命令里的路径是<strong>容器里</strong>的地址，还给它起了个名字，运行后就会将配置的目录映射到本机（Host）的一个目录下，想要确定这个目录可以使用下面的命令查看容器信息：<br><code>docker inspect nginx</code><br>后面跟的是我们起的那个名字哦，不是镜像名，然后重点看 <strong>Mounts</strong> 下的 Source 和 Destination 是不是正确，就是把容器内的 Destination 地址映射到了本机的 Source 目录下。<br>在本机的 Source 下修改会同步到容器里的 Destination 目录。</p>
<h3 id="映射主机里的目录到容器"><a href="#映射主机里的目录到容器" class="headerlink" title="映射主机里的目录到容器"></a>映射主机里的目录到容器</h3><p>与上面正好相反，把本机的一个目录映射到容器里，命令：<br><code>docker run -d -v $PWD/html:/usr/share/nginx/html nginx</code><br>这条命令就是把当前目录下的 html 文件夹映射到容器里 nginx 的目录下，这种方式用的比较多，非常的方便</p>
<h3 id="建立只存数据的容器"><a href="#建立只存数据的容器" class="headerlink" title="建立只存数据的容器"></a>建立只存数据的容器</h3><p>这种情况或者说需求也是比较常见的，使用的命令是：<br><code>docker create -v $PWD/data:/var/mydata --name data_container ubuntu</code><br>这样我们就创建了一个仅仅用来存储数据的新容器 data_container ，它会把当前目录下的 data 文件夹挂载到与之关联的容器的 <code>/var/mydata</code> 目录下，然后我们运行一个新的容器来测试下：<br><code>docker run --volumes-from data_container ubuntu</code><br>volumes-from 的作用就是从另一个容器挂载，这样就实现了当前容器挂载仅有数据容器的目的，主要想体现的是这种仅有数据的容器可以被多个容器挂载使用，用来做数据的共享。</p>
<h2 id="多容器APP"><a href="#多容器APP" class="headerlink" title="多容器APP"></a>多容器APP</h2><p>玩这个之前需要一个软件就是 docker-compose，在 Mac/Windows 下是自带的。<br>然后需要配置 docker-compose.yml 文件，文件名是固定的，使用的是 yaml 语法，也就是用缩进来表示层次关系，非常流行的一种配置文件格式。</p>
<blockquote>
<p>Dockerfile 可以让用户管理一个单独的应用容器；<br>而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 project，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等</p>
</blockquote>
<p>最后写好 docker-compose 的配置文件后，就可以使用 <code>docker-compose up -d</code> 来运行了，停止就是 stop，rm 是删除；当重新修改配置文件后需要用 <code>docker-compose build</code> 重新来构建。<br>PS：在 docker-compose 配置的名字可以在其他的容器里直接用（比如 nginx 的配置文件里），不需要再配置解析。<br>关于 docker-compose 的使用这里不会多说，具体操作还是蛮复杂的，计划是等用到后再来补充，先暂且知道有这么个多容器的概念，可参考慕课网视频：<a href="https://www.imooc.com/video/15735" target="_blank" rel="noopener">https://www.imooc.com/video/15735</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有时我们需要合并两个镜像，但是这个功能并没有被提供，在 Dockerfile 中也不能使用多次 from，那么有什么好方法呢，可以使用命令先把镜像逆向出来，然后手动合并，镜像 –&gt; Dockerfile 的命令：<br><code>docker history --no-trunc=true image &gt; image1-dockerfile</code><br>但是如果命令中有 ADD、COPY 之类的命令就会有一些问题，因为这些文件并不在你的机器上，需要自行处理了。</p>
<h2 id="附-Dockerfile示例"><a href="#附-Dockerfile示例" class="headerlink" title="附:Dockerfile示例"></a>附:Dockerfile示例</h2><p>一般是创建一个空目录，然后在这个空目录写 Dockerfile 文件，名字就叫 Dockerfile，这样打包的时候可以放心的用 <code>.</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu</span><br><span class="line">LABEL maintainer="Kerronex &lt;bfchengnuo@gmail.com&gt;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 执行命令</span><br><span class="line"><span class="meta">#</span> 替换镜像地址，加速下载，把 archive.ubuntu.com 换成 mirrros.ustc.edu.cn</span><br><span class="line">RUN sed -i 's/archive.ubuntu.com/mirrros.ustc.edu.cn/g' /etc/apt/sources.list</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">COPY index.html /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置容器的入口，会将数组展开来运行</span><br><span class="line"><span class="meta">#</span> 命令的意思是将 nginx 作为前台程序执行，而不是守护进程</span><br><span class="line">ENTRYPOINT ["/usr/sbin/nginx","-g","daemon off;"]</span><br><span class="line"><span class="meta">#</span> 暴露端口</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>
<p>然后可以使用 <code>curl http://localhost:80</code> 来测试一下。<br>文件中没有用的其他关键字：ADD 也是添加文件，它比 COPY 更加强大，可以添加远程文件；CMD 也是执行命令的意思，可以用于指定容器的入口，也可以使用 ENTRYPOINT 命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>WORKDIR</td>
<td>指定路径</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>维护者，现在推荐使用 LABEL maintainer</td>
</tr>
<tr>
<td>ENV</td>
<td>设定环境变量</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>容器入口</td>
</tr>
<tr>
<td>USER</td>
<td>指定用户</td>
</tr>
<tr>
<td>VOLUME</td>
<td>mount point（容器所挂载的卷）</td>
</tr>
</tbody>
</table>
<p>当没有指定 ENTRYPOINT 的时候，就用 CMD 来启动容器，如果指定了 ENTRYPOINT 那么 CMD 指定的字串就变成了 <em>argus</em> （参数）</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java定时任务调度工具]]></title>
      <url>http://bfchengnuo.com/2018/01/03/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>什么是定时任务调度呢？</p>
<blockquote>
<p>基于<strong>给定的时间点</strong>，<strong>给定的时间间隔</strong>或者<strong>给定的执行次数</strong>自动执行的任务</p>
</blockquote>
<p>Java 中最常见的两款定时任务调度工具就是 Timer 和 Quartz，一般来说 Timer 能解决 60% 的需求，解决不了的就交给大哥 Quartz 了，Timer 是 JDK 自带的，不需要其他依赖，而 Quartz 是开源软件。<a id="more"></a><br>需要注意的是：能用 Timer 实现的就用 Timer，因为大哥的出场费是很贵的….</p>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>简单定义：<br>有且只有<strong>一个后台线程</strong>对<strong>多个业务线程</strong>进行<strong>定时定频率的调度</strong>。<br>构件关系：<br>Timer （包含有一个队列和一个后台线程）定时调用 TimerTask</p>
<p>我记得在上篇文章中我是写过关于 Timer 的，具体内容可以<a href="https://bfchengnuo.com/2017/12/21/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">点击这里</a>回看，这里就简单复习或者补充下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> MyTask(), <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// timer.scheduleAtFixedRate(new MyTask(), 0, 1000);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消所有任务</span></span><br><span class="line">    timer.cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回取消任务的个数</span></span><br><span class="line">    <span class="keyword">int</span> s = timer.purge();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"task run!!"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取最近一次任务执行的时间</span></span><br><span class="line">      System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(scheduledExecutionTime()));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 取消任务</span></span><br><span class="line">      <span class="comment">// cancel();</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还是要再次说明：使用 Timer 执行周期性任务时，出现异常后会自动退出（全部任务）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> MyTask, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束线程池正在执行的任务，不再接受新任务，等待当前任务完成</span></span><br><span class="line">scheduledExecutorService.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池里的任务是否全部完成</span></span><br><span class="line">scheduledExecutorService.isTerminated();</span><br></pre></td></tr></table></figure>
<p>通过上面，知道 Timer 主要的方法有两个 schedule 和 scheduleAtFixedRate；然后来说说他们最大的区别：</p>
<ul>
<li>首次执行时间早于当前时间<br>也就是说规定 12:00 执行 task，但是 12:05 的时候才执行到 schedule / scheduleAtFixedRate；<br>对于这种情况，schedule 会以当前时间为准，然后间隔指定时间重复执行；<br>对于 scheduleAtFixedRate 它会尽可能的多执行几次以赶上落下的任务，比如说规定没 2 分钟执行一次，那么它会在执行 scheduleAtFixedRate 后连续执行两次 task 来弥补缺失的“工作量”</li>
<li>执行耗时超过了间隔时间<br>也就是说规定每隔 3 秒执行一次，但是 task 3 秒还没执行完的情况；<br>对于 scheduleAtFixedRate，当 task 超时后，第二次会很快被执行，它的间隔计算方式是程序开始执行的时间；<br>对于 schedule ，它的间隔计算方式是程序执行完后计时的，也就是说规定每隔 3 秒执行一次，task 耗时 5 秒，task 执行完后再等 3 秒才会执行第二次，从运行开始算的话也就是差了 8 秒</li>
</ul>
<p>他们两个方法的主要区别就集中在这两种情况上了，缺点也可以看出来了，因为是单线程所以在处理并发时效果会非常的不理想，基本不会做到并发执行；还有就是抛出异常所有的任务都会终止了。<br>所以在对<strong>时效性要求较高的多任务并发作业</strong>和<strong>对复杂任务的调度</strong>（可能抛出异常）Timer 是不适合的</p>
<h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>然后就到了介绍大哥的时候了，它的强大就不用说了，你想实现的它基本都能搞定，听说也是作为 Spring 默认的调度框架，并且它的分布式和集群能力也不错。<br>Quartz 的核心有三个：调度器、任务、触发器；可以对应为 Scheduler、Job、Trigger。<br>简单的流程就是：调度器根据触发器来执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloScheduler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建 JobDetail 实例，和 job 类进行绑定</span></span><br><span class="line">    JobDetail jobDetail = JobBuilder.newJob(HelloJob.class)</span><br><span class="line">      .withIdentity(<span class="string">"myJob"</span>, <span class="string">"group1"</span>)</span><br><span class="line">      <span class="comment">// 传入自定义参数</span></span><br><span class="line">      .usingJobData(<span class="string">"msg"</span>,<span class="string">"Loli"</span>)</span><br><span class="line">      .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建一个 trigger 实例，来控制执行的规则</span></span><br><span class="line">    Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">      <span class="comment">// 这里的组和上面的完全不一样，虽然名字一样，但不是在一个类</span></span><br><span class="line">      .withIdentity(<span class="string">"myTrigger"</span>, <span class="string">"group1"</span>)</span><br><span class="line">      <span class="comment">// 传入自定义参数</span></span><br><span class="line">      .usingJobData(<span class="string">"age"</span>, <span class="number">12</span>)</span><br><span class="line">      <span class="comment">// 立即执行</span></span><br><span class="line">      .startNow()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 每隔两秒执行一次，直到永远，使用 SimpleSchedule</span></span><br><span class="line">      <span class="comment">// .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span></span><br><span class="line">      <span class="comment">//         .withIntervalInSeconds(2)</span></span><br><span class="line">      <span class="comment">//         .repeatForever())</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用 CronTrigger 和 Cron 表达式</span></span><br><span class="line">      .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"* * * * * ? *"</span>))</span><br><span class="line">      </span><br><span class="line">      .build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建 Scheduler 实例</span></span><br><span class="line">    SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">    Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line">    scheduler.start();</span><br><span class="line">    <span class="comment">// 按照 trigger 指定的日期执行 jobDetail</span></span><br><span class="line">    <span class="comment">// 它返回最近一次要执行的时间</span></span><br><span class="line">    scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起，可以被重启</span></span><br><span class="line">    scheduler.standby();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止，不能被重启，如果传入 true 表示会等待任务结束后才(标记为)终止，默认 false</span></span><br><span class="line">    scheduler.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码结合下面的解释看最好啦，这也仅仅只是一个简单的小例子</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>实现业务逻辑的任务接口，没错它是个接口，非常容易实现，只有一个 execute 方法，相当于 TimerTask 的 run 方法；在里面编写逻辑即可，当任务执行失败时会抛出 JobExecutionException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    System.out.println(MessageFormat.format(<span class="string">"当前时间：&#123;0&#125;"</span>, <span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// System.out.println("Hello World!");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobExecutionContext.getJobDetail().getKey().getName();</span></span><br><span class="line">    <span class="comment">// jobExecutionContext.getJobDetail().getKey().getGroup();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// jobExecutionContext.getTrigger().getKey().getName();</span></span><br><span class="line">    <span class="comment">// jobExecutionContext.getTrigger().getKey().getGroup();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取自定义的参数</span></span><br><span class="line">    String msg = jobExecutionContext.getJobDetail().getJobDataMap().getString(<span class="string">"msg"</span>);</span><br><span class="line">    Integer age = jobExecutionContext.getTrigger().getJobDataMap().getInt(<span class="string">"age"</span>);</span><br><span class="line">    System.out.println(msg + <span class="string">"::"</span> + age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并后的大 Map,如果有相同的 key 以 Trigger 为准</span></span><br><span class="line">    jobExecutionContext.getMergedJobDataMap();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的 Job，只是展示部分常用的，结合下面的说明阅读比较好~</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>每次调度器（Scheduler）调用执行 job 的 execute  方法前会会创建一个新的 job 实例，当调用完成后，关联的 job 实例会被释放，释放的实例就会被 GC 回收</p>
<h4 id="JobExecutionContext"><a href="#JobExecutionContext" class="headerlink" title="JobExecutionContext"></a>JobExecutionContext</h4><p>当调度器调用一个 Job ，就会将 JobExecutionContext 传递给  job 的 execute  方法；这样 Job 就可以通过 JobExecutionContext 来访问 Quartz 运行时候的环境以及 Job 本身的明细数据。<br>从另一方面 JobExecutionContext  就是为了解决不同 Job 需要不同参数的问题。<br>通过 JobExecutionContext 对象，可以获得 JobDetail 或者 Trigger 设置的自定义参数。</p>
<h4 id="JobDataMap"><a href="#JobDataMap" class="headerlink" title="JobDataMap"></a>JobDataMap</h4><p>在进行任务调度时，<strong>JobDataMap 存储在 JobExecutionContext  中</strong>，非常方便获取。<br>JobDataMap 可以用来<strong>装载任何可序列化的数据对象</strong>，当 job 实例执行时，这些参数对象会传递给它。<br>JobDataMap 实现了 JDK 的 Map 接口，并添加了一些非常方便的方法用来<strong>存取基本数据类型</strong>。</p>
<p>关于获取，除了使用 JobExecutionContext ，还有另一种方式，那就是在 Job 的实现类里添加相应的成员变量，并且设置 setter 方法，<strong>默认的 JobFactory 实现类在初始化 Job 实例的时候会自动调用这些 setter 方法</strong>，把 JobDataMap 中相应的值放进去</p>
<h3 id="JobDetail"><a href="#JobDetail" class="headerlink" title="JobDetail"></a>JobDetail</h3><p>JobDetail 为 job 实例提供了许多设置属性，以及 JobDataMap 成员变量属性，它用来存储<strong>特定的</strong> job 实例的状态信息，<strong>调度器需要借助 JobDetail 对象来添加 Job 实例</strong>。<br>简单说就是 JobDetail 是用来绑定 Job 实例的，并携带一些 Job 实例没有携带的状态信息。<br>下面看看它的一些重要属性：<br>name 和 group ，这两个是必须的，group 的默认值是 <strong>DEFAULT</strong>；还有 jobClass 也是必须的，就是绑定的 Job 类；此外还有一个 JobDataMap ，可简单理解为是来传递数据的。<br>查看可以使用：<code>jd.getKey().getName()/getGroup();</code></p>
<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><p>Quartz 中的触发器用来告诉调度程序作业什么时候触发。即 Trigger 对象是用来触发执行 Job 的。<br>触发器的通用属性：</p>
<ul>
<li>JobKey<br>表示 Job 实例的标识，触发器被触发时，该指定的 Job 实例会执行</li>
<li>StartTime<br>触发器的时间表首次被触发的时间，类型是 Date，startAt()</li>
<li>EndTime<br>指定触发器的不再被触发的时间，类型也是 Date，endAt()，它的优先级比设置的重复执行次数高</li>
</ul>
<h4 id="SimpleTrigger"><a href="#SimpleTrigger" class="headerlink" title="SimpleTrigger"></a>SimpleTrigger</h4><p>首先来看它的作用：<br>在一个<strong>指定时间段</strong>内执行<strong>一次</strong>作业任务，或者是在<strong>指定的时间间隔</strong>内<strong>多次</strong>执行作业任务。<br>我们通过 <code>TriggerBuilder.newTrigger()</code> 代码实际上就是生成了一个 SimpleTrigger</p>
<h4 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h4><p>它的作用：<br><strong>基于日历</strong>的作业调度器，它不像 SimpleTrigger 那样精确的控制，但是更加常用。<br>说到 CronTrigger 就必须得说 Cron 表达式了，熟悉 Linux 的可能接触过，因为 Linux 有一个 crontab 命令来控制计划任务，也是 Cron 表达式。<br>简单说，Cron 表达式是由 7 个子表达式组成的字符串，描述了时间表的详细信息，格式：<br><code>[秒] [分] [小时] [日] [月] [周] [年]</code><br><code>*</code> ：表示“每”的意思，放在第一个位置就是每秒。<br><code>?</code> ：表示不确定，不指定值，就是不关心。<br><code>,</code> ：表示或的意思。<br><code>-</code> ：表示至的意思，就是范围啦。<br><code>/</code> ：表示的也是每的意思，举个例子，如果出现在秒的位置 <code>0/5</code> 就是从 0 秒开始，每隔 5 秒钟。<br><code>#</code> ：表示第，例如在周的位置有 <code>5#3</code> 意思就是第三周的<strong>星期四</strong> 。<br><code>L</code> ：意思是 List，在周位置 3L 就表示最后一周的周二。<br>需要注意的是，<strong>时分秒范围是从 0 开始，日月周就是 1 开始了，年可以省略</strong></p>
<blockquote>
<p>在西方，星期天是一个星期的第一天。所以星期天是 1 ，以此类推</p>
</blockquote>
<p>掌握了表达式其他的就不是问题了：<br><img src="/image/dev/cron表达式.png" alt="cron表达式.png"></p>
<p>月周可以使用英文单词的前三个字母，有在线生成 Cron 表达式的工具哦</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度器 Scheduler 可以说是 Quartz 的发动机，它是通过工厂模式来创建的，常用的两个是 StdSchedulerFactory 和 DirectSchedulerFactory。<br><strong>常用的还是 StdSchedulerFactory 因为它允许使用声明式的配置，也就是可以配置到 XML/Properties 文件中</strong>，而 DirectSchedulerFactory 生成的只允许在代码中配置。<br>StdSchedulerFactory 默认会加载工程目录下的 <strong>quartz.properties</strong> ，如果不存在就会去读取自带的配置文件（jar 中），在配置文件中可以配置调度器属性、线程池属性（如线程数）、作业存储位置、插件配置等，可参考 jar 包里的配置。</p>
<h2 id="Quartz与Spring整合"><a href="#Quartz与Spring整合" class="headerlink" title="Quartz与Spring整合"></a>Quartz与Spring整合</h2><p>Quartz 与 Spring 能够进行完美的整合，用的也是比较多，下面就赶紧来学习一下，首先，必要的一些依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是在 Spring 的配置文件中配置必要的 Bean 了，没办法，总要写配置文件的，或者使用 SpringBoot ？<br>在 Spring 中配置使用 Quartz 有两种方式：<br>MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean，它们主要是来确定要执行的任务的，也就是 Job</p>
<h3 id="MethodInvokingJobDetailFactoryBean"><a href="#MethodInvokingJobDetailFactoryBean" class="headerlink" title="MethodInvokingJobDetailFactoryBean"></a>MethodInvokingJobDetailFactoryBean</h3><p>使用这种方式，只需要写一个普通的 Bean 即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 相当于设置执行的 Job 为 myBean 的 printMessage 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleJobDetail"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span> <span class="attr">ref</span>=<span class="string">"myBean"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"printMessage"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应执行的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"myBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"MyBean Executes!"</span> + sf.format(date));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种相对简单的方法，然后都猜得出简单的方式定制性不太高，如果逻辑太复杂可能就无能为力了</p>
<h3 id="JobDetailFactoryBean"><a href="#JobDetailFactoryBean" class="headerlink" title="JobDetailFactoryBean"></a>JobDetailFactoryBean</h3><p><strong>当需要给作业传递数据，想要更加灵活的话就使用这种方式</strong>，配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"firstComplexJobDetail"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobClass"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value</span>=<span class="string">"com.imooc.springquartz.quartz.FirstScheduledJob"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDataMap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"anotherBean"</span> <span class="attr">value-ref</span>=<span class="string">"anotherBean"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Durability"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span>				</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为 firstComplexJobDetail 是通过代码的方式创建的并不是 Spring 容器注入的，启动时可能会报错，提示没有绑定触发器，这里使用的是 Spring 来配置的 trigger，它扫描不到，可以把 Durability 属性设置为 true 表示即使没有绑定触发器也会将其保存在任务容器中。<br>通过 jobClass 来指定 Job 类，对这个类的要求就是要继承 QuartzJobBean，实现 executeInternal 方法，这个还是比较熟悉的，和最开始我们学习时写法类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstScheduledJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AnotherBean anotherBean;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnotherBean</span><span class="params">(AnotherBean anotherBean)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.anotherBean = anotherBean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext arg0)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"FirstScheduledJob Executes!"</span> + sf.format(date));</span><br><span class="line">    <span class="keyword">this</span>.anotherBean.printAnotherMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -----分割线------ */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"anotherBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherBean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnotherMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AnotherMessage"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里加了点“难度”，设置自定参数时，我们可以设置对象，通过 value-ref 实现了自动注入，还是挺爽的。</p>
<h3 id="配置Trigger和Scheduler"><a href="#配置Trigger和Scheduler" class="headerlink" title="配置Trigger和Scheduler"></a>配置Trigger和Scheduler</h3><p>有了任务 Job，Quartz 还差两大核心，下面就来搞一下，完善 Spring 的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 距离当前时间1秒之后执行，之后每隔两秒钟执行一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySimpleTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>  <span class="attr">ref</span>=<span class="string">"simpleJobDetail"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"startDelay"</span>  <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"repeatInterval"</span>  <span class="attr">value</span>=<span class="string">"2000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 每隔5秒钟执行一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCronTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span>  <span class="attr">ref</span>=<span class="string">"firstComplexJobDetail"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cronExpression"</span>  <span class="attr">value</span>=<span class="string">"0/5 * * ? * *"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetails"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"simpleJobDetail"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"firstComplexJobDetail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"triggers"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mySimpleTrigger"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myCronTrigger"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义 Trigger 的时候也完全活用了上面学习的两种方式，一个使用 SimpleTrigger ，一个使用 CronTrigger；<br>这样当程序启动后就会执行配置的两个 Job 了，simpleJobDetail 使用方式一运行，firstComplexJobDetail 使用方式二运行，还是挺和谐的。<br>上面的也仅仅都是 Quartz 的初级使用，高级的并发、异常处理、持久化等没有涉及，以后有机会再补充吧！</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaSE二周目计划（二）]]></title>
      <url>http://bfchengnuo.com/2017/12/21/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>这次就不仅仅是复习了，大部分讲的是以前学习 JavaSE 的时候没有接触到的知识，并且很多情况下还是很有用的。<br>这篇主要讲解 Java 中的队列和线程池（包括支持周期任务的线程池），这也算得上是 SE 中的精华部分吧，当然还有一些对于日期的操作补充，平时用的也挺多的，算是非常简单的作为开胃菜~~<a id="more"></a></p>
<h2 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h2><p>代码中经常接触到日期的操作，我们不喜欢它默认的格式，大多数情况是需要进行格式化的，下面就说下最简单的格式化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">sf.format(<span class="keyword">new</span> Date());  <span class="comment">// 格式化当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串格式化为 Date 类型</span></span><br><span class="line"><span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-12-20 18:44:00"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时间是否超过五分钟</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOverstepMinute</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">  Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">  Calendar cal1 = Calendar.getInstance();</span><br><span class="line">  cal1.setTime(date);</span><br><span class="line">  cal1.add(Calendar.MINUTE, +<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cal1.compareTo(cal) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外可以通过 date 对象获取到年月日等信息，但是很遗憾已经过时，所以就有了 Calendar， Calendar 对象用的也很多，可以看看 API；<br>那么他什么用呢？<br>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，分钟? 我们又如何在日期的这些部分<strong>加上或者减去值</strong>呢? 答案是使用Calendar 类。</p>
<h2 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h2><p>很遗憾我看的视频里并没有讲这个，但是这个却非常的终于，好在现在知道了。<br>Java 中的队列 Queue 在 util 包下，它是个接口，它更倾向于是一种数据结构，也可以理解为集合吧，毕竟 Queue 是 Collection 的一个子接口，与 List、Set 同一级别。<br>首先来认识下什么是队列：</p>
<blockquote>
<p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。</p>
</blockquote>
<p>简单易懂的介绍，它本来也不是什么难题；<strong>在 Java 中，队列分为 2 种形式，一种是单队列，一种是循环队列</strong> ，循环队列就是为了解决数组无限延伸的情况，让它们闭合起来形成一个圈，这就不会出现角标越界问题了。<br>通常，都是使用数组来实现队列，假定数组的长度为6，也就是队列的长度为6，如果不指定一般默认是 internet 的最大值。<br>因为 LinkedList 实现了 Queue 接口，所以定义一个接口 new 时可以直接使用 LinkedList ，<strong>但它不是同步的！</strong><br>Java 中给了许多的队列实现，甚至有双端（读写）的、按优先级的，普通常用的就是阻塞和非阻塞的一些同步队列</p>
<h3 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>这样非阻塞也就明白了吧？<br>阻塞队列提供了四种处理方法：</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h3 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h3><p><strong>阻塞队列</strong>，当队列为空是取数据阻塞，队列满，插入数据阻塞<br><strong>线程安全的</strong>(批量操作不是) 是否是有界队列需要看具体的实现<br>常用的实现类有：</p>
<ul>
<li>ArrayBlockingQueue<br>规定大小的 BlockingQueue,其构造函数<strong>必须</strong>带一个 int 参数来指明其大小.<br>其所含的对象是以FIFO(先入先出)顺序排序的</li>
<li><strong>LinkedBlockingQueue</strong><br>大小不定的 BlockingQueue，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定.<br>其所含的对象是以 FIFO (先入先出)顺序排序的<br><strong>是作为生产者消费者的首选</strong></li>
<li>SynchronousQueue<br>特殊的 BlockingQueue，对其的操作必须是放和取交替完成的</li>
<li>PriorityBlockingQueue<br>类似于 LinkedBlockQueue，但其所含对象的排序<strong>不是 FIFO</strong>，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序</li>
</ul>
<p>至于它是如何实现同步的，两个 ReentrantLock 读和写。</p>
<h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><p>不是按照先进先出的顺序，是按照优先级（Comparator 定义或者默认顺序,数字、字典顺序）<br>每次从队列中取出的是具有最高优先权的元素<br>内部通过堆排序实现 transient Object[] queue; 每次新增删除的时候，调整堆</p>
<h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>非阻塞队列一般就直接实现自 Queue 了，特点就不说了，对比上面的阻塞队列就行了，下面说说常见的非阻塞队列：<br><strong>ConcurrentLinkedQueue</strong><br>虽然是非阻塞，但也是线程安全的，按照 FIFO 来进行排序，采用CAS操作，来保证元素的一致性</p>
<blockquote>
<p>非阻塞算法通过使用低层次的并发原语，比如比较交换，取代了锁。原子变量类向用户提供了这些底层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。<br>关键字：CAS<br><strong>线程安全就是说多线程访问同一代码，不会产生不确定的结果</strong></p>
</blockquote>
<p>ConcurrentLinkedQueue 的 <code>size()</code> 是要遍历一遍集合的，所以尽量要避免用 size 而改用 <code>isEmpty()</code>，以免性能过慢。</p>
<h3 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h3><p>一般情况下，操作队列不推荐使用 add 和 remove ，因为如果队列为空它就会抛异常；常使用的是 <strong>offer</strong> 和 <strong>poll</strong> 来添加和取出元素，如果此队列为空，则返回 null，如果使用 peek 取出元素则不会移除此元素，对于阻塞的队列，可以使用 put 和 take 来插入和获取。<br>带有 Deque 的一般是双端队列，不细说，我用的起码是非常少的<br>关于遍历队列如果使用 foreach 的方式相当于仅仅是 peek，也就是不会移除元素，如果需要遍历队列并且是取出，那么可以搭配 where 来使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历队列</span></span><br><span class="line">  Order order;</span><br><span class="line">  <span class="keyword">while</span> ((order = queue.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">    rechargeOrder(order);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程注意 size，如果一边放一边遍历的话是没有尽头的</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>同样视频里是没有提到的，只是讲了多线程的一些使用和注意事项，对于线程池，提及的很少，也许是因为 JavaEE 中并不常用，都是交给 Web 应用服务器来维护。<br>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，和连接池是一个道理。<br>Java 中的线程池，最核心的就是 <strong>ThreadPoolExecutor</strong> 了<br>ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。<br>下面解释下一下构造器中各个参数的含义：</p>
<ul>
<li>corePoolSize：核心池的大小<br>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 <code>prestartAllCoreThreads()</code> 或者 <code>prestartCoreThread()</code> 方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。<br>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中；</li>
<li>maximumPoolSize：线程池最大线程数<br>这个参数也是一个非常重要的参数，<strong>它表示在线程池中最多能创建多少个线程</strong>；</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。<br>默认情况下，只有当线程池中的线程数大于 corePoolSize 时，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize，即当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize。<br>但是如果调用了 <code>allowCoreThreadTimeOut(boolean)</code> 方法，在线程池中的线程数不大于 corePoolSize 时， keepAliveTime 参数也会起作用，直到线程池中的线程数为 0；</li>
<li>unit：参数 keepAliveTime 的时间单位<br>有7种取值，比如天、时、分、秒、毫秒等</li>
<li><strong>workQueue：一个阻塞队列，用来存储等待执行的任务</strong><br>这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue;<br>LinkedBlockingQueue;<br>SynchronousQueue;<br>ArrayBlockingQueue 和 PriorityBlockingQueue 使用较少，<strong>一般使用 LinkedBlockingQueue 和 Synchronous</strong>。<br>线程池的排队策略与 BlockingQueue 有关。</li>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li>handler：表示当拒绝处理任务时的策略<br>有以下四种取值：<br>ThreadPoolExecutor.AbortPolicy ：丢弃任务并抛出 RejectedExecutionException 异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<p>上面仅仅是对构造方法参数的一些介绍，相关的几个类或者接口就是 ThreadPoolExecutor、AbstractExecutorService、ExecutorService 和 Executor，名字越短越抽象，最后的 Executor 为顶级接口</p>
<h3 id="定义的方法"><a href="#定义的方法" class="headerlink" title="定义的方法"></a>定义的方法</h3><p>下面来了解下关于线程池中定义的几个方法：</p>
<ul>
<li>execute()方法<br>实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li>submit()方法<br>在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute() 方法不同，<strong>它能够返回任务执行的结果</strong>，去看 submit() 方法的实现，会发现它<strong>实际上还是调用的 execute() 方法</strong>，只不过它利用了 Future 来获取任务执行结果</li>
<li>shutdown() 和 shutdownNow() 是用来关闭线程池的。</li>
</ul>
<p>其他的方法还有 getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount() 等获取与线程池相关属性的方法，详细介绍去看 API 吧</p>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>当创建线程池后，初始时，线程池处于 <strong>RUNNING</strong> 状态；<br>如果调用了 <code>shutdown()</code> 方法，则线程池处于 <strong>SHUTDOWN</strong> 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；<br>如果调用了 <code>shutdownNow()</code> 方法，则线程池处于 <strong>STOP</strong> 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；<br>当线程池处于 <strong>SHUTDOWN</strong> 或 <strong>STOP</strong> 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 <strong>TERMINATED</strong> 状态。</p>
<h3 id="线程池的创建-amp-使用"><a href="#线程池的创建-amp-使用" class="headerlink" title="线程池的创建&amp;使用"></a>线程池的创建&amp;使用</h3><p>先来看一个简单使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                         <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">      MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">      executor.execute(myTask);</span><br><span class="line">      System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">                         executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 java doc中，并不提倡我们直接使用 ThreadPoolExecutor，而是使用 Executors 类中提供的几个静态方法来创建线程池：</p>
<ul>
<li>Executors.newCachedThreadPool();<br>创建一个缓冲池，缓冲池容量大小为 Integer.MAX_VALUE</li>
<li>Executors.newSingleThreadExecutor();<br>创建容量为 1 的缓冲池</li>
<li>Executors.newFixedThreadPool(int);<br>创建固定容量大小的缓冲池</li>
</ul>
<p>看一下他们三个的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从它们的具体实现来看，它们实际上也是调用了 ThreadPoolExecutor，只不过参数都已配置好了。<br><strong>newFixedThreadPool</strong> 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的 LinkedBlockingQueue；<strong>newSingleThreadExecutor</strong> 将 corePoolSize 和 maximumPoolSize 都设置为 1，也使用的 LinkedBlockingQueue；<strong>newCachedThreadPool</strong> 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。<br>实际中，如果 Executors 提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置 ThreadPoolExecutor 的参数有点麻烦，要根据实际任务的类型和数量来进行配置。<br>另外，如果 ThreadPoolExecutor 达不到要求，可以自己继承 ThreadPoolExecutor 类进行重写。</p>
<h3 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h3><p>一般需要根据任务的类型来配置线程池大小，当然也是仅供参考：<br>如果是 CPU 密集型任务，就需要尽量压榨 CPU，参考值可以设为 NCPU+1<br>如果是 IO 密集型任务，参考值可以设置为 2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>一提到定时任务，首先想到的是使用 Timer，但是使用 Timer 执行周期性任务时，出现异常后自动退出（全部）,因为它是基于单线程的。所以应该尽量使用 ScheduledExecutorService （支持周期任务的线程池）的方式来创建。<br>是的，这也是一个线程池，只不过它支持周期任务而已，看到这里对线程池应该也有所了解了，所以定时任务也就不难了</p>
<p><img src="/image/dev/线程池.png" alt="线程池.png"></p>
<p>它继承的 ThreadPoolExecutor 那些就不说了，来看看它特有的几个方法：</p>
<ul>
<li><strong>Schedule(Runnable command, long delay, TimeUnit unit)</strong><br>elay 指定的时间后，执行指定的 Runnable 任务，可以通过返回的 <code>ScheduledFuture&lt;?&gt;</code> 与该任务进行交互</li>
<li><strong>schedule(Callable\<v\> callable, long delay, TimeUnit unit)</v\></strong><br><em>delay</em> 指定的时间后，执行指定的 <code>Callable&lt;V&gt;</code> 任务，可以通过返回的 <code>ScheduledFuture&lt;V&gt;</code> 与该任务进行交互。</li>
<li><strong>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按周期 <em>period</em> 执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，那么第一次执行任务的时间点为 <code>initialDelay</code>，第二次为 <code>initialDelay + period</code>，第三次为 <code>initialDelay + period + period</code>，以此类推。</li>
<li><strong>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</strong><br><em>initialDelay</em> 指定的时间后，开始按指定的 <em>delay</em> 延期性的执行指定的 <code>Runnable</code> 任务。<br>假设调用该方法后的时间点为 <code>0</code>，每次任务需要耗时 <code>T(i)</code>（<strong>i</strong> 为第几次执行任务），那么第一次执行任务的时间点为 <code>initialDelay</code>，第一次完成任务的时间点为 <code>initialDelay + T(1)</code>，则第二次执行任务的时间点为 <code>initialDelay + T(1) + delay</code>；第二次完成任务的时间点为 <code>initialDelay + (T(1) + delay) + T(2)</code>，所以第三次执行任务的时间点为 <code>initialDelay + T(1) + delay + T(2) + delay</code>，以此类推。</li>
</ul>
<p>简单解释下 scheduleAtFixedRate 和 scheduleWithFixedDelay，前者会开始执行为起始点，如果任务耗时超过了间隔时间，那么在任务完成候第二次会很快（<del>马上</del>）执行，而后者会等待任务执行完后才开始计算周期间隔时间。<br>创建线程池的方式也与上面差不多，都有对应的方法：<br><strong>Executors.newScheduledThreadPool(int corePoolSize)</strong><br><strong>Executors.newSingleThreadScheduledExecutor()</strong></p>
<p>Apache 的 BasicThreadFactory 或许会更好….待进一步研究</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><code>ScheduledFuture</code> 接口 继承自 <code>Future</code> 接口，所以 <code>ScheduledFuture</code> 和任务的交互方式与 <code>Future</code> 一致。所以通过<code>ScheduledFuture</code>，可以 判断定时任务是否已经完成，获得定时任务的返回值，或者取消任务等<br>关于 <code>Future</code> 后面应该会再进行补充<br>可以先看一下：<a href="http://www.ideabuffer.cn/2017/04/06/FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这个很简单，没什么好说的，简单说就是构造函数的私有化，然后定义一个本类类型的静态变量，通过静态方法进行提供<br>需要注意的是，静态变量的初始化时机，比较一致的观点是：如果你确定这个类肯定要用，那么可以在定义静态变量的时候就直接进行实例化，否则可以放在静态方法中进行实例化（这样会有线程安全问题）比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton is = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是获取的时候实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">    is = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，单例模式需要注意的也就是这里了：<strong>线程安全问题</strong><br>如果你选择了在静态方法中进行实例化，并且使用了多线程技术，那么极有可能它并不是单例的；原因我想大概都知道，当然也有相应的解决方案，一般就从这三种中进行选择：</p>
<ul>
<li><p>同步方法<br>这是最简单的方式，如果不考虑性能的情况下是可以使用的，使用同步就意味着可能造成执行效率下降100倍<br><code>public static synchronized getInstance(){}</code></p>
</li>
<li><p>急切实例化<br>这个就是上面的第一种方式，在定义的时候就直接实例化<br>在创建运行时负担不重的情况下可以采用</p>
</li>
<li><p>双重检查加锁<br>在同步方法中我们发现，其实只需要第一次加锁就可以了，因为第一次创建出 is 后后面都是直接返回的<br>所以，可以进行下面的优化（java5+）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton is;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Test&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is == <span class="keyword">null</span>)&#123;</span><br><span class="line">          is = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以大大减少 get 方法的时间消耗，如果确实不考虑性能，使用这个就有点大材小用了。</p>
<blockquote>
<p>这个方法表面上看起来很完美，你只需要付出一次同步块的开销，但它依然有问题。<br>除非你声明 is 变量时使用了 volatile 关键字。没有 volatile 修饰符，可能出现 Java 中的另一个线程看到个初始化了一半的 is 的情况，但使用了 volatile 变量后，就能保证先行发生关系（happens-before relationship）<br>参考下面的：无序写入</p>
</blockquote>
</li>
<li><p>静态内部类<br>这也是一种懒汉式的实现，相比双重锁检查，更简单，更高效吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonIniti</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonIniti</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonIniti INSTANCE = newSingletonIniti();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonIniti <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br>并且外部类可以访问内部类的 private 方法。</p>
</li>
</ul>
<p>单例模式的使用情景并不是太多，并且如果程序有多个类加载器，还是会造成有多个实例的情况，所以如果用到了多个类加载器记得指定使用同一个类加载器</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>关于这个，确实不太常见，很多人以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。<br>Java 语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制。</p>
<p>对于 synchronized 我们都知道：<br>通过 synchronized 关键字来实现，所有加上 synchronized 和块语句，在多线程访问的时候，同一时刻只能有一个线程能够用 synchronized 修饰的方法 或者 代码块。<br><strong>用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。</strong></p>
<blockquote>
<p>在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是 jvm 虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候<strong>变量值信息</strong>。<br>当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值 load 到线程本地内存中，建立一个变量副本，<strong>之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值</strong>，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。<br>这样在堆中的对象的值就产生变化了。</p>
<p>原文：<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p>
</blockquote>
<p>从上面的解释也可以看出 volatile 并不能保证原子性，它的作用就是在每次<strong>使用的时候</strong>获取最新的值</p>
<h2 id="无序写入"><a href="#无序写入" class="headerlink" title="无序写入"></a>无序写入</h2><p>双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。<strong>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</strong><br><strong>双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</strong><br>关键原因就是： <code>instance = new Singleton();</code> 不是原子操作。<br>然后从两个方面来看原因：</p>
<ul>
<li>有序性：是因为 instance = new Singleton(); 不是原子操作。编译器存在指令重排，从而存在线程1 创建实例后（初始化未完成），线程2 判断对象不为空，但实际对象扔为空，造成错误。</li>
<li>可见性：是因为线程1 创建实例后还只存在自己线程的工作内存，未更新到主存。线程 2 判断对象为空，创建实例，从而存在多实例错误。</li>
</ul>
<p>也就是，要想保证安全，必须保证这句代码的有序性和可见性。<br><strong>volatile 对 singleton 的创建过程的重要性：禁止指令重排序（有序性）。</strong><br>实例化一个对象其实可以分为三个步骤：</p>
<ol>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
</ol>
<p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：</p>
<ol>
<li>分配内存空间。</li>
<li>将内存空间的地址赋值给对应的引用。</li>
<li>初始化对象</li>
</ol>
<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。<br>因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量，volatile 的禁止重排序保证了操作的有序性。<br>除了这种方案，还有人提出在“构造对象”和“连接引用与实例”之间加上一道内存屏障来保证有序性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Singleton temp = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//构造与赋值之间随意做点事情保证顺序</span></span><br><span class="line">temp.toString();</span><br><span class="line">instance=temp;</span><br></pre></td></tr></table></figure>
<p>这想法确实 nice~</p>
<hr>
<p>关于可见性，第二次非 null 判断是在加锁以后（也就是说后面的线程在获取锁以后判断 instance 是否为 null 必然是在第一个线程引用赋值完成释放锁以后），则根据这一条，另一个线程一定能看到这个引用被赋值。所以即使没有 volatile，依旧能保证可见性。</p>
<p><a href="https://www.zhihu.com/question/56606703" target="_blank" rel="noopener">https://www.zhihu.com/question/56606703</a></p>
<p>PS：据说因为 JVM 的实现不同，volatile 未必能保证绝对的安全，在 HotSpot 应该是没问题的。</p>
<h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-blocking-queue</a><br><a href="http://blog.csdn.net/xiaohulunb/article/details/38932923" target="_blank" rel="noopener">http://blog.csdn.net/xiaohulunb/article/details/38932923</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a><br><a href="https://segmentfault.com/a/1190000008038848" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008038848</a><br><a href="https://blog.csdn.net/chenchaofuck1/article/details/51702129" target="_blank" rel="noopener">https://blog.csdn.net/chenchaofuck1/article/details/51702129</a><br>拓展：<br><a href="http://www.jianshu.com/p/925dba9f5969" target="_blank" rel="noopener">http://www.jianshu.com/p/925dba9f5969</a><br><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/" target="_blank" rel="noopener">深入理解Java线程池</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaSE二周目计划]]></title>
      <url>http://bfchengnuo.com/2017/11/28/JavaSE%E4%BA%8C%E5%91%A8%E7%9B%AE%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>基础不能落下，习惯使用框架后基本功都忘得差不多，是时候复习一波了，跳着看的，重点放在多线程、IO、Socket 上；<br>这一篇是个开头，也正好以前学 SE 的时候还没搭博客所以也没 md 笔记，这次就顺便补上；<br>开头算是个补充，泛型、动态代理、悲观锁/乐观锁的小补充，后面是复习系列的多线程和 IO<br><a id="more"></a></p>
<h2 id="关于泛型"><a href="#关于泛型" class="headerlink" title="关于泛型"></a>关于泛型</h2><p>泛型还算是很简单的，稍微提一提，用的也很广泛，泛型可以用在方法上也可以用在类上，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用在类上，使用时最好是显式指定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// T stands for "Type"</span></span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">      p1.getValue().equals(p2.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> K key;</span><br><span class="line">  <span class="keyword">private</span> V value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JDK1.7+ 后会自动根据 type inference 进行推导，所以说在调用方法是是可以不写泛型的<br>泛型的定义一般是在类名的后面，或者方法返回值之前，有了泛型，省去了很多的强转，在编译阶段就能发现错误<br>然后说一下比较重要的，泛型的上限和下限：</p>
<ul>
<li>上限（<code>&lt;? extends E&gt;</code>）<br>说明传入的可以是 E 或者 E 的子类</li>
<li>下限（<code>&lt;? super E&gt;</code>）<br>说明传入的值可以是 E 或者 E 的父类</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在 C++ 中采用的方案是当实例化一个泛型会生成一个新类，例如模板类是 List ，然后你用 int ,double,string, Employee 分别去实例化， 那编译的时候，我们就会生成四个新类出来，例如List_int和List_double，List_string, List_Employee。</p>
<p>而在 Java 中采用的是擦除法，简单来说就是一个参数化的类型经过擦除后会去除参数， 例如 <code>ArrayList&lt;T&gt;</code>  会被擦除为 ArrayList ，既然这样类中使用的泛型怎么办，擦除了岂不是消失了？<br>最终其实泛型都会被替换为 Object，然后还有一个问题，比如 <code>Integer i = list1.get(0);</code> 现在类型被擦除，返回值变成 Object 了， 怎么处理啊？很简单，只需要在编译的时候做点手脚来个强转就行了，因为可以保证类型一致，否则也不会通过编译检测：<code>Integer i = (Integer)list1.get(0);</code></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java 中的两大类型：基本数据类型和引用数据类型，这个很熟悉都知道，在之前的 <a href="https://bfchengnuo.com/2016/09/25/Java%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98/">Java复习之内存</a> 也说的比较清晰了，但是还有一些小的知识点漏掉了，现在就来补上<br>都知道字符串、数组、自定对象之类的都是引用数据类型，会存储在堆内存中，默认会进行初始化，能够赋为 null，我想要说的是，基本数据类型也有可能放在堆中，也会进行初始化，那就是当它被定义为全局变量的时候，所以你能在定义全局变量的时候写：<code>int a;</code> 默认为 0，而在方法内定义时必须要这样写：<code>int a = 0;</code> 给它一个初始值，<strong>但是不能设置为 null</strong>。</p>
<h2 id="动态代理-amp-ASM"><a href="#动态代理-amp-ASM" class="headerlink" title="动态代理&amp;ASM"></a>动态代理&amp;ASM</h2><p>关于什么是动态代理、如何使用在前面的 Spring 文章和 Java 知识补充中已经说的很详细了，这里来补充一波没提到（写的好分散，忍忍吧，<del>有时间再整理到一起</del>）<br>官方的动态代理基于接口实现（通过反射）<br>CGLib（<strong>Code Generation Library</strong>）采用的是继承的方式实现，CGLIb 为了提高性能，还用了一种叫做FastClass 的方式来直接调用一个对象的方法，而不是通过反射。</p>
<hr>
<p>ASM 虽然很低调，但它确实很厉害，Spring , hibernate 的核心都是基于它来实现的，更不要说 AOP 了，以及上面的 CGLib 也是基于 ASM，那么它到底是什么呢？</p>
<blockquote>
<p>它可以动态的<strong>修改已经编译过的 class , 还可以动态的生成新的 java class</strong>,  注意我说的动态这个词， 那可以是完全在运行时， 在内存中完成的， 这是一件非常厉害的本事。</p>
<p>并不是仅仅像 jsp 那样， 使用 JavaComplier 接口在运行时动态的编译一个 java 源代码</p>
</blockquote>
<p>名字的由来：<br>C语言中的 <code>__asm__</code> 这个关键字， 可以允许你们在 C 语言中写点汇编，  他就把 ASM 这个关键字挪用了<br>需要注意的是，想使用 ASM 需要非常透彻的理解 Java 虚拟机指令和 Java 虚拟机内部结构，我们常用的 Spring、CGLib 都是进行了高级的封装使用起来更加友好。<br>有很多的语言是利用 ASM 来动态的生成字节码（解释性语言），跑在 JVM 的虚拟机上</p>
<p>官方提供的文档：<a href="http://download.forge.objectweb.org/asm/asm4-guide.pdf" target="_blank" rel="noopener">http://download.forge.objectweb.org/asm/asm4-guide.pdf</a> </p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>应该是和数据库相关了，但是多少有点联系，也找不到合适的地方就写在这里吧<br><strong>悲观锁：</strong><br>总认为数据会被别人修改，所以就总是给数据加锁，如果持有锁的时间过长，那么用户等待的时间也就越长<br><strong>乐观锁：</strong><br>本质其实是不加锁，但是会在字段的旁边加一个版本记录，读取时获取数值和版本，写入时先检查版本是否一致，如果不一致就重新获取重新计算；<br>这样的话如果冲突很多数据库争用激烈会导致不断的进行重试，反而降低了性能</p>
<p>Java 中的 Sychronized 可以看作是悲观，CAS（Compare and Swap） 操作可以看作是乐观。<code>java.util.concurrent</code> 包中借助 CAS 实现了区别于 synchronouse 同步锁的一种乐观锁<br>关于 CAS 其实还是蛮复杂的，不在深究，等以后如果用到了再看吧，这里给个网址和一点介绍吧</p>
<blockquote>
<p>目前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。<br>CAS 有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做并返回 false。</p>
<p><a href="http://ifeve.com/compare-and-swap/" target="_blank" rel="noopener">http://ifeve.com/compare-and-swap/</a></p>
</blockquote>
<h2 id="匿名内部类-amp-继承"><a href="#匿名内部类-amp-继承" class="headerlink" title="匿名内部类&amp;继承"></a>匿名内部类&amp;继承</h2><p>要使用匿名内部类需要有一个前提条件：<strong>继承某个类或者实现某个接口</strong><br>形式就是在需要某个类对象的时候直接 new 它的父类或者接口，然后去实现或者覆盖某些方法，并且一般需要实现的方法不会超过三个，否则阅读性极差，在回调机制中的用的较多，Android 上应该也有大量使用。<br>特殊的，因为所有的类都继承 object，所以甚至可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"haha"</span>);&#125;</span><br><span class="line">&#125;.show();</span><br></pre></td></tr></table></figure>
<p>但是不能定义一个 Obj 类型的变量去接收（这就相当于隐式的向上转型了），这样里面的方法就没法调了</p>
<hr>
<p>现在我知道了 JVM 在创建子类的时候首先会创建一个父类对象，并且放在子类对象的堆空间里（就是说是子对象的一部分）<br>然后在内存的方法区（分为静态方法区和非静态方法区），将 this 和 super 放在子对象拥有的空间里（和方法在一起），super 指向的就是父对象。<br>父类的 private 方法不能称之为覆盖，因为子类压根不知道有这个方法，称为覆盖不是很合适，就当做是子类的一个普通方法就行了，还有就是构造方法不能覆盖（构造方法和本类名一样，怎么可能覆盖 XD）<br>因为子类在创建时需要先创建父类，如果父类没有空的构造函数，需要在子类的构造函数中的<strong>第一行</strong>手动用 super 指定调用那个构造函数，也能看出一个规律： <strong>this() 和 super() 必须放在第一行</strong></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>先来说说线程的几种状态（还可细分，那就需要 JVM 的知识了）：<strong>创建 、 运行 、 阻塞 、 冻结（睡眠、等待）、 消亡</strong><br>说明一下，阻塞状态是拥有执行资格但是没有执行权；冻结是没有执行资格，也自然没有执行权；运行状态是有执行资格也有执行权（当前正在运行）。</p>
<p>然后就是重要的线程安全问题了，同步函数（函数上加 synchronized）默认使用的锁是 this，但是当函数被静态修饰的时候使用的不再是 this（这时内存中没有本类对象只有本类的字节码对象），用的是 <code>className.class</code> 字节码对象（相当于是某个类的 class 对象，也就是字节码对象），当其他地方需要用这把锁的时候就需要传入 XX.class 了。<br>在单例模式中的懒汉式，如果使用多线程访问就会存在安全性，但是如果将 get 方法加锁会变的低效，比较好的做法就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例对象必须是 volatile 修饰的，保证在多核处理器安全运行</span></span><br><span class="line"><span class="comment">// 详细的原因可参考 二周目计划（二）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XX <span class="title">getXX</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xxx == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(XX.class)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xxx == <span class="keyword">null</span>)&#123;</span><br><span class="line">        xxx = <span class="keyword">new</span> XX();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 get 方法一般是静态的，所以我们使用本类的字节码对象作为锁，并且做双重判断来解决线程安全和同步函数低效的问题，一般还是用饿汉式吧，简单方便；一般来说如果你确定这个对象一定会用到那就肯定用饿汉式</p>
<p>死锁的出现一般是同步的嵌套，但是用的锁（顺序）不同的情况下，并且死锁并不一定会出现，万一和谐了呢….<br>只要是多个线程在处理同一个资源一般就需要进行加锁，不管这几个线程是不是在一个类中，并且还要保证锁是相同的，这才是线程安全的前提。<br>多个线程在操作共享数据的时候（并且是执行同一个方法）可以采用一个标志位来做等待唤醒机制，达到生产者生产一个，消费者消费一个，即使生产者和消费者有多个线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">this</span>.wait();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name + count++;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">      <span class="keyword">try</span>&#123;<span class="keyword">this</span>.wait();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r;</span><br><span class="line">  Producer(Resource r)&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      r.set(<span class="string">"烤鸭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r;</span><br><span class="line">  Consumer(Resource r)&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      r.out();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">    Producer pro = <span class="keyword">new</span> Producer(r);</span><br><span class="line">    Consumer con = <span class="keyword">new</span> Consumer(r);</span><br><span class="line"></span><br><span class="line">    Thread t0 = <span class="keyword">new</span> Thread(pro);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(pro);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(con);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(con);</span><br><span class="line">    t0.start();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 set 和 out 方法上加 synchronized 是为了保证不会出现生产一个消费两次，或者生产两个消费一次的情况。<br>就是说多个线程要参与同一件事就需要在 wait 之前循环判断标记（where，不能用 if），防止某个线程唤醒后直接往下走（此时另一个线程已经重新修改了标记）。<br>但是循环判断标记带来的另一个问题就是可能所有的线程都会一直处于 wait 状态（消费者唤醒的是消费者这种情况），就会出现和死锁差不多的情况，所以要使用 notifyAll。</p>
<p>补充：<code>wait()</code>  、 <code>notify()</code> 这两个方法定义在 Obj 中，<strong>只有锁才能调用这两个方法</strong>，因为任何对象都可以是锁，所以这两个方法就只能定义在 object 中了吧</p>
<h3 id="使用Locks"><a href="#使用Locks" class="headerlink" title="使用Locks"></a>使用Locks</h3><p>上面的是曾经的写法，在 JDK1.5+ 后出现了新的工具，所以说 1.5 真是里程碑式的升级，新的工具在 <code>java.util.concurrent.locks</code> 包下，最重要的就是 Lock 替代了 synchronized 的使用，Condition 替代了 Object 监视器（wait 、notufy）的使用.</p>
<blockquote>
<p>JDK1.5 以后将同步和锁封装成了对象，并将操作锁的隐式方式定义到了该对象中，<strong>将隐式动作变成了显示动作</strong>。<br><strong>Lock 接口：</strong> 替代了同步代码块或者同步函数。将同步的隐式锁操作变成现实锁操作。同时更为灵活。可以<strong>一个锁上加上多组监视器</strong>。<br>lock(): 获取锁。<br>unlock(): 释放锁，通常需要定义 finally 代码块中。<br><strong>Condition接口：</strong>出现替代了 Object 中的 wait 、 notify 、 notifyAll 方法。将这些监视器方法单独进行了封装，变成 Condition 监视器对象。可以与任意锁进行组合。<br>await();<br>signal();<br>signalAll();</p>
</blockquote>
<p>使用新特性改造代码，关键是可以绑定多个监视器，就可以指定唤醒对方的某个线程而不是全部唤醒了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  Lock lock = <span class="keyword">new</span> ReentrantLock();  <span class="comment">// 获取锁</span></span><br><span class="line">  <span class="comment">//通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。</span></span><br><span class="line">  Condition producer_con = lock.newCondition();</span><br><span class="line">  Condition consumer_con = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(flag)</span><br><span class="line">        <span class="keyword">try</span>&#123;producer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.name = name + count++;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者5.0..."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">      flag = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 唤醒对方</span></span><br><span class="line">      consumer_con.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!flag)</span><br><span class="line">        <span class="keyword">try</span>&#123;cousumer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者.5.0......."</span>+<span class="keyword">this</span>.name);</span><br><span class="line">      flag = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 唤醒对方</span></span><br><span class="line">      producer_con.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然可能感觉写法上麻烦了一些，但是这样确实是更清晰了</p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>真正的让线程停下来只有一种方法，那就是 run 方法结束，我们写的 run  方法一般都是循环结构，所以只要控制住循环就能让线程停下来。<br>特殊情况下，线程处于冻结状态（wait 或 sleep）然后没人唤醒的情况下怎么办，不能一直挂在这啊，Thread 类有个方法叫 <strong>interrupt</strong> 方法，作用就是强制唤醒冻结状态的线程，毕竟是强制，所以同时会抛出一个 InterruptedException 异常.<br>可以认为，只要出现了这个异常就说名有人在调用 interrupt 方法，也就是有人想让它停下来，所以直接在 catch  里让自己停下来就行了，比如修改标志</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>简单介绍下什么是守护线程，守护线程在一般情况和用户线程没啥区别，都是在和主线程争夺 CPU ，关键是在结束的时候， <strong>当主线程结束时，守护线程会自动结束，不管有没有执行完</strong> ，有点像依赖关系。<br>设置一个线程为守护线程的方式为（必须要在 start 方法调用之前执行）：<code>t.setDaemon(true)</code> 然后 start 就可以了，然后当程序的线程全是守护线程时，JVM 会自动退出。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>介绍些其他的方法，线程方法还有个 join 方法，作用可以理解为抢夺 CPU 的执行权，例如在主线程执行到了 <code>t1.join();</code> 那么主线程会把执行权让给 t1 ，自己进入<strong>冻结</strong>状态，当 t1 执行完后再恢复执行。<br>设置优先级是：<code>t.setPriority(Thread.MAX_PRIORITY);</code> 优先级就 1-10，其中最明显的 1、5、10 都有常量定义，阅读性好些。<br>当线程执行到 <code>Thread.yield();</code> 时，会自动的交出执行权。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>JavaSE 中重要的一环，现在来复习一下，总体上可分为两类，字节流和字符流<br>字节流的两个基类：InputStream 和 OutputStream<br>字符流的两个基类：Reader 和 Writer<br><strong>它们都是抽象的</strong>，然后一个一个来看。</p>
<hr>
<p>然后除了上面的两大类，还有个桥梁，转换流，如果只有字节流的话就不需要转换了，所以转换流的体系是在字符流中，主要是：InputStreamReader 和 OutputStreamWriter；使用非常的简单，一般直接是扔进字符流的缓冲区包装类就行了，Bufr/Bufw 就都会用了。<br>最佳的测试方法就是用标准输入输出流了，System.in / System.out 它们都属于字节流，为了便于操作一般都将其转换为字符流，这样就用上上面的两个类了。<br>转换流还有一个好用的功能就是可以指定码表，这也许才是本体 2333</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>就以它的一个简单的孩子来看：FileWriter 对象，当它被 new 时会关联一个文件，此时文件会自动创建，如果存在会被覆盖，可通过其他的重载形式传入一个 Boolean（true） 来使用追加模式。<br>为了提高效率，一般都是用缓冲区，Java 提供了两个类来支持缓冲：BufferedWriter、BufferedReader<br>命名也是很有意思的，一般前面是功能描述，后面是所属的类别，比如上面的就是缓冲+字符流，大体就能知道是做什么的了。bufr 最爽的就是能一次读一行了（<strong>返回结果中不包含换行符</strong> ，原理是用数组做缓存，还是一个个读，都存到数组中，遇到回车标记返回整个数组的数据），用的很频繁。<br>调用缓冲区的 close 方法就不需要调用 FileWriter 的 close ，本质上它们是一样的，真正操作文件的还是 fw。<br>缓冲功能的设计其实就是使用了装饰模式，对已有对象的功能进行增强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String data = <span class="string">"xxxxxxxxxxxxx我是数据"</span>;</span><br><span class="line">  FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// true 代表以追加的形式写入，也可以使用一个参数的构造方法（不使用追加）</span></span><br><span class="line">    <span class="comment">// 如果文件不存在此方法会自动创建文件</span></span><br><span class="line">    fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">    fw.write(data);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">"test.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个读取</span></span><br><span class="line">    <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// 自动查码表</span></span><br><span class="line">      System.out.print((<span class="keyword">char</span>)ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用缓冲区</span></span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">      System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JAVA提供的缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriterFileBufr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">    BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      bufw.write(<span class="string">"test + "</span> + i);</span><br><span class="line">      <span class="comment">// 根据系统插入相应的换行</span></span><br><span class="line">      bufw.newLine();</span><br><span class="line">      bufw.flush();  <span class="comment">// 使用缓冲区，记得刷新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadFileBufr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="string">"tesst.txt"</span>);</span><br><span class="line">    BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">    String len;</span><br><span class="line">    <span class="keyword">while</span> ((len = bufr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并不会读取换行符，所以需要手动换行</span></span><br><span class="line">      System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的仅供参考，最基本的 IO 读写文件的写法吧，使用字符流最后记得调用 flush 刷进去，因为它内部必定是有一小块缓存的，保证至少读完一个字符才写（不同的编码所占的空间不同，底层还是使用字节流来读取），并不是都一个写一个，大体就是这么个意思。</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>看过字符流后字节流也基本一致，API 高度相似，最大的区别就是字节流的缓冲数组是 byte 数组，字符流是 char 数组，原因也很好理解<br>单纯使用字节流写入并不需要刷新，字符流中一个中文字符是两个字节（编码不同而不同），所以他必须得先存起来（一个非常小的缓存吧），所以最后需要刷新，字节流没这个问题，可以直接写，毕竟字符流的底层也是用的字节流。<br>下面主要说说字节流缓冲区的使用，其他的和上面基本一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BufferedInputStream bufis = <span class="keyword">null</span>;</span><br><span class="line">  BufferedOutputStream bufos = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    bufis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">    bufos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 先把文件的部分内容读到缓冲区（字节数组），再从缓冲区一个一个的读</span></span><br><span class="line">    <span class="keyword">while</span> ((len = bufis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      bufos.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufis != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bufis.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bufos != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        bufos.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于缓冲区的实现原理，大概的代码可以参考：<a href="https://github.com/bfchengnuo/java_learn" target="_blank" rel="noopener">我的Github</a></p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>class 前面没有加任何的访问修饰符，通常称为“默认访问模式”（<strong>default</strong> ），在该模式下，这个类只能被同一个包中的类访问或引用，这一访问特性又称包访问性。<br>一个 .java 文件可以有多个类，但是只能有一个 public 类, 而且如果有 public 类的话，这个文件的名字要和这个类的名字一样，编译的时候会分开生成多个 class 文件</p>
<p>关于 IO，Java 中有一个 Properties 对象，利用它可以获取系统的“环境变量”，我想表达的就是可以看平台的默认文件编码集设置的是什么，一般中文系统默认是 GBK，所以要想输出其他编码格式的文件不能用 <em>FileWriter</em>，用转换流进行转换才行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = System.getProperties();</span><br><span class="line">prop.list(System.out);</span><br><span class="line"><span class="comment">// new PrintStream("a.txt");</span></span><br></pre></td></tr></table></figure>
<p>在处理异常的时候的那个对象也和 IO 有点关系，可以看看它的 API，封装的还是挺方便的。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fiddler使用介绍]]></title>
      <url>http://bfchengnuo.com/2017/11/18/Fiddler%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>关于 Fiddler 的使用在之前我是看过的，但是今天偶然发现已经差不多全部忘光了，所以呀，还是记录下比较好，意外的发现它的附加的一个功能非常好用，就是排除 UWP 应用在“安全沙箱”运行，让 UWP 应用能够使用系统的代理。<br>关于它的简单介绍：<a id="more"></a></p>
<blockquote>
<p>Fiddler（中文名称：小提琴）是一个HTTP的调试代理，以代理服务器的方式，监听系统的Http网络数据流动，Fiddler可以也可以让你检查所有的HTTP通讯，设置断点，以及Fiddle所有的“进出”的数据（我一般用来抓包）,Fiddler还包含一个简单却功能强大的基于JScript .NET事件脚本子系统，它可以支持众多的HTTP调试任务。</p>
<p>Fiddler 是<strong>以代理WEB服务器的形式工作的</strong>,浏览器与服务器之间通过建立TCP连接以HTTP协议进行通信，浏览器默认通过自己发送HTTP请求到服务器;<br><strong>它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler开启会自动设置代理， 退出的时候它会自动注销代理</strong>，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法可以重新启动下Fiddler</p>
</blockquote>
<p>官方提供了详细的文档和视频教程，如果英语好，可以去参考</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>Fiddler的主界面分为 <strong>工具面板、会话面板、监控面板、状态面板</strong>；应该都看得见在那，都在主页面上<br>下面主要来看看比较复杂的工具面板，从左往右包含：<br>说明注释、重新请求、删除会话、继续执行、流模式/缓冲模式、解码、保留会话、监控指定进程、寻找、保存会话、切图、计时、打开浏览器、清除IE缓存、编码/解码工具、弹出控制监控面板、MSDN、帮助</p>
<p>PS：在新版本增加了对 Win8+ 的 UWP 应用代理支持，就是第一个 <code>WinConfig</code> 在里面可以设置 UWP 应用的白名单，也就是绕过“安全沙箱”可以让其使用代理<br><img src="/image/dev/会话面板图标.png" alt="会话面板图标.png"></p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>上面提到了某个按钮是转换模式的，分为两种：</p>
<ul>
<li><strong>缓冲模式（Buffering Mode）</strong><br>Fiddler直到 HTTP 响应完成时才将数据返回给应用程序。<em>可以控制响应，修改响应数据</em>。但是时序图有时候会出现异常</li>
<li><strong>流模式（Streaming Mode）</strong><br>Fiddler 会即时将 HTTP 响应的数据返回给应用程序。更接近真实浏览器的性能。<em>时序图更准确,但是不能控制响应。</em></li>
</ul>
<p>采用哪种模式看需求吧，默认应该是流模式，更加符合实际情况</p>
<h2 id="监控面板"><a href="#监控面板" class="headerlink" title="监控面板"></a>监控面板</h2><p>这个面板很重要，看的最多的应该就这个了，里面也包含了很多的选项卡，下面就来说说各个选项卡是做什么的</p>
<h3 id="审查（inspectors-）"><a href="#审查（inspectors-）" class="headerlink" title="审查（inspectors ）"></a>审查（inspectors ）</h3><p>指的是 inspectors 选项卡，不要在意前面的翻译<br>类似于 Chrome 的 F12 里的 NetWork，不过应该是更强大，可以对某个请求的头信息、内容、响应进行查看和操作，反正是很强大<br>关键是能修改啊，配合断点简直爽</p>
<h3 id="统计（statistics）"><a href="#统计（statistics）" class="headerlink" title="统计（statistics）"></a>统计（statistics）</h3><p>是的，就是统计一些请求或者其他啥的数据，还有图标显示，主要包含有：</p>
<ol>
<li>请求总数、请求包大小、响应包大小。</li>
<li>请求起始时间、响应结束时间、握手时间、等待时间、路由时间、TCP/IP、传输时间。</li>
<li>HTTP状态码统计。</li>
<li>返回的各种类型数据的大小统计以及饼图展现。</li>
</ol>
<p>当然并不只是这些，数据的描述都是英文，像我这种英语渣渣只能复制到 Google 去翻译下看看什么意思…..</p>
<h3 id="时间轴（Timeline）"><a href="#时间轴（Timeline）" class="headerlink" title="时间轴（Timeline）"></a>时间轴（Timeline）</h3><p>每个网络请求都会经历域名解析、建立连接、发送请求、接受数据等阶段。把多个请求以时间作为 X 轴，用图表的形式展现出来，就形成了瀑布图。<br>在Fiddler中，只要在左侧选中<strong>一些请求</strong>，右侧选择 Timeline 标签，就可以看到这些请求的瀑布图，不同的请求形式会有不同的颜色</p>
<ul>
<li>绿色的请求<br>表示这是一个“有条件的请求”。HTTP 协议定义了 5 个条件请求头部，最常见的两个是“If-Modified-Since”和“If-None-Match”。<br>服务器根据这两个头部来验证本地缓存是否过期，如果过期则正常返回资源的最新版本；否则仅返回 304 Not Modified，浏览器继续使用本地缓存。<br>包含条件请求头部的请求用绿色显示，否则用黑色。</li>
<li>有阴影线的请求<br><strong>它是缓冲模式下的请求，实心的是流模式下的请求</strong>。<br>Fiddler 提供了缓冲（Buffering）和流（Streaming）两种抓包模式：缓冲模式下，Fiddler 会在响应完成时才将数据返回给应用程序（通常是浏览器），这种模式下可以控制响应，方便地修改响应内容；流模式下，Fiddler 会实时返回响应数据给浏览器，但没办法控制响应。<br>一般使用流模式，瀑布图会更真实一些。这两种模式可以通过 Fiddler 的工具栏选择。<br>特别的，<strong>通过 Fiddler 的“AutoResponder”功能返回的响应，只能是缓冲模式</strong>。</li>
<li>请求条的不同颜色对应着不同类型的响应，根据响应头的 MIME Type 来归类。<br>如浅绿色表示图片类型的响应；深绿色是 JavaScript；紫色是 CSS；其它都是蓝色。</li>
<li>请求中的黑色竖线<br>表示的是浏览器收到服务端响应的第一个字节这一时刻。这个时间受 DNS 解析、建立连接、发送请求、等待服务端响应等步骤的影响。</li>
<li>请求条后面的图标表示响应的某些特征<br>如软盘图标表示这个响应正文从本地获得，也就是说服务端返回了 304；<br>闪电表示这是 Fiddler 的“AutoResponder”的响应；<br>向下的箭头表示响应是 302，需要重定向；<br>红色感叹号说明这个请求有错误发生（状态码是 4XX 或 5XX）。<br>特别的，如果请求条后面有一个红色的X，说明服务端响应完这个请求之后，断开了连接。出现这种情况一般有两种可能：HTTP/1.0 的响应中没有 Connection: Keep-Alive；或者是 HTTP/1.1 的响应中包含了 Connection: close。<br>使用持久连接可以省去建立连接的开销，也可以减小 TCP 慢启动和其它拥塞控制机制带来的影响，总之是好处多多。</li>
<li>请求前面的红色圆圈<br>表示这个连接是新建的，绿色表示是复用的。<br>上面的圆圈表示的是浏览器到 Fiddler 的连接，下面的圆圈是 Fiddler 到服务端的连接。</li>
</ul>
<p>时间轴也是分析的时候很重要的一个面板</p>
<h3 id="模拟响应（AutoResponder）"><a href="#模拟响应（AutoResponder）" class="headerlink" title="模拟响应（AutoResponder）"></a>模拟响应（AutoResponder）</h3><p>这是 Fiddler 比较重要且比较强大的功能之一。<strong>可用于拦截某一请求，并重定向到本地的资源</strong>，或者使用Fiddler的内置响应。<br>可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的文件或者得到的是Fiddler的内置响应。<br>因此，如果要调试服务器的某个脚本文件，可以将该脚本拦截到本地，在本地修改完脚本之后，再修改服务器端的内容，这可以保证，尽量在真实的环境下去调试，从而最大限度的减少bug发生的可能性。<br>一般设置步骤为：</p>
<ol>
<li>选中想要拦截的请求，比如 /api/foo</li>
<li>开启模拟（Enable rules）再选择  “Add Rule”</li>
<li>在最下面的下拉框选择 “Create New Response…”</li>
<li>然后 “Save”</li>
</ol>
<p>匹配支持正则，支持常用的重定向方式，这个功能真是一大杀器</p>
<h3 id="模拟请求（Composer）"><a href="#模拟请求（Composer）" class="headerlink" title="模拟请求（Composer）"></a>模拟请求（Composer）</h3><p>老版本的 fiddler 中叫 request-builder. 顾名思义，可以构建相应的请求，有两种常用的方式构建请求:</p>
<ol>
<li>Parsed 输入请求的 url 之后 executed 即可，也可以修改相应的头信息<br>如添加常用的 accept, host, referrer, cookie，cache-control 等头部后再 execute.<br>这个功能的常见应用是：“刷票”（不是火车票！！），如刷新页面的访问量（那啥，不要做为好）</li>
<li>Raw。<br>使用 HTTP 头部信息构建 http 请求。与上类似。不多叙述</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>常用的也就是这几个，还有一个就是 Filter，基本你能想到的基本都支持了，不多说<br>脚本功能应该也很 NB ，但我是没怎么用过，或者可以去找网友写好的脚本使用</p>
<h2 id="状态面板"><a href="#状态面板" class="headerlink" title="状态面板"></a>状态面板</h2><p>这个在软件界面的左下角，还是蛮重要的，控制台Fiddler的左下角有一个命令行工具叫做 QuickExec,允许你直接输入命令（就是那个黑框框）。<br>常见得命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>打开官方的使用页面介绍，所有的命令都会列出来</td>
</tr>
<tr>
<td>cls</td>
<td>清屏 (Ctrl+x 也可以清屏)</td>
</tr>
<tr>
<td>select</td>
<td>选择会话的命令</td>
</tr>
<tr>
<td>?.png</td>
<td>用来选择png后缀的图片</td>
</tr>
<tr>
<td>bpu</td>
<td>截获request</td>
</tr>
<tr>
<td>bpafter</td>
<td>截获response</td>
</tr>
</tbody>
</table>
<p>然后最左边的图标控制拦截的开启和关闭，右边是请求的来源，还有比较重要的就是设置断点了，在请求数的左边有一个空白的位置，它可以点击，有三种状态，每点击一次就切换一种状态：</p>
<ol>
<li>空白：<br>不设置断点。</li>
<li>箭头向上：<br>表示断点请求。此时客户端的请求是无法直接到达目标服务器的，需要手动控制。</li>
<li>箭头向下：<br>表示断点响应。此时目标服务器的响应是无法直接到达客户端的，需要手动控制。</li>
</ol>
<p>断点操作一般就是这几步：</p>
<ol>
<li>设置断点请求，手机端访问接口</li>
<li>点击对应的会话</li>
<li>查看请求报文信息</li>
<li>修改请求内容</li>
<li>完成断点，放行，把该请求发送给目标服务器。</li>
</ol>
<p>对应这幅图：<br><img src="/image/dev/fiddler.png" alt="fiddler.png"></p>
<p>修改的时候留意下超时时间就行了<br>上面的操作其实都可以通过命令行来完成</p>
<h2 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h2><p>常用的功能还有抓 HTTPS 的包、移动端抓包等，等想到更多了再来补充</p>
<h3 id="抓取-HTTPS"><a href="#抓取-HTTPS" class="headerlink" title="抓取 HTTPS"></a>抓取 HTTPS</h3><p>Fiddler不仅能监听HTTP请求而且默认情况下也能捕获到HTTPS请求，<code>Tool -&gt; Options... -&gt; HTTPS</code> 下面进行设置，勾选上 <strong>“Decrypt HTTPS traffic”</strong><br>还可以选择忽略证书错误（建议勾上）和忽略指定的 HOST 地址</p>
<h3 id="移动端抓包"><a href="#移动端抓包" class="headerlink" title="移动端抓包"></a>移动端抓包</h3><p>Fiddler 不但能截获各种浏览器发出的HTTP请求, 也可以截获各种智能手机发出的HTTP/HTTPS请求。<br>前提条件是：安装Fiddler的机器，跟设备在同一个网络里， 否则不能把 HTTP 发送到安装 Fiddler 的机器上来。</p>
<p>具体的设置步骤为（以 iPhone 为例）：</p>
<ol>
<li>打开 Fiddler,选择 Tools-&gt; Options。（配置完后记得要重启Fiddler）.</li>
<li>选中Connections 选项卡下的 “Allow remote computers to connect”. 是允许别的机器把 HTTP/HTTPS 请求发送到 Fiddler 上来</li>
<li>查看 Fiddler 所在机器的 IP（可通过 ipconfig 命令）</li>
<li>安装 Fiddler 证书<br>这一步是为了让 Fiddler 能捕获HTTPS请求。 如果你只需要截获 HTTP 请求， 可以忽略这一步<br>首先要知道 Fiddler 所在的机器的IP地址，假如我安装了 Fiddler 的机器的IP地址是:192.168.1.104；打开IPhone 的Safari, 访问 <a href="http://192.168.1.104:8888，" target="_blank" rel="noopener">http://192.168.1.104:8888，</a> 点 “FiddlerRoot certificate”  然后安装证书</li>
<li>打开iPhone, 找到你的网络连接， 打开HTTP代理， 输入 Fiddler 所在机器的 IP 地址以及 Fiddler 的端口号8888</li>
</ol>
<p>现在 Fiddler 就可以获取到移动设备的数据请求了</p>
<h2 id="关于Wireshark"><a href="#关于Wireshark" class="headerlink" title="关于Wireshark"></a>关于Wireshark</h2><p>Wireshark 是另外一种抓包工具，这种工具比 fiddler 更强大，消息量更多，开源，支持更多的协议。<br>这里说下，在测试中，发现用 fiddler 抓包，有些包是没有抓到的，比如在验证反作弊信息的时候，反作弊pingback 信息的消息用 fiddler 就没抓到，用 wireshark 就抓到了。</p>
<blockquote>
<p>Wireshark 使用 WinPCAP 作为接口，直接与网卡进行数据报文交换，注重的是网络封包分析<br>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。<br>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包<br>Fiddler 更注重的是 HTTP 协议调试方面</p>
</blockquote>
<p>Wireshark 配置起来比 fiddler 麻烦一些，学习门槛相对来说比较高，有机会再来学一学。<br>其他的抓包工具还有 tcpdump 可以理解为没有界面的 Wireshark  在 Linux 上用的比较多<br>Wireshark 能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结：<strong>如果是处理 HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP 就用wireshark.</strong></p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>还记得被广泛用于游戏外挂的 WPE 三件套（Winsock Packet Editor、Easy2Game、CCProxy），就是因为可以修改、发送封包，配合代理简直就…..<br>好孩子就不要研究了，也不简单。<br>可参考：<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E6%93%9A%E5%8C%85%E5%88%86%E6%9E%90%E5%99%A8" target="_blank" rel="noopener">Wiki 上的一些介绍</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/99b6b4cd273c" target="_blank" rel="noopener">http://www.jianshu.com/p/99b6b4cd273c</a><br><a href="https://segmentfault.com/a/1190000004240812" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004240812</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Fiddler </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java消息中间件]]></title>
      <url>http://bfchengnuo.com/2017/11/16/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>学习这个的契机是在做练手项目的时候用到了兔子（RabbitMQ），它遵循 AMQP 协议，属于消息中间件实现的一种，既然这样就来看看什么是消息中间件。<br>正好看到慕课网有相关的课程就顺便学习下吧，为什么使用消息中间件？<a id="more"></a><br>解耦、异步、横向扩展、安全可靠、顺序保证，这些还不够么，回想 Rabbit 官网的那几幅图吧<br>如果忘记了就再看看吧：<a href="https://github.com/bfchengnuo/java_learn/blob/master/ExampleCode/rabbitmq/Readme.md" target="_blank" rel="noopener">飞机</a></p>
<h2 id="关于JMS"><a href="#关于JMS" class="headerlink" title="关于JMS"></a>关于JMS</h2><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个 Java 平台中关于面向消息中间件（MOM）的 <strong>API</strong>，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>
<p>JSM 的组成有：</p>
<ul>
<li>JMS提供者<br>连接面向消息中间件的，JMS接口的一个实现。提供者可以是Java平台的JMS实现，也可以是非Java平台的面向消息中间件的适配器。</li>
</ul>
<ul>
<li>JMS客户<br>生产或消费消息的基于Java的应用程序或对象。</li>
</ul>
<ul>
<li>JMS生产者<br>创建并发送消息的JMS客户。</li>
</ul>
<ul>
<li>JMS消费者<br>接收消息的JMS客户。</li>
</ul>
<ul>
<li>JMS消息<br>包括可以在JMS客户之间传递的数据的对象</li>
</ul>
<ul>
<li>JMS队列<br>一个容纳那些被发送的等待阅读的消息的区域。队列暗示，这些消息将按照顺序发送。一旦一个消息被阅读，该消息将被从队列中移走。</li>
</ul>
<ul>
<li><p>JMS主题</p>
<p>一种支持发送消息给多个订阅者的机制。</p>
</li>
</ul>
<p>Java 消息服务应用程序结构支持两种模型：</p>
<ol>
<li><strong>点对点或队列模型</strong><br>包含生产者和消费者，队列中的消息只能被一个消费者消费，消费者可以随时消费消息<br>每一个连接都依次平均分担消息队列中的消息（即使一个应用建立了两个连接）</li>
<li><strong>发布/订阅模型</strong><br>包括发布者和订阅者，主题中的消息会被所有的订阅者消费，消费者不能消费在订阅之前的消息<br>每一个连接都会收到主题中完整的消息</li>
</ol>
<p>关于架构等详细信息可参考 wiki ：<br><a href="https://zh.wikipedia.org/wiki/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Java%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1</a></p>
<h2 id="中间件-amp-AMQP"><a href="#中间件-amp-AMQP" class="headerlink" title="中间件&amp;AMQP"></a>中间件&amp;AMQP</h2><p>中间件（英语：Middleware），是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。<br>如数据库、Apache的Tomcat，IBM公司的WebSphere,BEA公司的WebLogic应用服务器，东方通公司的Tong系列中间件，以及Kingdee公司的等都属于中间件。<br>或者简单说就是：非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给用户带来价值的软件统称为中间件</p>
<hr>
<p>高级消息队列协议（AMQP）是一个异步消息传递所使用的应用层<strong>协议</strong>规范。<br>作为线路层协议，而不是 API（例如 JMS），AMQP 客户端能够无视消息的来源任意发送和接受信息。现在，已经有相当一部分不同平台的服务器和客户端可以投入使用。</p>
<p>注意：JMS 是规范（针对 Java），AMQP 是协议</p>
<p>然后来张图来比较，JMS 和 AMQP：<br><img src="/image/dev/JMS&amp;AMQP.png" alt=""></p>
<p>然后是市面上常见的一些 MQ 方案：<br><img src="/image/dev/MQ.png" alt="MQ.png"></p>
<h2 id="ActiveMQ使用"><a href="#ActiveMQ使用" class="headerlink" title="ActiveMQ使用"></a>ActiveMQ使用</h2><p>导入依赖就不用多说了，下面的 Java 代码中的使用（以主题订阅模式为例），先来消息发布者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"topic-test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建 ConnectionFactory</span></span><br><span class="line">  ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建连接</span></span><br><span class="line">  Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.启动连接</span></span><br><span class="line">  connection.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.创建会话</span></span><br><span class="line">  <span class="comment">// 第一个参数是是否在事务中，第二个是自动提交</span></span><br><span class="line">  Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.创建一个目标(只需要修改这里)</span></span><br><span class="line">  Destination destination = session.createTopic(TOPIC_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.创建一个生产者</span></span><br><span class="line">  MessageProducer producer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.创建消息/发送消息</span></span><br><span class="line">  TextMessage message = session.createTextMessage(<span class="string">"testMessage"</span>);</span><br><span class="line">  producer.send(message);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8.关闭连接</span></span><br><span class="line">  connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是消息订阅者，在此模式下订阅之前发的消息是没法接收到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"tcp://127.0.0.1:61616"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"topic-test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建 ConnectionFactory</span></span><br><span class="line">  ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建连接</span></span><br><span class="line">  Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.启动连接</span></span><br><span class="line">  connection.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.创建会话</span></span><br><span class="line">  <span class="comment">// 第一个参数是是否在事务中，第二个是自动提交</span></span><br><span class="line">  Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.创建一个目标</span></span><br><span class="line">  Destination destination = session.createTopic(TOPIC_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.创建一个消费者</span></span><br><span class="line">  MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.创建监听器（异步监听）</span></span><br><span class="line">  consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">      TextMessage msg = (TextMessage) message;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(msg.getText());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9.关闭连接(监听器异步，应该在程序退出时关闭)</span></span><br><span class="line">  <span class="comment">// connection.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且接收消息的过程是异步的，所以不要马上 close；<br>完整的代码见 <a href="https://github.com/bfchengnuo/java_learn/tree/master/ExampleCode" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="关于集群"><a href="#关于集群" class="headerlink" title="关于集群"></a>关于集群</h2><p>集群总的来说就是为了实现高可用和负载均衡，以 ActiveMQ 为例，集群不只是在服务器端配置，客户端也需要支持；在ActiveMQ 中提供了失效转移的支持，URL 类似于：<br><code>failover:(tcp://127.0.0.1:61617,tcp://192.168.1.11:61617)?randomize=true</code><br>在服务器方面，想要实现负载均衡就要保证服务器之间的消息同步，采用的是 “网络连接器”的方式，用于服务器的透传消息，分为静态连接器和动态连接器（用网址来代替写死的 IP 地址）。<br>对于高可用服务器的方案一般有两种：</p>
<ul>
<li>共享存储集群<br>采用集群共享一份持久化数据（使用 NAS 或者 JDBC），服务器获取排它锁来独占资源的方式，当此服务器宕机时会释放（配合客户的的失效转移机制）备用服务器会获取锁成为新的 Master</li>
<li>基于复制的 LeveIDB Store<br>至少需要三台来保证稳定性，还用到了 ZooKeeper（ZK 本身也需要三台来保证自己的稳定性）<br>也就是 Master 由 ZK 来选举，然后通过 ZK 来实现各服务器之间的消息同步</li>
</ul>
<p>他们能达到高可用，但是实现不了负载均衡，想要同时实现就需要进行一些改造。<br>还有一些其他的问题解决方案：<br>实现每个系统消费各自的消息可以使用 ActiveMQ 提供的虚拟主题功能；<br>解决消息发送的一致性问题可以使用 JMS 中的 XA 系列接口；<br>解决幂等性的问题，方案和上面一样，使用本地事务或者内存日志</p>
<blockquote>
<p>JMS 中的 XA 协议常用于分布式事务，因为效率较低所以不太使用，或者还可以使用本地事务、内存日志解决（都要配合消息补偿机制）<br>解决这些问题一般分段考虑比较好。</p>
<p>幂等性就是指处理一次和多次的消息最终的效果是一样的。<br>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用</p>
</blockquote>
<p>为了解决代码过于复杂和复用，可以使用“基于消息机制的事件总线”，简单说 EDA （事件驱动架构）就是：有事你叫我，没事别烦我，这样一般就需要先在事件总线上注册，事件总线一般还需要包含消息提供者（各种 MQ 的实现）。<br>可以尝试<strong>面向服务的架构</strong></p>
<h2 id="Spring集成"><a href="#Spring集成" class="headerlink" title="Spring集成"></a>Spring集成</h2><p>主要涉及的有：<br><strong>ConnectionFactory</strong>：用于管理连接的连接工厂；Spring 提供了两个具体的类，SingleConnectionFactory 和 CachingConnectionFactory ，后者是带有缓存功能的。<br><strong>JmsTemplate</strong>：用于发送和接收消息的模板类，它是线程安全的<br><strong>MessageListerner</strong>：消息监听器<br>使用时记得引入 Spring-jms 依赖，具体的相关依赖有：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Java JMS 原生API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.jms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.jms-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-jms API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- active-mq核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是在 Spring 的配置文件中进行配置 Bean 了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接ActiveMQ的ConnectionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"amqConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:brokerURL</span>=<span class="string">"tcp://localhost:61616"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--为了提高效率，配置一个连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cachedConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.CachingConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:targetConnectionFactory-ref</span>=<span class="string">"amqConnectionFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:sessionCacheSize</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置队列--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"destination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"$&#123;queue.name&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置主题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"destinationTopic"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"$&#123;topic.name&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- **************配置消息生产者************* --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--点对点模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueJmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--消息持久--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deliveryPersistent"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--发布/订阅模型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicJmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--消息持久--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deliveryPersistent"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--目的地--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultDestination"</span> <span class="attr">ref</span>=<span class="string">"destinationTopic"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--订阅模型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pubSubDomain"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- **************配置消息消费者************* --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置消息队列监听者（Queue） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueMessageListener"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.Filter.QueueMessageListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听器是上面定义的监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueListenerContainer"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"cachedConnectionFactory"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"destination"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"queueMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>消费者和生产者的配置最好是分开来放，可以抽取相同的配置到独立的文件再利用 include 导入<br>Java 代码的使用，也分为两个角色，写在一起了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收消息，记得配置到 IOC 容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TextMessage textMessage = (TextMessage) message;</span><br><span class="line">      System.out.println(<span class="string">"MyQueueMessageListener收到消息："</span> + textMessage.getText());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息 Destination 已注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">// String destination = jmsTemplate.getDefaultDestinationName();</span></span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">" 向队列"</span>+destination+<span class="string">"发送消息---&gt;"</span>+msg);</span><br><span class="line">  jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> session.createTextMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用时记得把它们给分开，更改模式只需要在 Destination 注入的时候选择合适的模式即可，其他的地方不需要修改</p>
<p>更多内容：<br><a href="https://my.oschina.net/thinwonton/blog/889805" target="_blank" rel="noopener">https://my.oschina.net/thinwonton/blog/889805</a><br><a href="http://www.cnblogs.com/jaycekon/p/ActiveMq.html" target="_blank" rel="noopener">http://www.cnblogs.com/jaycekon/p/ActiveMq.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JMS </tag>
            
            <tag> ActiveMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Oracle学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/11/12/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>关于 Oracle 这个数据库就不需要做什么解释了，名声那么大，<del>怎么还不死</del>都懂得，就是死贵死贵的，还是要学一学，因为企业用的还是挺多的。<br>然后来看一下关于它的一些基本介绍，<strong>默认端口为 1521</strong> 一般固定不用改，数据库的数据文件是 DBF 结尾。<br>版本有三个，结尾分别为 i（internet）、g（grid）、c（clound）；对应早期、近期、现在；<a id="more"></a><br>早期的就不说了，一般没人用了，现在基本用的都是 g 系列，c 系列太贵了是融合了云计算服务器，一般用 g 就够了，g 表示的网格可以简单理解为是一个集群，将多台 Oracle 服务器当做一台主机协调使用</p>
<h2 id="关于SQL"><a href="#关于SQL" class="headerlink" title="关于SQL"></a>关于SQL</h2><p>准备知识，SQL92/99 标准的四大分类：</p>
<ul>
<li>DML（数据操纵语言）：<br>select,insert,update,delete  </li>
<li>DDL（数据定义语言）：<br>create table,alter table，drop table，truncate table  </li>
<li>DCL（数据控制语言）：<br>grant 权限 to scott，revoke 权限 from scott  </li>
<li>TCL（事务控制语言）：<br>commit，rollback，rollback to savepoint</li>
</ul>
<p>SQL92/99 标准，可以说是访问任何关系型数据库的标准，基本所有的数据库都或多或少的支持;<br>有些地方会把 DML 再拆分，将查询独立出来形成 DQL（数据查询语言）</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装就不说了，一搜一大把，卸载也有，Oracle 的卸载挺麻烦的，官方给的卸载工具是基本没人用，因为本身无法删除；<br>一般我们把它称作是 Oracle 数据库服务器，听到这个名字其实指的就是平常说的数据库，但是下面我为了省劲直接说 Oracle 了<br>然后就是 Oracle 其实包括两大部分，<strong>实例和数据库</strong>，并且必须通过实例才能操作数据库（SQL 语句是通过实例执行的），数据库可以理解为类，看得见的，比如前面的 DBF 文件，实例理解为对象，是看不见的。<br>一个数据库就是一个目录，可在安装目录下的 oradata 文件夹下查看，Oracle 创建、删除数据库是非常复杂的，需要专门的工具，经过大约 12 步才能搞定。<br>连接 Oracle 可以使用自带的 sqlplus (命令行，需要配环境变量)和 sqldeveloper，或者使用第三方的 PLSQL</p>
<hr>
<p>安装完成后会创建一个超级管理员，用户名：sys，角色：dba；<br>Oracle 可以使用账号密码登录也可以使用用户和角色登录；<br>常用的普通用户还有 scott 和 hr，默认都是被锁的，注：从 12c 版本开始 scott 就没了（这其实是最早进入 Oracle 的员工的名字）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  斜线前后：username/pwd，或者用角色登录：</span></span><br><span class="line">&gt; sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">account</span> <span class="keyword">unlock</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> tiger;</span><br><span class="line"></span><br><span class="line">&gt; sqlplus scott/tiger</span><br><span class="line"><span class="comment">-- or sqlplus</span></span><br></pre></td></tr></table></figure>
<p>上面就是一些安装后基础的设置了</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>查看当前用户：<code>show user;</code><br>查询当前用户下所有的对象(tab 表每个用户都有)：<code>select * from tab;</code><br>执行最近一次命令（专有）：<code>/</code><br>查询表结构：<code>desc tName;</code><br>条件查询（其中一种，(不)包括12与18）：<code>select * from users where age (not)between 12 and 18;</code><br>包含关系：<code>select * from users where age (not)in (8,12);</code></p>
<p>查询不重复的内容关键字一样是 distinct ，记住了。<br>Oracle 中有一张叫 dual 的表，称之为哑表或者伪表，只会返回一行数据（比如查询日期：<code>select sysdate from dual</code> ，返回的格式反正很恶心）。<br>单引号一般用于日期和字符串（字符串），双引号一般用于给列设置别名（常量），字符串与字段可以使用 <code>||</code> 来拼接。<br>可以适用 <code>spool d:/aa.sql</code> 命令开启“日志记录”，最后执行 <code>spool off;</code> 这样期间执行的 sql 和结果都会保存到这个文件；与之对应的是读取 sql 文件执行命令：<code>@ d:/a.sql;</code> 。<br>适用条件查询不等于某个数可以使用 <code>a != 30</code> 也可以使用 <code>a &lt;&gt; 30</code> ；然后 Oracle 中的 where 好像是从右往左进行判断，MySQL 的企业版好像也是（关于效率，现在的版本会自动优化，先去识别筛选最有利的条件）。<br>占位符和 MySQL 是一样的，下划线表示一个，百分号表示零或者多个，需要查询下划线的用转义：<code>like &#39;abc\_&#39; escape &#39;\&#39; ;</code><br>判断字段是否为 null 只能使用 <code>is (not) null</code> ，它不能参与精确比较，null 可以是任何类型，并且在排序的时候把 null 看做为最大的值；not  最好不要常用，能用其他代替的就不用，会影响效率。</p>
<blockquote>
<p>格式化日期显示可以设置下环境变量：nls_date_format=YYYY-MM-DD HH24:MI:SS</p>
</blockquote>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>并不保证在其他的数据库也能适用…..<br>函数分为两类，单行函数（一进一出）和多行函数（多进一出），也就是传入参数个数的问题；<br>用到了去查 API 也可以</p>
<ul>
<li><p>NVL<br>用法：NVL(a,b)，如果 a 为 null 就返回 b，如果 a 不为 null 就返回 a</p>
</li>
<li><p>NVL2<br>用法：NVL2(a,b,c) ，如果 a <strong>不为</strong> null 则返回 b ，否则取 c</p>
</li>
<li><p>NULLIF<br>用法：NULLIF(a, b) ，在类型一致的情况下，如果 a 和 b 相同则返回 null ，否则返回 a</p>
</li>
<li><p>case…end 表达式<br>SQL 99 标准里的所以 Mysql 也是支持的，用法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, age,</span><br><span class="line">  <span class="keyword">case</span> age</span><br><span class="line">    <span class="keyword">when</span> <span class="number">12</span> <span class="keyword">then</span> age+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> age+<span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span> <span class="string">"测试"</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>;</span><br><span class="line"></span><br><span class="line">case 字段</span><br><span class="line">  when 条件1 then 表达式1</span><br><span class="line">  else 表达式2</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个…..我倒是真没用过，<strong>这个主要是用于显示，并不会进行写入</strong></p>
</li>
<li><p>decode<br>这个函数就是优化了上面的 case 表达式，是 Oracle 专用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, age,</span><br><span class="line">  <span class="keyword">decode</span>(age,<span class="number">12</span>,age+<span class="number">1</span>,age+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>
<p>也就是说，decode 的第一个参数是字段最后一个是 else 的表达式，中间可以拼多个 when</p>
</li>
</ul>
<h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><p>常用的有：<strong>lower / upper / initcap</strong> ；分别对应为转小写、转大写、首字母大写；<br><code>select upper(&#39;aaaabv&#39;) from dual;</code><br>截取字符串使用 <strong>substr</strong> 函数，两个参数为：从第几个开始取（从 1 开始），取几个；<br>计算长度用 <strong>length</strong> 或 <strong>lengthb</strong> 分别为字符和字节数，字节就和编码有关了；<br>查找某个字符首次出现的位置 <strong>instr(‘hello’, ‘h’)</strong> ，返回的坐标是从 1 开始，找不到返回 0 。<br><code>select trim(&#39;o&#39; from &#39;ooabcodoo&#39;) from dual;</code> ：去掉两边的指定字符。<br><code>select replace(&#39;abcd&#39;,&#39;a&#39;,&#39;t&#39;) from dual;</code> ：把 abcd 中的 a 替换为 t。<br>对数字的处理常用的有 <strong>round / trunc / mod</strong> 分别对应四舍五入、截取、取余(相当于n1/n2)，需要传入两个参数，第二个是精度，前两个可以用在日期类型上，并且日期是可以直接进行简单的四则运算的（sysdate + 1 就是加一天）。<br>对日期处理的函数有 <strong>add_months / next_day / last_day</strong>(最后一天) ，日期的运算是可以负数，就是前一天或者上一个月了</p>
<h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><p>最常见的多行函数就是 count(*) 了吧（这是SQL查行数的标准，内部会优化），<del>因为会扫描所有字段，这也是不推荐用的原因，还不如用 count(1)</del>，或者用主键，还可以使用类似 <code>count(distinct dep)</code> ；<br>max / min / sum / avg 这些就更不用说了，常用的，不要忘了使用分组：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno <span class="string">"部门编号"</span> ,trunc(<span class="keyword">avg</span>(sal), <span class="number">0</span>) <span class="string">"部门平均工资"</span></span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">having</span> trunc(<span class="keyword">avg</span>(sal), <span class="number">0</span>) &gt; <span class="number">2000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>也是复习下 SQL，虽然和多行函数关系不是很大，记得 order 是放在最后的，因为 where 是先执行而 having 是后执行，所以能用 where 就用 where，避免查询不必要的数据；<br><strong>如果使用 order by ，那么 select 中的字段必须出现在 order by 中，但是反过来在 order by 中出现的不一定要在 select 中</strong></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>隐式的转换自然就不需要说了，关键是显式的转换</p>
<ul>
<li>日期转字符串<br>示例：<code>select to_char(sysdate, &#39;yyyy&quot;年&quot;mm dd  day hh24:mi:ss&#39;) from dual;</code> 不区分大小写</li>
<li>数值转字符串<br>示例（比如货币）：<code>select to_char(1234, &#39;L9,999&#39;) from dual;</code> ，9 表示的是数字</li>
<li>字符串转日期<br>和上面差不多，就是倒过来使用：<code>select to_char(&#39;2017-11-06&#39;, &#39;yyyy-mm-dd&#39;) from dual;</code></li>
</ul>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>最简单的笛卡尔集表（列数之和，行数之积，其中很多数据都是不合理的）：<br><code>select * from emp,dept;</code><br>其实这种方式在 SQL 标准中叫做<strong>交叉连接（CROSS JOIN）</strong> ，标准的语法是：<code>SELECT * FROM emp CROSS JOIN dept;</code>。</p>
<p>还有就是子查询，那个和 MySQL 基本一致就不多说了，可以用在 select 后也可以用在 where 后，非常的灵活；关于连接：</p>
<ul>
<li>内连接查询<br>只能查询出符合条件的记录（<strong>使用 where 对笛卡尔表进行过滤</strong>）</li>
<li>外链接查询<br>既能查询出符合条件的记录，也能根据一方强行将另一方查询出来<br>特别的提一下全（外）连接：<code>FULL OUTER JOIN…ON;</code> –&gt; 把两张表中没有的数据都显示</li>
</ul>
<p>然后就来看看左外连接/右外连接吧，下面的这个方法是 Oracle 专用，总结一下就是：那边的数据少就在那边写 <code>(+)</code> 但是只能写在最后，从命名上，如果左边的数据多就叫左外连接….<br>按照这个规则，那么可以总结为：</p>
<ul>
<li>(+)=：放在了等号的左边，表示的是右连接；</li>
<li>=(+)：放在了等号的右边，表示的是左连接；</li>
</ul>
<p>其实并不需要刻意的区分左和右，根据查询的结果如果发现有些需要的数据没有显示出来，就使用此符号更改连接方向就行了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept.deptno <span class="string">"部门号"</span> , dept.dname <span class="string">"部门名"</span>, <span class="keyword">count</span>(emp.empno) <span class="string">"人数"</span></span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> emp.deptno(+) = dept.deptno</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept.deptno, dept.dname;</span><br></pre></td></tr></table></figure>
<p>然后就是比较难的自连接，只要设置好别名，一切都不是问题。<br>涉及到子查询的，又分为两类：</p>
<ul>
<li>单行子查询<br>子查询只会返回一个结果，父查询使用 = 、&lt;&gt;、&gt;=、&lt;= 来连接</li>
<li>多行子查询<br>子查询会返回多个结果，父查询使用 in、any、all 这些符号来比较</li>
</ul>
<p>平时尽可能的使用多表查询（最终是查的一张笛卡尔表），效率相对子查询高一些，但是总的来说 <strong>多表查询的性能肯定不高</strong></p>
<p>更多参考：<a href="https://www.cnblogs.com/mchina/archive/2012/09/07/2651568.html" target="_blank" rel="noopener">https://www.cnblogs.com/mchina/archive/2012/09/07/2651568.html</a></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>首先，确定下他们之间的优先级：<br>from 优先级最高；然后是 where 的优先级次之，group by 的优先级仅次于 where；having 紧随 group by 之后；<br>order by 写在最后的，优先级是最低的；select 的优先级仅仅是高于 order by。<br>对于进行连接查询的，首先进行连接然后再对结果进行 where 过滤，所以在连接之前尽量使用 ON 后的条件进行筛选。</p>
<p>having 的效率极低，能不用就别用，前面尽量用 where 筛选好。</p>
<p>因为 in 的效率低，所以用 exists 代替；in 的效率低是因为需要对后面的内容进行一一匹配，当然 exists 并不是完全能替代 in，只是尽量少使用 in（not in）：<br><code>select * from school s where exists (select * from student st where st.sid = s.id);</code></p>
<hr>
<p>什么时候使用多表连接？什么时候子查询？</p>
<ul>
<li>如果需要查询的数据在多个表中，一定要使用多表连接</li>
<li>不需要表 A 中的列，但是又有该表 A 的条件，可以用子查询</li>
<li>子查询中如果使用了 in、some any、all 这几个关键字，效率比较低，可以考虑转换成多表关联的方式</li>
</ul>
<hr>
<p>稍微总结一下就是：</p>
<ul>
<li>建议不用 <code>*</code> 来代替所有列名</li>
<li>用 truncate 代替 delete</li>
<li>在确保语句完整性的情况下多用 commit 语句（用在 begin..end 中）</li>
<li>尽量减少表的查询次数（少用子查询）</li>
<li>用 not exists 代替 not in</li>
<li><del>表连接时，把能过滤多数据的连接放在右边，执行方式是先 ON 后 where，从右往左执行</del>（新版会自动识别，并不需要刻意排序）</li>
<li>合理使用索引</li>
<li>sql 语句尽量用大写的，oracle 总是先解析 sql 语句，把小写的转换成大写的在执行</li>
<li>连接多个表时尽量使用表的别名，减少解析时间</li>
<li>优化 group by，将不需要的记录在 group by 之前过滤掉</li>
</ul>
<p>SQL 的效率查询，也就是慢查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EXECUTIONS,DISK_READS,BUFFER_GETS, </span><br><span class="line">     <span class="keyword">ROUND</span>((BUFFER_GETS-DISK_READS)/BUFFER_GETS,<span class="number">2</span>) HIT_RADIO,</span><br><span class="line">     <span class="keyword">ROUND</span>(DISK_READS/EXECUTIONS,<span class="number">2</span>) Reads_per_run,SQL_TEXT </span><br><span class="line"><span class="keyword">FROM</span> V$SQLAREA </span><br><span class="line"><span class="keyword">WHERE</span> EXECUTIONS &gt; <span class="number">0</span> <span class="keyword">AND</span> BUFFER_GETS &gt; <span class="number">0</span> </span><br><span class="line"><span class="keyword">AND</span> (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; <span class="number">0.8</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">4</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>Mysql 中也有类似的命令，通过这个来排除那些执行慢的 SQL。</p>
<h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>关键字：<br>并集：union（只取相交部分的一个）、union all (相交部分的全部，即使重复)<br>交集：intersect<br>差集：minus（在第一个并且不在第二个中的）<br>这些关键字是用在两条查询语句中的，也就是连接两条 select 语句的。<br>需要注意的有：</p>
<ul>
<li>集合操作时，必须保证集合的列数是相等的</li>
<li>集合操作时，必须保证集合的列类型是对应相等的</li>
<li>多个集合操作时，结果的列名由前一个集合决定</li>
<li>A UNION B UNION C = C UNION B UNION A</li>
</ul>
<p>从选择来说，优先级：多表查询 –&gt; 子查询 –&gt; 集合查询</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在 Oracle 中没有 limit 关键字，分页还是蛮复杂的；<br>说到这里就得说 Oracle 中的关键字（隐藏列） rownum，它可以当做一个字段写在 select 语句中，与表同存在，并且是一直递增（在一次的查询中，从 1 开始），是 number 类型，能参与运算；<br>需要注意的是 &gt; 、 &gt;= 、 = 都是无值的（0 除外，<code>&gt;=1</code> 也可以），因为 rownum 是随着记录变化的，后面的可能是无限，无法确定的就返回空，并且 <code>&lt;&gt;</code> 和 &lt; 是一样的。<strong>也就是说它只能参与小于或者小于等于的运算</strong>。<br>使用子查询进行分页(查询 2-8 的记录)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xx.*</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">id</span> ,emp.* <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">rownum</span> &lt;= <span class="number">8</span>) xx</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>注意：子查询中加别名不能使用双引号了。</p>
<blockquote>
<p>分页查询中，不要直接使用 order by 进行排序，这样会打乱 rownum 的顺序，如果确实需要按照某个字段来排序，那么只能使用嵌套子查询，比如：<br><code>select rownum,a.* from (select rownum rn,name from (select * from test order by name) where rownum&lt;=30) a where rn&gt;=21;</code></p>
</blockquote>
<p>PS：还有一个隐藏列是 rowid ，它映射每一行数据物理地址的唯一标识，通常适用于删除完全重复的数据。<br>例如：<code>delete from lyric where rowid not in (select min(rowid) from lyric group by content);</code></p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>基本和 MySQL 保持一致吧，或许是 SQL99 的标准吧；<br>参考其他表结构来创建表，但是不要数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> back_emp <span class="keyword">where</span> <span class="number">1</span> &lt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>其他的有批量从其他表插入数据的，当然要保证列的类型能对应才行，都写在下面吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> back_emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选择添加</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>) </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> back_emp;</span><br></pre></td></tr></table></figure>
<p>基本都是一个套路，差不多的</p>
<h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>事务的开始不需要手动执行某条语句（MySQL 是 start transaction），它默认是从第一条 DML 操作（增删改查）作为事务的开始。<br>提交就是直接输入 commit ，回滚就是 rollback 都一样的了。<br>关于事务的提交，除了使用上面的显式 commit，还可以是 DDL/DCL/exit（sqlplus 工具） 语句，也就是说当你执行一条 DDL 语句默认会先进行事务提交。<br>同样也是有隐式回滚的，当关闭窗口、死机、停电等情况时就会进行自动的回滚。</p>
<p>下面就是回滚点的知识了，让我们能回滚到一个事务中的指定位置，看个栗子就知道了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">savepoint</span> a; <span class="comment">-- 设置回滚点</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> a;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>回滚点多了也不好，起码会占用空间啊，MySQL 也是一样的；<br>隔离级别我就不说了，前面说过，Oracle 只支持两个</p>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>介绍常用的表修改操作，比如修改表名、增加字段啥的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如何修改已经创建的表名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">to</span> teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 增加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> email varchar2(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 修改字段名</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">column</span> email <span class="keyword">to</span> yx;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 修改字段数据类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">name</span> varchar2(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 删除字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> yx;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表以后 删除表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure>
<p>关系比较中 <code>&lt;&gt;</code> 是标准语法，可以移植到其他任何平台，!= 是非标准语法，可移植性差。</p>
<h2 id="约束相关"><a href="#约束相关" class="headerlink" title="约束相关"></a>约束相关</h2><p>最简单的，约束可以分为这几类：<br>非空：not null<br>唯一：unique<br>检查：check<br>外键约束：foreign key  （references）<br>主键约束：primary key<br>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">class</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">3</span>) primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  qq varchar2(<span class="number">20</span>) <span class="keyword">check</span>(<span class="keyword">length</span>(qq)&gt;=<span class="number">8</span>),</span><br><span class="line">  tid <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">references</span> teacher(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何添加约束：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> <span class="keyword">constraint</span> aa  primary <span class="keyword">key</span>(tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何查看已经存在的约束：</span></span><br><span class="line"><span class="keyword">select</span> constraint_name,constraint_type <span class="keyword">from</span> user_constraints</span><br><span class="line"><span class="keyword">where</span> table_name = <span class="keyword">upper</span>(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--如何删除约束：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">drop</span> <span class="keyword">constraint</span> SYS_C0011126;</span><br></pre></td></tr></table></figure>
<p>创建外键的时候，FOREIGN KEY 关键字是可以省略的，直接写 REFERENCES 。</p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>sequence 一个单独的数据对象，是一个能够生成有序的整数列值的对象；oracle 通过调用序列的形式来实现主键自增。<br>关于序列的一些常规操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> seq_test</span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">1</span>/<span class="number">-1</span>  <span class="comment">--增长，一次增1   正数+1  负数-1</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>       <span class="comment">--从1开始    升序默认就是+1  降序-1</span></span><br><span class="line"><span class="keyword">minvalue</span> <span class="number">1</span>         <span class="comment">--最小值     -10的26次幂</span></span><br><span class="line">maxvalue <span class="number">100</span>       <span class="comment">--最大值     10的27次幂</span></span><br><span class="line"><span class="keyword">cycle</span>              <span class="comment">--循环       默认 nocycle</span></span><br><span class="line">nocache;           <span class="comment">--不缓存     默认生成20个序列号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前用户下有多少序列</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_sequences;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何获取下一个列的值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(seq_test.nextval,<span class="string">'g'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何获取当前序列的值</span></span><br><span class="line"><span class="keyword">select</span> seq_test.currval <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何删除序列</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">sequence</span> seq_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如何修改序列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">sequence</span> seq_test <span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 消除延迟段创建特性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> deferred_segment_creation=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">name</span>(<span class="keyword">id</span> <span class="built_in">number</span>) <span class="keyword">segment</span> <span class="keyword">creation</span> <span class="keyword">immediate</span>;</span><br></pre></td></tr></table></figure>
<p>关于最后一个 消除延迟段创建特性 ，这是因为在 11g+ 的版本中有了一个新特性，它会导致序列直接从 2 开始，尚不知道有什么用处，解决方案可以在建表的时候就指定立即使用序列。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图 view 可以简单理解为是一张假表，用查询的结果动态生成一张表。<br>视图是编译后将查询语言保存到数据库中，下次调用视图，可以不用在编译，直接执行。<br>创建一个简单的视图：<code>create view 视图名 as select * from student;</code><br>为什么要使用视图？</p>
<ul>
<li>节省编译时间，提高查询效率</li>
<li>屏蔽原表中的字段：避免没有权限的用户查询其他的字段（看到不该看的）</li>
<li>视图中能够根据原表的状态动态刷新</li>
<li>简单的视图是可以更新（插入等）原表中的数据</li>
<li>复杂的视图无法更新（插入等），因为涉及到多个表</li>
</ul>
<p>需要注意的一点是创建视图后<del>也许并不会马上进行编译</del>，或者后来表结构发生了变化视图并不会进行更新，如果想立即生效可以尝试进行手动更新：<code>alter view 视图名 compile;</code></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>数据库会在具有唯一性的列上自动添加唯一性索引，索引包含：普通索引（normal）、唯一索引（unique）、位图索引（bitmap）、函数索引。<br>正常操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(字段);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询索引</span></span><br><span class="line"><span class="keyword">select</span> index_name,table_name,uniqueness,<span class="keyword">status</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">user_indexes</span><br><span class="line"><span class="keyword">where</span> table_name = <span class="string">'STUDENT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">index</span> index_name <span class="keyword">rename</span> <span class="keyword">to</span> new_index_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一性索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 位图索引（分类），这种索引适合用在数据量比较大，基数比较小的列（比如：男/女）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bitmap</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数索引：在一个列上经过函数计算后的结果上创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(函数(列名));</span><br></pre></td></tr></table></figure>
<p>创建索引的优缺点：</p>
<ul>
<li>能够更快的帮助我们进行提高查询效率</li>
<li>增删改表中的数据，数据库就需要耗费资源去维护索引，降低增删改的效率</li>
<li>数据量如果很少，没必要用索引</li>
<li>数据量比较大，不需要经常增删改操作而且查询比较多，适合使用索引</li>
</ul>
<h2 id="存储过程-amp-触发器"><a href="#存储过程-amp-触发器" class="headerlink" title="存储过程&amp;触发器"></a>存储过程&amp;触发器</h2><p>什么是存储过程，简单说就是在服务器端，能够被一个或多个应用程序调用的一段 sql 语句集（已被预编译）。<br>存储过程的创建等操作和 MySQL 中也大同小异，看些例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建/覆盖存储过程</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span></span><br><span class="line">过程名（参数名 <span class="keyword">in</span> 参数类型，参数名 <span class="keyword">out</span> 参数类型）</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">变量名 变量类型 := 值;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span>语句集;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span></span><br><span class="line">pro_hi(mykey <span class="keyword">in</span> <span class="built_in">number</span>,<span class="keyword">value</span> <span class="keyword">out</span> <span class="built_in">varchar</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> mykey = <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span> <span class="keyword">value</span> := <span class="string">'你好'</span>;</span><br><span class="line">else if mykey = 2</span><br><span class="line">then value := '再见';</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">declare</span> </span><br><span class="line">变量 类型:=初始值;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">过程名（参数，变量）;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> serveroutput <span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">val varchar2(<span class="number">20</span>):=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">pro_hi(<span class="number">1</span>,val);</span><br><span class="line">dbms_output.put_line(val);</span><br><span class="line">pro_hi(2,val);</span><br><span class="line">dbms_output.put_line(val);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>:=</code> 的意思是赋值，存储过程可以没有参数，如果没有参数则过程名之后不能出现括号。</p>
<hr>
<blockquote>
<p>触发器是在数据库中，在执行对数据有异动的动作时，先行拦截并处理的一种数据库对象，它大部份会设在数据表中，作为强制运行特定动作的程序，因此又称为数据操纵语言触发器</p>
</blockquote>
<p>或者可以理解为执行某个操作时自动触发执行存储过程？比如用来日志的记录和主键的自动增长。<br>触发器可具体分为行级触发器和<del>表级触发器</del>，具体的简单使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名</span><br><span class="line"><span class="keyword">before</span>/<span class="keyword">after</span>  <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span>  <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span>语句集;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个行级触发器，当执行插入操作时，自动查询序列的下一个值</span></span><br><span class="line"><span class="comment">-- 将查询到的值赋给表中的 id 列</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> tri_insert_good</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> good</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> seq_ids.nextval</span><br><span class="line"><span class="keyword">into</span>:new.id</span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 增加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> good (good_name) <span class="keyword">values</span> (<span class="string">'loli'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表级触发器，用于记录日志</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> test_dept</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">delete</span> <span class="keyword">or</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span> <span class="keyword">on</span> dept</span><br><span class="line"><span class="keyword">declare</span> var_tag varchar2(<span class="number">20</span>); <span class="comment">--声明一个变量</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> inserting <span class="keyword">then</span></span><br><span class="line">var_tag :=<span class="string">'insert'</span>;</span><br><span class="line">elsif updating then</span><br><span class="line">var_tag :='<span class="keyword">update</span><span class="string">';</span></span><br><span class="line"><span class="string">elsif deleting then</span></span><br><span class="line"><span class="string">var_tag :='</span><span class="keyword">delete</span><span class="string">';</span></span><br><span class="line"><span class="string">end if;</span></span><br><span class="line"><span class="string">insert into test_log values(var_tag,sysdate);</span></span><br><span class="line"><span class="string">end;</span></span><br><span class="line"><span class="string">/</span></span><br></pre></td></tr></table></figure>
<p>使用 elsif 的形式末尾只需要一个 end if 就可以了，如果使用的是 else if 的形式，那么有多少个 if 就要对应多少个 end if。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>默认情况下，删除表会放进回收站，通过命令 <code>show recyclebin;</code> 可以查看回收站。<br>还原表：<code>flashback table name to before drop;</code> 或者 <code>flashback table name to before drop rename to newName;</code><br>彻底删除表：<code>drop table users purge;</code><br>清空回收站：<code>purge recyclebin;</code></p>
<hr>
<p>数据类型中的 varchar2(num) 中的 num 指的是<strong>字节</strong>数。<br>关于约束，Oracle 有专用的 check 约束<br>如果使用 sqlplus 工具进行连接，还可以使用占位符，它会提示你输入相关信息，占位符用 <code>&amp;</code> 符号加描述就可以了，用的应该也不是很多</p>
<hr>
<p>关于清空表数据可以用传统的 delete 语句，它是从上往下删，速度比较慢，属于 DML 语句，可以进行回滚；<br>还可以使用表截断：<code>truncate table</code> ，速度快属于 DDL，不可回滚，不支持 where。<br>还有就是 drop 语句了，这个干的很彻底，属于 DDL，如果删错了，那就跑路吧。<code>drop table student purge;</code><br>删除空数据的用 <code>where xx is null</code> ，因为不确定不能用 = 号</p>
<hr>
<p>查看自己的权限：<code>select * from user_sys_privs;</code></p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>oracle 中的用户都有属于自己的默认的空间，在一段内存空间中大部分存储的是表，所以称为表空间。<br>表空间可简单的分为：系统用户的表空间和普通用户的表空间。<br>那么，为什么要创建用户的表空间呢？<br>项目中很可能与其他项目使用同一个数据库，多个用户在使用同一个数据库的时候有可能访问同一个数据库文件，就会造成资源争用问题，给不同的用户指定不同的表空间，就可以让他们使用不同的数据文件，解决争用问题。<br>数据最终存储在数据块中，从小往大的顺序是：数据块=&gt;盘区=&gt;段=&gt;数据文件=&gt;表空间。<br>相关操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第1步：创建临时表空间  */</span></span><br><span class="line"><span class="keyword">create</span> temporarytablespace user_temp  </span><br><span class="line">tempfile <span class="string">'D:\app\user_temp.dbf'</span> </span><br><span class="line"><span class="keyword">size</span> <span class="number">50</span>m  </span><br><span class="line"><span class="keyword">autoextend</span> <span class="keyword">on</span>  </span><br><span class="line"><span class="keyword">next</span> <span class="number">50</span>m <span class="keyword">maxsize</span> <span class="number">20480</span>m  </span><br><span class="line"><span class="keyword">extent</span> <span class="keyword">management</span> <span class="keyword">local</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第2步：创建数据表空间  */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> <span class="keyword">user_data</span>  </span><br><span class="line"><span class="keyword">logging</span>  </span><br><span class="line"><span class="keyword">datafile</span> <span class="string">'D:\app\user_data.dbf'</span> </span><br><span class="line"><span class="keyword">size</span> <span class="number">50</span>m  </span><br><span class="line"><span class="keyword">autoextend</span> <span class="keyword">on</span>  </span><br><span class="line"><span class="keyword">next</span> <span class="number">50</span>m <span class="keyword">maxsize</span> <span class="number">20480</span>m  </span><br><span class="line"><span class="keyword">extent</span> <span class="keyword">management</span> <span class="keyword">local</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第3步：创建用户并指定表空间  */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> username <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">password</span>  </span><br><span class="line"><span class="keyword">default</span> <span class="keyword">tablespace</span> <span class="keyword">user_data</span>  </span><br><span class="line"><span class="keyword">temporary</span> <span class="keyword">tablespace</span> user_temp;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第4步：给用户授予权限  */</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>,<span class="keyword">resource</span>,dba <span class="keyword">to</span> username;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户后修改</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> et1803 <span class="keyword">default</span> <span class="keyword">tablespace</span> 表空间名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表空间</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> 表空间名 <span class="keyword">including</span> ontents <span class="keyword">and</span> datailes;</span><br></pre></td></tr></table></figure>
<p>删除表空间后，原先指向该表空间的用户仍然默认的空间位置，需要通过 alter user 命令将用户的表空间指向一个有效的表空间。</p>
<h3 id="truncate-、delete与drop区别"><a href="#truncate-、delete与drop区别" class="headerlink" title="truncate 、delete与drop区别"></a>truncate 、delete与drop区别</h3><blockquote>
<p><a href="https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html" target="_blank" rel="noopener">https://www.cnblogs.com/8765h/archive/2011/11/25/2374167.html</a></p>
</blockquote>
<p><strong>相同点：</strong></p>
<ol>
<li>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据。</li>
<li>drop、truncate 都是 DDL 语句(数据定义语言)，执行后会自动提交。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>truncate 和 delete 只删除数据不删除表的结构(定义)，而 drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</li>
<li>delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。<br>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</li>
<li>delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动；<br>drop 语句将表所占用的空间全部释放。<br>truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。</li>
<li><strong>速度，一般来说: drop&gt; truncate &gt; delete</strong></li>
<li>安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及</li>
<li>delete 是 DML 语句,不会自动提交。drop/truncate 都是 DDL 语句,执行后会自动提交。</li>
<li>TRUNCATE   TABLE   在功能上与不带   WHERE   子句的   DELETE   语句相同：二者均删除表中的全部行。但   TRUNCATE   TABLE   比   DELETE   速度快，且使用的系统和事务日志资源少。<br>DELETE   语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE   TABLE   通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 </li>
<li>TRUNCATE   TABLE   删除表中的所有行，但表结构及其列、约束、索引等保持不变。 </li>
<li>TRUNCATE   TABLE   不能用于参与了索引视图的表。  </li>
</ol>
<h2 id="附-Select-执行顺序"><a href="#附-Select-执行顺序" class="headerlink" title="附:Select 执行顺序"></a>附:Select 执行顺序</h2><blockquote>
<p><a href="http://www.cnblogs.com/likeju/p/5039128.html" target="_blank" rel="noopener">http://www.cnblogs.com/likeju/p/5039128.html</a></p>
</blockquote>
<p>全文的链接在上面，这里摘出其中的一点：注意多表连接的连接条件的选择与表示。<br>多表连接的连接条件对索引的选择有着重要的意义，所以我们在写连接条件条件的时候需要特别注意。</p>
<ul>
<li>多表连接的时候，连接条件必须写全，宁可重复，不要缺漏。</li>
<li>连接条件尽量使用聚集索引</li>
<li>注意 ON、WHERE 和 HAVING 部分条件的区别：<br>ON 是最先执行， WHERE 次之，HAVING 最后；<br>因为 ON 是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，WHERE 也应该比 HAVING 快点的，因为它过滤数据后才进行 SUM</li>
</ul>
<p>考虑联接优先顺序：</p>
<ul>
<li>INNER JOIN</li>
<li>LEFT JOIN (注：RIGHT JOIN 用 LEFT JOIN 替代)</li>
<li>CROSS JOIN</li>
</ul>
<p>其它注意和了解的地方有：</p>
<ol>
<li>在 IN 后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数</li>
<li>注意UNION和UNION ALL的区别。–允许重复数据用UNION ALL好</li>
<li>注意使用DISTINCT，在没有必要时不要用</li>
<li>TRUNCATE TABLE 与 DELETE 区别</li>
<li>减少访问数据库的次数</li>
</ol>
<blockquote>
<p>查询语句的执行顺序：<br>1、FROM 子句：执行顺序为从后往前、从右到左。数据量较少的表尽量放在后面。<br>2、WHERE子句：执行顺序为自下而上、从右到左。将能过滤掉最大数量记录的条件写在WHERE 子句的最右。<br>3、GROUP BY：执行顺序从左往右分组，最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉。<br>4、HAVING 子句：消耗资源。尽量避免使用，HAVING 会在检索出所有记录之后才对结果集进行过滤，需要排序等操作。<br>5、SELECT子句：少用<em>号，尽量取字段名称。ORACLE 在解析的过程中, 通过查询数据字典将</em>号依次转换成所有的列名, 消耗时间。<br>6、ORDER BY子句：执行顺序为从左到右排序，消耗资源。</p>
</blockquote>
<h2 id="附-函数整理补充"><a href="#附-函数整理补充" class="headerlink" title="附:函数整理补充"></a>附:函数整理补充</h2><p><strong>单行函数：</strong></p>
<ul>
<li>ceil()：返回大于等于x的最小整数</li>
<li>floor()：返回小于等于x的最大整数</li>
<li>round()：四舍五入<br>round(a1,a2)  保留指定位小数位的四舍五入</li>
<li>trunc()：直接截断<br>trunc(a1,a2)：保留指定位数的小数</li>
<li>sign()：求符号位   正数：1  负数：-1  零返回0</li>
<li>power(a,b)：求a的b次方</li>
<li>sqrt()：求正平方根</li>
</ul>
<p><strong>转换函数：</strong></p>
<ul>
<li>to_number(C)：将一个字符类型的数字变成数值类型</li>
<li>to_char()：将数字转换为字符串<br>常用在货币单位，格式化字符串<br>日期转换：<code>to_char(日期，&#39;yyyy-MM-dd HH:mm:ss&#39;)</code> OR <code>to_char(systimestamp,&#39;yyyy-mm-dd hh24:mi:ss:ff3&#39;)</code></li>
<li>to_date(c1,c2)<br>c1:字符类型的日期<br>c2:格式，例如： to_date(‘2018-03’,’yyyy-mm’)<br>日期可以加减（整数）运算 ，单位是：天，但是日期没法相加</li>
<li>months_between(c1,c2)  计算两个日期之间的月份，就是 c1-c2</li>
<li>last_day(c1)  计算给定日期的所在月份的最后一天</li>
<li>next_day(c1,c2) ，距离周几最近的日期<br>c1:日期<br>c2:周中的某天</li>
</ul>
<p><strong>字符函数：</strong></p>
<ul>
<li>lower():转换成小写</li>
<li>upper():转换成大写</li>
<li>initcap():首字母大写</li>
<li>length():求长度</li>
<li>substr(c1,c2,c3)  截取字符串<br>c1:被截取的字符串<br>c2:从哪个位置开始截取<br>c3:截取长度  默认截取到最后</li>
<li>instr(c1,c2,c3,c4)  索引字符串<br>c1:被查询的字符串<br>c2:希望找到的字符<br>c3:从哪个位置开始找  默认是1<br>c4:第几次出现</li>
<li>concat(c1,c2)  拼接字符串</li>
<li>lpad(c1,c2,c3)  左侧补全<br>c1:希望补全的字符串<br>c2:补全到多少位<br>c3:以哪个字符来补全</li>
<li>rpad(c1,c2,c3)  右侧补全</li>
<li>trim(c1) 默认c1的两侧去除空格<br>trim(c1 from c2) 把c2的两侧移除指定的c1</li>
<li>ltrim(c1,c2) 左侧去除<br>c1:被去除的字符串<br>c2:去除的字符串  默认是空格</li>
<li>rtrim(c1,c2) 右侧去除</li>
<li>replace(c1,c2,c3)  完全替换<br>c1:原字符串<br>c2:被替换的字符串<br>c3:替换的字符串</li>
</ul>
<p><strong>通用函数：</strong></p>
<ul>
<li>nvl()：空值处理<br>nvl(字段，替换显示的内容)</li>
<li>nvl2():空值处理二代<br>nvl2(字段，不是空显示什么，是空显示什么)</li>
<li>wm_concat(column) 字段合并<br><code>select u_id, wmsys.wm_concat(goods || &#39;(&#39; || num || &#39;斤)&#39; ) goods_sum from name group by u_id</code><br>用法详细展示：<a href="http://www.cnblogs.com/yangxia-test/p/4272493.html" target="_blank" rel="noopener">http://www.cnblogs.com/yangxia-test/p/4272493.html</a></li>
</ul>
<p><strong>用于 to_char(numeric) 的模板</strong> ：</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>9</td>
<td>带有指定位数的值</td>
</tr>
<tr>
<td>0</td>
<td>前导零的值</td>
</tr>
<tr>
<td>. （句点）</td>
<td><strong>小数</strong>点</td>
</tr>
<tr>
<td>, （逗号）</td>
<td>分组（千）分隔符</td>
</tr>
<tr>
<td>PR</td>
<td>尖括号内负值</td>
</tr>
<tr>
<td>S</td>
<td>带负号的负值（使用本地化）</td>
</tr>
<tr>
<td>L</td>
<td>货币符号（使用本地化）</td>
</tr>
<tr>
<td>D</td>
<td><strong>小数</strong>点（使用本地化）</td>
</tr>
<tr>
<td>G</td>
<td>分组分隔符（使用本地化）</td>
</tr>
<tr>
<td>MI</td>
<td>在指明的位置的负号（如果数字 &lt; 0）</td>
</tr>
<tr>
<td>PL</td>
<td>在指明的位置的正号（如果数字 &gt; 0）</td>
</tr>
<tr>
<td>SG</td>
<td>在指明的位置的正/负号</td>
</tr>
<tr>
<td>RN</td>
<td>罗马数字（输入在 1 和 3999 之间）</td>
</tr>
<tr>
<td>TH or th</td>
<td>转换成序数</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>to_char</strong>(now(),’Day, HH12:MI:SS’)</td>
<td><code>&#39;Tuesday , 05:39:18&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(now(),’FMDay, HH12:MI:SS’)</td>
<td><code>&#39;Tuesday, 05:39:18&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-0.1,’99.99’)</td>
<td><code>&#39; -.10&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-0.1,’FM9.99’)</td>
<td><code>&#39;-.1&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(0.1,’0.9’)</td>
<td><code>&#39; 0.1&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(12,’9990999.9’)</td>
<td><code>&#39; 0012.0&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(12,’FM9990999.9’)</td>
<td><code>&#39;0012&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’999’)</td>
<td><code>&#39; 485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’999’)</td>
<td><code>&#39;-485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’9 9 9’)</td>
<td><code>&#39; 4 8 5&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(1485,’9,999’)</td>
<td><code>&#39; 1,485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(1485,’9G999’)</td>
<td><code>&#39; 1 485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(148.5,’999.999’)</td>
<td><code>&#39; 148.500&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(148.5,’999D999’)</td>
<td><code>&#39; 148,500&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(3148.5,’9G999D999’)</td>
<td><code>&#39; 3 148,500&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’999S’)</td>
<td><code>&#39;485-&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’999MI’)</td>
<td><code>&#39;485-&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’999MI’)</td>
<td><code>&#39;485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’PL999’)</td>
<td><code>&#39;+485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’SG999’)</td>
<td><code>&#39;+485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’SG999’)</td>
<td><code>&#39;-485&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’9SG99’)</td>
<td><code>&#39;4-85&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(-485,’999PR’)</td>
<td><code>&#39;&lt;485&gt;&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’L999’)</td>
<td><code>&#39;DM 485</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’RN’)</td>
<td><code>&#39; CDLXXXV&#39;</code></td>
</tr>
<tr>
<td><strong>to_char</strong>(485,’FMRN’)</td>
<td><code>&#39;CDLXXXV&#39;</code></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis入门]]></title>
      <url>http://bfchengnuo.com/2017/10/28/Redis%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>Redis 是一个使用 ANSI C 编写的开源、支持网络、<strong>基于内存</strong>、可选持久性的<strong>键值对存储数据库</strong>。<br>从 2015 年 6 月开始，Redis 的开发由 Redis Labs 赞助，而2013年5月至2015年6月期间，其开发由 Pivotal 赞助。在2013年5月之前，其开发由 VMware 赞助。<a id="more"></a><br>根据月度排行网站 DB-Engines.com 的数据显示，<strong>Redis 是最流行的键值对存储数据库</strong></p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Redis 的外围由一个键、值映射的字典构成。与其他<strong>非关系型数据库</strong>主要不同在于：Redis 中值的类型不仅限于字符串，还支持如下抽象数据类型：</p>
<ul>
<li>字符串列表</li>
<li>无序不重复的字符串集合</li>
<li>有序不重复的字符串集合</li>
<li>键、值都为字符串的哈希表</li>
</ul>
<p>值的类型决定了值本身支持的操作。Redis 支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作</p>
<p>更多的基本信息可以查看 wiki：<a href="https://zh.wikipedia.org/wiki/Redis" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Redis</a></p>
<h2 id="关于缓存-amp-NoSQL"><a href="#关于缓存-amp-NoSQL" class="headerlink" title="关于缓存&amp;NoSQL"></a>关于缓存&amp;NoSQL</h2><p>我们所听说的 Redis 都基本是用于缓存，缓存也是非常必要的，除了 Redis 还有一种缓存技术是使用 Memcached ，它出现比 Redis 早，功能比较单一。<br>但从性能方面来说，也就是从缓存的命中率来说 Memcached 的性能更好，但是和 Redis 的差距并不大，但是 Redis 所提供的功能就更强大了。<br>重要区别：</p>
<ul>
<li>Memcached 是多线程的</li>
<li>Redis 是单线程的</li>
</ul>
<p>关于 NoSQL 就不多说了，比较出名的 NoSQL 产品还有 MongoDB ，它是基于 JSON 来存储的，这样就能做到不同的记录字段的长度不同</p>
<hr>
<p>NoSQL 指的是 Not only SQL，也就是不仅仅是 SQL，读作 N、 O、 SQL，不要读 no SQL。<br>它一般用于高并发的读写，这样的情况传统的关系数据库搞不定，并且有高扩展（横向）、高可用的特性。<br>具体到 Redis 它虽然查询速度快但是结构性不强，并没有什么两全其美的东西。<br>应用：<br>缓存、任务队列、排行榜、数据过期处理、分布式集群的 Session 分离</p>
<h2 id="版本安装"><a href="#版本安装" class="headerlink" title="版本安装"></a>版本安装</h2><p>官方其实并没有提供 Windows 版的（厉害），微软基于官方发布的版本进行编译创建了 Windows 的分支，所以一般情况 Windows 版都是比较落后的。<br>win 下双击运行即可，无需安装，cli 是客户端，默认会进行连接，使用的是 6379 端口，为什么用这个是有一段故事的，想知道就自己 Google 下吧。<br>另外可以直接安装到服务，这样就不用每次还得打开那个黑窗口了，安装方法在下载包的文档里有现成的，删除服务命令是：<code>sc delete XXName</code><br>启动 Redis 后会创建一个 dat 文件，大小和本机的内存一样，但是一般测试没必要搞这么大，在配置文件的 maxmemory 可以修改，例如：<code>maxmemory 200mb</code><br>渣渣的我只能先玩 win 版的了….在我下载的 3.2 版本中需要手动进入命令行指定配置文件才能运行：<br><code>redis-server.exe &quot;redis.windows.conf&quot;</code><br>退出命令：<code>redis-cli.exe shutdown</code></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>下载源码后首先编译 make，为什么编译安装都造，性能好，需要有相应的 gcc 库才可以哦<br>然后就可以进行安装了：<br><code>make PREFIX=/usr/local/redis install</code><br>下一步拷贝 conf 配置文件到安装目录就可以了，在配置文件中最好设置为 <code>daemonize yes</code><br>这样启动就是后台启动了，启动命令：<br><code>redis-server ./redis.conf</code><br>可以使用 <code>ps -ef | grep -i redis</code> 来查看是否启动成功。<br>关闭推荐使用：<br><code>redis-cli shutdown</code> ，强制关闭：<code>kill -9 pid</code></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>除了使用 cli 自动连接，也可以手动进行连接：<code>redis-cli -h 127.0.0.1 -p 6379</code><br>然后可以用 ping 来测试下是否正常，正常情况它会回你一个 pong</p>
<hr>
<p>Redis 默认有 16 个数据库，以数字命名，从 0 开始，并且是不支持修改的，数量可以在配置文件中设置（database）<br>使用 SELECT 命令来切换数据库，例如：<code>SELECT 0</code><br>数据库直接并不是完全隔离的，也就是说当执行 <code>FLUSHALL</code> 命令时，会清空所有数据库的数据，如果只想清空当前数据库的数据，要执行 <code>FLUSHDB</code><br>并且，<strong>官方建议不设置数据库的密码</strong>，安全应该由服务器来保证（并且也不支持设置单个数据库的密码）</p>
<hr>
<p>下面就开始看看使用频率很高的命令 :</p>
<ul>
<li>keys<br>前面说过 Redis 是以键值对存储的，可以想象为一个大 Map，这个命令也就是查询键了！用法如：<br><code>KEYS *</code> 查询所有;<br>也可以使用通配符，有四种，? 、 * 、 [] 以及转义符号，至于什么意思，学过正则的都知道哈;</li>
<li>exists<br>判断 key 是否存在，存在返回 1 不存在返回 0 。</li>
<li>del<br>可以删除一个或者多个 key，返回的是删除键的个数，键删除了相应的值自然也删除了，删除多个以空格分开.</li>
<li><p>type<br>获得键值的数据类型，返回的值可能是 string、hash、list（列表）、set（集合）、zset（有序集合）</p>
</li>
<li><p>rename<br>就是 key 的重命名了，特别的如果重命名新名称已存在会直接覆盖，所以 Redis 中还有大量的以 nx 结尾的命令，nx 结尾的命令都会进行一些判断，例如：<code>renamenx a b</code> 当 b 这个 key 已经存在时，此操作就不会生效，返回的是 0.</p>
</li>
<li>set/get/setex<br>设置、获取 key；setex 是 set 和 expire 的简写，可以顺便设置生存时间，例如：<code>setex a 100 a</code> ；<br>类似的还有 psetex 只不过时间单位成了毫秒。</li>
<li>getrange<br>获取值的指定范围的内容，例如 <code>getrange key 0 2</code> 就是获取第 0  个到第 2 个，是个闭合区间，包含 0 和 2；</li>
<li>getset<br>特点就是先 get 再 set，相当于在 set 的时候把旧的值拿出来了。</li>
<li>expire<br>设置 key 的生存时间，默认单位为秒，到期后会自动销毁</li>
<li>ttl<br>查看 key 剩余的生存时间，默认单位秒，如果返回 -1 表示无限制，返回 -2 表示不存在。</li>
<li>randomkey<br>获取一个随机的 key</li>
<li>flash/flashall<br>清空当前（全部）数据库</li>
<li>info<br>查看 Redis 的一些运行信息</li>
<li>help<br>帮助命令，就不多说了，教给你命令怎么用，有种用法是：<code>help 空格 [tab]</code></li>
</ul>
<h2 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h2><p>字符串数据类型是 Redis 最基本的数据类型了，它能存储任何形式的字符串，包括二进制数据；允许存储的数据容量最大 512 MB<br>存取字符串用的就是 set/get 命令了，还有一个 MGET/MSET 这个命令可以批量读取/设置值（MSET k1 v1 k2 v2）；特别的这个指令也支持 msetnx ，这有点像事务了，如果其中一个 key 已存在，那么整个批量操作都会失败。<br><code>INCR</code> 是<strong>递增命令</strong>，并且会返回递增后的值，默认每次递增的是 1，如需特殊指定就是 <code>INCRBY name 2</code> 这样就会每次递增二，如果不存在就会先初始化为 0 然后再递增；<br>相应的 <code>DECR</code> 就是<strong>递减</strong>了，比如： <code>DECR id</code> 就是递减 id 这个 key，默认也是每次一，同样也可以指定递减多少，用法和上面一样；<br><code>APPEND</code> 是<strong>往尾部追加内容</strong>，用在这里就是追加字符串内容，比如：<code>APPEND name 233</code> ，返回是的追加后的字符串的长度。<br><code>STRLEN</code> 获取字符串的长度，没啥可说的。<br>还有一个是 <code>getset</code> 先获取值再设置值</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>其结构可以比作 Java 里的 <code>Map&lt;String, String&gt;</code><br>常用的几个命令有：<br><strong>获取/存储值</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hset key name1 value1</span><br><span class="line">hget key name1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量存储/获取</span><br><span class="line">hmset key name1 value1 name2 val2</span><br><span class="line">hmget key name1 name2</span><br></pre></td></tr></table></figure>
<p>其他的一些指令就一起说了吧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取全面的属性和值</span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除多个值，删除 key 用 del 哦</span><br><span class="line">hdel key name1 name2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 递增递减都差不多，举一个栗子，前提是 age 这个值（val）要有，并且是数字类型</span><br><span class="line">hincrby key age 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断属性是否存在</span><br><span class="line">hexists key name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 属性的个数</span><br><span class="line">hlen key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取所有的属性名</span><br><span class="line">hkeys key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取所有的值</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure>
<p>常用的一般就是这些吧</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>同样它也有两种形式，数组的和链表的；特点和数据结构中的也一致</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 两端添加，一个是左边一个是右边</span><br><span class="line">lpush key a b c  # c 就在最左边</span><br><span class="line">rpush key a b c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 两端弹出</span><br><span class="line">rpop key</span><br><span class="line">lpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看list</span><br><span class="line">lrange key start end</span><br><span class="line">例如: lrange key 0 -1  # 左边数，第一个到最后一个</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看长度</span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 插入到头部，如果 key 不存在就不插入，不会自动创建</span><br><span class="line">lpushx key a</span><br><span class="line">rpushx key a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除，count 的负号表示方向</span><br><span class="line">lrem key count val</span><br><span class="line">lrem key 2 3  # 删除2个3</span><br><span class="line">lrem key -2 1 # 从后面（负号）删除2个1</span><br><span class="line">lrem key 0 2  # 删除所有的2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改值</span><br><span class="line">lset key 3 v  # 在第四个位置修改为 v；从 0 开始数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 插入</span><br><span class="line">linsert key before b ll  # 在 b 的前面插入 ll</span><br><span class="line">linsert key after b ll</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他</span><br><span class="line">rpoplpush key1 key2  # 把 key1 的右边弹出，添加到 key2 的左边</span><br></pre></td></tr></table></figure>
<p>push 返回的是长度，pop 返回的是弹出的元素，rpoplpush 这种命令非常适合用于 MQ</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>相当于无序的 List，并且是唯一的<br>常用的命令有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加删除</span><br><span class="line">sadd key a b c</span><br><span class="line">srem key c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看值</span><br><span class="line">smembers key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 是否存在？存在返回 1，不存在返回 0</span><br><span class="line">sismember key a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 相差比较，和顺序有关，可以理解为 key1 - key2</span><br><span class="line">sdiff key1 key2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 求交集、并集</span><br><span class="line">sinter k1 k2</span><br><span class="line">sunion k1 k2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看数量</span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取一个随机值</span><br><span class="line">srandmember key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 移除一个随机元素，并返回（比如可做订单号缓存池）</span><br><span class="line">spop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他</span><br><span class="line">sdiffstore k1 k2 k3   # k2 和 k3 的交集存到 k1</span><br><span class="line">sunionstore k1 k2 k3  # k2 和 k3 的并集存到 k1</span><br></pre></td></tr></table></figure>
<p>在做并集交集的处理时非常有优势，因为服务器端的聚合效率更高。<br>内部还是使用哈希表来实现，时间复杂度是 O(1)</p>
<h2 id="Sorted-set"><a href="#Sorted-set" class="headerlink" title="Sorted-set"></a>Sorted-set</h2><p>它存的都是字符串的内容，并且有一个分数与之关联，可用来排序，分数是可重复的，值不可以</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 增加、删除数据（返回插入元素的个数，已有的值分数会被覆盖）</span><br><span class="line">zadd key 10 n1 20 n2</span><br><span class="line">zrem key n1 n2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取分数</span><br><span class="line">zscore key name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取成员的数量</span><br><span class="line">zcard key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 范围查找</span><br><span class="line">zrange key 0 -1</span><br><span class="line">zrange key 0 -1 withscores  # 显示分数</span><br><span class="line">zrevrange key 0 -1  # 从大到小进行排序，默认是从小到大</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照范围删除（插入顺序）</span><br><span class="line">zremrangebyrank key 0 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照分数的范围删除</span><br><span class="line">zremrangebyscore 80 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 按照分数排序</span><br><span class="line">zrangebyscore key 0 100</span><br><span class="line">zrangebyscore key 0 100 withscores limit 0 2  # 显示部分数据</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 操作分数</span><br><span class="line">zincrby key 3 name  # 给 name 的分数 +3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 计算区间，80-90 之间有几个</span><br><span class="line">zcount key 80 90</span><br></pre></td></tr></table></figure>
<p>可以用来做热点话题和游戏排名之类的；<br>同上，使用哈希表实现，通过分数来保证顺序（默认从小到大），时间复杂度也是 O(1)</p>
<h2 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h2><p>前面说过，Redis 基本是用来做缓存的，并且它是基于内存的，所以当然有必要设置生存时间了；<br>设置生存时间（PEXPIRE 可以设置毫秒）：<br><code>EXPIRE Key seconds</code><br>然后可以使用 TTL 来查询，返回的是剩余的生存时间，单位是秒；如果是没有限制返回的是 -1；数据已删除是 -2<br>清除生存时间(重新设置值也会清除生存时间)：<br><code>PERSIST key</code></p>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><p>然后下面就说说在 Java 中的使用，有很多的 Java 客户端支持 Redis，当然这都不是官方的，其中用的比较多的是 jedis；它的使用也非常的简单，导入相应的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后最简单是使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">jedis.set(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">String value = jedis.get(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure>
<p>它有一个好处是方法和命令的名字是一致的，这是用起来最爽的，后面还会涉及到连接池和集群，具体可以参考 <a href="https://github.com/bfchengnuo/java_learn/tree/master/ExampleCode/jedis/src/main/java/cn/itcast/redis" target="_blank" rel="noopener">GitHub 上的示例代码</a><br>如果使用的是集群（下面会讲）就使用下面的代码操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt; jedisClusterNodes = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">jedisClusterNodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>));</span><br><span class="line">JedisCluster jc = <span class="keyword">new</span> JedisCluster(jedisClusterNodes);</span><br><span class="line">jc.set(<span class="string">"foo"</span>,<span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>
<p>这里的 jc 不需要手动关闭，内部已经自动关闭了</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 提供了两种持久化的方式，一种是 RDB （默认开启），另一种是 AOF，它们既可以单独使用也可以混合使用。<br>RDB 方式是通过快照完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并且存储到硬盘上。进行快照的条件在配置文件中指定，有2个参数构成：时间和改动的键的个数，<strong>当在指定时间内被更改的键的个数大于指定数值时就会进行快照。</strong><br>默认在配置文件中已经有一些配置了，就是 save 开头的；除了自动也可以手动保存，使用 SAVE 或者 BGSAVE 命令，区别就是一个在主进程（会阻塞）一个会 fork 一个子线程进行（需要的物理内存是 Redis 设置的内存的一倍）</p>
<hr>
<p>Redis 的 AOF 持久化策略是将发送到Redis服务端的每一条命令都记录下来，并且保存到硬盘中的AOF文件，AOF文件的位置和RDB文件的位置相同，都是通过dir参数设置，默认的文件名是appendonly.aof，可以通过appendfilename参数修改。<br>可以使用 BGREWRITEAOF 命令来重写 AOF 文件</p>
<blockquote>
<p>参数介绍<br>auto-aof-rewrite-percentage 100<br>当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。<br>auto-aof-rewrite-min-size 64mb<br>限制了允许重写的最小AOF文件大小，通常在AOF文件很小的时候即使其中有些冗余的命令也是可以忽略的。</p>
<p>文件写入默认情况下会先写入到系统的缓存中，系统每30秒同步一次，才是真正的写入到硬盘，如果在这30秒服务器宕机那数据也会丢失的，Redis可以通过配置来修改同步策略：<br>appendfsync always  每次都同步 （最安全但是最慢）<br>appendfsync everysec  每秒同步  （默认的同步策略）<br>appendfsync no  不主动同步，由操作系统来决定 （最快但是不安全）</p>
</blockquote>
<h2 id="主从复制（读写分离）"><a href="#主从复制（读写分离）" class="headerlink" title="主从复制（读写分离）"></a>主从复制（读写分离）</h2><p>和数据库的读写分离是类似的，主要是解决读取压力过大的问题，以及….避免宕机<br>相比来说，比 MySQL 数据库要简单的多，如果是在一台机器做测试，除了修改端口 pidfile 也要改，不能相同</p>
<p>设置主从：</p>
<ul>
<li><code>redis.conf</code> 配置文件中设置 slaveof</li>
<li>客户端内执行：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code><br>重启后将会失效</li>
</ul>
<p>然后可以使用 <code>NFO replication</code> 查看关系，默认的从库只能读取不能写入，这样更合理些，除了设置一主多从还可以设置主从从的架构，就是 A 的从是 B ，B 的从是 C，这样就减轻了主库的压力<br>同步的原理：</p>
<ol>
<li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令；</li>
<li>主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；</li>
<li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis；</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令；</li>
<li>之后，主Redis每当接收到<strong>写命令</strong>时就会将命令发送从Redis，从而保证数据的一致；</li>
</ol>
<p>如果硬盘的 IO 不好会拖累性能，从 2.8.18 的版本开始，Redis 支持无盘复制，就是直接通过网络传输，不过这个功能目前好像不是很稳定，开启无磁盘复制：<code>repl-diskless-sync yes</code></p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>当从库宕机后，只需要重启就可以了，会自动进行同步（增量同步，主库会记录上一次同步的偏移量）<br>当主库宕机就比较麻烦了，解决方案是：</p>
<ol>
<li>在从数据库中执行 <code>SLAVEOF NO ONE</code> 命令，断开主从关系并且提升为主库继续服务</li>
<li>将主库重新启动后，执行 <code>SLAVEOF</code> 命令，将其设置为其他库的从库，这时数据就能更新回来</li>
</ol>
<p>然后手动敲不能保证正确（避免人肉运维），所以 Redis 就提供了哨兵的功能，就是对所有的 Redis 进行监控，可以设置多个哨兵，它们也会互相监控，看看对方是不是挂了，<strong>哨兵肯定是独立的线程</strong><br>具体的配置就不贴了，太多了，总之就是检查到主库宕机后会自动执行上面的方案</p>
<h2 id="关于集群"><a href="#关于集群" class="headerlink" title="关于集群"></a>关于集群</h2><p>现在一般有两种，一种是官方的，一种是分片式的，当然是官方的好了，但是由于在 3.0+ 的版本官方才支持，所以在以前都是玩分片式的集群</p>
<h3 id="分片式集群"><a href="#分片式集群" class="headerlink" title="分片式集群"></a>分片式集群</h3><p>原理其实就是计算 key 的哈希值来进行存储（到相应的 Redis 数据库），这样就会有一个问题：无法动态的增加、减少服务节点，因为毕竟节点的数量涉及到哈希的计算，其实在读取的时候也会涉及到哈希的计算，要不然它怎么知道去那一台找</p>
<h3 id="官方提供的集群"><a href="#官方提供的集群" class="headerlink" title="官方提供的集群"></a>官方提供的集群</h3><p>需要 3.0 + 的版本哦，并且需要前面的主从复制知识<br>如果是在一台机器上测试，只需要拷贝不同的配置文件，然后启动的时候到相应的目录指定即可<br>设置集群主要是在配置文件开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 指定集群的配置文件</span><br><span class="line">cluster-config-file &quot;nodes-xxxx.conf&quot;</span><br></pre></td></tr></table></figure>
<p>然后就是使用一个官方提供的 Ruby 脚本，运行下就好了。<br>分布式的原理为通过插槽的分配确定存储位置，特点有：</p>
<ul>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效</li>
<li>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li>
<li>redis-cluster把所有的物理节点映射到[0-16383] slot（插槽）上, cluster 负责维护 node &lt;–&gt;slot &lt;–&gt; value</li>
</ul>
<p>一般情况插槽会平均分配到各个 Redis，存储数据的时候根据 key 来计算插槽值（当 key 有闭合的大括号时，大括号中的数据为有效值），然后做相应的存储，这样就需要在使用客户端的时候加一个 <code>-c</code> 的命令，设置为自动跟踪重定向，也就是当插槽值不在当前数据库时自动切换，所以直连一个就可以了</p>
<p>当一半以上的服务器 PING 不通某一个服务器（当一个服务器 PING 不通就将其标记为疑似下线），这个服务器就会被标记为下线，同时插槽出现空档，整个集群被标记为不可用。<br>解决方案可以和前面的主从联系起来，将每个节点设置为主从架构，这样就能保证高可用和负载均衡。<br><strong>集群中的节点只能使用 0 号数据库，切换数据库（SELECT）会报错</strong></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>下面都是在 Java 中经常使用的一些代码了，使用的客户端为 jedis</p>
<h3 id="与Spring整合"><a href="#与Spring整合" class="headerlink" title="与Spring整合"></a>与Spring整合</h3><p>在 Spring 的配置文件中定义下面几个 bean，就不需要进行实例化了，之间注入使用即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 连接池配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.MaxTotal&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shardedJedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.ShardedJedisPool"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisShardInfo"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.node1.host&#125;"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.node1.port&#125; "</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	redis.MaxTotal=50</span></span><br><span class="line"><span class="comment">	redis.node1.host=127.0.0.1</span></span><br><span class="line"><span class="comment">	redis.node1.port=6379</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后创建一个 Service 来统一操作 Redis：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)  <span class="comment">// 设置为不是必须的，这样即使没有配相关的 bean 也不会抛异常</span></span><br><span class="line">  <span class="keyword">private</span> ShardedJedisPool shardedJedisPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对重复的代码进行封装</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(Function&lt;T, ShardedJedis&gt; fun)</span> </span>&#123;</span><br><span class="line">    ShardedJedis shardedJedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从连接池中获取到jedis分片对象</span></span><br><span class="line">      shardedJedis = shardedJedisPool.getResource();</span><br><span class="line">      <span class="comment">// 从redis中获取数据后进行回调，这时输入已经确定</span></span><br><span class="line">      <span class="keyword">return</span> fun.callback(shardedJedis);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != shardedJedis) &#123;</span><br><span class="line">        <span class="comment">// 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态</span></span><br><span class="line">        shardedJedis.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存字符串到数据库（set操作）</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就确定了返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> Function&lt;String, ShardedJedis&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(ShardedJedis e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.set(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存字符串到数据库（set操作），并且设置生存时间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> Function&lt;String, ShardedJedis&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(ShardedJedis e)</span> </span>&#123;</span><br><span class="line">        String result = e.set(key, value); </span><br><span class="line">        e.expire(key, seconds);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从数据库获取数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> Function&lt;String, ShardedJedis&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(ShardedJedis e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.get(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除一条（缓存）数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> Function&lt;Long, ShardedJedis&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Long <span class="title">callback</span><span class="params">(ShardedJedis e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.del(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置生存时间, 单位秒</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> Function&lt;Long, ShardedJedis&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Long <span class="title">callback</span><span class="params">(ShardedJedis e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.expire(key, seconds);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中为了封装重复的代码达到复用的目的，使用了 js 的回调思想（什么设计模式来….），涉及的接口很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 简单理解为 T 为输出；E 为输入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">callback</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还是很好理解的。<br>嗯，到这里就差不多了吧，应该很全了，如果不全等以后用到了再来补充吧</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS7搭建PPTP服务]]></title>
      <url>http://bfchengnuo.com/2017/10/27/CentOS7%E6%90%AD%E5%BB%BAPPTP%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>至于为什么要搭建，这个就不好说明了，都懂得，总之可以说是突然来了兴趣，每天晚上抽半小时研究，三天才弄好啊！<br>主要是掉进了一个坑里没出来……其实搭建还是很简单的，我也就记录一下简单的搭建方法，避免日后再进坑<br>使用的是腾讯云的云主机，毕竟是练手嘛….CentOS7.2 的系统<a id="more"></a></p>
<p>或者你可以使用一键安装脚本，比如：<a href="https://github.com/userrory/centos7-pptp" target="_blank" rel="noopener">https://github.com/userrory/centos7-pptp</a></p>
<h2 id="检查是否支持"><a href="#检查是否支持" class="headerlink" title="检查是否支持"></a>检查是否支持</h2><p>终端输入：<code>modprobe ppp-compress-18 &amp;&amp; echo yes</code><br>返回 yes 表示支持 pptp</p>
<hr>
<p><strong>若你使用 XEN 架构的 VPS，下面的步骤不用执行</strong> ，腾讯云是 XEN ….<br>检测PPP是否开启：<code>cat /dev/ppp</code><br>开启成功的标志：<br><code>cat: /dev/ppp: No such file or directory</code> 或者 <code>cat: /dev/ppp: No such device or address</code>，可以继续</p>
<h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>运行下面的命令安装 iptables、ppp、pptpd ：<br><code>yum install ppp iptables pptpd</code><br>没什么好说的，如果没有那就尝试换个源或者用 rpm 包。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>官方如果没有提供可以先安装 epel 源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install pptpd</span><br></pre></td></tr></table></figure>
<p>可用性自行测试</p>
<hr>
<p>在 CentOS 6 X64 上可以用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -i http://poptop.sourceforge.net/yum/stable/rhel6/pptp-release-current.noarch.rpm</span><br><span class="line">yum -y install pptpd</span><br></pre></td></tr></table></figure>
<p>没测试过，不知道能不能用</p>
<h2 id="配置组件"><a href="#配置组件" class="headerlink" title="配置组件"></a>配置组件</h2><h3 id="编辑pptpd-conf"><a href="#编辑pptpd-conf" class="headerlink" title="编辑pptpd.conf"></a>编辑pptpd.conf</h3><p>编辑 pptpd.conf 这个文件：<code>vim /etc/pptpd.conf</code><br>找到下面的两行，并且去掉注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localip 192.168.0.1</span><br><span class="line">remoteip 192.168.0.234-238,192.168.0.245</span><br></pre></td></tr></table></figure>
<p>第一行的意思是VPN连接成功后，VPN server（就是你启动 pptpd 服务）的地址，就是说通过这个地址来找到 VPN server。<br>第二行是分配给客户端的 ip 范围。<br>remoteip最好不用和VPN client本身所在的局域网的ip冲突，默认即可</p>
<h3 id="编辑options-pptpd"><a href="#编辑options-pptpd" class="headerlink" title="编辑options.pptpd"></a>编辑options.pptpd</h3><p>终端输入：<code>vim /etc/ppp/options.pptpd</code><br>其他的一般保持默认即可，主要是设置下 DNS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms-dns 8.8.8.8</span><br><span class="line">ms-dns 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>同样是去掉注释，然后修改，一般设置个 DNS 就可以了，或者根据需要设置其他，给个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name pptpd                        #自行设定的VPN服务器的名字，可以任意</span><br><span class="line">#refuse-pap                        #拒绝pap身份验证</span><br><span class="line">#refuse-chap                      #拒绝chap身份验证</span><br><span class="line">#refuse-mschap                 #拒绝mschap身份验证</span><br><span class="line">require-mschap-v2             #为了最高的安全性，我们使用mschap-v2身份验证方法</span><br><span class="line">require-mppe-128              #使用128位MPPE加密</span><br><span class="line">ms-dns 8.8.8.8                   #设置DNS</span><br><span class="line">ms-dns 8.8.4.4</span><br><span class="line">proxyarp                            #启用ARP代理，如果分配给客户端的IP与内网卡同一个子网</span><br><span class="line">#debug                              #关闭debug</span><br><span class="line">lock</span><br><span class="line">nobsdcomp</span><br><span class="line">novj</span><br><span class="line">novjccomp</span><br><span class="line">#nologfd                            #不输入运行信息到stderr</span><br><span class="line">logfile /var/log/pptpd.log    #存放pptpd服务运行的的日志</span><br></pre></td></tr></table></figure>
<p>其实大部分默认都给配置好了</p>
<h3 id="设置账号密码"><a href="#设置账号密码" class="headerlink" title="设置账号密码"></a>设置账号密码</h3><p>终端输入： <code>vim /etc/ppp/chap-secrets</code><br>格式上面有提示，就是：<code>用户名 pptpd 密码 *</code><br><code>*</code> 表示的是随机分配 ip</p>
<h3 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h3><p>输入：<code>vim /etc/sysctl.conf</code><br>如果没有这个文件就自己创建一个吧，在文件的最后写入一行：<br><code>net.ipv4.ip_forward=1</code><br>这条命令的意思是使内核支持转发，还需要下面一条命令来使修改生效：<br><code>sysctl -p</code></p>
<h3 id="添加转发规则"><a href="#添加转发规则" class="headerlink" title="添加转发规则"></a>添加转发规则</h3><p>XEN架构：<br><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</code><br>OpenVZ架构：<br><code>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source VPS公网IP</code></p>
<p>腾讯云是 XEN 架构，阿里云是 OpenVZ</p>
<hr>
<p>但是添加转发规则后重启就会失效，Centos 6 系统可以使用 <code>service iptables save</code> 保存配置，但 Centos 7 不支持，我们需要将配置写入 <strong>rc.local</strong> 文件中，开机自动设置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/rc.local</span><br><span class="line">vim /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>
<p>编辑 rc.local 文件在最后写入上面的转发规则就可以了</p>
<h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><p>可以使用 <code>iptables -X -t nat</code> 清除转发规则(<code>iptables -F</code>)；<br><code>iptables -t nat -L</code> 可以查看 NAT 表是否已经生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>带行号查看当前所有规则 </span><br><span class="line">iptables -L -n --line-numbers</span><br><span class="line"><span class="meta">#</span>清除所有规则</span><br><span class="line">iptables -F</span><br><span class="line"><span class="meta">#</span>删除指定行号（以下命令中的“5”为指定行号）规则</span><br><span class="line">iptables -D 5</span><br><span class="line"><span class="meta">#</span>保存当前配置;相当于旧版/etc/init.d/iptables save</span><br><span class="line">service iptables save</span><br><span class="line"><span class="meta">#</span>重启iptables;相当于旧版本/etc/init.d/iptables restart</span><br><span class="line">service iptables restart</span><br><span class="line"><span class="meta">#</span>注册iptables服务;相当于旧版 chkconfig iptables on</span><br><span class="line">systemctl enable iptables.service</span><br><span class="line"><span class="meta">#</span>开启服务</span><br><span class="line">systemctl start iptables.service</span><br><span class="line"><span class="meta">#</span>查看状态</span><br><span class="line">systemctl status iptables.service</span><br></pre></td></tr></table></figure>
<p>这应该很全了，ipdables 配置文件位于 <code>/etc/sysconfig/iptables</code></p>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>关于启动服务的命令，网上有几种，用 <code>/etc/init.d/pptpd start</code> 、用 <code>service pptpd start</code> ….<br>我测试是都不行，在 centOS 7+ 中，他会提示让你使用 systemctl ，所以启动应该是：<br><code>systemctl start pptpd</code><br>下面的命令应该会让 pptpd 开机启动(未测试)：<br><code>systemctl enabled pptpd</code></p>
<h2 id="连不上VPN"><a href="#连不上VPN" class="headerlink" title="连不上VPN"></a>连不上VPN</h2><p>检查是否开放了 1723 端口，一般是因为这个原因吧，其他错误见参考的连接</p>
<h2 id="查看VPS的架构"><a href="#查看VPS的架构" class="headerlink" title="查看VPS的架构"></a>查看VPS的架构</h2><p>首先安装一个软件：<code>yum install virt-what</code><br>装好后使用命令 <code>virt-what</code> 即可查看 linux 下 VPS 的架构了</p>
<h2 id="打不开网页"><a href="#打不开网页" class="headerlink" title="打不开网页"></a>打不开网页</h2><p>这真是个坑，我搞了好长时间，原来是 MTU 的原因，值太小了！<br>可以在服务器端使用：<code>ifconfig ppp0 mtu 1472</code> 设置，但是这样不持久。</p>
<p>阿里云、腾讯云设置 MTU :<br><code>vim /etc/ppp/ip-up</code><br>在 <strong>exit 0</strong> 前写入 : <code>ifconfig $1 mtu 1500</code><br>这样就解决无法访问网页的问题了！</p>
<p>主要就是 MTU，具体的原因参考：<a href="http://blog.sandy1890.com/2016/10/23/pptpd_iptables/" target="_blank" rel="noopener">http://blog.sandy1890.com/2016/10/23/pptpd_iptables/</a><br>关于这个深深感到知识不够，看不明白，等以后在来补充吧</p>
<hr>
<p>MAC 系统需要设置下网卡：wifi—&gt;高级—-&gt;硬件—-&gt;默认是1500，修改为1472</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/12f7b66d1cab" target="_blank" rel="noopener">http://www.jianshu.com/p/12f7b66d1cab</a><br><a href="http://www.wanghailin.cn/centos-7-pptp/" target="_blank" rel="noopener">http://www.wanghailin.cn/centos-7-pptp/</a><br><a href="http://blog.sandy1890.com/2016/10/23/pptpd_iptables/" target="_blank" rel="noopener">http://blog.sandy1890.com/2016/10/23/pptpd_iptables/</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringBoot初尝试]]></title>
      <url>http://bfchengnuo.com/2017/10/15/SpringBoot%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。<br>通过这种方式，Boot 致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。<a id="more"></a><br>简单说就是为了实现免 XML 配置的开发体验，让开发者不在需要编写 XML 配置文件。</p>
<h2 id="进一步了解"><a href="#进一步了解" class="headerlink" title="进一步了解"></a>进一步了解</h2><p>都知道 Spring 框架功能很强大，项目中大多会使用吧，它带来方便的同时，也有一个麻烦的事，就算创建是一个很简单的项目，我们也要配置很多东西，写一堆的配置文件。<br>因此就有了 Spring Boot 框架，它的作用很简单，就是帮我们<strong>自动配置</strong>。Spring Boot 框架的核心就是自动配置，只要存在相应的 jar 包，Spring 就帮我们自动配置。<br>如果默认配置不能满足需求，我们还可以替换掉自动配置类，使用我们自己的配置。<br>另外，Spring Boot 还集成了嵌入式的 Web 服务器（所以可以脱离 Tomcat 来运行），系统监控等很多有用的功，让我们<strong>快速构建</strong>企业及应用程序。</p>
<p><strong>从名字也可以看出，它就是一个启动 spring 项目的一个工具而已，从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。</strong>简便起见，该框架也提供了命令行界面，它可以用来运行和测试 Boot 应用。</p>
<blockquote>
<p>  可以说 Spring 的整个生态系统都使用到了 Groovy 语言，感兴趣的可以了解下<br>  Spring Boot 不是一门新技术。从本质上来说，Spring Boot 就是 Spring，它做了一些对 Spring Bean 的默认配置。</p>
</blockquote>
<h3 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h3><p>以前在写 spring 项目的时候，要配置各种 xml 文件，还记得曾经被 ssh 框架支配的恐惧。随着spring3，spring4的相继推出，约定大于配置逐渐成为了开发者的共识，大家也渐渐的从写 xml 转为写各种注解，在spring4的项目里，你甚至可以一行xml都不写。<br>虽然spring4已经可以做到无xml，但写一个大项目需要茫茫多的包，maven 配置要写几百行，也是一件很可怕的事。<br>现在，快速开发一个网站的平台层出不穷，nodejs，php 等虎视眈眈，并且脚本语言渐渐流行了起来（Node JS，Ruby，Groovy，Scala等），spring 的开发模式越来越显得笨重。<br>在这种环境下，spring boot 伴随着 spring4 一起出现了。</p>
<h3 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h3><p>spring boot 并不是一个全新的框架，它<strong>不是</strong> spring 解决方案的一个替代品，而是 spring 的一个封装。所以，你以前可以用 spring 做的事情，现在用 spring boot 都可以做。<br>现在流行微服务与分布式系统，springboot 就是一个非常好的微服务开发框架，你可以使用它快速的搭建起一个系统。同时，你也可以使用 spring cloud（<strong>Spring Cloud是一个基于Spring Boot实现的云应用开发工具</strong>）来搭建一个分布式的网站。</p>
<ul>
<li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot 能自动提供相关配置</li>
<li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li>
<li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li>
<li>Actuator：让你能够深入运行中的Spring Boot应用程序，一套究竟。</li>
</ul>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>Spring Boot 是这几年 <strong>微服务</strong> 概念流行后，Spring 开发的一套快速开发 Spring 应用的框架（它非常年轻）。<br>它本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序（开箱即用，快速启动）。<br>也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），<strong>Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box）</strong>，大部分的 Spring Boot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<p>从概念上说，Spring Boot 需要使用到 Spring 框架的各个部分，并且对它们进行了大量的默认约定配置</p>
<p>PS：当你用过 SpringMVC 后再使用 Spring Boot 才能体会到是多么的幸福啊~~</p>
<blockquote>
<p>  spring boot 相当于腾讯的 Wegame，里面装了自家的各种游戏如 spring data 、spring mvc……<br>  你通过 Wegame 可以轻松 快速 安装、使用(引入、整合) Wegame 旗下的游戏</p>
</blockquote>
<h2 id="使用Java配置"><a href="#使用Java配置" class="headerlink" title="使用Java配置"></a>使用Java配置</h2><p>一般来说 Spring 中，IOC 推荐使用注解；AOP 推荐使用配置文件来配置；<br>到了 spring4.x+ 或者 springBoot 时代，官方则推荐使用 Java 配置的方式，可完全替代 XML。</p>
<p>使用 Java 配置最重要的就是两个注解： <strong>@Configuration 和 @Bean 注解</strong><br>带有 @Configuration 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。<br>@Bean 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean<br>简单说就是：@Configuration 注解相当于我们之前 Spring 的 XML 配置文件；@Bean 就相当于我们在 XML 中配置的 bean 标签。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 默认会扫描配置类所在的包</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=&#123;<span class="string">"com.bfchengnuo.service"</span>, <span class="string">"com.bfchengnuo.dao"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完全不用写配置文件了！上面的配置等同于：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.tutorialspoint.HelloWorld"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意 id 的名字哦，然后获取 IOC 容器就不是用 ClassPathXmlApplicationContext 而是 AnnotationConfigApplicationContext ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要在创建对象的时候注入一些参数，那就更简单了，直接用相应的构造函数 new 出来就行了，或者 set 设置，总之你返回的那个对象有相应的属性值就够了，引用其他 bean 也会了吧，这样一来一般是不会写错名字的。</p>
<p>另外还可以使用 <strong>@import</strong> 注解允许从另一个配置类中加载 @Bean 定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigA</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> A <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************分割线******************************/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(ConfigA.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigB</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> B <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> B(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在 AnnotationConfigApplicationContext 只需要传入一个 ConfigB.class 就够了，A 和 B 都可以获取到，其实和 import 标签差不多。<br>另外，其中也是可以使用 @Autowired 进行注入的，如果涉及到跨类（相当于跨配置文件）的引用，也可以用这个来解决，不要忘了扫描包就好了。<br>还可以使用 @ImportResource 注解来导入配置文件，达到混用的目的；然后还可以使用 @PropertySource 注解来引入外部配置文件，比如最常用的：<code>@PropertySource(value= {&quot;classpath:jdbc.properties&quot;})</code> ，然后在 Java 代码中的属性上使用 <code>@Value(&quot;${jdbc.url}&quot;)</code> 来注入即可</p>
<blockquote>
<p>  因为使用 @Configuration 注解的类本身也是一个Bean，因为 @Configuration 被 @Component 注解了，因此 @Configuration 注解可以指定 value 属性值，如 “ctxConfig” 就是该Bean的名字，如使用 <code>ctx.getBean(&quot;ctxConfig&quot;)</code> 将返回该 Bean。</p>
<p>  @Bean 注解的属性：<br>  <strong>name：</strong>指定 Bean 的名字，可有多个，第一个作为 Id，其他作为别名，默认不指定的时候使用方法名作为 ID；<br>  <strong>autowire：</strong>自动装配，默认 no 表示不自动装配该 Bean，另外还有 <code>Autowire.BY_NAME</code> 表示根据名字自动装配，<code>Autowire.BY_TYPE</code> 表示根据类型自动装配；<br>  <strong>initMethod和destroyMethod</strong>：指定 Bean 的初始化和销毁方法。<br>  <strong>使用 @Bean 注解的方法不能是 private、final 或 static 的</strong></p>
</blockquote>
<p><strong>在 Spring Boot项目中推荐使用 @SpringBootConfiguration 替代 @Configuration</strong></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>官方建议我们使用 Maven 或者 Gradle 来构建项目，然后这里就先用 Maven 了。<br>虽然 SpringBoot 可以零配置，但是还是建议写一个全局的配置文件，位置是 Resources 下，或者类路径下的 config 也行，但是不建议，名字也是固定写法，application.properties 或者 application.yml ，yml 格式的更简单吧，起码在 IDEA 中是有提示的。<br>还有一个好消息是 SpringBoot 中默认的编码统一设置为了 UTF-8 ，这就舒爽多了啊，下面就是一个简单的入门栗子，深入研究以后再说</p>
<h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>我是用 IDEA 建的工程，所以大部分都自动生成了，主要是 parent 是必须的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bfchengnuo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>firstspringboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>FirstSpringBoot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring-boot-starter-web 相当于是 web 的快速构建包（自动配置），需要其他技术的导入相应的依赖即可，plugin 可有可无，是为了能使用 mvn 命令启动工程，spring-boot-starter-data-jpa 相当于是对支持 jpa 的 ORM 框架的支持，我用 hibernate 所以可以理解为对 hibernate 的支持</p>
<h3 id="定义Controller"><a href="#定义Controller" class="headerlink" title="定义Controller"></a>定义Controller</h3><p>看过 SpringMVC 的都知道，这里的 Controller 和哪里的是一样的，使用起来也很熟悉，其实指的就是 springmvc 中的 handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入自定义属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;girl.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World! "</span> + name + <span class="string">"; age:"</span> + girl.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合注解，method=get</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World! "</span> + name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RestController 注解在 Spring4.x+ 的版本中加入，相当于 @ResponseBody 和 @Controller 的集合体；再来看看配置的 application.yml 文件（properties 文件也是可以的），其实不配也是完全可以的，这里是为了演示获取配置文件中的自定义属性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  context-path:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义属性</span></span><br><span class="line"><span class="attr">girl:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">测试</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>可以配一些 boot 相关的配置，有很多，放在 Github 了，然后还可以配自定义属性（Girl），甚至注入到对象，但是配置属性注入到对象并不推荐使用，还是单个值比较好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 注入自定义的配置（对象）</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"girl"</span>)</span><br><span class="line"><span class="comment">// @PropertySource("classpath:application.yml")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是利用配置文件的值来自动注入对象，但是不推荐使用，主要用到的是 @ConfigurationProperties 注解，prefix 用来确定是用什么前缀的配置注入</p>
<blockquote>
<p>  在新版的 SpringBoot 中，@ConfigurationProperties 去掉了 localhost 属性，在没指定路劲的情况下，默认在 resource 下的 applications.properties (yml) 中查找，如果找到则返回值，如果没有找到则返回默认值null/0/false…<br>  如果需要指定路径，配合 @PropertySource 和 @Component 注解</p>
</blockquote>
<h3 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h3><p>下面配一个 SpringBoot 的启动入口就可以直接启动了，不需要配 Tomcat、web.xml 之类的，只需要定义一个主函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// @ComponentScan(basePackages="com.bfchengnuo")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 启动 SpringBoot 所必须的入口</span></span><br><span class="line">		SpringApplication.run(FirstSpringBootApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication 注解是必须的，主要目的是开启自动配置，这就完成了，如果不是为了测试配置文件，可以更简单，只需要几行代码就可以完成</p>
<h2 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h2><p>可以使用分散配置，比如一份用于开发环境，一份用于生产环境：application-dev.yml ，application-prod.yml ；然后还需要一份主配置文件 application.yml ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 spring 的“环境”，加载那个配置文件</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/ssm?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  tomcat:</span></span><br><span class="line"><span class="attr">    uri-encoding:</span> <span class="string">utf-8</span></span><br></pre></td></tr></table></figure>
<p>主要是前三行，后面顺便配了数据源相关的东西，因为下面要说，配置在主配置文件中的内容全部环境都可以使用；<br>配置环境，除了使用多文件的方式也可以写在同一份配置文件中，不同的环境之间使用 <code>---</code> 进行分割就可以了。</p>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>这里使用的是 spring 提供的 spring-boot-starter-data-jpa 组件，然后使用的 ORM 框架是 hibernate，先确认以及导入了相关的依赖！<br>先是实体的定义，使用的全部是 JPA 注解的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@Min</span>(value = <span class="number">8</span>,message = <span class="string">"你太小了！"</span>)</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常熟悉了，使用了一个 @Min 注解，这是用来校验的，后面会看到，使用也非常的简单，按照以前的套路还需要写 Dao 层，现在只需要定义一个接口，继承 <strong>JpaRepository</strong> 就可以了，我把自己定义的这个接口放在了 Repository 包（和命名的最后保持一致比较好吧）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GirlRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Girl</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展接口，通过指定的条件来查询</span></span><br><span class="line">    <span class="function">List&lt;Girl&gt; <span class="title">findByAge</span> <span class="params">(Integer age)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型第一个就是对应的实体类，第二个是主键的类型，最好指定下；其实接口不用写任何东西就已经支持基本的 CRUD 操作了，如果需要自定义查询条件之类的，那么就需要再扩展，比如上面扩展的根据年龄字段查询，<strong>命名就是这么个格式，不要瞎写</strong><br>下面就是在 Controller 中的使用情况了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"girl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> GirlRepository girlRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"getList"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Girl&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> girlRepository.findAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"get/&#123;id&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> girlRepository.findOne(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"add"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Girl <span class="title">add</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name ,</span></span><br><span class="line"><span class="function">                  @<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> Integer age) </span>&#123;</span><br><span class="line">    Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line">    girl.setAge(age);</span><br><span class="line">    girl.setName(name);</span><br><span class="line"></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> girlRepository.save(girl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span>(<span class="string">"update"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Girl <span class="title">add</span><span class="params">(@Valid Girl girl, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">      System.out.println(bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> girlRepository.save(girl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"getAge/&#123;age&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Girl&gt; <span class="title">getAge</span><span class="params">(@PathVariable(<span class="string">"age"</span>)</span> Integer age) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> girlRepository.findByAge(age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GirlRepository 直接注入就可以了，其他的东西都是 springmvc 里的，应该比较属性了，主要就是 @Valid 注解用来校验的，结果会放到 BindingResult 中</p>
<h2 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h2><p>Spring 的精髓啊，怎么能不用一用呢，关于 Spring 中的 AOP 前面已经写的很清楚了，那就直接用了(如有必要，记得导入相应的类)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAspect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(HttpAspect.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.bfchengnuo.firstspringboot.controller.GirlController.*(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"log()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">    HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"url---&gt;&#123;&#125;"</span>, request.getRequestURL());</span><br><span class="line">    LOGGER.info(<span class="string">"method---&gt;&#123;&#125;"</span>, request.getMethod());</span><br><span class="line">    LOGGER.info(<span class="string">"ip---&gt;&#123;&#125;"</span>, request.getRemoteAddr());</span><br><span class="line"></span><br><span class="line">    LOGGER.info(<span class="string">"class_method---&gt;&#123;&#125;"</span>, joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"."</span> + joinPoint.getSignature().getName());</span><br><span class="line">    LOGGER.info(<span class="string">"args---&gt;&#123;&#125;"</span>, joinPoint.getArgs());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning</span>(returning = <span class="string">"o"</span>, pointcut = <span class="string">"log()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法执行完后的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">      LOGGER.info(<span class="string">"response:&#123;&#125;"</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说，非常简单的切面定义，使用了 slf 的 log4j 日志工具，确实是比较爽的</p>
<h2 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h2><p>异常用好了也能提高效率，这里定义了一个自定义异常，但并没怎么用，具体如何使用要看需求了，简单说说，毕竟这篇就是简单的初尝试而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GirlException</span><span class="params">(String message, Integer code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的就是要继承 RuntimeException ，否则 SpringBoot 不会进行回滚事务的，注意：Exception 的构造方法需要一个  message 哦。<br>既然有异常，那就有相应的处理（捕获）异常的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要捕获那个异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">// 转成 json....额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加了 @ControllerAdvice 注解它就会自动捕获规定的异常了，配合 @ExceptionHandler 注解使用，然后就随你怎么干了</p>
<h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><p>Spring 中应该是提供了专门的测试注解，这个我还没研究，这里说两种简单的测试，比如，这是 IDEA 自动生成的测试代码，可以借鉴一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)  <span class="comment">// 低层用的还是 Junit，表明是在测试环境下跑</span></span><br><span class="line"><span class="meta">@SpringBootTest</span>  <span class="comment">// 表明会启动整个工程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstSpringBootApplicationTests</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用断言</span></span><br><span class="line">		<span class="comment">// Assert.assertEquals();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最普通的测试了，SpringBootTest 很重要，只有加入了这个测试的时候才运行整个工程。<br>然后就是 MVC 的测试方法了，我们要测 URL 是不是能用啊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span>  <span class="comment">// 针对 MVC 的测试，为测试 URL 访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/getAge/12"</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对返回的内容进行判断断言</span></span><br><span class="line">        <span class="comment">// mvc.perform(MockMvcRequestBuilders.get("/getAge/12"))</span></span><br><span class="line">        <span class="comment">//         .andExpect(MockMvcResultMatchers.content().string("xxxx"));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也差不多，非常的简单，Spring 都提供给我们 MocMvc 这个类，一切就好说了。</p>
<p>执行 <code>mvn clean package</code> 命令打包的时候会自动进行测试，并显示结果(在命令行)；<br>由于一些原因也可以跳过测试直接打包：<code>mvn clean package -Dmaven.test.skip=true</code></p>
<h2 id="几种启动方式"><a href="#几种启动方式" class="headerlink" title="几种启动方式"></a>几种启动方式</h2><p>启动 SpringBoot 项目常用的就这三种:<br>第一就是 IDE 直接启动（通过 @SpringBootApplication 配合 SpringApplication.run）;<br>第二种是使用 java 命令来启动：<code>java -jar xxx.jar -spring.profiles.active=dev</code> 后面可以加一些参数，为了得到这个 jar 所以最好先 <code>mvn install</code> 命令来安装下;<br>第三种是用 mvn 命令来运行：<code>mvn spring-boot:run</code> ，但需要在 pom 文件中导入了相应的插件才行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于调试来说，这几种都算是非常方便的，因为内嵌了 tomcat 这种服务器，所以即使单独运行 jar 也是可以的，真正在部署的时候还是用 war 包比较稳！</p>
<h2 id="关于2-0"><a href="#关于2-0" class="headerlink" title="关于2.0"></a>关于2.0</h2><p>现在发布了 SpringBoot2.X 版本，虽然还不是正式版，变动有点大，下面来稍微总结下，在 Github 的代码仓库里有一个用 2.0 的例子，可参考。<br>然后，sb2.x 是基于 spring framwork 5.0 的，所以要 jdk8+，这样才能使用某些特性。<br>全新特性：<strong>web flux</strong> 包含：</p>
<ul>
<li>声明式的函数编程  Java8 的 lambda</li>
<li>响应式编程，Reactive Streams</li>
<li>异步编程，Servlet 3.1 或 Asyc NIO</li>
</ul>
<p>其他的还没看到，先 TODO….</p>
<h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://blog.csdn.net/qq_31655965/article/details/71258191" target="_blank" rel="noopener">http://blog.csdn.net/qq_31655965/article/details/71258191</a><br><a href="https://www.tianmaying.com/qa/205" target="_blank" rel="noopener">https://www.tianmaying.com/qa/205</a><br><a href="https://waylau.gitbooks.io/spring-boot-tutorial/docs/overview.html" target="_blank" rel="noopener">Spring Boot 是什么，不是什么</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSM框架整合简述]]></title>
      <url>http://bfchengnuo.com/2017/10/11/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E7%AE%80%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>现在最流行的应该就是 SSM 了，SSH 一去不复返，SSM 指的是：SpringMVC + Spring + MyBatis<br>弃用 Struts2 的原因在于漏洞比较多吧（毕竟人用的也多），危害还比较大，<del>官方实力甩锅</del> <a id="more"></a><br>至于弃用 Hibernate 倒不是它不好，因为太大了，对于小项目用不着这么重量级的东西，MyBatis 这种轻量级的框架是很适合的，并且性能也好<br>不得不说，相比 SSH 来说，SSM 整合确实更加简单，错觉？</p>
<h2 id="Spring和MyBatis整合"><a href="#Spring和MyBatis整合" class="headerlink" title="Spring和MyBatis整合"></a>Spring和MyBatis整合</h2><p>万年不变定律，先导包，除了 Spring 和 MyBatis 的基本包，别忘了还有一个 MyBatis-spring 的“插件包”，应该也是需要连接池的吧，除了 C3P0 还可以选择 bonecp，据说它的性能比 C3P0 还高，如果用它就别忘了导入 bonecp-spring 的依赖，我的栗子用的 Maven 构建的，pom 文件一览：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bfchengnuo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>FirstSSM<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.0.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- log4j日志文件管理包版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试、日志依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring 相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--MyBatis 相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--整合相关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jolbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bonecp-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Jackson Json处理工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Apache工具组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JSP 相关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>FirstSSM<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--设置编译版本--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">showWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWarnings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样大部分依赖就处理完了，接下来就是配置 Spring、MyBatis 的环境，就是写写配置文件，这里我拆了一下，分成 jdbc.properties 、log4j.properties 、applicationContext.xml 、applicationContext-mybatis.xml 等几个文件：<br>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG,A1</span><br><span class="line">log4j.logger.org.mybatis = DEBUG</span><br><span class="line">log4j.appender.A1=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n</span><br></pre></td></tr></table></figure>
<p>applicationContext：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置扫描器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--设置数据源--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.jolbox.bonecp.BoneCPDataSource"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 相应驱动的jdbcUrl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库的用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库的密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 检查数据库连接池中空闲连接的间隔时间，单位是分，默认值：240，如果要取消则设置为0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriodInMinutes"</span> <span class="attr">value</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池中未使用的链接最大存活时间，单位是分，默认值：60，如果要永远存活设置为0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleMaxAgeInMinutes"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个分区最大的连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxConnectionsPerPartition"</span> <span class="attr">value</span>=<span class="string">"150"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个分区最小的连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minConnectionsPerPartition"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>applicationContext-mybatis （数据源的定义我想抽在这里也许也比较好）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 结合Spring和Mybatis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定MyBatis的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis-config.xml"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mappers/UserMapper.xml"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置别名扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.bfchengnuo.pojo"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 扫描包，Spring 会自动查找其下的类（mapper），将其实例化 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.bfchengnuo.mapper"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多数据源的时候使用下面指定 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name = "sqlSessionFactoryBeanName" value = "sqlSessionFactory" /&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本实现了自动化，根据定义的接口自动实例化 Mapper ，通过包扫描的方式来自动扫描定义的接口，这样不需要使用 getMapper 方法了，也不需要自己在 beans 中一个个的定义 Mapper 了。<br>其中引用了 MyBatis 的配置文件，这个文件的大部分内容都可以在 spring 中配置了，少数几个还不行，比如 Settings、插件等还是需要配置在 MyBatis 的配置文件中才行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启驼峰映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样配置文件就算是写完了，接下来就是写几个 mapper 映射文件和 mapper 对应的接口去测试一下了，详情参考 <a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/FirstSSM" target="_blank" rel="noopener">Github</a></p>
<h2 id="与SpringMVC整合"><a href="#与SpringMVC整合" class="headerlink" title="与SpringMVC整合"></a>与SpringMVC整合</h2><p>这个就更简单了，SpringMVC 本来就是 spring 的子项目，可以说是无缝整合，不需要其他任何的插件包，直接导入 spring-web 包就可以用了，记得写写配置文件就行：<br>firstssm-servlet.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--定义注解驱动--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--controller 扫描包--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo.controller"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--定义视图解析器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最后有 / 啊！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--避免静态资源被拦截--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后把关键的 web.xml 文件搞一搞就完事了！</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                             http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>FirstSSM<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--手动指定 spring 文件的位置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring的ApplicationContext 载入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 编码过滤器，以UTF8编码，处理POST方式提交的乱码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--Spring MVC 配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义SpringMVC配置文件路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/firstssm-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 随容器自动启动完成初始化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截所有的请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为配置的是拦截所有的请求，所以记得在 springmvc 的配置文件中放行静态资源，要不然 css、js 都是会 404 的</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>然后就可以写个简单的栗子看看行不行了，来看定义的 controller ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时测试</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"users"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"getList"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"users"</span>);</span><br><span class="line">    List&lt;User&gt; users = userService.queryUserList();</span><br><span class="line">    mv.addObject(<span class="string">"userList"</span>,users);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了自动包扫描就是方便，只需要配置一个 @Controller 注解就可；然后是 service，很薄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userMapper.queryUserList();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省下的 mapper 接口和相应的映射文件就不贴了，完整代码：<a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/FirstSSM" target="_blank" rel="noopener">Github</a></p>
<h2 id="关于外部配置文件"><a href="#关于外部配置文件" class="headerlink" title="关于外部配置文件"></a>关于外部配置文件</h2><p>有时候需要从 properties 文件中加载配置，最原始的方案是这样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 允许JVM参数覆盖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"systemPropertiesModeName"</span> <span class="attr">value</span>=<span class="string">"SYSTEM_PROPERTIES_MODE_OVERRIDE"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 忽略没有找到的资源文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreResourceNotFound"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置资源文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到后来是这样的（Spring 也推荐这样用）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:spring/jdbc.properties"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上两种方式，在 bean 定义中依然可以通过“${}”这种方式来取值。<br><code>&lt;context:property-placeholder/&gt;</code> 这个基于命名空间的配置，其实内部就是创建一个 PropertyPlaceholderConfigurerBean 而已，并且它有一个“有趣”的现象：<br>使用分散配置的方式，在两个模块中都引入了这个标签，单独运行某个模块没问题，当一起运行时就会报 <code>Could not resolve placeholder...</code> 的错误。</p>
<blockquote>
<p>  原因：<br>  Spring 容器采用反射扫描的发现机制，在探测到 Spring 容器中有一个 PropertyPlaceholderConfigurer 的 Bean 就会停止对剩余PropertyPlaceholderConfigurer 的扫描（Spring 3.1 已经使用 PropertySourcesPlaceholderConfigurer 替代PropertyPlaceholderConfigurer 了）。<br>   换句话说，即 Spring 容器仅允许最多定义一个 PropertyPlaceholderConfigurer (或 <code>&lt;context:property-placeholder/&gt;</code> )，其余的会被 Spring 忽略掉</p>
</blockquote>
<p>至于如何解决，我找到了两种，第一种就是不使用分散配置了，集合读取：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:conf/conf*.properties"</span>/&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"a.xml"</span>/&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"b.xml"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式应该算是比较优雅的了，如果有特殊需求，不能使用这种方式，可以用第二种来“强制”支持多个pp标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">order</span>=<span class="string">"1"</span> <span class="attr">location</span>=<span class="string">"classpath*:conf/conf_a.properties"</span> <span class="attr">ignore-unresolvable</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这两个配置可能不在一个文件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">order</span>=<span class="string">"2"</span> <span class="attr">location</span>=<span class="string">"classpath*:conf/conf_b.properties"</span> <span class="attr">ignore-unresolvable</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先来解释下这两个属性：</p>
<ul>
<li><strong>ignore-unresolvable</strong><br>单独使用来看是“是否忽视不存在的配置项”，不仅如此，经过测验，有一个隐含意思：是否还要扫描其他配置项：如果扫描到的为 false，则会忽视后续的 property-placeholder<br>默认值为 false</li>
<li><strong>order</strong><br>会反应出顺序，值越小优先级越高即越早执行</li>
</ul>
<p>也就是说，当配置多个 property-placeholder 的时候，要配置 order，并且最后一个的 ignore-unresolvable 要保证为 false，其他的为 true</p>
<h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>上面的基本配置中应该是没有加入事务管理的，除去纯 AOP 的配置，常用的还有“声明式”和“编程式”，他们两个是可以共同使用的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tx"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 标识事务唯一，配合注解的 value 在多事务管理器的场景下使用 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;qualifier value=""/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 默认使用JDK的接口代理，如果没有接口就不起作用 proxy-target-class=false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"tx"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是“声明式”事务的简单配置，这样可以在要启用事务的方法上直接使用 <code>@Transactional</code> 注解来开启事务，然后通过 propagation 属性可以配置其传播特性等，只需要注意下嵌套方法调用的情况就好了。<br>还有就是事务一般是加在 Service 层，加在 Controller 层会失效，起码和 SpringMVC 时是这样，这里和父子容器有点关系，还有就是在扫描时注意子容器的范围，这个在 Github 已经做了笔记。<br>然后下面就来介绍“编程式”事务：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- transactionManager 配置和上面一样，省略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编程式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tt"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"tx"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实就是配置了个 TransactionTemplate，然后在代码中手动调用 TransactionTemplate 来管理事务，这样能解决多线程下 <code>@Transactional</code> 事务失效的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  template.execute((status) -&gt; &#123;</span><br><span class="line">    <span class="comment">// TransactionStatus - status 参数：事务开启、回滚等状态</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(UUID.randomUUID().toString());</span><br><span class="line">    user.setUsername(<span class="string">"Nxuan"</span>);</span><br><span class="line">    <span class="comment">// int x = 1/0;</span></span><br><span class="line">    <span class="keyword">return</span> userMapper.add(user);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果不想写 <code>@Transactional</code>  注解，可以使用纯 AOP 的配置方式，简单贴下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义事务策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有以 query 开头的都是只读的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他方法默认 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义一个切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"myPointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.bfchengnuo.manage.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"myPointcut"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过这种总体来说用的不算多，但是某些情景下是非常实用的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.iteye.com/topic/1131688" target="_blank" rel="noopener">http://www.iteye.com/topic/1131688</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> MyBatis </tag>
            
            <tag> SSM </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC学习笔记（二）]]></title>
      <url>http://bfchengnuo.com/2017/10/06/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>接着上一篇来说，这篇包括 RequestMapping 的进一步探索、与 Struts2 的主要区别、为什么用 JSTL、设置 JSON 格式相关、文件上传以及（自定义）拦截器的相关内容。<a id="more"></a><br>相比之下这篇的内容就少了，果然 SpringMVC 是轻量级的原因么，比 Struts 的篇幅要少得多，但依然做到高效开发，有一些源码级别的内容还没深入看，以后慢慢再继续补充。</p>
<h2 id="深入RequestMapping"><a href="#深入RequestMapping" class="headerlink" title="深入RequestMapping"></a>深入RequestMapping</h2><p>都知道它是一个处理请求地址的注解，来研究下当一个方法被 @RequestMapping 标记后（处理器方法），它所支持的方法参数和返回类型。</p>
<h3 id="支持的方法参数"><a href="#支持的方法参数" class="headerlink" title="支持的方法参数"></a>支持的方法参数</h3><ol>
<li>HttpServlet 对象，主要包括 HttpServletRequest 、HttpServletResponse 和 HttpSession 对象。<br>但是有一点需要注意的是在使用 HttpSession 对象的时候，如果此时 HttpSession 对象还没有建立起来的话就会有问题。</li>
<li>Spring 自己的 WebRequest 对象。<br>使用该对象可以访问到存放在 HttpServletRequest 和 HttpSession 中的属性值。</li>
<li>InputStream 、OutputStream 、Reader 和 Writer 。<br>InputStream 和 Reader 是针对 HttpServletRequest 而言的，可以从里面取数据；OutputStream 和 Writer 是针对 HttpServletResponse 而言的，可以往里面写数据。</li>
<li>使用 @PathVariable 、@RequestParam 、@CookieValue 和 @RequestHeader 标记的参数。</li>
<li>使用 @ModelAttribute 标记的参数。</li>
<li>java.util.Map 、Spring 封装的 Model 和 ModelMap 。<br>这些都可以<strong>用来封装模型数据</strong>，用来给视图做展示。</li>
<li>实体类。<br>可以用来接收上传的参数。</li>
<li>Spring 封装的 MultipartFile 。<br>用来接收上传文件的。</li>
<li>Spring 封装的 Errors 和 BindingResult 对象。<br>这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</li>
</ol>
<p>仔细看看确实不算少，但大部分都已经看过了。</p>
<h3 id="支持的返回类型"><a href="#支持的返回类型" class="headerlink" title="支持的返回类型"></a>支持的返回类型</h3><ol>
<li>一个包含模型和视图的 ModelAndView 对象。</li>
<li>一个模型对象，这主要包括 Spring 封装好的 Model 和 ModelMap ，以及 java.util.Map ，当没有视图返回的时候视图名称将由 RequestToViewNameTranslator 来决定。</li>
<li>一个 View 对象。<br>这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。</li>
<li>一个 String 字符串。<br>这往往代表的是一个视图名称。这个时候如果在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。</li>
<li>返回值是 void 。<br>这种情况一般是我们直接把返回结果写到 HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用 RequestToViewNameTranslator 来返回一个对应的视图名称。<br>如果视图中需要模型的话，处理方法与返回字符串的情况相同。</li>
<li>如果处理器方法被注解 @ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过 HttpMessageConverters 转换之后写到 HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。</li>
<li>除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理；<br>而返回的视图还是由 RequestToViewNameTranslator 来决定，<br>添加到模型中的属性名称可以在该方法上用 @ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。<br>使用 @ModelAttribute 标记的方法会在 @RequestMapping 标记的方法执行之前执行。</li>
</ol>
<h2 id="与Struts2的区别"><a href="#与Struts2的区别" class="headerlink" title="与Struts2的区别"></a>与Struts2的区别</h2><p>它们两者的实现机制是不同的，所以说区分是很大的，主要是下面几点：</p>
<ul>
<li>SpringMVC 的入口是 Servlet，Struts2 是基于 Filter，所以就说它们的实现机制是不同的</li>
<li>SpringMVC 是基于方法的设计，也就是说传递参数是通过方法的形参，实现是单例（Spring 实例化对象默认就是单例），也推荐单例，这样就省去了创建、销毁对象的过程，提高效率，并且使用方法的形参传值，也不需要担心并发问题。<br>Struts2 是基于类设计，传递参数通过类的属性，只能设置为多例。</li>
<li>参数传递方面，Struts2 因为是用类属性接收，所以不同方法可以共享；但是在 SpringMVC 中多个方法直接不能共享参数，因为是基于方法的嘛</li>
</ul>
<h2 id="使用JSTL"><a href="#使用JSTL" class="headerlink" title="使用JSTL"></a>使用JSTL</h2><p>前面学过，JSTL 是个标签库，为什么要使用 JSTL 呢？SpringMVC 没有么？<br>答案是 SpringMVC 有自己的标签库，但是并没有 Struts2 的那么强大，所以就没有必要用它的了，使用经典成熟的 JSTL 或许是更好的选择。<br>在讲框架流程的时候也说了，最终模型里的数据会填充到 Request 域，所以 JSTL 可以直接获取数据来用的。<br>只要你还记得导 C 标签库和会用 JSTL 就行….</p>
<h2 id="输出-amp-输入为JSON"><a href="#输出-amp-输入为JSON" class="headerlink" title="输出&amp;输入为JSON"></a>输出&amp;输入为JSON</h2><p>在上一篇的 @ResponseBody 注解中提到了，使用了这个注解就意味着是不正常的输出（其他视图），默认就是 JSON。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/userlist"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">show</span> <span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>返回值是 List，<strong>当加入了 Jackson 的依赖后</strong>，会自动注册其对应的转换器，最终响应的就是 JSON 数据格式了，会自动把 List 对象序列化为 JSON 格式的数据。<br>当输入为 JSON 的时候就需要用 @RequestBody 来处理了，它们一个是从对象到 JSON，一个是 JSON 到对象（这里以 JSON 这种格式为例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(@RequestBody User user)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 获取原始 JSON 数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(@RequestBody String user)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这个栗子就是接收一个 JSON 数据，然后反序列为 user 对象。</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>这里就用比较简单的方式了，Spring 自带的上传功能效率好像更好些，比较复杂，稍后再说；<br>首先要添加 Apache 的 commons-fileupload 依赖，上传功能依赖于它；然后在 SpringMVC 的配置文件中做相应的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 上传文件的设置 ，maxUploadSize=-1，表示无穷大。uploadTempDir为上传的临时目录 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">p:defaultEncoding</span>=<span class="string">"UTF-8"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">p:maxUploadSize</span>=<span class="string">"5400000"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">p:uploadTempDir</span>=<span class="string">"fileUpload/temp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用了 p 命名空间，不记得？去看 spring 笔记二。可以配合 Spring 提供的 CharacterEncodingFilter 来简单处理下乱码问题。<br>如果怕出异常（如超出限制），可以配下 exceptionResolver 这个 bean。<br>然后定义处理上传文件的控制器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value=<span class="string">"/uploadfile"</span>,method=RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upLoadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"upload"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value=<span class="string">"/uploadfile"</span>,method=RequestMethod.POST)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">upLoadFile</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile[] myfiles, HttpServletRequest request) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//如果只是上传一个文件，则只需要MultipartFile类型接收文件即可</span></span><br><span class="line">    <span class="keyword">for</span>(MultipartFile myfile : myfiles) &#123;</span><br><span class="line">      <span class="keyword">if</span>(myfile.isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"文件未上传"</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">"文件长度: "</span> + myfile.getSize()); </span><br><span class="line">        System.out.println(<span class="string">"文件类型: "</span> + myfile.getContentType()); </span><br><span class="line">        System.out.println(<span class="string">"文件名称: "</span> + myfile.getName()); </span><br><span class="line">        System.out.println(<span class="string">"文件原名: "</span> + myfile.getOriginalFilename()); </span><br><span class="line">        System.out.println(<span class="string">"==================="</span>); </span><br><span class="line"></span><br><span class="line">        String realPath = request.getSession().getServletContext().getRealPath(<span class="string">"/WEB-INF/upload"</span>);</span><br><span class="line">        <span class="comment">// FileUtils.copyInputStreamToFile() 会自动关流 </span></span><br><span class="line">        FileUtils.copyInputStreamToFile(myfile.getInputStream(), <span class="keyword">new</span> File(realPath + <span class="string">"/"</span> +myfile.getOriginalFilename()));</span><br><span class="line">        <span class="comment">// 或者使用下面的方式保存</span></span><br><span class="line">        <span class="comment">// myfile.transferTo(new File(realPath + "/" +myfile.getOriginalFilename()));</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/success.html"</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这些方法的返回值都是 String 类型的，根据前面所讲，对应的就是视图名了，如果字符串是以 redirect 开头，那就表示是以重定向的方式跳转到后面的地址。<br>然后，可以看到文件上传多数是通过 MultipartFile 这个对象来处理的，能够理解为什么前面在配置文件中配了个 MultipartResolver 解析器了吧。<br>Spring使用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResolver；<br>如果上传的是超大文件，还是使用流式传输比较好（使用 CommonsMultipartFile  对象来接收），虽然慢，但是省资源。<br>因为 <em>transferTo()</em> 函数调用 <em>write()</em> 函数，而这个函数要求上传文件已经要在内存中，或者是在磁盘里，才能成功执行。</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>这一块的学习成本应该是比较低的，据说 SpringMVC 的拦截器思想来源就是 Struts2，所以应该差不多。<br>SpringMVC 拦截器接口（<strong>HandlerInterceptor</strong>）定义了三个方法：</p>
<ul>
<li>preHandle<br>该方法在目标方法之前被调用（调用 Handler 之前），在该方法中对用户请求 request 进行处理<br>若返回值为 true, 则继续调用后续的拦截器和目标方法.<br>若返回值为 false, 则不会再调用后续的拦截器和目标方法.<br>可以考虑做权限. 日志, 事务等。<br>方法中的 Object 对象，对于静态资源是 ResourceHttpRequestHandler 类型（一般都会进行排除不会拦截的）；对于动态资源是 HandlerMethod 类型，通过它可以获得 Method 等对象。</li>
<li>postHandle<br>调用目标方法之后, 但渲染视图之前.<br>可以对请求域中的属性或视图做出修改，也就是说：<br>这个方法在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求 request 进行处理。</li>
<li>afterCompletion<br>渲染视图之后被调用（在 DispatcherServlet 完全处理完请求后）. 可用来释放资源</li>
</ul>
<p>自定义拦截器就不贴了，建个类，实现 HandlerInterceptor 接口就行了，就是上面的那三个方法，光写完了是没卵用的，还需要配置进 springmvc 的配置文件，这样它才知道你写了，然后才会执行（还记得框架流程图里的执行链？）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置自定义的拦截器，这样写所有请求都会生效 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.MySpringMVC.interceptors.FirstInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面看比较理性的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置拦截器作用的路径；/** 为所有请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/emps"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若要配置不起作用的路径，则使用 &lt;mvc:exclude-mapping path=""/&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果使用了 @Component 注解，可以用 ref 来指定，id 默认类名首字母小写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.MySpringMVC.interceptors.SecondInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前面说过吧，<code>/**</code> 是指所有目录，也可以认为是所有请求了。<br>注意：即使配置了 mvc:resources 或者 mvc:default-servlet-handler 排除静态资源，但是除了视图（jsp、html）其他静态资源也会被拦截，需要再配置放行规则。</p>
<hr>
<p>然后下面就是重点的顺序问题，和 Struts 相似，preHandle 按照配置文件的顺序执行，剩余两个按照配置顺序的反序执行，应该能想得通吧。<br>工作流程（建议参考源码）：</p>
<ol>
<li>当页面发送请求后，DispatcherServlet 会通过其中的 HandlerExecutionChain 对象依次调用各拦截器的的 preHandle() 方法。<br>该 HandlerExecutionChain 对象，其中的 <strong>interceptors</strong> 属性记录了当前项目配置的所有拦截器，除了我们自定义的两个拦截器以外，还有一个 SpringMVC 内置的 ConversionServiceExposingInterceptor 拦截器。<br>此外，还有一个 int 型参数 <strong>interceptorIndex</strong> 用于记录当前时刻 preHandle() 方法已经返回 true 的拦截器的最大下标；<br>例如现在我们的 SecondInterceptor 拦截器的 preHandle() 方法返回了 false，那么 interceptorIndex 参数便为1，代表拦截器 ConversionServiceExposingInterceptor 和 FirstInterceptor 的 preHandle() 方法返回了 true</li>
<li>当 HandlerExecutionChain 对象发现某拦截器的 preHandle() 方法返回了 false 后，便执行 triggerAfterCompletion() 方法用于从下标值为 interceptorIndex 开始执行各拦截器的 <strong>afterCompletion()</strong> 方法，直到下标值减为 -1 为止<br>然后执行链直接 return，终止执行。</li>
<li>如果 HandlerExecutionChain 对象发现某拦截器的 preHandle() 方法返回的是 true ，那么会继续执行下一个的 preHandle，全部执行完后再执行 Handler 的具体逻辑</li>
<li>Handler 执行完毕后，开始倒序执行 postHandle() 各拦截器的后置方法</li>
<li>后置方法调用完成后开始渲染视图（利用 ModelAndView 对象），渲染完成后倒序调用拦截器的完成方法 afterCompletion()</li>
</ol>
<p>也就是说，无论第二个拦截器的 preHandle 返回的是什么，第一个（<strong>已经通过的拦截器</strong>）的 afterCompletion 都会执行；但是如果返回的是 false，Handler 和 postHandle 就不会执行了。</p>
<blockquote>
<p>和过滤器的区别：<br>简单来说，过滤器什么都能拦下来，而拦截器则不一定，看框架的实现，比如 SpringMVC 的拦截器就不拦视图。<br>其次，过滤器是 Servlet API 里的，其中不能注入 Spring IoC 的对象；拦截器是 Spring 自己的（SpringMVC 中），就可以使用了。</p>
</blockquote>
<h2 id="使用RESTful"><a href="#使用RESTful" class="headerlink" title="使用RESTful"></a>使用RESTful</h2><p>前面最开始的时候页介绍了，SpringMVC 支持 RESTful 风格，原来是使用 @ResponseBody 注解来转成相关的 json 格式，其实不需要这么的复杂。<br>这里必须要说下 <code>ResponseEntity&lt; T&gt;</code> 这个对象了:</p>
<blockquote>
<p>ResponseEntity 意味着表示整个 HTTP 响应。你可以控制任何进入它：状态码，标题和正文。<br>@ResponseBody 是 HTTP 响应正文的标记，@ResponseStatus 声明 HTTP 响应的状态代码。</p>
</blockquote>
<p>来看几个栗子就知道是怎么回事了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"rest/girl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RestfulController.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> GirlService girlService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"&#123;id&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ResponseEntity&lt;Girl&gt; <span class="title">getGirl</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"-----------------&gt;"</span> + id);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Girl girl = girlService.queryGirl(id);</span><br><span class="line">      <span class="keyword">if</span> (girl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 200 可以进行简写</span></span><br><span class="line">      <span class="keyword">return</span> ResponseEntity.ok(girl);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">saveGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"--------------&gt;"</span> + girl.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (girl.getName().isEmpty() || girl.getAge().toString().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 400 错误，参数不正确</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).build();</span><br><span class="line">      &#125;</span><br><span class="line">      Boolean flag = girlService.saveGirl(girl);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 新增成功，响应 201,如果返回是 void 可以使用 build 方法</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增失败</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.PUT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">updateGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"--------------&gt;"</span> + girl.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (girl.getName().isEmpty() || girl.getId().toString().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 400 错误，参数不正确</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).build();</span><br><span class="line">      &#125;</span><br><span class="line">      Boolean flag = girlService.updateGirl(girl);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 修改成功，响应 204,如果返回是 void 可以使用 build 方法</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NO_CONTENT).build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增失败</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.DELETE)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">deleteGirl</span><span class="params">(@RequestParam(value = <span class="string">"id"</span>,defaultValue = <span class="string">"0"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).build();</span><br><span class="line">      &#125;</span><br><span class="line">      Boolean flag = girlService.deleteGirl(id);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 删除成功，响应 204</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NO_CONTENT).build();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增失败</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的时候会自动把实体里的属性（凡是有 getter 方法的）转换成 JSON 类型的格式(默认)返回，同时可以设置状态码之类的，总之就是非常的全面了，先说这些，等以后再补充。</p>
<p>其他相关的注解：</p>
<ul>
<li>@RestController：<br>Spring 4 的新注解。 她自动为每个方法加上 @ResponseBody ；<br>@RestController 可以看做是 @Controller 和@ResponseBody 两个注解的组合。</li>
<li>@RequestBody：<br>如果一个方法申明了 @RequestBody 注解, Spring 会基于请求头中的 Content-Type 使用 HTTP Message converters 将 request body 反序列化成对象。</li>
<li>@ResponseBody：<br>是在方法的上注解，如果一个方法申明了@ResponseBody, Spring 会基于请求头中的 Accept 使用 HTTP Message converters 将对象序列化成 response body。<br>在 Spring 4 中如果使用了 @RestController，则可以不用再声明此注解。</li>
</ul>
<h2 id="关于父-子容器"><a href="#关于父-子容器" class="headerlink" title="关于父/子容器"></a>关于父/子容器</h2><p>当我们的项目中引入了 Spring + SpringMVC 后，在启动后其实有两个 Spring 容器，一个是 Spring 的容器（处理 Bean），一个是 SpringMVC 的容器（处理 Controller），它们是父子关系，Spring 就是父容器了！<br>它们的关系：</p>
<ul>
<li><strong>子容器能够访问父容器的资源（Bean）</strong><br>比如说在 Controller 中可以引用（注入） Service 中的 Bean</li>
<li><strong>父容器不能访问子容器中的资源</strong><br>这也就说明了为什么在 Spring 的配置文件中配置了扫描包，而在 SpringMVC 的配置文件中却还要再配置</li>
</ul>
<p>然后再说下 @Value 这个注解，<strong>它就是用来获取配置文件中的值的</strong>；时机就是在所有 Bean 初始完成后从<strong>当前所在容器中</strong>获取值，然后注入；所以说如果在 Controller 中使用可能获取不到（假设配置在 Spring 文件中读取），即使子容器能够访问父容器，但是优先级最高的还是注解自身的特性。<br>解决方案可以采用在 Service 中写一个 <strong>propertiesService</strong> 专门用来注入配置文件的值，然后在 Controller 中注入这个 Service 来间接的使用配置文件中的值。<br>在它们整合的时候，SpringMVC 其实会扫描是否存在 Spring 容器（存在 Application 域，所以还算好找），如果存在就把它作为父容器，如果不存在它会自己搞一个（具体不是很清楚）</p>
<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>在 SpringMVC 中遵循：路径匹配，先最长路径匹配，再最短路径匹配；优先级最高的精确匹配就不说了。<br>所以说 <code>/*</code> 可以匹配所有，如果设置为 <code>&lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;</code> 那么 <code>/abc/def/user/list</code> 也是可以匹配到的，我想说明的就是这个，在以前的文章中应该提到过，不过我没找到呢。</p>
<h2 id="关于放行静态资源"><a href="#关于放行静态资源" class="headerlink" title="关于放行静态资源"></a>关于放行静态资源</h2><p>当 SpringMVC 拦截 <code>/</code> 的时候，会拦截所有请求，这时候需要配置让其放行静态资源，方式有几种：</p>
<ul>
<li>激活Tomcat的defaultServlet来处理静态文件</li>
<li>XML 中使用 <strong>mvc:resources</strong> 标签</li>
<li>XML 中使用 <strong>mvc:default-servlet-handler</strong> 标签</li>
</ul>
<p>对于方案一，要写在 DispatcherServlet 的前面， 让 defaultServlet 先拦截，这个就不会进入 Spring 了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>     </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>         </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>      </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>          </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>         </span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于默认 servlet 是专门处理静态资源的，名字也不是乱写的：</p>
<blockquote>
<p>Tomcat, Jetty, JBoss, and GlassFish  默认 Servlet的名字 – “default”<br>Google App Engine 默认 Servlet的名字 – “_ah_default”<br>Resin 默认 Servlet的名字 – “resin-file”<br>WebLogic 默认 Servlet的名字  – “FileServlet”<br>WebSphere  默认 Servlet的名字 – “SimpleFileServlet”</p>
</blockquote>
<hr>
<p>方案二配置：<code>&lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot; /&gt;</code></p>
<ul>
<li>location 指定静态资源的位置，可以是 web application 根目录下、jar 包里；多个路径可使用 <code>,</code> 分割</li>
<li>mapping 指的是 location 映射成的路径，前端请求访问的就是这个路径，<code>**</code> 表示的是包含多层目录。</li>
</ul>
<p><strong>由 Spring MVC 框架自己处理静态资源</strong>，并添加一些有用的附加值功能。</p>
<blockquote>
<p> <code>&lt;mvc:resources /&gt;</code> 允许静态资源放在任何地方，如 WEB-INF 目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。<br>通过 location 属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。<br>传统 Web 容器的静态资源只能放在 Web 容器的根路径下，<code>&lt;mvc:resources /&gt;</code> 完全打破了这个限制。 </p>
<p>其次，<code>&lt;mvc:resources /&gt;</code> 依据当前著名的 Page Speed、YSlow 等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。<br>在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能 。</p>
</blockquote>
<hr>
<p>方案三是用的最多的一种，<strong>将静态资源的处理经由 Spring MVC 框架交回Web应用服务器处理</strong> 。<br>定义此标签后，会在 Spring MVC 上下文中定义一个 <code>org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler</code>，它会像一个检查员，对进入 DispatcherServlet 的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。<br>一般 Web 应用服务器默认的 Servlet 名称是 “default”，因此 DefaultServletHttpRequestHandler 可以找到它。如果你所有的 Web 应用服务器的默认 Servlet 名称不是 “default”，则需要通过 default-servlet-name 属性显示指定：<br><code>&lt;mvc:default-servlet-handler default-servlet-name=&quot;所使用的Web服务器默认使用的 Servlet 名称&quot; /&gt;</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>接收数据时用到日期时，默认 SpringMVC 是不会处理的，如果使用的是 po 来接收，那么肯定会转换异常，这时可以使用 <code>@DateTimeFormat</code> 注解来格式化，它有一个 pattern 参数可以指定日期的格式，比如：<code>@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</code><br>类似的，SpringMVC 提供其他多个 format，比如 NumberFormat 需要时了解吧</p>
<hr>
<p>如果只是简单的跳转视图逻辑，那么可以使用 <code>&lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;/&gt;</code> 来配置，省的单独写一个 controller 方法了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-interceptor.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-interceptor.html</a><br><a href="http://blog.csdn.net/xiangwanpeng/article/details/53157756" target="_blank" rel="noopener">http://blog.csdn.net/xiangwanpeng/article/details/53157756</a><br><a href="http://www.jianshu.com/p/58cf4936c523" target="_blank" rel="noopener">http://www.jianshu.com/p/58cf4936c523</a><br><a href="https://www.cnblogs.com/fangqi/archive/2012/10/28/2743108.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangqi/archive/2012/10/28/2743108.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/10/05/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>SpringMVC 是 Spring 的一个模块，提供 web 层解决方案；和众多其他web框架一样，它基于MVC的设计理念，此外，它采用了松散耦合可插拔组件结构，比其他MVC框架更具扩展性和灵活性。<br>SpringMVC <strong>通过一套 MVC 注解</strong>，让 POJO 成为处理请求的控制器，无需实现任何接口，同时，SpringMVC 还支持 REST 风格的 URL 请求。<br>此外，SpringMVC 在数据绑定、视图解析、本地化处理及静态资源处理上都有许多不俗的表现。<a id="more"></a><br><strong>它在框架设计、扩展性、灵活性等方面全面超越了 Struts、WebWork 等 MVC 框架，从原来的追赶者一跃成为 MVC 的领跑者。</strong><br>SpringMVC 框架围绕 Dispatcher<strong>Servlet</strong> 这个核心展开，DispatcherServlet 是 SpringMVC 框架的总导演、总策划，它负责截获请求并将其分派给相应的处理器处理。</p>
<h2 id="框架流程"><a href="#框架流程" class="headerlink" title="框架流程"></a>框架流程</h2><p>下面说说 SpringMVC 的执行流程，当然和传统的 MVC 模式是非常相似的：</p>
<p><img src="/image/dev/SpringMVC.jpeg" alt="SpringMVC.jpeg"></p>
<p>介绍中提到过，DispatcherServlet 是前端控制器，相当于中央调度器，各个组件都和前端控制器进行交互，降低了各个组件之间耦合度；Handler 是后端控制器，当成模型（Model）。<br>那么一个请求的完整步骤可以概况为：</p>
<ol>
<li>用户发起 request 请求，请求至 <strong>DispatcherServlet 前端控制器</strong></li>
<li>DispatcherServlet 前端控制器请求 <strong>HandlerMapping 处理器映射器</strong>查找 Handler</li>
<li>HandlerMapping 处理器映射器，根据 url 及一些配置规则（xml配置、注解配置）查找 Handler，将 Handler 返回给 DispatcherServlet 前端控制器；<br>这里其实会以 <strong>HandlerExecutionChain</strong> 对象的形式返回，我就称它为执行链了，<strong>它包含了 Handler 对象和拦截器列表</strong></li>
<li>DispatcherServlet 前端控制器根据返回的 Handler 调用合适的<strong>适配器</strong>执行 Handler，有了适配器通过适配器去扩展对不同 Handler 执行方式（比如：原始servlet开发，注解开发）</li>
<li>适配器执行 Handler（成功获得 HandlerAdapter 后，将开始执行拦截器的 preHandler(…) 方法 ），其中会经过一些消息转换器，例如进行数据绑定相关操作（数据转换、格式化、校验等）</li>
<li>Handler 执行完成后返回 ModelAndView 给适配器<br>ModelAndView 是 springmvc 的一个对象，对 Model （数据）和 view （仅仅是 View 的名字）进行封装。</li>
<li>适配器将 ModelAndView 返回给 DispatcherServlet </li>
<li>DispatcherServlet 通过返回的 View 的名称，调用视图解析器进行视图解析，解析后生成真正的 view<br>也就是说视图解析器根据逻辑视图名解析出真正的视图对象。<br>View：springmvc 视图封装对象，提供了很多 view，比如：jsp、freemarker、pdf、excel。。。</li>
<li>ViewResolver 视图解析器给前端控制器返回真正的 view 对象</li>
<li>DispatcherServlet 调用 view 的渲染视图的方法（根据模型对象的数据），<strong>将模型数据填充到 request 域</strong>。</li>
<li>View 返回渲染后的视图</li>
<li>DispatcherServlet 向用户响应结果(jsp页面、json数据等)</li>
</ol>
<p>以上就是 springmvc 处理一个请求的步骤了，然后再贴一张详细一点的流程图吧：</p>
<p><img src="/image/dev/Spring-MVC-详细运行流程图（通俗易懂）.png" alt="Spring-MVC-详细运行流程图（通俗易懂）.png"></p>
<h2 id="一个简单的栗子"><a href="#一个简单的栗子" class="headerlink" title="一个简单的栗子"></a>一个简单的栗子</h2><p>然后就来看看具体的开发流程，首先定义 web.xml 文件，也就是定义 SpringMVC 的总导演 DispatcherServlet 这就是一个 servlet：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- springMVC前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定配置文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- load-on-startup 表示在web应用启动时，即加载该DispatcherServlet，而不是等到首次请求再中载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于配置文件也有必要说一下，首先这里使用了 init-param 标签来指定配置文件的位置，如果不配置，默认加载的是 <code>WEB-INF/{servlet-name}-servlet.xml</code> ，其中大括号中指的是变量名，还记的 servlet-name 在那设置的么？看第六行！也就是说最终默认找的配置文件是 springmvc-servlet.xml 。<br>然后就是 url-pattern 了，匹配规则，SpringMVC 支持：<code>*.xxx</code>、<code>/</code>、<code>/xxx/*</code> ；不支持 ：<code>/*</code> ；<br>是的，原来在 struts 中写的很爽的 <code>/*</code> 在这里是错误的；使用这种配置，最终要转发到一个 jsp 页面时，仍然会由 DispatcherServlet 解析 jsp 地址，不能根据 jsp 页面找到 handler，会报错。<br>不过 <code>/</code> 表示所有访问的地址都由 DispatcherServlet 解析，对于静态文件的解析需要配置不让 DispatcherServlet 解析，使用此种方法可以实现 RESTful 风格的 url。<br>按照套路接下来就应该是 <strong>springmvc 的配置文件</strong>了（先使用配置文件的方式），其实就是 spring 的配置文件，因为基本没差嘛：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"</span>&gt;</span>                    </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置 HandlerMapping（处理器映射器） --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 处理器适配器，所有的处理器适配器都实现HandlerAdapter --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置Handler(自己写的) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/hello.action"</span> <span class="attr">class</span>=<span class="string">"cn.itcast.ssm.controller.HelloController"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义视图解析器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些定义其实都没必要看文档，就看上面的那个流程图，定义的这些 bean 完全就是按照图的顺序定义的，因为图中都是接口所以定义的时候要写具体实现的 bean。<br>视图解析器的前缀后缀是什么意思呢？从图中得知，最终要根据一个 View 的名字（在 Handler 的返回值中）返回一个具体的视图对象，视图说白了就是 jsp、json 等这种，所以视图解析器会根据前缀和后缀最后拼出一个真正的视图，也就是找到具体你定义的 jsp 文件。<br>视图就不写了，就是简单的一个 JSP 文件，除了视图 Handler 也需要自己写，看下 Handler 应该怎么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Controller接口的映射器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 返回ModelAndView</span></span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">// 相当于 request 的 setAttribute 方法</span></span><br><span class="line">    <span class="comment">// 在jsp页面中就可以通过 EL 表达式获取数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">"msg"</span>,<span class="string">"HelloWorld!"</span>);</span><br><span class="line">    <span class="comment">//指定视图</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一定要实现 Controller 接口，在适配器中会检查是否有实现这个接口，一般 Handler 会放在 controller 包下。<br>视图解析器会根据 setViewName 设置的名字和前缀、后缀进行拼接，最后就转到了我们定义的 jsp 视图上；<br>这样就可以通过访问 <code>/hello.action</code> 来调用 Handler 了。<br><strong>从命名来说，一般如果是 addXXX 那么就可以添加多个，如果是 setXXX 那么就只能设置一个了。</strong><br>另外，Controller（handler）的名字和视图的名字应该是对应的。</p>
<h3 id="优化配置文件"><a href="#优化配置文件" class="headerlink" title="优化配置文件"></a>优化配置文件</h3><p>我们在 springmvc 的配置文件中配置了一些 bean，但是有些其实是不用配也是可以的（有默认值），比如前两个：处理器映射器和处理器适配器，后面两个肯定不能省了，因为有我们自己配的信息</p>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>在最开始的介绍中也说明了，springmvc 中的注解是很重要的，大多都是用注解吧，毕竟在默认的配置文件中就已经开启了注解，所以注解我们可以直接用。<br>目标就是达到零配置！虽然默认配置已经开启了注解，但是已经过时了（AnnotationMethodHandlerAdapter 和 DefaultAnnotationHandlerMapping），推荐使用新的类（RequestMappingHandlerAdapter 和 RequestMappingHandlerMapping）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring 3.1之后由RequestMappingHandlerAdapter和RequestMappingHandlerMapping代替 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者直接使用下面的注解驱动，上面的两个就不用写了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明DispatcherServlet不要拦截下面声明的目录 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 另一种放行方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>至于注解驱动是如何将最新的映射器和适配器注入的可以去看 <code>org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser</code> 这个类，我就先不研究了….<br>简单说，驱动注解内部其实包含了这些内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter "</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HadnlerExceptionResolvers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver "</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>在 SpringMVC 中，控制器 Controller 负责处理由 DispatcherServlet 分发的请求，它把用户请求的数据 经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。<br>在 SpringMVC 中提供了一个非常简便的定义 Controller 的方法，<strong>你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是 Controller</strong> 。<br>然后使用 @RequestMapping 和 @RequestParam 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。<br>Controller 不会直接依赖于 HttpServletRequest 和 HttpServletResponse 等 HttpServlet 对象，它们可以通过 Controller 的方法参数灵活的获取到。<br>也就是说，@Controller 用于标记在一个类上，使用它标记的类就是一个 SpringMVC Controller 对象，然后 Spring 怎样才能找到它呢，有两种方式，当然，推荐使用扫描啦：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.controller.MyController"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"com.host.app.web"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>首先这是一个重点！其次，它非常 NB。<br>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上；访问的时候就是 类上 value + 方法上的 value 拼起来，并且可以不加斜线，会自动处理。<br>RequestMapping 注解有六个属性，可分为五种映射（或者说三种映射两种限制）：</p>
<ol>
<li><p>标准URL映射<br>比如：<code>@RequestMapping(&quot;hello&quot;)</code> or <code>@RequestMapping(&quot;/hello&quot;)</code> or <code>@RequestMapping(value=&quot;hello&quot;)</code> ，它们都是一样的。</p>
</li>
<li><p>Ant 风格的 URL 映射<br>Ant 通配符有三种，<code>？</code>- 匹配单个字符；<code>*</code> - 匹配 0 或者任意数量的字符；<code>**</code> - 匹配 0 或者更多的目录。<br>例如：<code>@RequestMapping(&quot;/test/*/hello&quot;)</code></p>
</li>
<li><p>占位符映射<br> 使用占位符用花括号括起来，可以使用多个占位符。例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">int</span> pid) </span>&#123;</span><br><span class="line">	ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);</span><br><span class="line">	modelAndView.addObject(<span class="string">"msg"</span>,<span class="string">"HelloWorld!"</span> + pid);</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这样访问 <code>xxx/user/123.action</code> 的时候，会自动把 123 传进 pid 这个参数，这样就又多了一种传值的方式。</p>
</li>
<li><p>限制请求方法映射<br>也就是限制请求方式，只要添加一个属性就可以了，使用到的是 <strong>method</strong> 属性：<br><code>@RequestMapping(value=&quot;hello&quot;,method = RequestMethod.GET)</code><br>需要多个的话用花括号括起来就行了，之间用逗号分割。</p>
</li>
<li><p>限制参数映射<br>也是通过属性指定，<strong>params</strong> 属性：指定 request 中必须包含某些参数值是，才让该方法处理。<br>过个参数还是用花括号括起来，一般有下面的几种形式：<br><code>&quot;!user&quot;</code> ：参数不能包含 user；<br><code>&quot;userID != 1&quot;</code> ：参数必须包含 userID 但是不能为 1；<br><code>{&quot;user&quot;,&quot;age&quot;}</code> ：参数必须包含 user 和 age；</p>
</li>
</ol>
<p>然后属性这样就已经说了三个了，value、method、params；其它是的：<br><strong>headers</strong>： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求；举个栗子：<br><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; })</code> ，这样就表示只有当请求头包含 Accept 信息，且请求的 host 为 localhost 的时候才能正确的访问到此方法。<br><strong>consumes：</strong> 指定处理请求的提交内容类型（Content-Type），例如 application/json 、 text/html;<br><strong>produces</strong>:    指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回；</p>
<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>用于将请求 URL 中的模板变量映射到功能处理方法的参数上，即取出 uri 模板中的变量作为参数。<br>上面已经使用过了，需要注意的是 value 参数不能省略！虽然省略了可以执行，但是当正常编译（ IDE 一般为 debug 模式）时，方法的传入参数不会被记录，所以会报错。<br>许多注解都是这个机制，所以最好是写上 value ，万无一失，总之就是不要依赖变量名。<br>Eclipse 中的 Java Compiler 中的 <code>add variable attributes to generated class files</code> 默认是开启的。</p>
<h3 id="requestParam"><a href="#requestParam" class="headerlink" title="@requestParam"></a>@requestParam</h3><p>主要用于在 SpringMVC 后台控制层获取参数，类似一种是 <code>request.getParameter(&quot;name&quot;)</code>，它有三个常用参数：<br><strong>defaultValue = “0”、required = false、 value = “isApp”；</strong><br>defaultValue 表示设置默认值，required 通过 boolean 设置是否是必须要传入的参数（默认为 true），value 值表示接受的传入的参数类型。<br>具体用在哪里可以参考上面的 PathVariable ，差不多的，这样就直接把请求参数放进方法参数里了，在方法里使用非常方便了，对于基本数据类型，记得一定要写，不要省略。<br>它可以直接对参数进行 POJO 实体注入、转换数组、List 等集合，并且不会出现空指针异常，非常的方便！</p>
<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>可以把 Request header 中关于 cookie 的值绑定到方法的参数上，例如获取 cookie 中的 JSESSIONID 的值：<br><code>public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie) {}</code><br>和上面两个注解也没啥差别，都是获取数据的。</p>
<h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>和 CookieValue 等注解类似，就是将 HttpServletRequest 头信息到 Controller 的方法参数上，比如 <code>@RequestHeader(&quot;host&quot;)</code> 就是获取 host 头信息；<br>不同的是，在 RequestHeader 中是不区分大小写的，但在 @PathVariable 、 @RequestParam 和 @CookieValue 中都是大小写敏感的。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>作用：该注解用于将 Controller 的方法返回的对象，通过适当的 HttpMessageConverter 转换为指定格式后，写入到 Response 对象的 body 数据区。<br>使用时机：返回的数据不是 html 标签的页面，而是其他某种格式的数据时（如 json、xml等）使用；默认为 JSON；<br>补充：为什么默认是 JSON ，在注解驱动中已经定义了，如果项目中有 Jackson 的依赖，那么会自动注册其转换器做转换输出。</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>和上面长的很像…..我都看错了，它们是一对。<br>该注解常用来处理<strong>请求的</strong> Content-Type 不是<code>application/x-www-form-urlencoded</code>编码的内容，例如 <code>application/json</code>, <code>application/xml</code> 等.<br>它是通过使用 HandlerAdapter 配置的 HttpMessageConverters 来解析 post data body，然后绑定到相应的 bean 上的。<br>因为配置有 FormHttpMessageConverter，所以也可以用来处理 <code>application/x-www-form-urlencoded</code> 的内容，处理完的结果放在一个 <code>MultiValueMap&lt;String, String&gt;</code> 里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter API.</p>
<h3 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h3><p>业务异常可以使用 @ResponseStatus 来注解。当异常被抛出时，ResponseStatusExceptionResolver 会设置相应的响应状态码。DispatcherServlet 会默认注册一个 ResponseStatusExceptionResolver 以供使用。<br>它有两个属性，value 属性是 http 状态码，比如 404，500 等。reason 是错误信息：<br><code>@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=&quot;用户不匹配&quot;)</code><br>通常它是修饰类的，然后在抛出异常的时候就会起作用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value=HttpStatus.FORBIDDEN,reason=<span class="string">"用户不匹配"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotMatchException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testResponseStatus"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseStatus</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UserNotMatchException();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，用户看到的异常界面正是我们自己定义的异常，而不再是一大堆用户看不懂的代码，但如果用这个注解来修饰方法，那么<strong>无论它执行方法过程中有没有异常产生，用户都会得到异常的界面。而目标方法正常执行</strong></p>
<h3 id="ModelAttribute和-SessionAttributes"><a href="#ModelAttribute和-SessionAttributes" class="headerlink" title="@ModelAttribute和@SessionAttributes"></a>@ModelAttribute和@SessionAttributes</h3><p>该 Controller 的所有方法在调用前，先执行此 @ModelAttribute 方法；<br>可以把这个 @ModelAttribute 特性，应用在 BaseController 当中，所有的 Controller 继承 BaseController，即可实现在调用 Controller 时，先执行 @ModelAttribute 方法。<br>@SessionAttributes 即将值放到 session 作用域中，写在 class 上面有效。</p>
<hr>
<p><strong>SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型（model）和控制器之间共享数据。</strong> @ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。<br>当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 <code>@ModelAttribute(&quot;attributeName&quot;)</code> 在标记方法的时候指定，<strong>若未指定，则使用返回类型的类名称（首字母小写）作为属性名称</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> ( <span class="string">"/myTest"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"hello"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"-------------Hello---------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"intValue"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"-------------intValue---------------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span> ( <span class="string">"sayHello"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">( @ModelAttribute ( <span class="string">"hello"</span> )</span> String hello, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"intValue"</span> )</span> <span class="keyword">int</span> num, @<span class="title">ModelAttribute</span> <span class="params">( <span class="string">"user2"</span> )</span> User user, Writer writer, HttpSession session) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer.write( <span class="string">"Hello "</span> + hello + <span class="string">" , Hello "</span> + user.getUsername() + num);</span><br><span class="line">    writer.write( <span class="string">"\r"</span> );</span><br><span class="line">    Enumeration enume = session.getAttributeNames();</span><br><span class="line">    <span class="keyword">while</span> (enume.hasMoreElements())</span><br><span class="line">      writer.write(enume.nextElement() + <span class="string">"\r"</span> );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ModelAttribute</span> ( <span class="string">"user2"</span> )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System. out .println( <span class="string">"---------getUser-------------"</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"user2"</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们请求 <code>/myTest/sayHello.do</code> 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值.<br><strong>这时，数据都是放在模型中，而不是存放在 session 属性中</strong>，如果想要也同时放进 Session 中，那么需要加 @SessionAttributes 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">"/myTest"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span> (value=&#123; <span class="string">"intValue"</span> , <span class="string">"stringValue"</span> &#125;, types=&#123;User. <span class="class"><span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyController</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session 中；但是当访问时，Session 中并没有值，第二次访问才有，也就是说：等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中，所以第二次访问才能拿到值。</p>
<h2 id="绑定Servlet内置对象"><a href="#绑定Servlet内置对象" class="headerlink" title="绑定Servlet内置对象"></a>绑定Servlet内置对象</h2><p>使用注解后确实简单多了，但有一个问题，怎么才能获得 Servlet 中的内置对象呢，比如 request、response、session 之类的，工具类？接口？<br>完全不需要，需要什么定义什么就 OK 了，直接定义在 handler 中的方法参数中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"test/show"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">show</span> <span class="params">(HttpServletRequest request,HttpServletResponse response,HttpSession session)</span></span>&#123;</span><br><span class="line">	ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	mv.setViewName(<span class="string">"show"</span>);</span><br><span class="line">	</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	sb.append(<span class="string">"request = "</span> + request);</span><br><span class="line">	sb.append(<span class="string">"&lt;br/&gt;response = "</span> + response);</span><br><span class="line">	sb.append(<span class="string">"&lt;br/&gt;session = "</span> + session);</span><br><span class="line">	</span><br><span class="line">	mv.addObject(<span class="string">"msg"</span>, sb.toString());</span><br><span class="line">	<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似不似非常简单方便，这种做法确实非常棒！</p>
<h2 id="POJO对象绑定"><a href="#POJO对象绑定" class="headerlink" title="POJO对象绑定"></a>POJO对象绑定</h2><p>对于“实体”对象，也是非常的简单，和上面一样，直接在方法参数里写就行了，会自动把请求中的参数注入到这个 POJO 中去；<br>例如，方法为：<code>public ModelAndView show (User user){}</code> ；请求的时候直接 <code>id=1&amp;name=abc</code> 这样就可以了。<br>然后，还有一个对于我们来说最烦人的问题，中文乱码问题…..，如何解决后面再补充</p>
<hr>
<p>如果提交的是集合，就是这样：<code>&lt;input name=&quot;users[0].name&quot; /&gt;</code> ；这样提交的不是一个集合或者数组嘛，但是接收不能使用 <code>public ModelAndView show (List&lt;user&gt; users){}</code> 的形式来接收，从上面的简单栗子也可以看得出，填充对象的时候应该是去参数对象中去找相应的 setter 方法进行注入（<del>除非使用 @requestParam 注解，适用于基本数据类型，大概是这样</del>），所以，<strong>你需要将 List 进行对象包装后才可以使用</strong>。<br>虽然这种使用形式并不会经常用到。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/leskang/p/5445698.html" target="_blank" rel="noopener">http://www.cnblogs.com/leskang/p/5445698.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis学习笔记（二）]]></title>
      <url>http://bfchengnuo.com/2017/09/30/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>接笔记一继续，还剩下一些知识点，本篇包含缓存、高级查询、延迟加载（lazy）、插件的使用<br>当然，仅靠这两篇也是不全的（注解就没说），只能说个大概，后面做 SSM 的时候还会再进行补充吧….<a id="more"></a></p>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>MyBatis 的强大特性之一便是它的动态 SQL。<br>如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。<br>MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p>下面就来详细说说到底怎么用，还是那句话，官方有很详细的文档，详细了解还是去官方比较好，飞机：<a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html</a><br>这里就是演示最基本的使用，首先是 if，最常用的就是根据传入的参数来决定 sql ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogWithTitleLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null and title != ''"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>熟悉 OGNL 的就不用多说了，都看得懂，忽然发现我对 OGNL 并不是多了解o(￣▽￣<em>)ゞ))￣▽￣</em>)o，抽时间单独搞一篇！；<br>需要提一下的是，OGNL 中可以直接使用 Java 中的方法<br>比如 <code>&lt;if test=&quot;title != null and &#39;&#39;.equals(title.trim())&quot;&gt;</code> 是合法的，我以前有说过么？？大概</p>
<hr>
<p>然后继续向下看，第二个 <strong>choose (when, otherwise)</strong> ，它比较类似 Java 中的 switch，从其中根据条件选择一种：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果都没匹配到就会执行 otherwise 标签的内容，如果没有定义这个标签就默认什么也不做，当匹配到第一个后就会 break，即使后面的也匹配但是会按照第一个来确定最终的语句；</p>
<hr>
<p>第三个是 <strong>trim (where, set)</strong> ，有些时候 WHERE 后面没有默认的语句，就是说条件是通过动态 SQL 确定的，但是如果都不匹配那么 WHERE 语句后面就是空了；比较业余的做法就是加 1=1 这种恒等条件；<br>MyBatis  有一个简单的处理，这在 90% 的情况下都会有用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结一下：<br>如果 where 标签内部有 sql 语句那么就会在前面自动添加 where 关键字，如果标签内是空那么就不做处理；<br>更 NB 的是，如果内部的语句是 “AND”或“OR”开头的，会自动处理它们…</p>
<p>再来看 set，也能猜到了，是用在 update 语句中的 set 关键字哪里，就是处理逗号的问题了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthorIfNecessary"</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bio != null"</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，嗯~很赞</p>
<p>然后，trim 标签其实可以代替它们两个，可以用来做他们两个做不到的一些逻辑：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 和 where 标签等价 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和 set 标签等价 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。<br>它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。<br>通俗说就是：如果判断 trim 里面有东西就在前面加 prefix 的值（还可以指定一个 suffix 值，就是在后面输出了），否则不输出；prefixOverrides 的意思就是判断标签里面的内容的最前面有没有设定的值，如果有就去除；suffixOverrides 就是判断最后有没有了，有就去除。</p>
<hr>
<p>这样还剩最后一个 <strong>foreach</strong> ，从名字很明显看出这是用来遍历的，一般用在批量删除、更新等，也就是<strong>构建 IN 条件语句的时候</strong> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后它贴心的提供了几个属性，比如在开始前加入 <code>(</code> ，结束后加入 <code>)</code>，指定分隔符为 <code>,</code>；index 是当前迭代的次数;<br>另外不要忘了使用 @Param 注解指定参数名哦，要不然 collection 可能会报 “404” 错误</p>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>对于缓存和 Hibernate 中的是差不多的，所以这一部分应该是相对比较轻松的；<br>MyBatis 中的一级缓存作用域也是 Session 级别的，如果执行的是相同的 SQL （相同的语句和参数）那么就会从缓存中获取；<br>同样的，一级缓存默认是开启的，并且你是关不掉的…..但是可以使用 sqlSession 的 <code>sqlSession.clearCache()</code> 方法清除缓存；<br>在同一个 Session 中，如果两句相同的 SQL 之间进行了 insert、update、delete 时，会刷新缓存，下次获取还是会重新从数据库中进行获取。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存的作用域是一个 mapper 的 namespace ；同一个 namespace 中查询 sql 是可以从缓存中命中的；<br>二级缓存是跨 session 的；<br>要使用二级缓存首先要开启，开启非常简单，在映射文件 mapper 中加入 <code>&lt;cache/&gt;</code> 标签即可，还有就是别忘了把实体进行序列化，要不然缓存的时候会出错<br><div class="note info"><p>在全局配置文件中，settings 标签中有一个 cacheEnabled 的属性，该配置影响的所有映射器中配置的缓存的全局开关，默认是 true；所以默认情况下只需要配置下 <code>&lt;cache/&gt;</code> 标签就可以使用了；<br>但是如果全局配置文件中的 cacheEnabled  为 false，那么二级缓存依然是不可用的状态。</p>
</div></p>
<p>当然 cache 标签还可以设置很多属性，详细的说明还是看官方文档：<a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache</a><br>下面是一个比较全的栗子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个更高级的配置创建了一个 FIFO 缓存，并每隔 60 秒刷新（默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新），存数结果对象或列表的 512 个引用（默认值是 1024），而且返回的对象被认为是只读的（默认 false），因此在不同线程中的调用者之间修改它们会 导致冲突。<br>可用的收回策略有:</p>
<ul>
<li><code>LRU</code> – 最近最少使用的：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
<p>默认的是 LRU。一般这个就够用了</p>
<h3 id="使用第三方缓存"><a href="#使用第三方缓存" class="headerlink" title="使用第三方缓存"></a>使用第三方缓存</h3><p>比如，都很熟悉的 EHCache、或者  Memcache（高性能 KV 缓存框架，目前被 Redis 所替代）；<br>下面说 MyBatis 如何集成 EHcache ，处理依赖就不用说了，然后是编写配置文件： <code>ehcache.xml</code> ，或者选择集成在 MyBatis 中的配置文件中。<br>Ehcache 默认使用 CLASSPATH 根目录下的 ehcache.xml 作为配置文件，如果没找到，则使用 Jar 包下的 ehcache-failsafe.xml 作为配置文件，该配置文件提供了默认的简单配置；<br>关于它的配置就不说了，现在的功力还达不到…….不知道怎么配，然后就是在 MyBatis 中的映射文件中使用了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeToIdleSeconds"</span> <span class="attr">value</span>=<span class="string">"3600"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeToLiveSeconds"</span> <span class="attr">value</span>=<span class="string">"3600"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxEntriesLocalHeap"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxEntriesLocalDisk"</span> <span class="attr">value</span>=<span class="string">"100000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"memoryStoreEvictionPolicy"</span> <span class="attr">value</span>=<span class="string">"LRU"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果你的配置文件写在了外面，可以直接使用下面的其中一种 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.LoggingEhcache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用外部配置文件需要注意的是文件名一定不要写错，ehcache.xml ！！还有就是两种 type 的区别，第一种可以输出日志，第二种不可以。</p>
<h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>使用 MyBatis 的好处是性能好，使用也相对简单，毕竟是一个比较轻量级的框架，当然是与 hibernate 相比的，但是相应的也给我带来了个问题，就是要写 SQL 语句了（如果你喜欢写，那就….）<br>首先来看第一种方案：<br>SQL 语句是必须的吗，就不说了，对于一对一可以使用 左连接的方式将其关联的表给查出来，但是这样一来返回的字段肯定比实体中的字段多，并且没有一个实体与其对应，所以可以创建一个新类，继承自原来的实体（第一个一的一方），然后扩展你所需要的其他属性。</p>
<hr>
<p>第二种方案：<br>这种方式就和 hibernate 有点相似了，采用 OO 的思想，使用组合的方式，在原来的实体中引用另一个实体，这样一来，<strong>自动映射就不行了，需要手动指定了</strong>，一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Order"</span> <span class="attr">id</span>=<span class="string">"orderResultMap"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		association: 用于映射java对象</span></span><br><span class="line"><span class="comment">		property：Order对象中的属性名（User对象）</span></span><br><span class="line"><span class="comment">		javaType：属性的java类型（可以使用别名）</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"User"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- id：User对象的id --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为使用了 association（定义实体引用的对象类型），所以默认 autoMapping 是关闭的，需要手动开启，这样指定实体的 resultMap 就可以了</p>
<h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>一对多的实现只有一种那就是 OO 的组合思想，继承是办不到的，和上面类似，需要在实体里加一个集合，比如 List ，然后使用泛型来约束多的一方的类型，就是 hibernate 中的一对多的写法啊；<br>然后来看看映射文件怎么写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Order"</span> <span class="attr">id</span>=<span class="string">"orderAndUserAndOrderDetailResultMap"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		javaType: 属性的 java 类型</span></span><br><span class="line"><span class="comment">		ofType：集合中的对象类型</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderdetails"</span> <span class="attr">javaType</span>=<span class="string">"List"</span> <span class="attr">ofType</span>=<span class="string">"Orderdetail"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"detail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>是的，无论什么时候，既然用 resultMap，那就起码得写个 id 吧，然后用 collection 定义集合，写好后下面就可以用了，这种情况下不用忘了 autoMapping ，默认是 false 的</p>
<h2 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h2><p>本质上还是写映射文件，展示的就是在集合中还能够再套属性，就是说：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Order"</span> <span class="attr">id</span>=<span class="string">"orderAndUserAndOrderDetailAndItemResultMap"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">extends</span>=<span class="string">"orderResultMap"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		javaType: 属性的javae类型</span></span><br><span class="line"><span class="comment">		ofType：集合中的对象类型</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"orderdetails"</span> <span class="attr">javaType</span>=<span class="string">"List"</span> <span class="attr">ofType</span>=<span class="string">"Orderdetail"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"detail_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"item"</span> <span class="attr">javaType</span>=<span class="string">"Item"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"iid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的配置中，还可以得出一个结论，就是  resultMap 是可以继承的，支持这个特性就可以做到代码复用了；还是不要忘记 autoMapping 。<br>下面写一个示例的 sql 语句，仅供参考：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"query...ByOrderNumber"</span> <span class="attr">resultMap</span>=<span class="string">"orderAndUser...ResultMap"</span>&gt;</span></span><br><span class="line">	SELECT</span><br><span class="line">		o.*,</span><br><span class="line">		u.user_name,</span><br><span class="line">		u.name,</span><br><span class="line">		od.item_id,</span><br><span class="line">		od.total_price,</span><br><span class="line">		od.id detail_id,</span><br><span class="line">		i.id iid,</span><br><span class="line">		i.item_name,</span><br><span class="line">		i.item_price,</span><br><span class="line">		i.item_detail</span><br><span class="line">	FROM</span><br><span class="line">		tb_order o</span><br><span class="line">	LEFT JOIN tb_user u ON o.user_id = u.id</span><br><span class="line">	LEFT JOIN tb_orderdetail od ON od.order_id = o.id</span><br><span class="line">	LEFT JOIN tb_item i ON od.item_id = i.id</span><br><span class="line">	WHERE</span><br><span class="line">		o.order_number = #&#123;orderNumber&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果这样都能看得懂，那应该就没啥问题了，emmmm；<br>关于多对多我还是有点蒙的，订单和商品应该是多对多，但是这个体现方式我还需要消化消化</p>
<h2 id="批量查询"><a href="#批量查询" class="headerlink" title="批量查询"></a>批量查询</h2><p>在 JDBC 中，批量操作使用 addBatch 的方式就可以实现，但是在 MyBatis 中就只能….<br>想要做到批量查询在 MyBatis 中就只能写相应的 SQL 语句了，或者说拼相应的 SQL 语句；不同的数据库的 SQL 写法会有区别，比如在 MySQL 中：<code>insert into tabName(a,b) values(&#39;A&#39;,&#39;B&#39;),(&#39;D&#39;,&#39;E&#39;)</code><br>所以在 ParameterType 中直接接收一个 List 就行了，然后用 foreach 遍历出来就行了，注意它们直接有 <code>,</code> 所以要用上 foreach 的特性 separator 属性。</p>
<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>就是所谓的 lazy 懒加载，就是说，数据用的时候再加载；<br>要开启延迟加载，需要在主配置文件中的 settings 标签中加入两个开关：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>lazyLoadingEnabled</strong>：延迟加载的全局开关， 特定关联关系中可通过设置<code>fetchType</code>属性来覆盖该项的开关状态。默认为 false;<br><strong>aggressiveLazyLoading</strong>：当开启时，如果有多个延迟加载项调用其中一个都会加载，false 则按需加载，默认为 false (true in ≤3.4.1)</p>
<p><strong>注意：懒加载需要使用动态代理技术（get 的时候需要执行查询逻辑），但是实体应该都是没有接口的，所以记得加入 Cglib 相关的依赖~</strong></p>
<p>使用懒加载，Java 代码不需要进行更改，改的还是映射文件，栗子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Order"</span> <span class="attr">id</span>=<span class="string">"lazyOrderResultMap"</span> <span class="attr">autoMapping</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">		select:延迟加载时执行SQL的StatementId</span></span><br><span class="line"><span class="comment">		column：指定关联的字段(传入的参数)</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"User"</span> <span class="attr">select</span>=<span class="string">"queryUserById"</span> <span class="attr">column</span>=<span class="string">"user_id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUserById"</span> <span class="attr">parameterType</span>=<span class="string">"Long"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">	SELECT * FROM tb_user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"lazyQueryOrderAndUserByOrderNumber"</span> <span class="attr">resultMap</span>=<span class="string">"lazyOrderResultMap"</span>&gt;</span></span><br><span class="line">	SELECT * FROM tb_order WHERE order_number = #&#123;orderNumber&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为全局配置中已经开启了懒加载，所以默认 association 就会进行延迟加载，事前就要配置好</p>
<h2 id="第三方插件-实现分页"><a href="#第三方插件-实现分页" class="headerlink" title="第三方插件(实现分页)"></a>第三方插件(实现分页)</h2><p>在 MyBatis 主配置文件里有个 插件（plugins）的说明，插件说白了其实就是拦截器，就是在原有的处理流程上加入自己的逻辑（相当于修改源代码的效果）。然后就以分页来作为栗子吧，分页其实就是使用 limit 来实现的；<br>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li><strong>StatementHandler</strong> (prepare, parameterize, batch, update, query)</li>
</ul>
<p>从上到下可以理解为：<strong>拦截执行器的方法、拦截参数的处理、拦截结果集的处理、拦截Sql语法构建的处理；</strong><br>关于自定义插件的步骤先挖坑吧，暂时可参考官方的文档嘛…..</p>
<hr>
<p>然后来实现分页，使用果然开发的 PageHelper 就可以了，不重复造轮子（我也造不出来）；因为是国人写的所以有详细的中文文档，使用也很简单，就不多说了，给个地址好了：<br><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper</a><br>下面说个最简单的使用栗子，首先要保证在主配置文件中已经配置好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第1页，10条内容，默认查询总数count</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectAll();</span><br><span class="line"><span class="comment">//用PageInfo对结果进行包装</span></span><br><span class="line">PageInfo page = <span class="keyword">new</span> PageInfo(list);</span><br><span class="line"><span class="comment">//测试PageInfo全部属性</span></span><br><span class="line"><span class="comment">//PageInfo包含了非常全面的分页属性</span></span><br><span class="line">assertEquals(<span class="number">183</span>, page.getTotal());  <span class="comment">// 数据总数</span></span><br><span class="line">assertEquals(<span class="number">19</span>, page.getPages());  <span class="comment">// 总页数</span></span><br><span class="line">assertEquals(<span class="number">1</span>, page.getFirstPage());</span><br></pre></td></tr></table></figure>
<p>主配置文件的配置，这里按最简单的最基本的设置来：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置方言 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helperDialect"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 查询总页数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rowBoundsWithCount"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>嘛，这样就差不多了，基本使用的话</p>
<h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>使用自定义插件（拦截器）来实现一个批量分页功能，最终就是只需要定义普通的 SQL 语句，id 命名符合一定规范，传入相应的分页参数（对象形式）就可以返回相应的分页数据。<br>所使用的就是上面提到的 StatementHandler — 拦截Sql语法构建的处理。<br>首先来分析一下，除 SQL 语句和配置参数（如何分页，每页几条这样的）不同，其他大部分都是相同的，JSP 页面的重复代码可以使用自定义标签来实现复用，然后一行代码就搞定了；然后解决的就是拿到执行的 SQL 语句然后利用子查询拼成一个分页查询的 SQL 语句再替换回去，SQL 语句在配置文件中，由 MyBatis 进行处理，想要得到要么改源码，要么就是使用 拦截器（插件）了！<br>那么关键点就是：</p>
<ol>
<li>要拦截住（拦截什么样的对象、对象的什么行为、什么时候拦截）</li>
<li>拦截下来做什么</li>
<li>做完后要交回主权</li>
</ol>
<p>要实现在执行前完成 SQL 的替换（创建 statement 的时候），需要了解 MyBatis 的源码，这里只说大体，先看看定义的拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type=StatementHandler.class,method=<span class="string">"prepare"</span>,args=&#123;Connection.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String test;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 处理拦截后要干什么，参数就是被拦截的对象</span></span><br><span class="line">  <span class="comment">// 只有拦截成功的才会执行这个方法，相当于动态代理中的那个 InvocationHandler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line">    <span class="comment">// 通过 MetaObject 能达到使用反射获取属性的效果</span></span><br><span class="line">    MetaObject metaObject = MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY);</span><br><span class="line">    MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(<span class="string">"delegate.mappedStatement"</span>);</span><br><span class="line">    <span class="comment">// 获取配置文件中 SQL 语句的 ID，判断是不是要分页功能，通过 id 命名结尾带有 ByPage</span></span><br><span class="line">    String id = mappedStatement.getId();</span><br><span class="line">    <span class="keyword">if</span>(id.matches(<span class="string">".+ByPage$"</span>)) &#123;</span><br><span class="line">      BoundSql boundSql = statementHandler.getBoundSql();</span><br><span class="line">      <span class="comment">// 原始的SQL语句</span></span><br><span class="line">      String sql = boundSql.getSql();</span><br><span class="line">      <span class="comment">// 查询总条数的SQL语句</span></span><br><span class="line">      String countSql = <span class="string">"select count(*) from ("</span> + sql + <span class="string">")a"</span>;</span><br><span class="line">      Connection connection = (Connection)invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">      PreparedStatement countStatement = connection.prepareStatement(countSql);</span><br><span class="line">      <span class="comment">// 获取并填充 SQL 中的参数</span></span><br><span class="line">      ParameterHandler parameterHandler = (ParameterHandler)metaObject.getValue(<span class="string">"delegate.parameterHandler"</span>);</span><br><span class="line">      parameterHandler.setParameters(countStatement); <span class="comment">// 填充</span></span><br><span class="line">      ResultSet rs = countStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取在 service 层调用时传入的参数，也就是配置文件里的 parameterType</span></span><br><span class="line">      Map&lt;?,?&gt; parameter = (Map&lt;?,?&gt;)boundSql.getParameterObject();</span><br><span class="line">      Page page = (Page)parameter.get(<span class="string">"page"</span>);</span><br><span class="line">      <span class="keyword">if</span>(rs.next()) &#123;</span><br><span class="line">        page.setTotalNumber(rs.getInt(<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 改造后带分页查询的SQL语句</span></span><br><span class="line">      String pageSql = sql + <span class="string">" limit "</span> + page.getDbIndex() + <span class="string">","</span> + page.getDbNumber();</span><br><span class="line">      <span class="comment">// 将改造后的 SQL 塞回 statementHandler，这样就偷梁换日了</span></span><br><span class="line">      metaObject.setValue(<span class="string">"delegate.boundSql.sql"</span>, pageSql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回主权，也就是继续执行 prepare 方法，这样会执行我们换的 statementHandler</span></span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 负责拦截对象（请求）</span></span><br><span class="line">  <span class="comment">// 参数为被拦截的对象，如果判断成功返回的是代理类，否则是拦截对象本身</span></span><br><span class="line">  <span class="comment">// 这里相当于是拦截所有的要创建 statement 的对象</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.test);</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 可以把注册时配置的参数加载进来</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.test = properties.getProperty(<span class="string">"test"</span>);	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要实现 Interceptor 接口，也就是那三个方法，setProperties 用于注入配置的参数，plugin 负责拦截对象，intercept 负责拦截后的进一步处理（还需要判断下拦下的这个“人”是不是要执行某个“动作”）；<br>注解确定了要拦截那个对象的那个方法，通过这个方法有什么参数来确定是那个重载，达到唯一的目的。<br>MyBatis 获取 statement 是在 StatementHandler 这个类（接口）中定义的，其中的 prepare 方法返回的就是 statement 对象；所以知道注解怎么写了吧。<br><strong>Plugin.wrap()</strong> 方法中会根据注解来判断是不是需要拦截的对象，如果是就返回代理类，如果不是就返回拦截对象本身（放行）；因为这个方法第二个参数传入了 this ，所以其实当调用代理类的时候，执行的就是在 Interceptor 中定义的 intercept 方法！<br><strong>MetaObject</strong> 对象提供了一个 getValue 的方法可以让我们很方便的访问被包装对象的属性（即使是保护权限的），StatementHandler 有两个实现类，我们拦截到的首先是 RoutingStatementHandler 然后通过里面的一个 delegate 属性拿到另一个实现类 BaseStatementHandler ，从它里面的 mappedStatement 属性拿到 MappedStatement ，也就是映射配置文件的信息。还可以拿到 ParameterHandler 对象，其中保存了填充 SQL 的数据，可以用它来填充一个 statement ，然后这个 statement 就可以执行了。<br>获取处理 SQL 是在 <strong>prepare</strong> 方法中进行的，所以我们拦截这个方法（在处理这个方法之前会被拦截），更准的说获取 SQL 其实是 <strong>instantiateStatement</strong> 方法，这个方法是在 prepare 方法中调用的。<br>然后最后的注册插件就不多说了 plugins 标签，上面也是写过的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>写 SQL 的时候尽量不用用 <code>select *</code> 这种，就是说不要用星，直接手写上就行了，避免给数据库带来不必要的压力，虽然这样写我们倒是很省事；</p>
<hr>
<p>在 Mybatis 中映射文件的各种标签是可以写多条 SQL 语句的，比如 INSERT 里可以批量插入几张表的数据，多条语句以分号分割；但是有一个前提，就是在连接数据库的 URL 中要加个参数开启这个功能（默认是关闭的）<br>对于 MySQL：在 URL 的后面再追加 <code>&amp;allowMultiQueries=true</code><br>并且写在同一标签的多条 SQL 是在同一个事务下的，只要你不 try ，就能回滚</p>
<p>还有事务的具体操作没有提到，待补充….</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-模板方法模式]]></title>
      <url>http://bfchengnuo.com/2017/09/29/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>首先来看下模板方法的概述：<br>定义一个操作中算法的框架，而<strong>将一些步骤延迟到子类中</strong>。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<strong>它是一种类行为型模式，是基于继承的代码复用的基本技术。</strong><a id="more"></a></p>
<p>这种设计模式非常的简单，同时也是最常见的设计模式之一，但是不能大意，就像单例模式一样，虽然简单，但是有许多细节需要注意</p>
<h2 id="结构-amp-角色"><a href="#结构-amp-角色" class="headerlink" title="结构&amp;角色"></a>结构&amp;角色</h2><p>模板方法模式需要开发<strong>抽象类</strong>和<strong>具体子类</strong>的设计师之间的协作。<br>一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。<br>代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p>
<p>前面说过，这种模式非常简单，只涉及到两个角色：</p>
<ul>
<li>抽象模板(Abstract Template)角色<br>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。<br>定义并实现了一个模板方法。<strong>这个模板方法一般是一个具体方法</strong>，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
<li>具体模板(Concrete Template)角色<br>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>首先定义抽象模板角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="comment">// 使用 final 关键字保证算法不会被篡改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareExecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用基本方法</span></span><br><span class="line">        Operation1();</span><br><span class="line">        Operation2();</span><br><span class="line">        hookMethod();</span><br><span class="line">        Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 基本方法声明（由子类实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"顶级类中的方法执行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"顶级类方法 final"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本方法，空方法--钩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中，我们可以使用 final 关键字来保证子类继承的时候无法覆盖父类中的算法，也就是说这个抽象类它拥有算法，而且保护这个算法。<br>下面再来看看具体模板角色，就非常简单了，这个栗子中就需要实现一个算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类中的具体实现"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用钩子...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后稍微测试下就可以了，测试代码就不写了，超简单的</p>
<h2 id="关于钩子"><a href="#关于钩子" class="headerlink" title="关于钩子"></a>关于钩子</h2><p>上面的栗子中，我们还定义了一个叫钩子的方法，什么是钩子？<br>在此设计模式中可以这么理解：一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。<br>作为子类，你可以视情况绝对要不要去覆盖它们（也就是说是可选的），更加常用的是通过钩子来控制某个算法要不要执行，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用基本方法</span></span><br><span class="line">    Operation1();</span><br><span class="line">    Operation2();</span><br><span class="line">    <span class="keyword">if</span> (hookMethod()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"钩子控制的代码被执行...."</span>);</span><br><span class="line">        Operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以通过钩子方法的返回值来决定要不要执行某些算法，应该是比较实用的。<br>钩子方法的名字应当以 do 开始，这是熟悉设计模式的 Java 开发人员的标准做法。在上面的例子中，钩子方法 hookMethod() 应当以 do 开头；在 HttpServlet 类中，也遵从这一命名规则，如 doGet()、doPost() 等方法。</p>
<p>根据基本设计原则，我们应该将决策权放在高层模块中</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>实际应用中，JDK 中的排序的功能就是用的模板方法，如果排序一个对象数组（ Object[] ），我们实现两个对象的比较，就要实现 Comparable 接口的 compareTo 方法.<br>Java 的 sort 方法实现就比较像模板方法，首先克隆数组，然后进行一系列的调取算法</p>
<p>在 Java 提供的 Applet 中也使用了大量的钩子来提供行为</p>
<h2 id="与策略模式关系"><a href="#与策略模式关系" class="headerlink" title="与策略模式关系"></a>与策略模式关系</h2><p>也会会感觉它和策略模式非常相似，但是其实有着本质的不同，虽然它们都是封装算法，但是一个用组合一个用继承。<br>策略模式：是定义一个算法家族（具体实现），并让这些算法可以互换。<br>模板方法：定义一个算法的大纲（算法的步骤），由子类定义其中某些步骤的内容。</p>
<p>模板方法可以定义具体的方法、抽象方法、钩子<br><strong>或者可以说，工厂方法也是模板方法的一种特殊版本。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/09/28/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>MyBatis 是一个 <strong>Java 持久化框架</strong>，它通过 XML 描述符或注解把对象与存储过程或 SQL 语句关联起来。<br>MyBatis 是在 Apache 许可证  2.0 下分发的自由软件；MyBatis 的前身是 iBatis ，是 Apache 的一个开源项目<a id="more"></a><br>由于 MyBatis 是直接基于 JDBC 做了简单的映射包装，所以从性能的角度来看：<br>JDBC &gt; MyBatis &gt; hibernate</p>
<blockquote>
<p>  MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
</blockquote>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>首先来看下 MyBatis 的整体架构，有一个大体的了解，相比 Hibernate 真是简单多了：</p>
<p><img src="/image/dev/MyBatis架构.png" alt="MyBatis架构.png"></p>
<p>可以看出，MyBatis 也是依赖于两类配置文件，一类是主配置文件（只有一个），一般约定命名为 <code>mybatis-config.xml</code> ，配置了运行参数、插件、连接池等信息。<br>还有就是 <code>Mapper.xml</code> 映射文件，可以有多个，里面配置的是 Statement （简单说是 SQL 也行）<br>执行的时候会通过主配置文件构建出 <strong>SqlSessionFactory</strong> ，然后获得 SqlSession 对象，利用 SqlSession 就可以操作数据库了<br>SqlSession 的底层会通过一个执行器来执行 Statement（SQL），执行器一般有两种实现，一种是基本的，一种是带有缓存功能的<br>前面说过 Statement 可以简单理解为 SQL 语句，一般我们写 SQL 语句都是用 ？占位符，所以需要输入参数，然后执行，返回执行结果，至于输入输出的类型，图上已经说的很清楚了</p>
<h2 id="一个入门栗子"><a href="#一个入门栗子" class="headerlink" title="一个入门栗子"></a>一个入门栗子</h2><p>了解其的最好方法就是看文档，官方有中文文档哦，首先我们需要配置基本的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入外部资源配置文件，以使用 $&#123;&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置环境，数据库等信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入映射文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面就是主配置文件，如果是 Maven 工程，默认是在工程的 resurces 中查找映射文件，所以可以直接写文件名；<br>然后来看看映射文件应该怎么写，这个映射和 Hibernate 的可不一样，简单的多，其实就是写 SQL 语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.bfchengnuo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"com.bfchengnuo.domain.Blog"</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>resultType 指定的就是结果集映射到的相应的实体类，其他的先不说，看完下面的 Java 代码更好理解，下面是一段基本的 MyBatis 使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line"><span class="comment">// Resources 是 MyBatis 提供的工具类</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(<span class="string">"com.bfchengnuo.selectBlog"</span>, <span class="number">101</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以看出，通过 session 的 selectOne 方法进行查询的时候是用 <code>namespace.id</code> 来定位 Statement 的</p>
<h2 id="添加日志支持"><a href="#添加日志支持" class="headerlink" title="添加日志支持"></a>添加日志支持</h2><p>按照上面的方法确实是可以执行，但是控制台没任何日志输出，也看不到执行的 SQL，如果想了解就需要添加日志支持，既然是日志，那就用大名鼎鼎的 log4j 了，MyBatis 是支持的，会自动检测，如果发现有 slf 就会加载的~所以只需要写个配置文件了。<br>导入依赖这个就不用说了，只要在 log4j 的配置文件中写入下面的代码即可看到效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=DEBUG,A1</span><br><span class="line">log4j.logger.org.mybatis = DEBUG</span><br><span class="line">log4j.appender.A1=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n</span><br></pre></td></tr></table></figure>
<p>简单说下意思：第一行是设置日志的等级和位置（可以随便起个名字，比如 A1），MyBatis 的许多信息都是用的 Debug 级别，可以去源码看看；<br>第二行是单独指定 MyBatis 的级别，第一行是全局的，相当于个性化设置；<br>第三行就是指定位置（A1）具体是什么，这里是控制台；<br>下面是布局和格式，d-时间；t-线程名；p-显示级别名；n-换行；<br>关于 log4j 的使用，待补充…</p>
<h2 id="进行CRUD操作"><a href="#进行CRUD操作" class="headerlink" title="进行CRUD操作"></a>进行CRUD操作</h2><p>下面就再深入一点，看下 MyBatis 是如何进行 CRUD 操作的：<br>首先来定义映射文件 UserMapper （习惯上，命名为 xxxMapper）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryUserById"</span> <span class="attr">resultType</span>=<span class="string">"cn.itcast.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">		SELECT *,user_name userName FROM tb_user WHERE id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.itcast.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">		SELECT *,user_name userName  FROM tb_user</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveUser"</span> <span class="attr">parameterType</span>=<span class="string">"cn.itcast.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">		INSERT INTO tb_user (</span><br><span class="line">			id,</span><br><span class="line">			user_name,</span><br><span class="line">			age,</span><br><span class="line">			sex,</span><br><span class="line">			updated</span><br><span class="line">		)</span><br><span class="line">		VALUES</span><br><span class="line">			(</span><br><span class="line">				NULL,</span><br><span class="line">				#&#123;userName&#125;,</span><br><span class="line">				#&#123;age&#125;,</span><br><span class="line">				#&#123;sex&#125;,</span><br><span class="line">				NOW()</span><br><span class="line">			);</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"cn.itcast.mybatis.pojo.User"</span>&gt;</span></span><br><span class="line">		UPDATE tb_user</span><br><span class="line">		SET </span><br><span class="line">		 user_name = #&#123;userName&#125;,</span><br><span class="line">		 age = #&#123;age&#125;,</span><br><span class="line">		 sex = #&#123;sex&#125;,</span><br><span class="line">		 updated = NOW()</span><br><span class="line">		WHERE</span><br><span class="line">			id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUserById"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span>&gt;</span></span><br><span class="line">		DELETE FROM tb_user WHERE id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般一个 mapper 文件对应一个 Dao 层中的一些方法，一般来说方法名就是其 id，毕竟方法的执行需要 SQL 语句；注意下它们的标签就行了，下面 dao 层的具体实现也是都差不多，就是方法名和 SQL 语句的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSession.selectOne(<span class="string">"user.queryUserById"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSession.selectList(<span class="string">"user.queryAll"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.insert(<span class="string">"user.saveUser"</span>, user);</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.update(<span class="string">"user.updateUser"</span>, user);</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.delete(<span class="string">"user.deleteUserById"</span>, id);</span><br><span class="line">    <span class="keyword">this</span>.sqlSession.commit();<span class="comment">//提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就会想，能不能不写这个 dao 的实现，因为感觉都是重复代码啊….最好是连映射文件也不用写…..<br>这是可能的，后面再说（<del>如果连接口都不用写那就更爽了</del>）</p>
<hr>
<p>解决字段名于属性名不一致的问题：<br>最容易想的是用别名的方式，在 SQL 语句中将字段名起一个和属性名相同的别名就可以了，例如：<code>select *,user_name userName from users</code> 就能正确映射了<br>或者直接用 MyBatis 提供的功能，在<strong>主配置</strong>文件中加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样貌似更简单是吧…..但是只限于驼峰命名规则，也就是：<code>A_COLUMN ===&gt; aColumn</code></p>
<h2 id="动态代理实现DAO"><a href="#动态代理实现DAO" class="headerlink" title="动态代理实现DAO"></a>动态代理实现DAO</h2><p>MyBatis 提供了使用动态代理的方式来实现 DAO，也就是说只需要写个 dao 的接口就行了，而不需要写具体的实现类；<br>然后先来介绍映射文件 XML 法，让我们只要配置好映射文件就不需要再写实现类：</p>
<ul>
<li>Mapper 中的 namespace 指定为接口</li>
<li>id 对应接口中的方法名</li>
<li>接口方法中的参数必须和 Mapper 中 parameterType 配置的一致（可以省略，会根据传入值进行判断）</li>
<li>接口方法的返回值必须和 Mapper 中 resultType 配置的一致（不可省略）</li>
</ul>
<p>满足上面四个条件应该就可以使用了，所以 dao 层接口又称为是 mapper 接口，使用的时候直接通过下面一行代码获取代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置事务自动提交</span></span><br><span class="line">SqlSession session = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">userDAO = sqlSession.getMapper(UserDAO.class);</span><br></pre></td></tr></table></figure>
<p>这样就省去了写 dao 实现类的时间，如果还想省去 XML 文件那么就需要使用注解了，它就是专门做这个的，关于注解等会再说</p>
<hr>
<p>那么为什么不需要具体的实现类呢，很显然使用的是动态代理技术；源码中有个 MapperProxy 类来做这件事，它实现了 InvocationHandler 接口，当我们调用 getMapper 方法时，就会创建出相应的一个代理对象，当我们执行这个接口的方法时就会调用 MapperProxy 中的 invoke 方法，从而不需要具体的实现类了。<br>那么它如何找到相关的 SQL 语句呢，在 MyBatis 加载主配置文件的同时，映射文件也一同加载了，如果接口和配置文件是对应的，那么就可以利用动态代理以及反射拿到接口名、方法名等数据通过方法名等找到对应的映射配置文件，也就知道对应的 SQL 语句了。<br>我们使用 getMapper 方法的时候还传入了一个类，内部通过使用泛型做了强转，所以即使是返回的代理对象我们可以直接用 UserDAO 去接收。</p>
<hr>
<p>这里的 getMapper 方法的实现应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是在 DefaultSqlSession 中被定义的，可以看出深层次的调用中还传入了 this （DefaultSqlSession），这是为后面调用 selectOne、selectList 等方法做准备。<br>在 MyBatis 加载配置文件的时候（准确说是 build 的时候），就会判断映射文件配置的 namespace 是不是个接口，如果是就做为 key （class 对象），并且根据这个接口创建一个 MapperProxyFactory 对象作为值，put 进一个叫 knownMappers 的 Map 对象中去。<br>在调用 getMapper 的时候，其实就是在从这个 Map 中获取相应的代理工厂，最终通过 MapperProxyFactory 的 newInstance 方法生产出一个具体的代理对象（ MapperProxy ），其中会根据返回值而调用不同的 SQL 查询方法，调用会触发其 invoke 方法</p>
<h2 id="configuration常用配置"><a href="#configuration常用配置" class="headerlink" title="configuration常用配置"></a>configuration常用配置</h2><p>因为官方有中文文档，所以可以直接去看官方的详细解释，这里写几个比较常用的以便查询<br>下面的配置都是写在主配置文件里的！！</p>
<h3 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h3><p>常用它来读取外部的配置文件（properties 文件），然后用 <code>${name}</code> 来引用，让配置更加的灵活，例如可以这样定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样是不是感觉更灵活了，读取顺序是先读取 properties 中定义的，再读取指定的文件，出现重名的情况时，文件中定义的会覆盖 xml 定义的；<br>从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值，但需要先开启这个功能，详情可看官方，因为感觉用的不多就不贴了</p>
<h3 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h3><p>第一个其实已经说过了，就是解决属性名和字段名不同的问题，会自动转换的那个（mapUnderscoreToCamelCase）；<br>然后重点是这几个，后面会说到：</p>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>描述</th>
<th style="text-align:left">有效值</th>
<th style="text-align:right">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cacheEnabled</td>
<td>该配置影响的所有映射器中配置的缓存的全局开关。</td>
<td style="text-align:left">true / false</td>
<td style="text-align:right">true</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置<code>fetchType</code>属性来覆盖该项的开关状态。</td>
<td style="text-align:left">true / false</td>
<td style="text-align:right">false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考<code>lazyLoadTriggerMethods</code>).</td>
<td style="text-align:left">true / false</td>
<td style="text-align:right">false (true in ≤3.4.1)</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td>
<td style="text-align:left">true / false</td>
<td style="text-align:right">False</td>
</tr>
</tbody>
</table>
<h3 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h3><p>简单说就是把 Java 类型取一个别名，在其他地方用的时候就不需要写一大堆的包了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Blog"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Blog"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 可以写一个包，将会从这个包下找 JavaBean --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain.blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>别名的<strong>首字母</strong>是不区分大小写的，但是习惯是大写，毕竟是类；然后 MyBatis 定义了一些默认的别名，直接用就可以了：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody>
</table>
<p>另外，当传入的是个数组的时候，根据源码的定义要类似这样的形式：<code>parameterType=&quot;Object[]&quot;</code> ，解析配置文件的过程中在 TypeAliasRegistry 这个类中定义了这些别名。</p>
<h3 id="环境（environments）"><a href="#环境（environments）" class="headerlink" title="环境（environments）"></a>环境（environments）</h3><p>前面刚开始就用到了，用它来配置的数据库信息，因为一般都有有多个环境，比如开发环境、测试环境、生产环境；每个环境的数据库是不一样，这样做是为了便于分离<br>可以使用 <code>new SqlSessionFactoryBuilder().build(reader, environment);</code> 来指定加载某个环境的配置<br>实际上，都是用 Spring 来处理这个，所以了解就好</p>
<h3 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h3><p>这个是一个重点，mappers 可以通过四种方式引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Using classpath relative resources --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/AuthorMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/builder/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Using url fully qualified paths --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/AuthorMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Using mapper interface classes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.AuthorMapper"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"org.mybatis.builder.BlogMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Register all interfaces in a package as mappers --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.builder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一种是比较熟的了；第二种通过绝对路径的方式基本不会用；第三种通过类引用就要必须将映射文件和接口文件放在一起，名字也要统一；第四种的包扫描方式也是如此，需要放在一起才行<br>这四种并没有想象中的那样优雅，但是好消息是，和 Spring 整合后就能使用更优雅的方式了，不用和类混在一起也不需要配置那么多 mapper，等下篇说吧</p>
<h2 id="Mapper常用配置"><a href="#Mapper常用配置" class="headerlink" title="Mapper常用配置"></a>Mapper常用配置</h2><p>这里所有的配置都是写在映射文件中的哦。<br>这方面官方文档中写的也是非常详细的，也是挑常用的说，SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p>
<ul>
<li><code>cache</code> – 给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<p>最后的四个其实已经用过了，对应 CRUD 操作，对它们还是有些补充的东西；<br>对于 insert/update，如果设置的是 id 自动增长，插入一条数据后是获取不到 id 的，为了让 id 回填，需要配置一些东西（下表加黑的属性）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>命名空间中的唯一标识符，可被用来代表这条语句。</td>
</tr>
<tr>
<td>parameterType</td>
<td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td>flushCache</td>
<td>将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td>
</tr>
<tr>
<td>timeout</td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td>statementType</td>
<td>STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td><strong>useGeneratedKeys</strong></td>
<td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td><strong>keyProperty</strong></td>
<td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：<code>unset</code>。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td><strong>keyColumn</strong></td>
<td>（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td>databaseId</td>
<td>如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody>
</table>
<p>简单来说是 useGeneratedKeys 开启回填 id；keyColumn 指定数据库中的列（如果和 keyProperty 相同可以省略不写）；keyProperty 指定对象中的属性名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertAuthor"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>这样插入以后获取 id 就是有值的</p>
<h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>官方给出的介绍是：是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象；<br>可以看出这个标签是很重要的，同时也看出了它的作用，就是来处理字段和属性之间的映射关系的，所以它也是可以处理字段名和属性名不同的问题，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"user_name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">  select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 resultMap 有一个 <strong>autoMapping</strong> 自动映射的属性，开启后如果没写的字段也会进行映射，也就是不用写全，这个默认应该是开启状态（当使用了集合等标签默认是关闭），但还是写上比较好</p>
<h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p>sql 片段就是为了 sql 代码的复用，和 Java 代码类似，如果有很多重复的 sql 语句，可以提取出来，也便于以后的统一维护；<br>一般情况下，我们会把这些 sql 片段统一在一个单独的 mapper 文件中，就像 Java 中的工具类；下面就来看看 sql 片段的写法和使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 include 标签来引用，在这其中可以使用 property 标签来指定片段中引用的值</p>
<h2 id="与"><a href="#与" class="headerlink" title="$与#."></a>$与#.</h2><p>在 Mapper 中，参数传递有两种方式，一种是 <code>${}</code> 另一种是 <code>#{}</code> 它们有很大的区别；</p>
<ul>
<li><code>#{}</code> 是实现的 sql 语句的预处理，之后执行的 sql 中会用 ？来代替，不需要关注数据类型（自动处理），并且能防止 SQL 注入，因为本质是占位符，所以名字其实可以随便写（<code>#{xxx}</code>），最后都会换成 ？，前提是参数是基本数据类型；</li>
<li><code>${}</code> 是 SQL 语句的直接拼接，不做数据类型转换，需要自行判断数据类型，不能防止 SQL 注入；</li>
</ul>
<p>当我们的表名不确定时，就可以使用 $ 了，<code>select * from ${tabName}</code> ，表名可以通过参数传递过来，如果使用 <code>#</code> 那么最终的 sql 语句就会变成：<code>select * from ?</code> ，当然会报错；<br><strong>使用 $ 时要注意的是它默认会从传入的对象中找 getter 方法获得配置的名（<code>#</code> 也是类似，但当传入的是基本数据类型时名称其实可以随便写）</strong>，例如，你传入的是一个字符串类型的表名，但是它会调用 <code>String.getTabName()</code> 方法，自然会报错，所以你知道为什么前面 CRUD 的时候一条 SQL 可以使用多次 <code>#{name}</code> 了吧。<br>解决方法有两种：</p>
<ul>
<li>使用 <code>${value}</code> ，这样就会获取默认传入的参数，它是 MyBatis 中提供的默认参数名</li>
<li>代码中使用注解 ( @Param )<br><code>public List&lt;Map&lt;String,Object&gt;&gt; queryByTableName(@Param(&quot;tabName&quot;) String tabName);</code></li>
</ul>
<p>还记得那张架构表么，resultType 的类型是可以设置为 Map 的，不过 Map 是个接口，需要写具体类，比如 HashMap；</p>
<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><p>当传入的是多个参数的时候，就和 <code>#{name}</code> 中的名字有关了，但是你直接写肯定是不行的，方法也是有两种：</p>
<ul>
<li>使用 <code>#{0}</code> 、<code>#{param1}</code> 这样依次增加</li>
<li>代码中使用 @Param  注解，然后就可以使用 <code>#{name}</code> 的形式了</li>
</ul>
<p>优先选择的当然是注解了，这样看着比较舒服….<br>单个参数的时候 # 是与参数名无关的，最终反正会被替换成 ？</p>
<blockquote>
<p>  当我们传入一个对象时，可以在 SQL 中用多个 <code>#{name}</code> 来获取对象中的属性，就像刚开始的栗子里用的一样；这种情况算是只传入了一个参数哦</p>
</blockquote>
<h3 id="使用OGNL"><a href="#使用OGNL" class="headerlink" title="使用OGNL"></a>使用OGNL</h3><p>MyBatis 默认采用的是 OGNL 表达式，所以在这里也是可以使用的，在写 SQL 的时候写的 <code>#{name}</code> 中就可以使用，还可以用在一些标签里面（比如 if 里的 test 表达式）。<br>获取几种值的写法（对大小写敏感），例如获取基本数据类型是 <code>#{_parameter}</code>：<br>获取基本类型：<code>_parameter</code><br>自定义类型：<strong>属性</strong>名<br>获取集合：数组（用 <strong>array</strong>）、List（用 <strong>list</strong> ）、Map（用 <code>_parameter</code> ）；例如：对于基本数据类型的数组：<code>array[索引]</code><br>如果是 Map 的话就是 <code>_parameter.key</code> ，自定义的类型（<code>Map&lt;string,obj&gt;</code>） 可以直接 <code>key.属性名</code> 获取</p>
<blockquote>
<p>  在 OGNL 中可以直接使用 Java 中的操作符（+、-、/、==、!=、||、&amp;&amp;），以及调用 Java 中的一些方法<br>  因为是写在 XML 中，所以有些符号需要转义，于是 OGNL 提供了自己的操作符代替（and、or、in、not in、mod）mod 就是取余</p>
</blockquote>
<p>所以，当 parameterType 的类型是字符串或者基本数据类型时（因为值是唯一的），并且只有一个的情况下，可以 <code>#{_parameter}</code> 也可以 <code>#{随便写点啥}</code> 或者还可以使用 OGNL 的方式直接写 <code>_parameter</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>因为 mapper 的定义可以省去写 dao 层接口实现类，所以很多情况下直接把原来的 dao 层命名为 mapper 层，原接口的命名 UserDAO 就写成了 UserMapper ，它们其实是指的一个东西，这样在使用 MyBatis 的情况下看着还是比较规范的。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的AOP]]></title>
      <url>http://bfchengnuo.com/2017/09/22/Spring%E4%B8%AD%E7%9A%84AOP/</url>
      <content type="html"><![CDATA[<p>想了想还是单独来总结一篇吧，关于 AOP 内容不少，分散在两篇文章中也不好看，在 Spring 的两大核心 IoC 和 AOP 中，普遍认为 AOP 是比较难的，因为它的概念比较多吧，并且还都非常抽象，所以单独来一篇。<a id="more"></a><br>虽然会和以前写的有重复，但也不删了，重就重吧；这篇大多都是说的理论，实践的话可暂时参考 [4] 或者 [0] 中的连接</p>
<h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP (Aspect-Oriented Programming)，即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong> ，什么是切面下面会说。</p>
<h2 id="关于AspectJ"><a href="#关于AspectJ" class="headerlink" title="关于AspectJ"></a>关于AspectJ</h2><p>AspectJ 实际上是对 AOP 编程思想的一个实践，当然，除了 AspectJ 以外，还有很多其它的 AOP 实现，例如 ASMDex，但目前最好、最方便的，依然是 AspectJ。也许是因为最早做 Java 的 AOP 实现的原因。<br>AspectJ 可以干净地模块化横切关注点，基本上可以实现无侵入，同时学习成本低，功能强大（甚至可以通过修改字节码来实现多继承），可扩展性高。</p>
<blockquote>
<p>  AspectJ 意思就是 Java 的 Aspect，Java 的 AOP。<br>  它其实不是一个新的语言，它就<strong>是一个代码编译器</strong>（也就是 AJC ），在 Java 编译器的基础上增加了一些它自己的关键字识别和编译方法。<br>  因此，ajc 也可以编译 Java 代码。它在编译期将开发者编写的 Aspect 程序编织到目标程序中，对目标程序作了重构，目的就是建立目标程序与 Aspect 程序的连接（耦合，获得对方的引用（默认情况下，也就是不使用 this 或 target 来约束切点的情况下，那么获得的是声明类型，不是运行时类型）和上下文信息），从而达到 AOP 的目的（这里在编译期还是修改了原来程序的代码，但是是 AJC 替我们做的）。</p>
</blockquote>
<p>AspectJ 是一套<strong>独立的</strong>面向切面解决方案，你可以在 Eclipse 的官网找到它，然后下载安装，然后使用它的 <strong>ajc.exe</strong> 进行编译，入门请参考：<a href="http://zhoujingxian.iteye.com/blog/667214" target="_blank" rel="noopener">http://zhoujingxian.iteye.com/blog/667214</a><br>使用 AspectJ 有两种方法：</p>
<ul>
<li>完全使用 AspectJ 的语言。<br>这语言一点也不难，和 Java 几乎一样，也能在 AspectJ 中调用 Java 的任何类库。AspectJ 只是多了一些关键词罢了。</li>
<li>使用纯 Java 语言开发，然后使用AspectJ注解，也就是 @AspectJ。</li>
</ul>
<p><strong>当然不论哪种方法，最后都需要 AspectJ 的编译工具 AJC 来编译。</strong><br>关于 AspectJ 就不多说了，想详细了解的见参考 [1] ；另外 Android 中也有很多人开始使用 AspectJ  了！</p>
<h2 id="SpringAOP与AspectJ"><a href="#SpringAOP与AspectJ" class="headerlink" title="SpringAOP与AspectJ"></a>SpringAOP与AspectJ</h2><p>首先，Spring 采用的就是 AspectJ，在 Spring 的 AOP 相关包里你能看到 AspectJ 的影子；<br><strong>Spring AOP 采用的动态织入，而 AspectJ 是静态织入</strong>。<br>静态织入：指在编译时期就织入，即：编译出来的class文件，字节码就已经被织入了。<br>动态织入又再分静动两种，静则指织入过程只在第一次调用时执行；动则指根据代码动态运行的中间状态来决定如何操作，每次调用 Target Object 的时候都执行。</p>
<p>使用 Spring 自己原生的 AOP，你需要实现大量的接口，继承大量的类，所以Spring AOP一度被人所诟病，这与它的无侵入，低耦合完全冲突，我在笔记一中采用的就是这种方式，确实麻烦。<br>不过 Spring 对开源的优秀框架，组件向来是采用兼容，并入的态度。所以，后来的 Spring 就提供了 Aspectj 支持，也就是我们后来所说的基于纯 POJO 的 AOP。</p>
<h2 id="AOP中的术语"><a href="#AOP中的术语" class="headerlink" title="AOP中的术语"></a>AOP中的术语</h2><h3 id="通知-增强（Advice）"><a href="#通知-增强（Advice）" class="headerlink" title="通知/增强（Advice）"></a><strong>通知/增强（Advice）</strong></h3><p>切面的工作被称为通知，通知定义了切面是什么以及何时使用。<br>除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只是在方法抛出异常时调用？<br>简单说就是你想要（切入）的具体功能实现(想要干啥)，比如安全，事物，日志操作等。</p>
<p>许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截.<br>例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.</p>
<h3 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a><strong>连接点(JoinPoint)</strong></h3><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br>就是 Spring 允许你使用通知的地方</p>
<p>另一种说法：程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理；<strong>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</strong><br>Spring 中是方法、方法、方法，重要的事情说三遍！</p>
<h3 id="切点-Pointcut"><a href="#切点-Pointcut" class="headerlink" title="切点(Pointcut)"></a><strong>切点(Pointcut)</strong></h3><p>一组连接点的总称，用于指定某个通知（增强）应该在何时被调用。<br>切入点是「在哪干」，你可能在很多地方（连接点）都可以干，但并不是每个地方都要干，要干的地方叫切点</p>
<p>在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配 joinpoint, 给满足规则的 joinpoint 添加 Advice</p>
<h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a><strong>切面（Aspect）</strong></h3><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——<strong>它是什么，在何时和何处完成其功能</strong><br>通知说明了干什么和什么时候干（什么时候通过方法名中的before、after、around 等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。<br>Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中.<br><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<h3 id="joinPoint-和-pointCut-的区别"><a href="#joinPoint-和-pointCut-的区别" class="headerlink" title="joinPoint 和 pointCut 的区别"></a>joinPoint 和 pointCut 的区别</h3><p>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.<br><strong>advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</strong></p>
<h3 id="目标对象-Target"><a href="#目标对象-Target" class="headerlink" title="目标对象(Target)"></a>目标对象(Target)</h3><p>织入 advice 的目标对象. 目标对象也被称为 <code>advised object</code>.<br><strong>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)</strong><br>注意，adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</p>
<h3 id="织入-weaving"><a href="#织入-weaving" class="headerlink" title="织入(weaving)"></a><strong>织入(weaving)</strong></h3><p>把切面应用到目标对象来创建新的代理对象的<strong>过程</strong>。专业点的说法是：将 aspect 和其他对象连接起来, 并创建 adviced object 的过程。<br>有3种方式，spring 采用的是运行时（上面提到过）：</p>
<ul>
<li>编译器织入, 这要求有特殊的Java编译器.</li>
<li>类装载期织入, 这需要有特殊的类装载器.</li>
<li>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式.<br>Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</li>
</ul>
<h3 id="关注点（concern）"><a href="#关注点（concern）" class="headerlink" title="关注点（concern）"></a>关注点（concern）</h3><p>对软件工程有意义的小的、可管理的、可描述的软件组成部分，一个关注点通常只同一个特定概念或目标相关联。</p>
<p>通俗来说其实指的就是重复代码；在一些方法中，我们可能需要写许多重复代码，而真正的核心代码就只有几行。<br>比如 DAO 层中的 session 处理的代码，又是事务又是连接的，每个方法都需要写，这些代码就可以看作是关注点，我们要做的就是分离它，使用代理，可以在运行期间，执行核心业务代码的时候动态植入关注点代码<br>AOP 的目标就是让关注点代码和业务代码进行分离<br>不太严谨的讲，切面也可以理解为关注点形成的类，也就是说很多重复的代码就可以形成一个切面</p>
<h2 id="通知-advice-类型"><a href="#通知-advice-类型" class="headerlink" title="通知(advice)类型"></a>通知(advice)类型</h2><p>Spring 中的通知有五种类型：</p>
<ol>
<li><strong>前置通知(Before)：</strong><br>在目标方法被调用之前调用通知功能；<br>在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</li>
<li><strong>后置通知(After)：</strong><br>在目标方法完成之后调用通知；<br><strong>不管是否正常退出或者发生了异常都会执行</strong></li>
<li><strong>返回通知/最终通知(After-returning)：</strong><br>在目标方法成功执行之后调用通知，如果有后置通知会在其之后执行；<br>在方法正常返回后执行</li>
<li><strong>异常通知(After-throwing)：</strong><br>在目标方法抛出异常后调用通知；</li>
<li><strong>环绕通知(Around)：</strong><br>通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>在 join point 前和 joint point 退出后都执行的 advice. <strong>这个是最常用的 advice.</strong></li>
</ol>
<p>运行顺序：<strong>前置通知/环绕通知</strong>–<strong>目标方法执行</strong>–<strong>返回通知/异常通知</strong>–<strong>后置通知/环绕通知</strong><br>这里需要注意的是：环绕通知由于和前置、后置处于同一个 aspect 内，所以是无法确定其执行顺序的，当然可以通过其他手段来解决<br>实际开发中，一般会将顺序执行的 Advice 封装到不同的 Aspect，然后通过注解或者实现接口的方式控制 Aspect 的执行顺序，二选一（对于在同一个切面定义的通知函数将会根据在类中的声明顺序执行）</p>
<h2 id="关于-AOP-Proxy"><a href="#关于-AOP-Proxy" class="headerlink" title="关于 AOP Proxy"></a>关于 AOP Proxy</h2><p>Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.<br>如果需要为一个类（没有实现接口）实现代理, 那么可以使用 CGLIB 代理.<br>当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.</p>
<p>JDK 中的代理一般是 $ 开头，Cglib 一般就是代理对象名开头后面再加一些东西<br>这两种我以前都写过，关于 JDK 动态代理的介绍我放在参考[2]；关于 Cglib 的介绍使用我放在参考[3]</p>
<h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p><strong>@AspectJ</strong> 是一种使用 Java 注解来实现 AOP 的编码风格.<br>@AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持@AspectJ 的 AOP 风格.</p>
<h3 id="使能-AspectJ-支持"><a href="#使能-AspectJ-支持" class="headerlink" title="使能 @AspectJ 支持"></a>使能 @AspectJ 支持</h3><p>@AspectJ 可以以 XML 的方式或以注解的方式来使用, 并且不论以哪种方式使能 @ASpectJ, 我们都必须保证 <code>aspectjweaver.jar</code> 在 classpath 中.<br>使用 <strong>Java Configuration</strong> 方式使能 @AspectJ，想深入了解的可见参考[5]：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>@Configuration 注解简单说就是把一个类作为 IoC 容器（还可配合 @Bean 使用，写 Spring 注解的时候有解释）；<br>使用 XML 方式使能 @AspectJ ，顺便记得加上命名空间：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动扫描方式加载对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动 @AspectJ 支持 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="定义-aspect-切面"><a href="#定义-aspect-切面" class="headerlink" title="定义 aspect(切面)"></a><strong>定义 aspect(切面)</strong></h4><p>当使用注解 <strong>@Aspect</strong> 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并<strong>添加到 Spring AOP 中</strong>, 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：仅仅使用 @Aspect 注解, 并不能将一个 Java 对象转换为 Bean，因此我们还需要使用类似 @Component 之类的注解.<br><div class="note info"><p>如果一个 类被 @Aspect 标注, 则这个类就不能是其他 aspect 的 <strong>advised object</strong> 了, 因为使用 @Aspect 后, 这个类就会被排除在 auto-proxying 机制之外.</p>
</div></p>
<p>也就是说：Spring 将会把它当作一个特殊的 Bean（一个切面），也就是说不对这个类本身进行动态代理</p>
<h4 id="声明-pointcut"><a href="#声明-pointcut" class="headerlink" title="声明 pointcut"></a>声明 pointcut</h4><p>一个 pointcut 的声明由两部分组成:</p>
<ul>
<li>一个方法签名, 包括方法名和相关参数</li>
<li><strong>一个 pointcut 表达式</strong>, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).</li>
</ul>
<p>在 @AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 一般用空方法即可，方法名随意，即:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xys.service.UserService.*(..))"</span>) <span class="comment">// 切点表达式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 切点前面</span></span><br></pre></td></tr></table></figure>
<p><strong>这个方法必须无返回值.</strong><br>这个方法本身就是 pointcut signature；<strong>pointcut 表达式使用 @Pointcut 注解指定.</strong><br>上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 <strong>com.xys.service.UserService</strong> 下的所有方法的执行，第一个 <code>*</code> 指的是任何返回值，<code>(..)</code> 指的是此方法的任何参数，多个可以使用 <code>||</code> 分割，其他的应该就更好理解了；需要注意的是最后一定是定义到方法的！</p>
<h4 id="声明-advice"><a href="#声明-advice" class="headerlink" title="声明 advice"></a>声明 advice</h4><p>advice 是<strong>和一个 pointcut 表达式关联在一起的</strong>, 并且会在匹配的 join point 的方法执行的前/后/周围 运行.<br><strong>pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式.</strong><br>下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAspectTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xys.service.UserService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************分割线*****************************/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviseDefine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.xys.aspect.PointcutDefine.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeAccessCheck</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****Before advise, method: "</span> + joinPoint.getSignature().toShortString() + <span class="string">" *****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 @Before 引用的是一个 pointcut 的名字，并且这个 pointcut 并不是和它在同一个包下的，如果在同一个类中那直接写名字就可以了，或者直接把表达式放在 @Before 中就行了</p>
<p>这里再着重说下 around advice，因为 around advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, <strong>并且甚至可以决定何时, 如何, 是否调用匹配到的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviseDefine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"com.xys.aspect.PointcutDefine.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAroundAccessCheck</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 开始</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        System.out.println(<span class="string">"invoke method: "</span> + pjp.getSignature().getName() + <span class="string">", elapsed time: "</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诺，就是这样，其他的通知就不写了，都是一样的，就是注解不一样而已</p>
<h3 id="切点标志符-designator"><a href="#切点标志符-designator" class="headerlink" title="切点标志符(designator)"></a>切点标志符(designator)</h3><p>AspectJ5 的切点表达式由<strong>标志符(designator)</strong>和<strong>操作参数</strong>组成. 如 <code>&quot;execution(* greetTo(..))&quot;</code> 的切点表达式, <strong>execution</strong> 就是标志符, 而圆括号里的 <code>* greetTo(..)</code> 就是操作参数<br>下面介绍几个标志符：</p>
<ul>
<li><p><strong>execution</strong><br>匹配 join point 的执行, 例如 <code>&quot;execution(* hello(..))&quot;</code> 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.<br>不写包名默认就是本包内，必须要精确到方法</p>
</li>
<li><p><strong>within</strong><br>匹配特定包下的所有 join point, 例如 <code>within(com.xys.*)</code> 表示 com.xys 包中的所有连接点, <strong>即包中的所有类的所有方法</strong>. 而 <code>within(com.xys.service.*Service)</code> 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.</p>
</li>
<li><p><strong>this 与 target</strong><br>this 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of).<br>而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).</p>
</li>
<li><p><strong>bean</strong><br>匹配 bean 名字为指定值的 bean 下的所有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bean(*Service) <span class="comment">// 匹配名字后缀为 Service 的 bean 下的所有方法</span></span><br><span class="line">bean(myService) <span class="comment">// 匹配名字为 myService 的 bean 下的所有方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>args</strong><br><strong>匹配参数满足要求的的方法</strong>，一般和其他的标志符连用，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.xys.demo2.*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(value = <span class="string">"pointcut2()  &amp;&amp;  args(name)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"---page: &#123;&#125;---"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************分割线*************************/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---NormalService: someMethod invoked---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---NormalService: test invoked---"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"服务一切正常"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <strong>NormalService.test</strong> 执行时, 则 advice <strong>doSomething</strong> 就会执行, test 方法的参数 name 就会传递到 doSomething 中，常用的一些栗子有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配只有一个参数 name 的方法</span></span><br><span class="line"><span class="meta">@Before</span>(value = <span class="string">"aspectMethod()  &amp;&amp;  args(name)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配第一个参数为 name 的方法</span></span><br><span class="line"><span class="meta">@Before</span>(value = <span class="string">"aspectMethod()  &amp;&amp;  args(name, ..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配第二个参数为 name 的方法</span></span><br><span class="line">Before(value = <span class="string">"aspectMethod()  &amp;&amp;  args(*, name, ..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这个标志符是非常重要的，经常能用到，因为使用方式非常的灵活。</p>
</li>
<li><p><strong>@annotation</strong><br><strong>匹配由指定注解所标注的方法</strong> ，举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配由注解 AuthChecker 所标注的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.xys.demo1.AuthChecker)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>常用的标志符就是上面的这些了，这些基本能满足大部分的需求了，大概……..</p>
<h3 id="常见的切点表达式"><a href="#常见的切点表达式" class="headerlink" title="常见的切点表达式"></a>常见的切点表达式</h3><p>标志符知道了，表达式也不在话下，上面说过表达式是由标志符和操作参数组成，那么来看一下常用的表达式吧：</p>
<p>匹配<strong>方法</strong>签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配指定包中的所有的方法</span></span><br><span class="line">execution(* com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配当前包中的指定类的所有方法</span></span><br><span class="line">execution(* UserService.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">int</span> com.xys.service.*(String name, ..))</span><br></pre></td></tr></table></figure>
<p>匹配<strong>类型</strong>签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配指定包中的所有的方法, 但不包括子包</span></span><br><span class="line">within(com.xys.service.*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有的方法, 包括子包</span></span><br><span class="line">within(com.xys.service..*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配当前包中的指定类中的方法</span></span><br><span class="line">within(UserService)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配一个接口的所有实现类中的实现的方法</span></span><br><span class="line">within(UserDao+)</span><br></pre></td></tr></table></figure>
<p>匹配 Bean 的名字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配以指定名字结尾的 Bean 中的所有方法</span></span><br><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure>
<p>常用的表达式组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配以 Service 或 ServiceImpl 结尾的 bean</span></span><br><span class="line">bean(*Service || *ServiceImpl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean</span></span><br><span class="line">bean(*Service) &amp;&amp; within(com.xys.service.*)</span><br></pre></td></tr></table></figure>
<p>以上，就是常用的了，应该能满足大部分的需求了吧….</p>
<h2 id="使用-XML-定义"><a href="#使用-XML-定义" class="headerlink" title="使用 XML 定义"></a>使用 XML 定义</h2><p>首先应当确保引入了命名空间，也就是 schema 的支持，先来看一段简单的栗子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">ref</span>=<span class="string">"aBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"businessService"</span>   </span></span><br><span class="line"><span class="tag">          <span class="attr">expression</span>=<span class="string">"execution（* com.xyz.myapp.service.*.*（..）） &amp;&amp; this（service）"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"businessService"</span> <span class="attr">method</span>=<span class="string">"monitor"</span>/&gt;</span>  </span><br><span class="line">    ...  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置多个切点，&amp;&amp; || ! --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pc"</span> <span class="attr">expression</span>=<span class="string">"execution(public * com.*.service.*.*(..)) || execution(public * com.*.*.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc"</span> <span class="attr">advice-ref</span>=<span class="string">"userTxAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看以看出，所有的相关配置都写在 <strong>aop:config</strong> 中，<strong>aop:aspect</strong> 是定义一个切面，<strong>aop:pointcut</strong> 是定义一个切点，指明一个表达式，然后就是通过 <strong>aop:before</strong> 等一系列标签来指定通知了<br>看过注解后再看 XML 大部分都是能直接看懂的。</p>
<p>补充一点，在 XML 中如果想定义多个切点，第一种可以在表达式使用 <code>&amp;&amp;/and</code> 或者 <code>||/or</code> 连接，推荐使用小写字母；第二种可以定义多个 <code>&lt;aop:advisor pointcut=&quot;&quot; /&gt;</code></p>
<p>关于 Hibernate 事务相关的 AOP 配置：<a href="https://bfchengnuo.com/2017/09/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/#%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1">点我跳转</a></p>
<h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p>[0]：<a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469968</a><br>[1]：<a href="http://linbinghe.com/2017/65db25bc.html" target="_blank" rel="noopener">http://linbinghe.com/2017/65db25bc.html</a><br>[2]：<a href="https://bfchengnuo.com/2017/05/26/Java%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/#动态代理">JDK动态代理</a><br>[3]：<a href="https://bfchengnuo.com/2017/09/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/#AOP编程">关于Cglib</a><br>[4]：<a href="https://jacksmiththu.github.io/2017/06/26/Spring%E4%B8%AD%E7%9A%84AOP/" target="_blank" rel="noopener">https://jacksmiththu.github.io/2017/06/26/Spring%E4%B8%AD%E7%9A%84AOP/</a><br>[5]：<a href="http://blog.csdn.net/ethanwhite/article/details/52050351" target="_blank" rel="noopener">http://blog.csdn.net/ethanwhite/article/details/52050351</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring学习笔记（二）]]></title>
      <url>http://bfchengnuo.com/2017/09/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>这里的 Spring 指的还是 SpringFramework ；Spring 是做什么的上一篇中已经说的很详细了，也主要是说的怎么用，这篇主要是对上篇的知识补充，多是理论的补充，有些重复内容，写的也很混乱….<a id="more"></a><br>Spring AOP 详细的整理已出！强行下一篇就是！</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring 提供了一站式解决方案，它主要包含六大模块：</p>
<ol>
<li>Spring Core<br>核心功能：IoC 容器，解决对象的创建及其依赖关系<br>jar 包组成由：<br><code>spring-expression-4.3.11.RELEASE.jar</code><br><code>spring-beans-4.3.11.RELEASE.jar</code><br><code>spring-core-4.3.11.RELEASE.jar</code><br><code>commons-logging-1.2.jar</code><br><code>spring-context-4.3.11.RELEASE.jar</code></li>
<li>Spring Web<br>这是 spring 对 web 模块的支持，也就是说可以与 Struts 整合，把 Action 的创建交给 spring；<br>或者可以使用自家的 springMVC，相关的 jar 包有：<br><code>spring-web-4.3.11.RELEASE.jar</code><br><code>spring-webmvc-portlet-4.3.11.RELEASE.jar</code><br><code>spring-webmvc-4.3.11.RELEASE.jar</code><br><code>spring-websocket-4.3.11.RELEASE.jar</code></li>
<li>Spring DAO<br>这是 spring 对 jdbc 的支持，比如 JdbcTemplate 模板工具类，相关的 jar 包有：<br><code>spring-jdbc-4.3.11.RELEASE.jar</code><br><code>spring-oxm-4.3.11.RELEASE.jar</code><br><code>spring-jms-4.3.11.RELEASE.jar</code><br><code>spring-tx-4.3.11.RELEASE.jar</code><br><code>spring-orm-4.3.11.RELEASE.jar</code></li>
<li>Spring ORM<br>这是 spring 对 ORM 的支持，既可以与 hibernate 整合，也可以选择使用 spring 对 hibernate 操作的封装</li>
<li>Spring AOP<br>上篇中说过了，对 AOP 的支持，也就是面向切面编程，相关的 jar 包有：<br><code>spring-aop-4.3.11.RELEASE.jar</code><br><code>spring-instrument-4.3.11.RELEASE.jar</code><br><code>spring-aspects-4.3.11.RELEASE.jar</code><br><code>spring-instrument-tomcat-4.3.11.RELEASE.jar</code></li>
<li>Spring EE<br>这是 spring 对 javaEE 其他模块的支持</li>
</ol>
<h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><p>关于 Bean 的生命周期在上一篇说的非常非常详细了，总结就是：如果你设置了单例模式，也就是默认的，并且懒加载没有开启（默认）那么它会在启动的时候创建（实例化）；但是如果设置的是 prototype 就是在获取的时候才进行实例化</p>
<h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>在装配 Bean 的时候，上一篇使用的是 property 标签，通过相应的 Set 方法进行注入，其实还可以使用 <strong>constructor-arg</strong> 标签来进行初始化，它们的区别是一个是通过 set 方法，一个是通过构造函数（不一定非要是构造，其他带参数的方法也行，比如下面要说的工厂方式），默认用的就是无参的构造函数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.rc.sp.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"dream"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>soldier<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>scientist<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>pilot<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"math"</span> <span class="attr">value</span>=<span class="string">"90"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"english"</span> <span class="attr">value</span>=<span class="string">"85"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意下顺序，如果顺序和构造函数不同要使用 index （从 0 开始）或者 name 属性来指定；name 省略其实也可以</p>
<h3 id="使用工厂"><a href="#使用工厂" class="headerlink" title="使用工厂"></a>使用工厂</h3><p>创建 bean 的方式中，除了使用构造函数常见的还有就是使用工厂模式了，并且分为静态工厂和实例工厂；如果使用的不是静态方法，那么就需要先创建工厂对象然后通过方法进行获取实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先创建工厂对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.TestFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用工厂的方法创建实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用的是静态的，那么就不需要创建工厂对象了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用工厂的方法创建实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.TestFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getStaticInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="p命名空间"><a href="#p命名空间" class="headerlink" title="p命名空间"></a>p命名空间</h2><p>p 命名空间是用来简化属性注入的，就是说让我们少写一些 property 标签，使用之前需要先引入 xmlns，但是没有对应的 Schema 文件，因为没有办法预先知道用户使用的属性名称，所以也就无法定义 Schema 文件。<br>所以说只需要加入 <code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 就可以使用了，具体的使用方式是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rob"</span> <span class="attr">class</span>=<span class="string">"..TestBean"</span> <span class="attr">p:name</span>=<span class="string">"Rob Harrop"</span> <span class="attr">p:spouse-ref</span>=<span class="string">"sally"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sally"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样是不是简洁多了呢，使用 <code>p:name</code> 直接注入其 name 属性的值，<code>p:spouse-ref</code> 就是注入 spouse 属性，不过是引用的其他 bean，当然使用的还是 set 方法来进行注入的。</p>
<h2 id="AOP编程"><a href="#AOP编程" class="headerlink" title="AOP编程"></a>AOP编程</h2><p><a href="https://bfchengnuo.com/2017/09/22/Spring%E4%B8%AD%E7%9A%84AOP/">Spring中的AOP</a> 文章已经整理完，关于 AOP 的详细信息推荐去看看！<br>在 Spring 中的 AOP 处理中，如果加入容器的目标对象有实现接口就使用 JDK 代理，如果目标对象没有实现接口就使用 Cglib 代理。</p>
<p>另外补充下，最早做 AOP 的是 Eclipse 的 Aspect，Spring 也是引用的它</p>
<h3 id="代理对象的创建-Cglib"><a href="#代理对象的创建-Cglib" class="headerlink" title="代理对象的创建-Cglib"></a>代理对象的创建-Cglib</h3><p>不知道以前是否写过，在创建代理对象的时候，如果目标对象有接口那么用 JavaAPI 的那一套就可以创建代理对象了，但是如果目标对象没有实现接口，那么就白搭了，好在有一个叫 Cjlib 的库，它被许多 AOP 框架使用，它就是为了解决这个问题，具体的介绍自行搜索，这里只说明它的作用<br>它是通过继承的方式来实现的，首先有一个通用的工具类 <strong>Enhancer</strong>，通过这个工具类设置父类为我们的目标对象，然后设置回调函数，最后创建一个子类返回就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">	<span class="comment">// 维护目标对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 1.工具类</span></span><br><span class="line">		Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">// 2.设置父类</span></span><br><span class="line">		en.setSuperclass(target.getClass());</span><br><span class="line">		<span class="comment">// 3.设置回调函数</span></span><br><span class="line">		en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 4.创建子类（代理对象）</span></span><br><span class="line">		<span class="keyword">return</span> en.create();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">		MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始"</span>);</span><br><span class="line">		<span class="comment">// 执行目标对象的方法</span></span><br><span class="line">		Object returnValue = method.invoke(target, args);</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么用就不用说了吧…..因为本质是采用的继承的方式，所以有几个注意事项：</p>
<ul>
<li>代理的类不能为 final，否则报错</li>
<li>目标类的方法不能为 final 或者 static，否则不会进行拦截</li>
</ul>
<p>当然不要忘记了代理类实现接口。<br>JDK 中的代理一般是 <code>$</code> 开头，Cglib 一般就是代理对象名开头后面再加一些东西</p>
<h3 id="关注分离"><a href="#关注分离" class="headerlink" title="关注分离"></a>关注分离</h3><p>前面也是提到过这个词的，什么关注分离思想，<strong>关注点是什么呢？其实指的就是重复代码</strong>；在一些方法中，我们可能需要写许多重复代码，而真正的核心代码就只有几行。<br>比如 DAO 层中的 session 处理的代码，又是事务又是连接的，每个方法都需要写，这些代码就可以看作是关注点，我们要做的就是分离它<br><strong>使用代理，可以在运行期间，执行核心业务代码的时候动态植入关注点代码</strong></p>
<p>AOP 的目标就是让关注点代码和业务代码进行分离</p>
<p>对比上一篇“专业”的解释，我们来一把通俗的介绍，当然可能并不准确；<br>通知/增强： 就是 关注点，也就是重复的代码；<br>切面： 就是关注点形成的类，也就是说很多重复的代码就可以形成一个切面；<br>切入点：运行时在哪里织入切面类的代码，拦截的作用；</p>
<p>面向切面编程：对很多重复的代码进行抽取，然后在运行的时候往业务方法上进行织入切面类代码。</p>
<h2 id="Spring中使用AOP"><a href="#Spring中使用AOP" class="headerlink" title="Spring中使用AOP"></a>Spring中使用AOP</h2><p>提起 AOP 那其实要说下 Aspect 了，它值得去单独去学习，也不少的内容，这里就只是简单的说下 Spring 中常用的几种形式，如果有必要，会单独开一篇写 AspectJ ，并且一篇都不一定写的完，大体浏览了下，内容确实不少，慢慢来吧</p>
<p>首先必要的在 xml 中引入命名空间和相关 jar 包就不细说了，记得配置开启注解，这个比较省事，大都采用这种形式吧</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 自动扫描方式加载对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动 @AspectJ 支持 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上一篇中使用的 XML 配置，然后下面简单介绍下注解的使用：</p>
<ul>
<li>@Aspect<br>声明该类是一个切面， Spring 将会把它当作一个特殊的 Bean（一个切面），也就是说不对这个类本身进行动态代理 。</li>
<li>@Pointcut<br>定义切入点，切入点的名称就是此方法名，也就是确定拦截哪些方法，就是为哪些类生成代理对象<br>参数为切入点表达式：<code>@Pointcut(&quot;execution (* com.bfchengnuo.service..*.*(..))&quot;)</code><br>第一个 <code>*</code> 指的是任何返回值，<code>(..)</code> 指的是任何参数，<code>..</code> 指的是本包、以及及其子包下，多个可以使用 <code>||</code> 分割，甚至可以在前面加 <code>!</code> ，其他的应该就更好理解了；需要注意的是最后一定是定义到方法的！</li>
</ul>
<p>其他的注解就没什么难度了，来看个栗子就都知道了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> calss Audience &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把 Performance 的 perform 方法定义为名为 performance 的切点</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 表演之前输出</span></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silencePhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Siliencing phones."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 表演之后输出</span></span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Claping."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 表演失败（抛出异常）输出</span></span><br><span class="line">  <span class="meta">@AfterThrowing</span>（“Performance()”)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的理论知识补充可以去参考 <a href="https://bfchengnuo.com/2017/09/22/Spring%E4%B8%AD%E7%9A%84AOP/">Spring中的AOP</a> 一文</p>
<h2 id="对JDBC的支持"><a href="#对JDBC的支持" class="headerlink" title="对JDBC的支持"></a>对JDBC的支持</h2><p>在刚开始的时候已经看到了，Spring 中有个模块就是 Spring DAO，说明了 Spring 对 JDBC 的支持还是很好的，；例如体现在对 C3P0 连接池的支持上，甚至比 Hibernate 都好，并且有 JdbcTemplate 模板工具类（类似 DBUtils）。<br>下面配置 dataSource 的方式应该都比较熟悉了，使用 C3P0：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"org.gjt.mm.mysql.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/ssh?useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池中保留的最小连接数。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池中保留的最大连接数。Default: 15 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.curd.spring.impl.UserDAOImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">ref</span>=<span class="string">"jdbcTemplate"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>并且顺便把 JdbcTemplate 也进行实例化了，它需要一个数据域，可以 set 方法指定，也可以构造函数给它；<br>至于它怎么使用，看个栗子就都知道了，会感觉很熟悉吧….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IUserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user values(?,?,?)"</span>;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(sql, user.getId(), user.getUsername(),</span><br><span class="line">                user.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from user where id=?"</span>;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(sql, id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update user set username=?,password=? where id=?"</span>;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(sql, user.getUsername(),</span><br><span class="line">                user.getPassword(), user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">searchUserName</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;<span class="comment">// 简单查询，按照ID查询，返回字符串</span></span><br><span class="line">        String sql = <span class="string">"select username from user where id=?"</span>;</span><br><span class="line">        <span class="comment">// 返回类型为String(String.class)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForObject(sql, String.class, id);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;<span class="comment">// 复杂查询返回List集合</span></span><br><span class="line">        String sql = <span class="string">"select * from user"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().query(sql, <span class="keyword">new</span> UserRowMapper());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">searchUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        String sql=<span class="string">"select * from user where id=?"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForObject(sql, <span class="keyword">new</span> UserRowMapper(), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UserRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">　　　　　<span class="comment">//rs为返回结果集，以每行为单位封装着</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">            user.setUsername(rs.getString(<span class="string">"username"</span>));</span><br><span class="line">            user.setPassword(rs.getString(<span class="string">"password"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户自己编写DAO 只需要继承 JdbcDaoSupport， 就可以注入 JdbcTemplate，下面就可以直接用了；JdbcTemplate 基本就可以满足一些日常需求了</p>
<h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>事务可分为两种，编程式事务和声明式事务；<br>编程式的我们都用过，比如 JDBC 中的 <code>conn.setAutoCommite(false)</code>，或者 Hibernate 中的 <code>session.beginTransaction()</code>；好处是操作比较灵活，能够实现细粒度的控制（但在 Spring 中一般不提倡使用）；<br>声明式事务就是字面意思，先声明后面直接用，如果不需要细粒度的事务控制那么可以选择，在 Spring  中只需要在配置文件中配置一下就可以了，无侵入性、无耦合的，是基于 AOP 的；<br>下面主要说说声明式事务，基于 AOP 那也就可以得出只能对方法进行事务控制，对方法内的几行实现事务控制是做不到的，可以使用两种方式进行配置，XML 或者 注解；</p>
<h3 id="XML配置方式"><a href="#XML配置方式" class="headerlink" title="XML配置方式"></a>XML配置方式</h3><p>XML 的话这样配：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义事务管理器（声明式的事务） --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate版（上）JDBC版（下） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 配置事务增强（如何管理事务） --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 将我们想要施加在事务中的语义封装在&lt;tx:advice/&gt;中，</span></span><br><span class="line"><span class="comment">	其中默认的设置为：事务性传播设置是REQUIRED；隔离级别为DEFAULT；事务是读/写；</span></span><br><span class="line"><span class="comment">	事务超时默认是依赖于事务系统的，或者事务超时没有被支持；</span></span><br><span class="line"><span class="comment">	任何 RuntimeException 将触发事务回滚，但是任何 checked Exception 将不触发事务回滚。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"test*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span>   </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 设置一个 pointcut 确保由 "txAdvice" bean定义的事务通知在应用中合适的点来执行，</span></span><br><span class="line"><span class="comment">	然后使用一个通知器(advisor)将该切面与 txAdvice 绑定到一起，</span></span><br><span class="line"><span class="comment">	其中 expression 的属性是织入点语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(public * com.niu.service..*.*(..))"</span> <span class="attr">id</span>=<span class="string">"transactionAop"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"transactionAop"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- *******************分割线************************ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定异常回滚类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">rollback-for</span>=<span class="string">"NoProductInStockException"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--即使遇到没有经过处理的InstrumentNotFoundException异常，也不要回滚事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">no-rollback-for</span>=<span class="string">"InstrumentNotFoundException"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了上面列出的两种事务管理器，其实还有 JpaTransactionManager、JtaTransactionManager 等，就不介绍了，声明事务管理并不是这一种，更多的可以参考最后一个<a href="#参考&amp;资料">参考连接</a><br>分割线下的不设置也可以，大概……. ；这里的 txManager 就相当于是个切面了<br><code>&lt;tx:method&gt;</code>设置：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>是否需要</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>是</td>
<td></td>
<td>与事务属性关联的方法名。</td>
</tr>
<tr>
<td>propagation</td>
<td>不</td>
<td>REQUIRED</td>
<td>事务传播行为</td>
</tr>
<tr>
<td>isolation</td>
<td>不</td>
<td>DEFAULT</td>
<td>事务隔离级别</td>
</tr>
<tr>
<td>timeout</td>
<td>不</td>
<td>-1</td>
<td>事务超时时间，以秒为单位</td>
</tr>
<tr>
<td>readonly</td>
<td>不</td>
<td>false</td>
<td>事务是否只读</td>
</tr>
<tr>
<td>rollback-for</td>
<td>不</td>
<td></td>
<td>将被触发回滚的Exception，以逗号隔开</td>
</tr>
<tr>
<td>no-rollback-for</td>
<td>不</td>
<td></td>
<td>不被触发回滚的Exception，以逗号隔开</td>
</tr>
</tbody>
</table>
<h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>使用注解的方式还是要配下 XML 文件，起码要设置开启扫描、事务管理器之类的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--启动注解版事务管理开关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以使用 <strong>@Transactional</strong> 注解进行设置了，关于这个注解前面文章中讲过（<a href="https://bfchengnuo.com/2017/09/04/Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">Spring 中的注解</a>）</p>
<h2 id="参考-amp-资料"><a href="#参考-amp-资料" class="headerlink" title="参考&amp;资料"></a>参考&amp;资料</h2><p>AOP 系列：<a href="https://my.oschina.net/itblog/blog/208067" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/208067</a><br><a href="https://jacksmiththu.github.io/2017/06/26/Spring%E4%B8%AD%E7%9A%84AOP/" target="_blank" rel="noopener">https://jacksmiththu.github.io/2017/06/26/Spring%E4%B8%AD%E7%9A%84AOP/</a><br><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a><br><a href="http://www.cnblogs.com/hellojava/archive/2012/11/21/2780694.html" target="_blank" rel="noopener">http://www.cnblogs.com/hellojava/archive/2012/11/21/2780694.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-适配器模式]]></title>
      <url>http://bfchengnuo.com/2017/09/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>总的来说这是一个非常简单的适配器，但却非常的好用；另外还补充了个和它差不多的模式：外观模式<br>首先来看下适配器的定义：<br><strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong><a id="more"></a><br>划重点就是：使用对象组合的方式，把一种接口转换成另一种接口；也就是说适配者和被适配者不需要改变任何的代码，只需要在它们中间加一个适配器就可以了<br>来张图就显得非常好理解了：</p>
<p><img src="/image/dev/适配器.png" alt="适配器.png"></p>
<h2 id="适配器分类"><a href="#适配器分类" class="headerlink" title="适配器分类"></a>适配器分类</h2><p>实际上有两种适配器，对象适配器和类适配器<br>对象适配器多是用的组合的方式；类适配器则是用的多继承的方式，因为在 Java 中并不支持多继承，所以类适配器就不演示了，看看对象适配器就好，反正思想都是一样的</p>
<p>对象适配器不仅可以适配某个类，也可以适配该类的任何子类<br>类适配器非要说的话，Java 中也是可以模拟的，就是适配器继承一个类（源）然后实现一个接口（目标）的方式了<br>适配器也不一定是单向的，如果实现了双方的接口，也就成了一个双向的适配器</p>
<h2 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h2><ul>
<li><strong>目标(Target)角色：</strong><br>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</li>
<li><strong>源(Adapee)角色：</strong><br>现在需要适配的接口。</li>
<li><strong>适配器(Adaper)角色：</strong><br>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</li>
</ul>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>既然是把接口转换成另一种接口，那么就先来定义接口吧，就是目标角色和源角色的接口以及它们的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wearClothes</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 穿女装？？！</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wearDress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prayer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***************实现类们****************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LovelyGirl</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wearDress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿女装 o(*≧▽≦)ツ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"少女进食中...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"少女祈祷中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReliableBoy</span> <span class="keyword">implements</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wearClothes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿“合适”的衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"男孩吃饭中...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后下面就是关键的适配器了，在这个简单的栗子里是非常的简单的，没什么技术含量…..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyAdapter</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boy boy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoyAdapter</span><span class="params">(Boy boy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.boy = boy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wearDress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"适配/转换中..."</span>);</span><br><span class="line">        boy.wearClothes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boy.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我不会...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来测试下，按照设计原则，尽量的多使用接口，多使用组合..：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">new</span> ReliableBoy();</span><br><span class="line">        Girl girl = <span class="keyword">new</span> LovelyGirl();</span><br><span class="line">        BoyAdapter boyAdapter = <span class="keyword">new</span> BoyAdapter(boy); <span class="comment">// 使他看起来像个女孩...</span></span><br><span class="line"></span><br><span class="line">        testGirl(girl);</span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        testGirl(boyAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法需要一个 Girl</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">        girl.eat(); <span class="comment">// 先吃饭</span></span><br><span class="line">        girl.wearDress(); <span class="comment">// 穿衣服</span></span><br><span class="line">        girl.prayer();  <span class="comment">// 做祷告</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适配器差不多就这个样子了，就是说当目标调用的方法（接口）和期望的不同时，可以转换一下，达到以假乱真的目的，由于调用者使用的是接口，所以它确实不知道你传进来的其实是一个<del>伪娘</del>不同类型的对象</p>
<h3 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h3><ul>
<li>装饰者：不改变接口，但加入责任<br>将一个对象包装起来以增加新的行为和责任</li>
<li>适配器：将一个接口转成另一个接口</li>
<li>外观：让接口更简单<br>将一群对象“包装”起来以简化其接口<br>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观模式</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式也是一个改变接口的模式，但它改变接口的原因是为了简化接口，让其显露出一个干净的外观嘛~~同时它也将客户从组件的子系统中解耦了<br><strong>一个子系统可以定义多个外观</strong>；引入外观之后依然可以调用之前的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> SubSystemA obj1 = <span class="keyword">new</span> SubSystemA();  </span><br><span class="line">    <span class="keyword">private</span> SubSystemB obj2 = <span class="keyword">new</span> SubSystemB();  </span><br><span class="line">    <span class="keyword">private</span> SubSystemC obj3 = <span class="keyword">new</span> SubSystemC();  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        obj1.MethodA();  </span><br><span class="line">        obj2.MethodB();  </span><br><span class="line">        obj3.MethodC();  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj1.MethodA();</span><br><span class="line">        obj3.MethodC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。<br>另外，它可以让客户端（调用者）的学习成本降低；或者可以配合工厂模式来进行使用<br>引用的 SubSystem 都应该是接口才对，另外可以提供 setter 方法或者在构造函数中进行延迟初始化<br>放在这里因为和适配器模式还是有点关联的，并且它非常非常的简单<br>更多可参考：<a href="http://blog.csdn.net/c_son/article/details/51121432" target="_blank" rel="noopener">http://blog.csdn.net/c_son/article/details/51121432</a></p>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>还是以 JDK 中的栗子，早先，所有的集合都实现了一个 elements 的方法，用于返回一个枚举，使用枚举来进行迭代元素；<br>后来开始使用了 Iterator 这个接口，使用迭代器来迭代元素，它还支持删除元素的能力<br>那么，为了让它和老版本的枚举兼容，就需要使用适配器来进行转换了</p>
<p>在 Android 开发中就有大量的适配器，写过 ListView 的都造是吧？</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-命令模式]]></title>
      <url>http://bfchengnuo.com/2017/09/14/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>首先，我们来看下命令模式的定义：<br><strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</strong><br>命令模式是一种行为模式，通俗点说 可以把它看成分离的关注点，可将“动作请求者”从“动作执行者”对象中解耦；<a id="more"></a><br>对于请求者（客户端）只需要知道调用某个方法就能达到相应的效果，并不需要执行者具体是怎么做的，它们之间用一个命令对象来连接</p>
<h2 id="命令模式结构"><a href="#命令模式结构" class="headerlink" title="命令模式结构"></a>命令模式结构</h2><p>命令模式涉及到五个角色，它们分别是：</p>
<ul>
<li><strong>客户端(Client)角色：</strong><br>创建一个具体命令(ConcreteCommand)对象并确定其接收者。<br>通俗理解我们写的测试类就是一个客户端角色，也就是要负责创建那些所需要的对象</li>
<li><strong>命令(Command)角色：</strong><br>声明了一个给所有具体命令类的抽象接口。一般会定义一个 execute 和 undo 方法</li>
<li><strong>具体命令(ConcreteCommand)角色：</strong><br>定义一个接收者和行为之间的弱耦合；实现 execute() 方法，负责调用接收者的相应操作。<br>execute() 方法通常叫做执行方法。</li>
<li><strong>请求者(Invoker)角色：</strong><br>负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
<li><strong>接收者(Receiver)角色：</strong><br>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ul>
<h2 id="一个简单的栗子"><a href="#一个简单的栗子" class="headerlink" title="一个简单的栗子"></a>一个简单的栗子</h2><p>还是通过代码来看比较好，首先从<strong>命令角色</strong>开始写吧，就是定义一个接口，所有的命令都要实现它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<strong>接收者角色</strong> ；就是具体做事情的类了，这种栗子大概只有我会看懂….emmm，下面会改的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LovelyLoli</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"啦啦啦o(*≧▽≦)ツ.....dance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义具体的命令角色，大部分情况下是一种具体的命令对应一种“行为”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoliDanceCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 命令角色中会持有一个接受者角色</span></span><br><span class="line">    <span class="keyword">private</span> LovelyLoli loli;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造函数来取得</span></span><br><span class="line">    LoliDanceCommand(LovelyLoli loli) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loli = loli;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备中....."</span>);</span><br><span class="line">        loli.action();</span><br><span class="line">        System.out.println(<span class="string">"谢谢~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个，，，没法撤销...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请求者角色</strong> ，这个怎么说….就是执行命令的那个类？？可理解为控制器，其实还是蛮重要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoliconControl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先里面包含有一个命令，这个命令控制着一个“功能”</span></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个 set 方法可以随时更改命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用命令相关的方法称为行动方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备的差不多多了，下面就可以进行测试了，测试类也可以说是客户端角色，随意就好，反正在真正用的时候我感觉不会管是什么角色…..知道怎么用就行…额</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LoliconControl control = <span class="keyword">new</span> LoliconControl();  <span class="comment">// 调用者</span></span><br><span class="line">    LovelyLoli loli = <span class="keyword">new</span> LovelyLoli();   <span class="comment">// 具体执行者</span></span><br><span class="line">    <span class="comment">// 创建命令</span></span><br><span class="line">    LoliDanceCommand command = <span class="keyword">new</span> LoliDanceCommand(loli);</span><br><span class="line"></span><br><span class="line">    control.setCommand(command); <span class="comment">// 设置命令</span></span><br><span class="line">    control.action();  <span class="comment">// 调用命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就应该看到效果了，以上就是命令模式的栗子了，可以看出其实还是非常简单的</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>可对比定义，一个命令对象通过在特定的接受者上绑定一组动作来封装一个请求。<br>要达到这一点，需要命令对象将动作和接收者包进对象中；这个对象（命令对象）只暴露出一个 execute 方法，当这个方法被调用的时候就会执行这些动作。<br>从外面看来，其他对象不知道究竟是那个<code>接收者</code>进行了那些<code>动作</code>，只知道如果调用 execute 方法请求的目的就能达到<br>最终的主要目的之一就是让请求者和接收者之间进行解耦</p>
<h2 id="更全面的栗子"><a href="#更全面的栗子" class="headerlink" title="更全面的栗子"></a>更全面的栗子</h2><p>这里就参考 HeadFirst 中的栗子了，感觉还是非常好的，还是那几个角色，就是加入了一些别的功能，比如撤销、宏命令<br>命令角色我就不写了，因为是一样的，都是统一的 execute 和 undo 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************* 接收者角色 **********************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String local;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Light</span><span class="params">(String local)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.local = local;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(local + <span class="string">"灯已经打开！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(local + <span class="string">"灯已经关闭！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************* 具体命令角色 **********************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里其实可以执行一系列的方法</span></span><br><span class="line">        <span class="comment">// 如果次对象的状态存在多种，可以在执行之前记录当前的状态；以便给后面的撤销操作用</span></span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存在多个状态，在 exec 中记录状态，在这里获取记录的状态，然后再相应的处理</span></span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************* 请求者角色 **********************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] onCommand;</span><br><span class="line">    <span class="keyword">private</span> Command[] offCommand;</span><br><span class="line">    <span class="comment">// 如果想撤销多次，需要使用一个堆桟进行记录了</span></span><br><span class="line">    <span class="keyword">private</span> Command undoCommand; <span class="comment">// 撤销命令</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在构造器中进行初始化，具体几个按键就不用太纠结了</span></span><br><span class="line">        onCommand = <span class="keyword">new</span> Command[<span class="number">4</span>];</span><br><span class="line">        offCommand = <span class="keyword">new</span> Command[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认所有的按键都是空的，这样执行的时候就省了判断 null 了</span></span><br><span class="line">        NoCommand noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            onCommand[i] = noCommand;</span><br><span class="line">            offCommand[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot, Command onCommand, Command offCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onCommand[slot] =onCommand;</span><br><span class="line">        <span class="keyword">this</span>.offCommand[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButton</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        onCommand[slot].execute();</span><br><span class="line">        <span class="comment">// 记录当前的命令</span></span><br><span class="line">        undoCommand = onCommand[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButton</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>&#123;</span><br><span class="line">        offCommand[slot].execute();</span><br><span class="line">        <span class="comment">// 记录当前的命令</span></span><br><span class="line">        undoCommand = offCommand[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的简单例子相比，这个请求者容纳更多的命令，就像遥控器一样各自都有指定的位置，并且还具备撤销操作，其实也非常简单，接收者应该最清楚撤销怎么实现了，所以我们执行某个命令后如果需要撤销操作就再执行这条命令的撤销方法就行了，也就是说只需要记录执行时的这个命令对象就可以了，下面就看下测试的代码吧（或者说客户端？）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lightTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先创建好控制器（请求者）</span></span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    <span class="comment">// 创建具体的执行者（接受者）</span></span><br><span class="line">    Light corridorLight = <span class="keyword">new</span> Light(<span class="string">"走廊"</span>);</span><br><span class="line">    Light roomLight = <span class="keyword">new</span> Light(<span class="string">"卧室"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建相关的具体命令</span></span><br><span class="line">    LightOnCommand roomOnCmd = <span class="keyword">new</span> LightOnCommand(roomLight);</span><br><span class="line">    LightOffCommand rommOffCmd = <span class="keyword">new</span> LightOffCommand(roomLight);</span><br><span class="line">    LightOnCommand corridorOnCmd = <span class="keyword">new</span> LightOnCommand(corridorLight);</span><br><span class="line">    LightOffCommand corridorOffCmd = <span class="keyword">new</span> LightOffCommand(corridorLight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置到指定的按键上</span></span><br><span class="line">    remoteControl.setCommand(<span class="number">0</span>,roomOnCmd,rommOffCmd);</span><br><span class="line">    remoteControl.setCommand(<span class="number">1</span>,corridorOnCmd,corridorOffCmd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用执行</span></span><br><span class="line">    remoteControl.onButton(<span class="number">0</span>);</span><br><span class="line">    remoteControl.onButton(<span class="number">1</span>);</span><br><span class="line">    remoteControl.offButton(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 撤销</span></span><br><span class="line">    System.out.println(<span class="string">"撤销...."</span>);</span><br><span class="line">    remoteControl.undoButton();</span><br><span class="line">    remoteControl.offButton(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样，这样命令模式就应该差不多很全了；关于撤销，如果想撤销多次那么可以使用一个类似堆桟的结构来按顺序存储多个命令，然后就很容易可以实现多次撤销了</p>
<h3 id="使用宏命令"><a href="#使用宏命令" class="headerlink" title="使用宏命令"></a>使用宏命令</h3><p>所谓的宏命令就是命令的集群，就是说一次性执行一连串的命令达到某个效果，当然也是可以进行撤销的，使用宏命令我们再加两个类，嫌麻烦不用接口大概也是可以的…..就是嘛可能会….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MacroCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最基本的添加和删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Command command)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Command command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************* 宏命令 **************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroLightCommand</span> <span class="keyword">implements</span> <span class="title">MacroCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; undoCommands = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commands.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commands.remove(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">            undoCommands.add(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = undoCommands.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            undoCommands.get(i).undo();</span><br><span class="line">        &#125;</span><br><span class="line">        undoCommands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并没有太大的差别，具体命令对象中只是改用 List 保存一串命令，增加了 add 和 remove 方法，在执行的时候是将集合里的每个命令按顺序执行，下面是测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MacroCommand macroCommand = <span class="keyword">new</span> MacroLightCommand();</span><br><span class="line">    Light light = <span class="keyword">new</span> Light(<span class="string">"卧室"</span>);</span><br><span class="line">    LovelyLoli loli = <span class="keyword">new</span> LovelyLoli();</span><br><span class="line">    LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">    LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line">    LoliDanceCommand loliDanceCommand = <span class="keyword">new</span> LoliDanceCommand(loli);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到宏命令</span></span><br><span class="line">    macroCommand.add(lightOnCommand);</span><br><span class="line">    macroCommand.add(loliDanceCommand);</span><br><span class="line">    macroCommand.add(lightOffCommand);</span><br><span class="line"></span><br><span class="line">    macroCommand.execute();</span><br><span class="line">    System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">    macroCommand.undo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果还是不错的，嗯….</p>
<h3 id="关于空对象"><a href="#关于空对象" class="headerlink" title="关于空对象"></a>关于空对象</h3><p>注意，这里说的是空<strong>对象</strong> ，比如上面所说的 NoCommand 对象，当你不想返回一个有意义的对象时，空对象就显得非常的有用了，将处理 Null 的责任转移给了空对象，这大概会避免写太多的判断 <code>xxx != null</code> 的语句了，并且有效避免了空指针异常</p>
<p>在许多模式中都会看到空对象的使用，甚至在有些时候，空对象本身也视为是一种设计模式</p>
<h2 id="命令模式的应用"><a href="#命令模式的应用" class="headerlink" title="命令模式的应用"></a>命令模式的应用</h2><p>就像定义中所说，很多语言在设计队列请求、线程池的时候就是用的命令模式，起码我知道在 Android 中的消息机制就是这样实现的；<br>比如，在一个工作队列中，我们在一边进行添加命令，另一端则是线程；线程会从队列中取出一个命令然后执行它的 execute 方法，等待调用完成后就将此命令进行丢弃，再取出下一个命令….<br>这样的实现，工作队列和进行计算的对象之间是完全解耦的，只要实现了命令模式的对象就可以加入到队列中；当线程调用的时候，不管你是具体做什么的，只知道调用其 execute 方法</p>
<hr>
<p>还有一种比较出名的就是日志请求，通过序列化，当每个命令被执行时全部存储到硬盘中，如果出现宕机，可以从硬盘中取出重新加载，以正确的次序执行，这就相当于是回滚操作了</p>
<p>或者还可以应用于事务系统</p>
<h2 id="命令模式的优点"><a href="#命令模式的优点" class="headerlink" title="命令模式的优点"></a>命令模式的优点</h2><ul>
<li><strong>更松散的耦合</strong><br>命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</li>
</ul>
<ul>
<li><strong>更动态的控制</strong><br>命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</li>
</ul>
<ul>
<li><strong>很自然的复合命令</strong><br>命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</li>
</ul>
<ul>
<li><strong>更好的扩展性</strong><br>由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring中的注解使用总结]]></title>
      <url>http://bfchengnuo.com/2017/09/04/Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在实际使用中，Spring 的注解使用还是非常常见的，毕竟省去了那么多罗嗦的配置，前面在看它们整合 SSH 框架的时候栗子都是用注解，忽然发现我并没有学习过 Spring 的注解….<br>这不就马上来补上<a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>使用注解是在 Spring2.5（2.0以后陆续加入） 以后新加的功能，所以至少要保证版本是 2.5+，并且引入了注解的包<br>然后需要在 Spring 的配置文件中告诉它你使用了注解，最简单的一种方式就是加入下面的一句：<br><code>&lt;context:component-scan base-package=&quot;com.xxx&quot; /&gt;</code><br>它的意思就是开启自动扫描，会自动扫描你设置的包路径下的所有类，如果有注解就进行解析<br>这就是所谓的用注解来构造 IoC 容器；base-package 是可以指定多个包的，用逗号分割</p>
<h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>顾名思义，就是自动装配，其作用是为了消除 Java 代码里面的 getter/setter 与 bean 属性中的 property。<br>当然，getter 看个人需求，如果私有属性需要对外提供的话，应当予以保留。<br>@Autowired <strong>默认按类型匹配的方式</strong>，在容器查找匹配的 Bean，当<strong>有且仅有一个</strong>匹配的 Bean 时，Spring 将其注入 @Autowired 标注的变量中。<br>下面就搞个栗子看看吧，便于理解，首先在 Spring 的配置文件中设置好：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.spring"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"zoo"</span> <span class="attr">class</span>=<span class="string">"com.spring.model.Zoo"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tiger"</span> <span class="attr">class</span>=<span class="string">"com.spring.model.Tiger"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"monkey"</span> <span class="attr">class</span>=<span class="string">"com.spring.model.Monkey"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置中我们开启了自动扫描，并且配了三个 bean，但是没有给这些 bean 配置 property 属性，因为我们用注解的话是不需要的<br>下面在我们的 zoo.java 文件中这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 bean 中使用了 @Autowired 注解，并且没有设置 getter/setter 方法；因为开启了自动扫描，当 Spring 发现 @Autowired 注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的 Bean，并自动注入到相应的地方去。<br>所以，类中的 tiger 和 monkey 都已经注入成功了</p>
<div class="note info"><p>这里有个细节，就是如果在配置文件中配置了 property 属性，又使用了注解，会怎么样？<br>Spring 会按照 <strong>xml 优先的原则</strong>去 Zoo.java 中寻找这两个属性的 getter/setter，如果连 getter/setter 方法也没有那就只能抛异常了</p>
<p><strong>匹配不到 bean 的情况下，如果不想让 Spring 抛异常而是将属性设置位 null，那么可以将 @Autowired 注解的 required 属性设置为 false 即可</strong></p>
</div>
<h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><p>这个注解是用来<strong>指定注入 Bean 的名称</strong> ；也就是说如果容器中有一个以上匹配的 Bean，则可以通过 @Qualifier 注解限定 Bean 的名称，否则调用的时候会抛异常<br>比如：某个 bean 中引用了一个接口，实现这个接口的 bean 有多个，Spring 在注入的时候就不知道注入那一个了，这样要么删除其他的 bean 要么就是使用 @Qualifier 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"bmwCar"</span>)</span><br><span class="line"><span class="keyword">private</span> ICar car;</span><br></pre></td></tr></table></figure>
<p>这样通过 id 就指明了注入的是那个 bean</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>@Resource 注解与 @Autowired 注解作用非常相似，是通过 name/type 进行注入的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"tiger"</span>)</span><br><span class="line">    <span class="keyword">private</span> Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(type=Monkey.class)</span><br><span class="line">    <span class="keyword">private</span> Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就来看下它的装配顺序和与 @Autowired  的区别</p>
<h3 id="Resource的装配顺序"><a href="#Resource的装配顺序" class="headerlink" title="@Resource的装配顺序"></a>@Resource的装配顺序</h3><ol>
<li>@Resource 如果后面没有任何内容，默认通过 name 属性去匹配 bean，找不到再按 type 去匹配</li>
<li>指定了 name 或者 type 则根据指定的类型去匹配 bean</li>
<li>指定了 name 和 type 则根据指定的 name 和 type 去匹配 bean，<strong>任何一个不匹配都将报错</strong></li>
</ol>
<h3 id="与-Autowired注解区别"><a href="#与-Autowired注解区别" class="headerlink" title="与@Autowired注解区别"></a>与@Autowired注解区别</h3><ol>
<li>@Autowired 默认按照 byType 方式进行 bean 匹配，@Resource 默认按照 byName 方式进行 bean 匹配</li>
<li>@Autowired 是 Spring 的注解，@Resource 是 J2EE 的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了</li>
</ol>
<p><strong>Spring 属于第三方的，J2EE 是 Java 自己的东西，因此，建议使用 @Resource 注解，以减少代码和 Spring 之间的耦合。</strong></p>
<p>它们都可以使用在“字段”或者 setter 方法上，如果写在了字段上不写 setter 方法也是可以成功注入的</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p><strong>@Service 对应的是业务层 Bean</strong><br>上面一开始的例子，还可以继续简化，因为 Spring 的配置文件里面还定义了三个 bean，下一步的简化是把这三个 bean 也给去掉，使得 Spring 配置文件里面只有一个自动扫描的标签，增强 Java 代码的内聚性并进一步减少配置文件。<br>使用到的当然就是 @Service 注解了，配置文件不用说了，就剩一行扫描了，Java 类要进行稍微的改造了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Tiger tiger;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Monkey monkey;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tiger + <span class="string">"\n"</span> + monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实是没什么大的变化，只是在类上加了一个 @Service 注解，这样，Zoo.java 在 Spring 容器中存在的形式就是 “zoo”，即可以通过 <code>ApplicationContext.getBean(&quot;zoo&quot;)</code> 来得到 Zoo 对象<br>@Service 注解，其实做了两件事情：</p>
<ol>
<li>声明 Zoo.java 是一个 bean，这点很重要，因为 Zoo.java 是一个 bean，其他的类才可以使用 @Autowired 将 Zoo 作为一个成员变量自动注入。</li>
<li>Zoo.java 在 bean 中的 id 是 “zoo”，即类名且首字母小写。</li>
</ol>
<p>那么我想指定 id 的名称怎么办？我想设置 bean 为原型怎么办（每次都会 new 一个新的）？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"Zoo"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>@Scope 注解和 bean 标签例的 Scope 属性是一致的；Spring 默认产生的 bean 是单例，也就是说默认是 “singleton” 即单例，需要每次都 new 一个新的就选择 “prototype”<br><strong>struts2 是要求每次次访问都对应不同的 Action</strong></p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p><strong>@Controller 对应表现层的 Bean，也就是 Action</strong>，用法上倒是和 @Service 并没有什么区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @Controller 注解标识 UserAction 之后，就表示要把 UserAction 交给 Spring 容器管理，在 Spring 容器中会存在一个名字为 “userAction” 的 action，默认的 bean 名字为这个类的类名首字母小写，如果需要单独指定就手动设置下其注解的 value 值</p>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p><strong>@Repository 对应数据访问层 Bean</strong> ；和上面类似，本质也是把类交给 Spring 管理而已，只不过对应的不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>(value=<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在 Service 层使用 @Resource 进行注入即可</p>
<blockquote>
<p>  @Repository / @Service / @Controller 这三个没什么功能上的差别，差别只是在语义上，分别代表了特定语义的类（DAO、Service、Web）<br>  这个有点类似于 HTML 5 提出的语义化标签，你说 HTML 5 里面的 “header” 和 “div” 有什么差别呢，其实功能上来说没有，只是语义表达的更清楚</p>
<p>  更确切的说，@Service 和 @Controller  功能上和 @Component  是相同的，@Repository 在 2.0 就有了，那时候只能标注在 DAO 层，否则可能抛异常（因为它除了识别 bean 同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型）</p>
</blockquote>
<h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>@Component 是所有受 Spring 管理组件的通用形式，@Component 注解可以放在类的头上，<strong>@Component 不推荐使用。</strong><br>标识该类需要 Spring 初始化时自动装配，也许正是因为太通用所以不推荐，实在不好归类的时候再用</p>
<h2 id="Spring常用注解汇总"><a href="#Spring常用注解汇总" class="headerlink" title="Spring常用注解汇总"></a>Spring常用注解汇总</h2><ul>
<li><p>@Configuration<br>把一个类作为一个配置类，它的某个方法头上如果注册了 @Bean，就会作为这个 Spring 容器中的 Bean。<br>一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean，默认它的 id 就是方法名，此注解包含了 @Component；<br>比如，看下面的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码如果写成 XML 文件就是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorld"</span> <span class="attr">class</span>=<span class="string">"com.tutorialspoint.HelloWorld"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样应该就比较好理解了，然后就可以通过 <em>AnnotationConfigApplicationContext</em>  进行获取定义的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(<span class="string">"Hello World!"</span>);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************分割线******************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = </span><br><span class="line">   <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种方式都可以获取，用那种就自己看着办吧….</p>
</li>
<li><p>@Scope<br>设置 bean 的作用域</p>
</li>
<li><p>@Lazy(true)<br>表示延迟初始化</p>
</li>
<li><p>@Service<br>用于标注<strong>业务层</strong>组件</p>
</li>
<li><p>@Controller<br>用于标注<strong>控制层</strong>组件（如 struts 中的 action）</p>
</li>
<li><p>@Repository<br>用于标注<strong>数据访问组件</strong>，即 DAO 组件。</p>
</li>
<li><p>@Component<br>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
</li>
<li><p>@Scope<br>用于指定 scope 作用域的（用在类上）</p>
</li>
<li><p>@PostConstruct<br>用于指定初始化方法（用在方法上）</p>
</li>
<li><p>@PreDestory<br>用于指定销毁方法（用在方法上）</p>
</li>
<li><p>@DependsOn<br>定义 Bean 初始化及销毁时的顺序</p>
</li>
<li><p>@Primary<br>自动装配时当出现多个 Bean 候选者时，被注解为 @Primary 的 Bean 将作为首选者，否则将抛出异常</p>
</li>
<li><p>@Autowired<br>默认按类型装配，如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。如下：<br><strong>@Autowired @Qualifier(“personDaoBean”)</strong> 存在多个实例配合使用</p>
</li>
<li><p>@Resource<br>默认按名称装配，当找不到与名称匹配的 bean 才会按类型装配。</p>
</li>
<li><p>@PostConstruct<br>初始化注解</p>
</li>
<li><p>@PreDestroy<br>摧毁注解 默认 单例  启动就加载</p>
</li>
<li><p>@Async<br>异步方法调用</p>
</li>
</ul>
<h2 id="补充-关于事务"><a href="#补充-关于事务" class="headerlink" title="补充-关于事务"></a>补充-关于事务</h2><p>因为上面貌似没有提到过，就单独拿出来补充，除了事务应该还有 AOP，不过那个还没用到以后再说吧<br>事务方面用的还是比较多的，比如常用的 @Transaction 注解，来说下这个注解<br>准备工作就不说了，在 SSH 整合中已经说过了，就是要开启事务管理器以及配置下开启注解，然后来看下它的属性吧：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td>
</tr>
<tr>
<td style="text-align:left">propagation</td>
<td style="text-align:left">事务的传播行为，默认值为 REQUIRED。</td>
</tr>
<tr>
<td style="text-align:left">isolation</td>
<td style="text-align:left">事务的隔离度，默认值采用 DEFAULT。</td>
</tr>
<tr>
<td style="text-align:left">timeout</td>
<td style="text-align:left">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td style="text-align:left">read-only</td>
<td style="text-align:left">指定事务是否为只读事务，默认值为 false；<strong>为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</strong></td>
</tr>
<tr>
<td style="text-align:left">rollback-for</td>
<td style="text-align:left">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>
</tr>
<tr>
<td style="text-align:left">no-rollback- for</td>
<td style="text-align:left">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>
</tr>
</tbody>
</table>
<p>此注解可以设置在合适的方法上，也可以设置在类上，当把 @Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。<br>当类级别配置了@Transactional，方法级别也配置了@Transactional，应用程序会以方法级别的事务属性信息来管理事务，换言之，方法级别的事务属性信息会覆盖类级别的相关配置信息。</p>
<blockquote>
<p>  在应用系统调用声明 @Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据 @Transactional 的属性配置信息，这个代理对象决定该声明 @Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截；<br>  在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器 AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务</p>
</blockquote>
<h3 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h3><p>事务的传播行为大约有七种，需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。</p>
<ol>
<li>TransactionDefinition.<strong>PROPAGATION_SUPPORTS</strong>：<br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.<strong>PROPAGATION_NOT_SUPPORTED</strong>：<br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.<strong>PROPAGATION_NEVER</strong>：<br>以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ol>
<p>其他的一些传播行为有：</p>
<ul>
<li>TransactionDefinition.<strong>PROPAGATION_REQUIRED</strong>：<br>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务（默认）。</li>
<li>TransactionDefinition.<strong>PROPAGATION_REQUIRES_NEW</strong>：<br>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.<strong>PROPAGATION_MANDATORY</strong>：<br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>TransactionDefinition.<strong>PROPAGATION_NESTED</strong>：<br>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；<br>如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="isolation属性"><a href="#isolation属性" class="headerlink" title="isolation属性"></a>isolation属性</h3><p>就是隔离级别的问题，这个在前面其实已经详细说过了</p>
<ul>
<li>TransactionDefinition.<strong>ISOLATION_DEFAULT</strong>：<br>这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.<strong>ISOLATION_READ_UNCOMMITTED</strong>：<br>该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li>
<li>TransactionDefinition.<strong>ISOLATION_READ_COMMITTED</strong>：<br>该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.<strong>ISOLATION_REPEATABLE_READ</strong>：<br>该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.<strong>ISOLATION_SERIALIZABLE</strong>：<br>所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="rollbackFor属性"><a href="#rollbackFor属性" class="headerlink" title="rollbackFor属性"></a>rollbackFor属性</h3><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor</p>
<h3 id="只有public的方法才有效"><a href="#只有public的方法才有效" class="headerlink" title="只有public的方法才有效"></a>只有public的方法才有效</h3><p>只有 @Transactional 注解应用到 public 方法，才能进行事务管理。<br>这和使用的 AOP 技术有关，从上面的原理中可以推断出来，详情可见参考</p>
<h3 id="AOP自调用问题"><a href="#AOP自调用问题" class="headerlink" title="AOP自调用问题"></a>AOP自调用问题</h3><p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有 @Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    insertOrder();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//insert log info</span></span><br><span class="line">        <span class="comment">//insertOrder</span></span><br><span class="line">        <span class="comment">//updateAccount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insertOrder 尽管有 @Transactional 注解，但它被内部方法 insert 调用，事务被忽略，出现异常事务不会发生回滚。<br>要解决这个问题需要使用 AspectJ 取代 Spring AOP 代理（具体的配置见参考2）。</p>
<h2 id="补充-Spring中的过滤器"><a href="#补充-Spring中的过滤器" class="headerlink" title="补充-Spring中的过滤器"></a>补充-Spring中的过滤器</h2><p>临时看到的就写在这里了，在 Spring 中还自带了一些过滤器，比如最常用的设置编码的，避免中文乱码问题，直接在 web.xml 中配置就行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果查看源码，其实实现比我们的要简单，<strong>没有处理 GET 乱码问题</strong>，所以，需要 GET 的还是要自己写(或者直接在 Tomcat 中设置死)，不过在 Tomcat8.x 默认 Get 编码已改为 utf-8 ，Get 乱码就不用操心了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//........省略..............  </span></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.forceEncoding || request.getCharacterEncoding() == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">        request.setCharacterEncoding(<span class="keyword">this</span>.encoding);  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.forceEncoding) &#123;  </span><br><span class="line">            response.setCharacterEncoding(<span class="keyword">this</span>.encoding);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    filterChain.doFilter(request, response);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//........省略..............</span></span><br></pre></td></tr></table></figure>
<hr>
<p>然后还有一个很常见的问题就是 No Session 的问题，因为 Spring 已提供了过滤器来解决 nosession or session is closed 这个问题，所以我们直接用就行了，使用的也是过滤器来实现的，以此延长 Session 的生命周期（所以有利有弊，对象层级较多的话会拖慢加载速度），在 web.xml 文件中直接配置就行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  配置 OpenSessionInViewFilter 解决 nosession 问题</span></span><br><span class="line"><span class="comment">  该过滤器必须配置在 struts2 核心控制期之前，否则 action 访问不了</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInViewFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInViewFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以配置它的两个参数：singleSession 和 sessionFactoryBeanName<br>sessionFactoryBeanName 默认值是 sessionFactory<br>singleSession 默认值是 true </p>
<p>不过在 SSH 的项目中一般都配了事务管理器，并且启用了注解，人嘛，能省事则省事一般都直接加个 @Transaction 注解就不管了，这个也确实能解决问题，至于是不是 openSessionInViewFilter 的思路目前我还不知道，我懒的也没获取下各自的 session 对比下是不是同一个对象…..</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/xiaoxi/p/5935009.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoxi/p/5935009.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSH框架整合笔记]]></title>
      <url>http://bfchengnuo.com/2017/09/01/SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>这一篇说的是纯手动的整合，目前主流的应该是采用 Maven 或者 Gradle 进行整合，这个以后再说吧…<br>关于集成顺序，不是固定的，但是一般是先添加 Spring 支持，再添加 Hibernate 支持，这样 <strong>hibernate.cfg.xml</strong> 就被集成到 <strong>applicationContext.xml（beans.xml）</strong> 中，就不用手动配置了。至于 Struts 在他们俩前后都可以了….<br>每添加一个框架建议做一次测试，以保证引入是没有问题的，用简单的单元测试就行<a id="more"></a></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>先用最基本的手动搭建大法，现在使用构建工具来搭建也很普遍了，也更方便一些，后面看看再说吧，这里采用的是：Struts2-2.3 + Spring4.3 + Hibernate5.2<br>手动导入的时候还要注意一个问题，那就是 jar 包的<strong>冲突问题</strong></p>
<h3 id="1-引入Spring-amp-XML知识补充"><a href="#1-引入Spring-amp-XML知识补充" class="headerlink" title="1.引入Spring&amp;XML知识补充"></a>1.引入Spring&amp;XML知识补充</h3><p>作为第一个引入的来说，应该是最简单的，没什么可说的和平常加入 Spring 是一样的，导入相应的 jar 包，设置好相应的配置文件就行了<br>配置文件的名字和位置其实是随意的，前面都说过，通过用 applicationContext 或者 beans 还有种是 spring-config，一般放在 src 目录下<br>配置方面可以加入 aop 和事务的约束，对于 spring 来说 xsd 文件可以不写版本号，会使用自带的最新的版本，内部做了本地的映射，jar 包中就有 xsd 文件，避免离线不能用的情况</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 自动扫描方式加载对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bfchengnuo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里就顺便补充下关于 xml 的一些知识吧，原来大多使用的是 dtd 约束文件，但是因为其的局限性已经逐步被 <strong>XML Schema</strong> 取代，对于 Spring ，为了避免冲突，有几种不同的命名空间，相当于 java 中的包了<br>需要那个加那个就可以了</p>
<ul>
<li><strong>xmlns=</strong><br>声明 xml 文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。<br>如果没有提供 schemaLocation，那么 Spring 的 XML 解析器会从 namespace 的 URI 里加载 XSD 文件</li>
<li><strong>xmlns:xsi=</strong><br>声明 XML Schema 实例，声明后就可以使用 schemaLocation 属性了<br>说明当前的 xml 是 schema 一个实例文档</li>
<li><strong>xmlns:aop=</strong><br>声明前缀为 aop 的命名空间，<strong>后面的 URL 用于标示命名空间的地址，不会被解析器用于查找信息</strong>。<br>其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。</li>
<li><strong>xsi:schemaLocation=</strong><br>这个从命名可以看出个大概，指定 Schema 的位置这个属性必须结合命名空间使用。<br>这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 XML schema 的位置<br>schemaLocation 提供了一个 xml namespace 到对应的 XSD 文件的一个映射，所以我们可以看到，在 xsi:schemaLocation 后面配置的字符串都是成对的，前面的是 namespace 的 URI，后面是 xsd 文件的 URI</li>
</ul>
<p>为了防止离线获取不到的问题，Spring 很贴心的将这些文件打包到 jar 文件里了，并且进行了映射，所以说：<strong>不要在 Spring 的配置里，配置上 XSD 的版本号，因为如果没有配置版本号，取的就是当前 jar 里的 XSD 文件，减少了各种风险</strong>。而且这样约定大于配置的方式很优雅。</p>
<hr>
<p>如果感觉下载 XSD 文件非常慢，导致IDE的卡顿，可以事先下载好然后本地引用，详细配置可以参考：<br><a href="http://blog.csdn.net/jackphang/article/details/17021241" target="_blank" rel="noopener">http://blog.csdn.net/jackphang/article/details/17021241</a></p>
<h3 id="2-引入Hibernate"><a href="#2-引入Hibernate" class="headerlink" title="2.引入Hibernate"></a>2.引入Hibernate</h3><p>和一般的引入也是差不多的，倒不如说更简单了，因为 cfg 文件不需要单独配置了(映射的 hbm 文件也可以用 JPA 来代替了)，直接在 Spring 的配置文件里用就行了<br>导入相关的 jar 包不要忘了数据库驱动的包和连接池相关的包（spring 也自带一些）</p>
<p>首先要配置数据源，这里使用的 C3P0：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"org.gjt.mm.mysql.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/itcast?useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接池中保留的最小连接数。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接池中保留的最大连接数。Default: 15 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"300"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span> <span class="attr">value</span>=<span class="string">"60"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至于为什么要配置数据源，现在基本都是用线程池的吧，要不然效率也太低了并且官方也推荐这样配置，关于连接池的好处前面其实已经说过了<br>然后就是 Hibernate 最重要的对象 sessionFactory 了（单例），并且我们知道它是需要一个数据源的，我们配置的 cfg 配置文件其实就是为了生成它：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用的注解，或者 packagesToScan --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"annotatedClasses"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.bfchengnuo.entity.UsersEntity<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置 session 的上下文，解决 getCurrentSession 获取不到的情况 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>org.springframework.orm.hibernate5.SpringSessionContext<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/ssh<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上面用的是注解形式，如果使用的是 hbm 映射文件就是这样配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappingResources"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>com/bfchengnuo/domain/Employee.hbm.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>至于里面的配置是什么意思，我想都看出来了，这也更说明了 Spring 其实就是个快速生成对象（bean）的框架（从这里来看）<br>其他的，可以配置下事务等配置，使用事务管理器最大的好处就是能少些代码，由它来管理 sessionFactory 的事务，其实是使用的类似 AOP 技术的（织入）通知实现的，这样在 Service 层的类中写的 CRUD 方法的时候就不需要写事务相关的代码了（记得在类上加注解）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate5.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用注解配置事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以创建个实体 bean，编写好对应的映射文件，在上面的配置中写好 hbm 的文件路径（如果用注解就是类名了），然后就可以进行测试了，不出意外的话 hibernate 就集成完毕了</p>
<h3 id="3-引入Struts"><a href="#3-引入Struts" class="headerlink" title="3.引入Struts"></a>3.引入Struts</h3><p>Struts 作为 web 层的框架引入也是很简单的，首先当然还是要导入相关的 jar ，还是要注意 jar 包的重复，以及因为要和 spring 整合，不要忘了导入 struts2-spring-plugin 包和 spring-web-x.x.x.RELEASE.jar 包<br>然后顺便配置下相关的配置文件，有 struts 的 <strong>Struts.xml</strong> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定Action对象由谁创建 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.objectFactory"</span> <span class="attr">value</span>=<span class="string">"spring"</span>&gt;</span><span class="tag">&lt;/<span class="name">constant</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置Action  不用写全名，因为已经交给Spring管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"employee"</span> <span class="attr">namespace</span>=<span class="string">"/employee"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"employeeAction"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span>/WEB-INF/page/employee.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>Action 的管理托管给 Spring 后，在 action 标签配置的 class 就是 spring 配置文件中 bean 的 id</strong><br>在 <strong>web.xml</strong> 中配置 struts：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后还是要在 <strong>Web.xml</strong> 中配置实例化 Spring 容器，避免每一次请求就初始化一次，浪费资源；实际上就是把 spring 容器存到 ServletContext 中去了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定spring的配置文件，默认从web根目录寻找配置文件，我们可以通过spring提供的classpath:前缀指定从类路径下寻找 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:beans.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对Spring容器进行实例化 Spring容器放在application范围 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到这里基本就整合完了，下面要做的就是测试一下然后进行开发了，测试也非常的简单</p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>创建个 Action 访问下测试就可以了，比如可以这样写一个测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="meta">@Resource</span> EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ActionContext.getContext().put(<span class="string">"empList"</span>, employeeService.list());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，到这里基本就真的完成了，如果不出问题的话。。。。</p>
<h2 id="所谓整合"><a href="#所谓整合" class="headerlink" title="所谓整合"></a>所谓整合</h2><p>我们所说的整合一般就是：<br><strong>Spring 整合 Hibernate ：</strong>由 <code>IOC</code> 容器（Spring 框架的核心）管理 Hibernagte 的 <code>SessionFactory</code> ；以及让 Hibernate 使用上 Spring 的声明式事务<br><strong>Spring 整合 Struts ：</strong>让 spring 来接管 Struts 的 <code>Action</code></p>
<p>在服务器启动的时候自动创建相应的 Action，如果想要解决高并发问题可以利用 spring 的 <strong>scope</strong> 属性（<code>scope=&quot;prototype&quot;</code>），让其每一个请求产生独立的 Action，避免数据的混乱，当然它的生命周期是很短的</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>来说一下为什么要在 web.xml 中配置实例化 Spring，如果不实例化那么在 Action 被访问的时候是必须要实例化的（因为 Action 要用啊），如果有很多人访问就会多次执行生成 ApplicationContext 的代码，这个是非常耗费资源的<br>所以不如索性在服务器启动的时候就把 ApplicationContext 给实例化了，存到 ServletContext 中，需要的时候可以使用下面的代码获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = WebApplicationContextUtils.getRequiredWebApplicationContext(<span class="keyword">this</span>.getServletContext());</span><br><span class="line"><span class="comment">// 还有一种形式是</span></span><br><span class="line">ApplicationContext ac2 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</span><br></pre></td></tr></table></figure>
<p>更好的，可以通过继承 ApplicationContextAware 来构造一个 spring 的工具类，别忘了让 spring 把这个工具类顺便给实例化了，这样直接调用就可以了</p>
<p>或者可以直接使用 spring 提供的：<br><code>WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext();</code><br>进而使用 wac 来获取 bean</p>
<div class="note info"><p>WebApplicationContext:<br>其实这个接口不过是 applicationContext 接口的一个子接口罢了，只不过说它的应用形式是 web 罢了. 它在ApplicationContext 的基础上，添加了对 ServletContext 的引用(<del>后面还加入了很多其他作用域的引用</del>)，即 getServletContext 方法.<br>可以说：它是一个是支持 web 特性的 BeanFactory。</p>
</div>
<p>相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>在配置 Hibernate 数据库信息的时候，就是 datasource 的时候，可以从 prop 文件中装载的，需要配一个：<br><code>&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</code> 属性而已<br>这样可以在 datasource 中使用：<code>value=&quot;${user}&quot;</code> 进行引用；<br>同理，配置 SessionFactory 的时候也可以引用外部文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:hinernate.cfg.xml"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上下的作用、内容都是一样的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernateProperties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 一定不要忘记，要不然 getCurrentSession 是获取不到的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>org.springframework.orm.hibernate5.SpringSessionContext<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/ssh<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样 cfg 文件中就没必要写数据库连接的相关东西了，因为会注入一个连接池，只需要写 hibernate 特有的一些配置就 OK 了<br>至于是使用外部文件好还是直接写在一起好，我也不造….</p>
<hr>
<p>再补充 classpath 是指 WEB-INF 文件夹下的 classes 目录；<br>classpath 和 <code>classpath*</code>  区别： </p>
<ul>
<li>classpath：只会到你的 class 路径中查找找文件；</li>
<li>classpath*：不仅包含 class 路径，还包括 jar 文件中( class 路径)进行查找. </li>
</ul>
<p>也就是说前者只会从第一个 classpath 中加载，而后者会从所有的 classpath 中加载，用 <code>classpath*</code> 需要遍历所有的 classpath，所以加载速度是很慢的，因此，在规划的时候，应该尽可能规划好资源文件所在的路径，尽量避免使用 <code>classpath*</code> ；<br>另外，<code>&quot;**/&quot;</code>  表示的是任意目录；<code>**/applicationContext-*.xml&quot;</code> 表示任意目录下的以 “applicationContext-“ 开头的 XML 文件。  </p>
<hr>
<p>千万注意 jar 包的重复和未部署 jar 包的巨坑，详细的解决笔记在我的 <a href="https://github.com/bfchengnuo/MyRecord/blob/master/FixException/SSH%E6%95%B4%E5%90%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">Github</a></p>
<h2 id="参考-amp-拓展"><a href="#参考-amp-拓展" class="headerlink" title="参考&amp;拓展"></a>参考&amp;拓展</h2><p><a href="http://www.cnblogs.com/doit8791/p/5757798.html" target="_blank" rel="noopener">http://www.cnblogs.com/doit8791/p/5757798.html</a><br><a href="http://blog.csdn.net/hzy38324/article/details/44139609" target="_blank" rel="noopener">http://blog.csdn.net/hzy38324/article/details/44139609</a><br><a href="https://www.dexcoder.com/selfly/article/326" target="_blank" rel="noopener">spring获取bean的几种方式</a><br><a href="https://essviv.github.io/2016/07/02/spring/spring-differerce-between-application-context-and-servlet-context/" target="_blank" rel="noopener">https://essviv.github.io/2016/07/02/spring/spring-differerce-between-application-context-and-servlet-context/</a><br><a href="http://www.cnblogs.com/panxuejun/p/5898540.html" target="_blank" rel="noopener">http://www.cnblogs.com/panxuejun/p/5898540.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
            <tag> Spring </tag>
            
            <tag> Struts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JPA学习笔记（二）]]></title>
      <url>http://bfchengnuo.com/2017/08/21/JPA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>上一次只是说了保存数据的方法，下面就把其他的一些 CRUD 操作补充完整，以及其他的一些细节，有些知识是和上一篇有关联的，但是上一篇感觉写的有点多于是就放在了这里<a id="more"></a><br>虽然这一篇也非常的多….</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在很多情况和 hibernate 是差不多的，毕竟作者是主导者，套路都一样<br>保存数据在上一篇已经说了，主要就是那个 persist 方法，Hibernate 中也是一样的，以前可能是 save 方法，persist 这个命名更规范，作用其实是一样的</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>在 hibernate 中获取数据是 get/load 简单说分别对应的是正常获取和延迟加载（lazy），在 JPA 中也是类似的，对应的通过 find/getReference 获取；由于它们使用了 Java 泛型方法，<strong>无需任何显示的类型转换即可获得特定类型的实体对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">EntityManager em = factory.createEntityManager();</span><br><span class="line"><span class="comment">// 查询其实无需开启事务</span></span><br><span class="line">em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">Employee emp = em.find(Employee.class, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 相同的，返回的也是代理对象，延迟加载</span></span><br><span class="line">Employee emp = em.getReference(Employee.class, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">em.getTransaction().commit();</span><br><span class="line">em.close();</span><br><span class="line">factory.close();</span><br></pre></td></tr></table></figure>
<p>与 hibernate 一样，如果使用延迟加载，在 EntityManager 关闭后是无法再向数据库查询数据的，EntityManager 内部其实也是在操纵 session 对象<br>然后下面就当复习了，find 如果找不到会返回 null；getReference 找不到会抛异常</p>
<p>PS：<strong>获取的时候不使用事务也是可以的</strong></p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>继续复习，因为开启了事务，所以修改实体后在最后事务提交的时候会将变化更新到数据库，所以不需要再保存<br>总结下就是只要满足两点，就会在事务提交时自动更新：1.和事务关联，2.处于托管状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee emp = em.find(Employee.class, <span class="number">1</span>);</span><br><span class="line">emp.setName(<span class="string">"new Name"</span>);</span><br></pre></td></tr></table></figure>
<p>可以参考下后面的 JPA 中的对象状态</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除也很简单，就是调用 EntityManager 的 remove 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee emp = em.find(Employee.class, <span class="number">1</span>);</span><br><span class="line">em.remove(emp);</span><br></pre></td></tr></table></figure>
<h2 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h2><p>在 JPA 中对象有四种状态，分别是：新建、托管、游离、删除 ；在 hibernate 中好像是三种来，其实是差不多的，所以也就不多解释了，可以参考 <a href="https://bfchengnuo.com/2017/07/01/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#对象状态">Hibernate 笔记</a>里的内容</p>
<ul>
<li>新建<br>当进行 new 对象时，这个对象处于新建状态</li>
<li>托管<br>首先事务要开启，然后比如通过 find 来获取实体，那么这个实体就处于托管状态<br>这个对象发生改变 EntityManager 会感知到，并且在事务提交的时候会自动更新到数据库</li>
<li>游离<br>当调用 <strong>entity.clear()；</strong>等方法时此时，bean 将变成游离状态（此方法就是把实体管理器中的所有实体变成游离状态）<br>游离状态修改实体不会再同步到数据库中<br>如果此时调用 <strong>entity.merge(person);</strong> 将会把游离状态的实体变化的数据同步到数据库</li>
<li>删除<br>就是认为删除的对象或是垃圾回收掉的对象</li>
</ul>
<h2 id="JPQL语句"><a href="#JPQL语句" class="headerlink" title="JPQL语句"></a>JPQL语句</h2><p>和 HQL 语句非常的相似，它们最大的特点就是采用的面向对象的方式，所以语句中出现的应该都是属性名而不是字段，那就先来看一段简单的 JPQL 使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createQuery 中还可以传入第二个参数，这样就不用强转了，当然不写也是可以执行的</span></span><br><span class="line">TypedQuery&lt;Employee&gt; query = </span><br><span class="line">     em.createQuery(<span class="string">"SELECT e FROM Employee e"</span>,</span><br><span class="line">                     Employee.class);</span><br><span class="line">List&lt;Employee&gt; emps = query.getResultList();</span><br></pre></td></tr></table></figure>
<p>如果是使用 HQL 的话那就是直接 <code>FROM Employee</code> 就可以了，当然如果使用的 ORM 是 hibernate，那么其实也是可以这样写的，但是为了规范，最好还是这样写：<code>SELECT e FROM Employee e</code> 这里的 e 就是起的别名啦<br>其他的也都差不多，如果后面填充参数所使用的占位符，索引的话用 <code>?</code>，key 的话用 <code>:</code> ，补充一点的是如果想从指定的索引开始可以这样写：<code>?1</code> 这样就是从1开始的</p>
<blockquote>
<p>  Hibernate 中获取单一结果（只查一条）是使用 <strong>query.uniqueResult</strong> 方法；在 JPA 中是使用 <strong>getSingleResult</strong> 方法，其实也就只是方法名不一样</p>
<p>  查询可以不开启事务，增删改就需要开启事务了</p>
</blockquote>
<p>如果是执行增删改的语句，那就得执行 query 的 <strong>executeUpdate</strong> 方法了，和 hibernate 是一样的</p>
<p>其他的多数语句是一样的，遇到特殊的再回来补充吧…..（ORM 如果用的是 hibernate，写 HQL 也是可以跑的嘛）</p>
<h3 id="关于create"><a href="#关于create" class="headerlink" title="关于create"></a>关于create</h3><p>EntityManager 以 create 开头的有三个（用于创建相关查询语句），分别是 createQuery、createNamedQuery、createNativeQuery</p>
<ul>
<li><p><strong>createQuery</strong><br>用于执行编写的 jpql 语句，不能用于执行 SQL 语句<br>它有两个重载：<br><code>Query createQuery(java.lang.String qlString)</code><br><code>&lt;T&gt; TypedQuery&lt;T&gt; createQuery(java.lang.String qlString,java.lang.Class&lt;T&gt; resultClass)</code><br>执行的结果是一样的（返回值略有不同），不同的是前者指定了返回的结果集的类型，后者没有制定，当然这两种查询得到的结果集是一样的，但是建议在使用的时候制定结果集</p>
</li>
<li><p><strong>createNamedQuery</strong><br>用于传入命名查询的名称创建查询，如：<code>createNamedQuery(&quot;findAllUser&quot;);</code><br>使用 <strong>@NamedQuery</strong> 注解在实体类中定义命名查询：<br><code>@NamedQuery(name=&quot;findAllUser&quot;,query=&quot;SELECT u FROM User u&quot;)</code><br>如果要定义多条命名查询，可以使用这种形式：<br><code>@NamedQueries({@NamedQuery(xx),...})</code></p>
</li>
<li><p><strong>createNativeQuery</strong><br>此方法用于执行 SQL 语句，不能用于执行 jpql 语句，一般用于复杂的 sql 语句<br>此方法有三个重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Query <span class="title">createNativeQuery</span><span class="params">(java.lang.String sqlString,java.lang.Class resultClass)</span></span>;</span><br><span class="line"><span class="function">Query <span class="title">createNativeQuery</span><span class="params">(java.lang.String sqlString)</span></span>;</span><br><span class="line"><span class="function">Query <span class="title">createNativeQuery</span><span class="params">(java.lang.String sqlString,java.lang.String resultSetMapping)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前面两个方法中一个指定了结果集一个没有制定，但是其执行结果是不一样的<br>在返回的结果中由于没有指定结果集的类型，返回结果中只有结果，没有结果对应的字段名。<br>也就是说指定结果集意味着原生查询的结果集中的栏将完全匹配实体的 O/R 映射。<br>第三个方法使用一个字符串来指定结果集（主要应用于复杂的查询，返回的结果不能被实体一一映射），和第一个使用类来指定有所不同。</p>
</li>
</ul>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>结合上一篇的注解看，哎╮(╯▽╰)╭又是分开的，太长了写不下了<br>首先记住第一定律：只要注解后面是以 Many 结尾的（比如：@OneToMany）默认统一是延迟加载（lazy），其他的一般是立即加载</p>
<h3 id="关于级联"><a href="#关于级联" class="headerlink" title="关于级联"></a>关于级联</h3><p>JPA 中的提供的级联有四种，下面会用到</p>
<ul>
<li><strong>CascadeType.REFRESH</strong><br>级联刷新<br>当你刚开始获取到了这条记录，那么在你处理业务过程中，这条记录被另一个业务程序修改了（数据库这条记录被修改了），那么你获取的这条数据就不是最新的数据，那你就要调用实体管理器里面的 <strong>refresh</strong> 方法来刷新实体。<br>使用其他获取是获取的缓存的数据，所以…..注意<br>一般配置为：<code>cascade={CascadeType.REFRESH},fetch=FetchType.LAZY</code>，不会影响系统的正常运作。</li>
<li><strong>CascadeType.PERSIST</strong><br>级联持久化（级联保存）<br>比如保存 order 的时候也保存 orderItem，如果在数据库里已经存在与需要保存的 orderItem 相同的 id 记录，则级联保存出错。<br>也就是说相当于是 insert 操作</li>
<li><strong>CascadeType.MERGE</strong><br>级联更新<br>比如当对象 Order <strong>处于游离状态时</strong>，对对象 Order 里面的属性作修改，也修改了 Order 里面的 orderItems。</li>
<li><strong>CascadeType.REMOVE</strong><br>级联删除<br>就是删除的时候都删了….不是很推荐，加上逻辑判断更好</li>
<li><strong>CascadeType.ALL</strong><br>具备上面的全部</li>
</ul>
<p>还有一些需要注意的是：</p>
<blockquote>
<p>  级联的配置是生效于对应的方法的，比如上面的四个就依次对应实体管理器的 <strong>refresh</strong> 、<strong>persist</strong>、<strong>merge</strong>、<strong>remove</strong><br>  所以说，使用 JPQL 语句的时候级联是不会生效的</p>
</blockquote>
<h3 id="一对多-多对一"><a href="#一对多-多对一" class="headerlink" title="一对多/多对一"></a>一对多/多对一</h3><p>大体套路是不变的：多的一方为关系维护端，负责外键记录的更新，关系被维护端没有权利更新外键记录<br>当属性中出现 mappedBy 时，一般就是关系被维护端了，值为是由谁维护的（维护端的属性名）</p>
<p>在一对多的“一”的一方，可以使用注解 <strong>@OneToMany</strong> 来标识多的一方的集合，以及设置相应的级联（级联是可以设置多个的，用括号套）<br>下面是一个简单的用户和订单的栗子，对于关系被维护端的用户类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span>(cascade = CascadeType.ALL,mappedBy = <span class="string">"user"</span>)</span><br><span class="line">    <span class="comment">//拥有mappedBy注解的实体类为关系被维护端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrders</span><span class="params">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orders = orders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只为方便测试添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        order.setUser(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.orders.add(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是多的一方，为关系的维护端 Order：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"orders"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 optional 设置为必填项</span></span><br><span class="line">    <span class="meta">@ManyToOne</span>(cascade = CascadeType.ALL,optional = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"user_id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的测试类，其实只需要执行完 createEntityManagerFactory 就会自动建表了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">    EntityManager em = factory.createEntityManager();</span><br><span class="line">    em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"佳芷"</span>);</span><br><span class="line">    user.setId(<span class="number">123</span>);</span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">"测试项1"</span>);</span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">"测试项2"</span>);</span><br><span class="line">    user.addItem(order1);</span><br><span class="line">    user.addItem(order2);</span><br><span class="line"></span><br><span class="line">    em.persist(user);</span><br><span class="line">    em.getTransaction().commit();</span><br><span class="line">    em.close();</span><br><span class="line">    factory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说下的是，如果设置的一对多/多对一关系是单向的，那么不加 mappedBy 也是可以的，在双向关系中是必须的，否则会引发数据一致性的问题<br>什么是单向映射？<br>简单地说就是可以从关联的一方去查询另一方，却不能反向查询；以上面的栗子，在 user 中的 set 集合使用 @OneToMany （不用 mappedBy），在 order 中去掉 user 的属性，什么也不用加，这就是单向的；只能通过 user 获取 order ，不能通过 order 获取 user<br>想深入了解的话可以去：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jparelated/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jparelated/index.html</a></p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>在一对一中和一对多其实也差不多，都需要设置关系维护端和被维护端，只不过因为是一对一，所以这两个角色是可以互换的，设谁都可以<br>在被维护端记得加 mappedBy 属性，在维护端记得使用 @JoinColumn 注解指定外键约束的那一列的名字，然后因为是一对一，如果在关系维护端使用了 （非空），那么关系被维护端就没必要在设了<br>具体的代码就不贴了，和上面很类似，一对一也区分单向和双向，如果是单向的话，只需要在一方加入 <code>@OneToOne @JoinColumn(name=&quot;PSPACE_ID&quot;)</code> ；在另一方什么都不用了。<br>如果是双向的，那么就需要在被维护方加 <code>@OneToOne(mappedBy=&quot;department&quot;)</code> 注解；在关系维护方加 注解 <code>@OneToOne @JoinColumn(name=&quot;PSPACE_ID&quot;)</code></p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>会了上面的两种，这种其实也差不多了，会比上面的复杂一点，关于实体的定义就不全部贴了，主要贴下不太一样的东西，以学生和老师为例，这是多对多的关系，假设规定学生的一方为关系的维护端，那么老师就是关系被维护端，学生有权修改和更新中间表的数据，老师则不可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Teacher&gt; teachers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inverseJoinColumns 即关系被维护端的外键列名</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(cascade = CascadeType.REFRESH)</span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"student_teacher"</span>,inverseJoinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"teacher_id"</span>),</span><br><span class="line">            joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"student_id"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Teacher&gt; <span class="title">getTeachers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teachers;</span><br><span class="line">    &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是被维护端的老师，也是省略了一部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 在多对多的关系中，一般不会设置级联删除，太危险</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(cascade = CascadeType.REFRESH,mappedBy = <span class="string">"teachers"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相同的 ID 即认为是相同的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Teacher teacher = (Teacher) o;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.equals(teacher.id) : teacher.id == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是测试类，大部分的管理其实只要操作关系维护端就可以了，因为它才是有权利更新中间表的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">     EntityManager em = factory.createEntityManager();</span><br><span class="line">     em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">     Student student = <span class="keyword">new</span> Student(<span class="string">"佳芷"</span>);</span><br><span class="line">     Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"冰封承諾"</span>);</span><br><span class="line"></span><br><span class="line">     em.persist(student);</span><br><span class="line">     em.persist(teacher);</span><br><span class="line">     em.getTransaction().commit();</span><br><span class="line">     em.close();</span><br><span class="line">     factory.close();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立学生与老师之间的关系，也就是在中间表中添加记录</span></span><br><span class="line"><span class="comment">// 只有关系维护端才有权利</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">    EntityManager em = factory.createEntityManager();</span><br><span class="line">    em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">    Student student = em.find(Student.class, <span class="number">1</span>);</span><br><span class="line">    student.getTeachers().add(em.getReference(Teacher.class, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 解除关系的话</span></span><br><span class="line">    <span class="comment">// student.getTeachers().remove(em.getReference(Teacher.class, 1));</span></span><br><span class="line"></span><br><span class="line">    em.getTransaction().commit();</span><br><span class="line">    em.close();</span><br><span class="line">    factory.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除学生，会自动删除相关的“关系”</span></span><br><span class="line"><span class="comment">// 如果是删除老师，没有权利删除关系，所以要先解除关系再删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delStudent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">    EntityManager em = factory.createEntityManager();</span><br><span class="line">    em.getTransaction().begin();</span><br><span class="line"></span><br><span class="line">    Student student = em.find(Student.class, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    em.remove(student);</span><br><span class="line">    em.getTransaction().commit();</span><br><span class="line">    em.close();</span><br><span class="line">    factory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><p>所谓主键就是可以唯一确定该行数据，由此可以知道，当一个字段不能决定该行的值时，就要考虑采用多个字段作为主键。<br>比如，对于学校来说，班号可以决定班级，但是决定不了班级里的某个人，表示班级里的某个人就需要用班号+该学生在该班内的编号.这就可以说是联合（复合）主键了<br>首先要定义一个联合主键的类，也就是里面的属性都是主键，并且这个类有几个规定：首先要实现序列化的接口，然后要重写 hashCode 和 equals，最后标上 <strong>@Embeddable</strong> 注解就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuPK</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer classId;</span><br><span class="line">    <span class="keyword">private</span> Integer stuId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了下面测试便于初始数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuPK</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuPK</span><span class="params">(Integer classId, Integer stuId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classId = classId;</span><br><span class="line">        <span class="keyword">this</span>.stuId = stuId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getClassId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassId</span><span class="params">(Integer classId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classId = classId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStuId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuId</span><span class="params">(Integer stuId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuId = stuId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        StuPK stuPK = (StuPK) o;</span><br><span class="line">        <span class="keyword">if</span> (classId != <span class="keyword">null</span> ? !classId.equals(stuPK.classId) : stuPK.classId != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> stuId != <span class="keyword">null</span> ? stuId.equals(stuPK.stuId) : stuPK.stuId == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = classId != <span class="keyword">null</span> ? classId.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (stuId != <span class="keyword">null</span> ? stuId.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是具体的持久化类了，引用 StuPK 作为主键，StuPK 类里的属性在这里是可以直接用的，也就是说最后会保存到数据库的表中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StuPK id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name,Integer classId, Integer stuId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        id = <span class="keyword">new</span> StuPK(classId, stuId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EmbeddedId</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StuPK <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(StuPK id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类就不写了，没什么好写的和上面是一样的，主要是执行后看看数据库对应的表结构对不对</p>
<h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p>这个算是个补充内容吧，本来是应该写在上一篇中的，但是那篇看了下有点长，就补充在这吧，自带的四种就不说了，上一篇中已经说的很详细了，下面主要说的是使用 hibernate 的情况下如何使用 hibernate 提供的其他注解生成策略，通过 Hibernate 的 <strong>@GenericGenerator</strong> 实现。首先看下用法吧(以 uuid 为例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(generator = <span class="string">"system-uuid"</span>)</span><br><span class="line"><span class="meta">@GenericGenerator</span>(name=<span class="string">"system-uuid"</span>, strategy=<span class="string">"uuid"</span>)</span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"uuid"</span>, length=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">private</span> String uuid;</span><br></pre></td></tr></table></figure>
<p><code>@GeneratedValue(generator = &quot;system-uuid&quot;)</code> ：用 generator 属性指定要使用的策略生成器。<br><code>@GenericGenerator(name = &quot;system-uuid&quot;, strategy = &quot;uuid&quot;)</code> ：声明一个策略通用生成器，策略 strategy 为 “uuid”。<br>uuid 可以说是最通用的，适用于所有数据库。</p>
<h2 id="persistence-unit中的类集合"><a href="#persistence-unit中的类集合" class="headerlink" title="persistence-unit中的类集合"></a>persistence-unit中的类集合</h2><p>一个 persistence unit 将固定数量的一组类映射到关系数据库。缺省情况下，如果你没有在 <strong>persistence.xml</strong> 中指定任何元数据，persistence provider 就会对包含该 <strong>persistence.xml</strong> 的 JAR 文件进行扫描，从根目录开始搜寻任何标注有 <strong>@javax.persistence.Entity</strong> 注解的类，并将这些类添加到由 persistence unit 管理的类集合中。<br>此外，你还可以通过 <code>&lt;jar-file&gt;</code> 元素指定额外的 JAR 文件，以供 persistence provider 搜索。该元素的值不能使用绝对路径，只能是一个以包含 <strong>persistence.xml</strong> 的JAR文件为基准的相对路径。比如：<code>&lt;jar-file&gt;../lib/customer.jar&lt;/jar-file&gt;</code><br><strong>JAR 文件的自动扫描在 Java EE 环境下是保证可以正常执行的，但在 Java SE 应用程序中却无法做到可移植。</strong><br>理论上，要决定必须搜索哪些 JAR 文件也许是不太可能的。不过，现实中这不是问题。参与 EJB 3.0 专家组的主要厂商都非正式地宣称过，它们会毫无疑问的在 Java SE 中支持这一特性。无论是否使用自动 JAR 文件扫描，你都可以用 <code>&lt;class&gt;</code> 元素显式的列出 persistence unit 中的类集合。 </p>
<p>通常情况下，你无需指定 <code>&lt;class&gt;</code>，<code>&lt;jar-file&gt;</code> 或 <code>&lt;mapping-file&gt;</code> 元素。但是有一种情形你可能需要使用上述元素，即当你需要在两个或多个 persistence unit 中映射同一个类时。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wizardforcel.gitbooks.io/tutorialspoint-java/jpa/629.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/tutorialspoint-java/jpa/629.html</a><br><a href="https://www.w3cschool.cn/java/jpa-entitymanager.html" target="_blank" rel="noopener">https://www.w3cschool.cn/java/jpa-entitymanager.html</a><br><a href="http://blog.csdn.net/javaeeteacher/article/details/1661458" target="_blank" rel="noopener">实体管理器和实体管理器工厂</a><br><a href="http://www.litianhua.net/blog/spring-orm-cascade.html" target="_blank" rel="noopener">JPA中的级联</a><br><a href="http://flowercat.iteye.com/blog/667773" target="_blank" rel="noopener">JPQL大全</a><br><a href="http://gukeming888.iteye.com/blog/1704779" target="_blank" rel="noopener">stence-Unit中的类集合</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JPA学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/08/14/JPA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>JPA</strong>( Java Persistence API )是 Sun 官方提出的 Java 持久化<strong>规范</strong>。 它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。 他的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。<a id="more"></a></p>
<p><strong>注意：JPA 是规范，不是 ORM 框架；是 ORM 框架的规范，JPA 没有实现 ORM，具体实现由 ORM 厂商提供</strong><br>JPA 其实和 Hibernate 使用并没有多少差别，采用的 JPQL 语句和 HQL 差不多呢，毕竟 Hibernate 的作者是主导的</p>
<h2 id="组件构成与优势"><a href="#组件构成与优势" class="headerlink" title="组件构成与优势"></a>组件构成与优势</h2><blockquote>
<p>  <strong>标准化</strong>: 提供相同的 API，这保证了基于 JPA  开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。</p>
<p>  <strong>简单易用，集成方便</strong>:  JPA  的主要目标之一就是提供更加简单的编程模型，在  JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 <code>javax.persistence.Entity</code> 进行注释；JPA 的框架和接口也都非常简单</p>
<p>  <strong>可媲美 JDBC 的查询能力</strong>: JPA 的查询语言是面向对象的，JPA 定义了独特的 JPQL，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</p>
<p>  <strong>支持面向对象的高级特性</strong>: JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型<br>  摘自：<a href="http://www.jianshu.com/p/afd588c8951c" target="_blank" rel="noopener">http://www.jianshu.com/p/afd588c8951c</a></p>
</blockquote>
<p>JPA 由三个不同的组件构成：</p>
<ul>
<li><code>实体（Entities）</code>: 在当前版本的 JPA 中实体是普通 Java 对象（POJO）。老版本的 JPA 中实体类需要继承 JPA 提供的实体基类，但是这样的设计导致框架中存在了严重的依赖关系，测试变得更加困难；所以在新版 JPA 中不再要求实体类继承任何框架类。</li>
<li><code>对象-关系型元数据（Object-relational metadata）</code>: 应用程序的开发者们必须正确设定 Java 类和它们的属性与数据库中的表和列的映射关系。有两种设定方式：通过特定的配置文件建立映射(XML)；或者使用在新版本中支持的注解。</li>
<li><code>Java持久化查询语句（Java Persistence Query Language - JPQL):</code> 因为 JPA 旨在建立不依赖于特定的数据库的抽象层，所以它也提供了一种专有查询语言来代替 SQL。 这种由 JPQL 到 SQL 语言的转换，为 JPA 提供了支持不同数据库方言的特性，使得开发者们在实现查询逻辑时不需要考虑特定的数据库类型。</li>
</ul>
<p>PS：Hibernate 针对 JPA 实现的相关包在 required、jpa 下</p>
<h2 id="初探JPA"><a href="#初探JPA" class="headerlink" title="初探JPA"></a>初探JPA</h2><p>这里还是以 hibernate 为栗子，要使用 JPA，首先要知道它必须的配置文件，按照规范是放在<strong>类路径的 META-INF 目录下</strong> ，文件名也是固定的 <strong>persistence.xml</strong>  在这个文件中配置持久化单元需要指定跟哪个数据库进行交互；需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</p>
<p>下面的步骤可以总结为：<strong>创建实体类</strong>, 使用 annotation 来描述实体类跟数据库表之间的映射关系；<strong>使用 JPA API 完成数据增加、删除、修改和查询操作</strong></p>
<blockquote>
<p>  创建 EntityManagerFactory (对应 Hibernate 中的 SessionFactory);<br>  创建 EntityManager (对应 Hibernate 中的Session);</p>
</blockquote>
<p>下面就展示一份 persistence 的配置文件，差不多是这样配的，transaction-type 事务类型一般都是本地事务吧，全局事务感觉用的很少</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">version</span>=<span class="string">"2.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">             <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"jpaDemo"</span> <span class="attr">transaction-type</span>=<span class="string">"RESOURCE_LOCAL"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 配置 Hibernate JPA作为JPA的实现ORM框架 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 若项目只有一个JPA实现产品，那么这个配置可以不写 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.ejb.HibernatePersistence<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.jpaDemo.entity.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.jpaDemo.entity.Order<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">          配置二级缓存的策略 </span></span><br><span class="line"><span class="comment">          ALL：所有的实体类都被缓存</span></span><br><span class="line"><span class="comment">          NONE：所有的实体类都不被缓存. </span></span><br><span class="line"><span class="comment">          ENABLE_SELECTIVE：标识 @Cacheable(true) 注解的实体类将被缓存</span></span><br><span class="line"><span class="comment">          DISABLE_SELECTIVE：缓存除标识 @Cacheable(false) 以外的所有实体类</span></span><br><span class="line"><span class="comment">          UNSPECIFIED：默认值，JPA 产品默认值将被使用</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shared-cache-mode</span>&gt;</span>ENABLE_SELECTIVE<span class="tag">&lt;/<span class="name">shared-cache-mode</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 连接数据库的基本信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///jpa"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置 JPA 实现产品的基本属性. 配置 hibernate 的基本属性 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span> <span class="attr">value</span>=<span class="string">"update"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 二级缓存相关 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.use_second_level_cache"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.region.factory_class"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cache.ehcache.EhCacheRegionFactory"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.use_query_cache"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出大部分的配置是在 <strong>persistence-unit</strong> 中，直译就是持久化单元，简单说就是一堆实体 bean 的集合<br>上面的配置中还开启了二级缓存，那么就需要配相关的信息，下面作为简单演示就不搞了，我只是配了 properties 标签的前两部分而已<br>那么下面就写几个实体吧，需要注意的是如果使用注解不要导错包，以 javax 开头的是 sun 公司定义的标准</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单的一个 bean，下面就弄段测试代码来跑一下，记得导入相关的包比如 JPA 和 Hibernate 的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 这句话执行后就会创建相应的表，前提是配置了相关配置;相当于 SessionFactory</span></span><br><span class="line">    EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"jpaDemo"</span>);</span><br><span class="line">    EntityManager em = factory.createEntityManager();</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    em.getTransaction().begin();</span><br><span class="line">    <span class="comment">// 和 save 是一样的，只不过这个名字更规范</span></span><br><span class="line">    em.persist(<span class="keyword">new</span> Person(<span class="string">"佳芷"</span>));</span><br><span class="line">    em.getTransaction().commit();</span><br><span class="line">    em.close();</span><br><span class="line">    factory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JPA注解"><a href="#JPA注解" class="headerlink" title="JPA注解"></a>JPA注解</h2><p>首先，看准包是 javax 开头的，其次，和 hibernate 的注解其实是差不多了</p>
<ul>
<li><strong>@Table</strong><br>使用格式：<code>@Table(name=&quot;&quot;,catalog=&quot;&quot;,schema=&quot;&quot;)</code><br><strong>只能标注在实体的 class 定义处</strong> ，表示实体对应的数据库表的信息，当然这三个值都是可选的</li>
<li><strong>@Id</strong><br>必须，定义了映射到数据库表的主键的属性,一个实体只能有一个属性被映射为主键.<br>标注在属性或者 <strong>getter</strong> 方法前</li>
<li><strong>@GeneratedValue</strong><br>使用格式：<code>@GeneratedValue(strategy=GenerationType, generator=&quot;&quot;)</code><br><code>strategy</code>：表示主键生成策略，有 AUTO、INDENTITY、SEQUENCE 和 TABLE 4 种，分别表示让 ORM 框架自动选择、根据数据库的 Identity 字段生成（差不多就是自增长）、根据数据库表的 Sequence 字段生成、以有根据一个额外的表生成主键，默认为AUTO<br><code>generator</code>：表示主键生成器的名称,这个属性通常和 ORM 框架相关，例如 Hibernate 可以指定 uuid 等主键生成方式.</li>
<li><strong>@Column</strong><br>同上，一般标注在 <strong>getter</strong> 方法前，当实体的属性与其映射的数据库表的列不同名时需要使用，一般可以省略不写<br>描述了数据库表中该字段的详细定义，这对于根据 JPA 注解生成数据库表结构的工具非常有作用.<br><strong>name</strong>：表示数据库表中该字段的名称,默认情形属性名称一致<br><strong>nullable</strong>：表示该字段是否允许为 null，默认为 true<br><strong>unique</strong>：表示该字段是否是唯一标识，默认为 false<br><strong>length</strong>：表示该字段的大小，<strong>仅对 String 类型的字段有效</strong><br><strong>insertable</strong>：表示在 ORM 框架执行插入操作时，该字段是否应出现 INSETRT 语句中，默认为 true<br><strong>updateable</strong>：表示在 ORM 框架执行更新操作时，该字段是否应该出现在 UPDATE 语句中，默认为 true；对于一经创建就不可以更改的字段，该属性非常有用，如对于 birthday 字段.<br><strong>columnDefinition</strong>：表示该字段在数据库中的实际类型，通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型，但是对于 Date 类型仍无法确定数据库中字段类型究竟是 DATE,TIME 还是 TIMESTAMP，此外，String 的默认映射类型为 VARCHAR，如果要将 String 类型映射到特定数据库的 BLOB 或 TEXT 字段类型（或者使用 @Lob 注解），该属性非常有用</li>
<li><strong>@Lob</strong><br>用于标注字段类型为 Clob 和 Blob 类型，比如标注在 string 类型上就是长文本型<br>Clob(Character Large Ojects) 类型是长字符串类型,实体的类型可为char[]、Character[]、或者 String 类型<br>Blob(Binary Large Objects) 类型是字节类型,实体的类型可为 byte[]、Byte[]、或者实现了 Serializable 接口的类。<br>通常使用惰性加载的方式,，<strong>@Basic(fetch=FetchType.LAZY)</strong></li>
<li><strong>@Transient</strong><br>表示该属性<strong>并非一个到数据库表的字段的映射</strong> ，ORM 框架将忽略该属性.<br>如果一个属性并非数据库表的字段映射，就务必将其标示为 @Transient，否则，ORM 框架默认其注解为 @Basic.</li>
<li><strong>@Temporal</strong><br>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision)。而在数据库中表示 Date 类型的数据有 DATE, TIME 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者兼备)。<br>在进行属性映射时可使用 @Temporal 注解来调整精度，比如：<code>@Temporal (TemporalType.TIMESTAMP)</code></li>
<li><strong>@Basic</strong><br>表示一个简单的属性到数据库表的字段的映射，<strong>对于没有任何标注的 getXxxx() 方法，默认即为 @Basic</strong><br>fetch：表示该属性的读取策略，有 EAGER 和 LAZY 两种，分别表示主支抓取和延迟加载，默认为 EAGER.<br>optional：表示该属性是否允许为 null，默认为 true</li>
<li><strong>@Enumerated</strong><br>用来指定实体持久化属性的为<strong>枚举类型</strong><br>如果标记没有显性给出或者 EnumType 没有指定，那枚举类型默认为 ORDINAL 数字(索引)标识<br>或者明确指定其 EnumType  为 STRING，采用的是字符串存到数据库，通常此字段配合 Column 来设置长度和非空</li>
</ul>
<hr>
<ul>
<li><p><strong>@ManyToOne</strong><br>表示一个<strong>多对一的映射，该注解标注的属性通常是数据库表的外键</strong><br>optional：是否允许该字段为 null，该属性应该根据数据库表的外键约束来确定,默认为 true<br>fetch：表示抓取策略，默认为 FetchType.EAGER<br>cascade：表示默认的级联操作策略，可以指定为 ALL、PERSIST、MERGE、REFRESH 和 REMOVE 中的若干组合，默认为无级联操作<br>targetEntity：表示该属性关联的实体类型，该属性通常不必指定，ORM 框架根据属性类型自动判断 targetEntity.<br>此注解一般需要配合 <strong>@JoinColumn</strong> 来确定外键名（字段名）</p>
</li>
<li><p><strong>@JoinColumn</strong><br>@JoinColumn 和 @Column 类似，只不过它描述的不是一个简单字段，而一一个关联字段；例如.描述一个 @ManyToOne 的字段.<br>name：该<strong>字段</strong>的名称，由于 @JoinColumn 描述的是一个关联字段，则默认的名称由其关联的实体决定.<br>例如，实体 Order 有一个 user 属性来关联实体 User，则 Order 的 user 属性为一个外键<br>其默认的名称为实体 User 的名称 + 下划线 + 实体 User 的主键名称</p>
</li>
<li><p><strong>@OneToMany</strong><br>描述一个<strong>一对多的关联，该属性应该为集体类型，在数据库中并没有实际字段</strong>.<br>fetch：表示抓取策略，默认为 FetchType.LAZY，因为关联的多个对象通常不必从数据库预先读取到内存<br>cascade：表示级联操作策略，对于 OneToMany 类型的关联非常重要，通常该实体更新或删除时，其关联的实体也应当被更新或删除<br>mappedBy：拥有 mappedBy 注解的实体类为关系被维护端（One），值为维护端的属性名（当前实体在关联实体中的属性名称）；<strong>如果类之间是单向关系，不需要提供定义，在双向关系中是必须的，否则会引发数据一致性的问题</strong><br>例如：实体 User 和 Order 是 OneToMany 的关系，则实体 User 被删除时，其关联的实体 Order 也应该被全部删除</p>
</li>
<li><p><strong>@OneToOne</strong><br>描述一个<strong>一对一的关联</strong><br>fetch：表示抓取策略，默认为 FetchType.LAZY<br>cascade：表示级联操作策略</p>
</li>
<li><p><strong>@ManyToMany</strong><br>描述一个<strong>多对多的关联，多对多关联上是两个一对多关联，但是在 ManyToMany 描述中中间表是由 ORM 框架自动处理</strong><br>targetEntity：表示多对多关联的另一个实体类的全名，例如：package.Book.class<br>mappedBy：表示多对多关联的另一个实体类的对应<strong>集合</strong>属性名称<br>示例：User 实体表示用户，Book 实体表示书籍，为了描述用户收藏的书籍，可以在 User 和 Book 之间建立 ManyToMany 关联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity=<span class="keyword">package</span>.Book.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getBooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(List books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books=books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List users;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity=<span class="keyword">package</span>.Users.class, mappedBy=”books”)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(List users)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users=users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个实体间相互关联的属性必须标记为 @ManyToMany ，并相互指定 targetEntity 属性<br>需要注意的是，有且只有一个实体的 @ManyToMany 注解需要指定 mappedBy 属性，指向 targetEntity 的集合属性名称<br>利用 ORM 工具自动生成的表除了 User 和 Book 表外，还自动生成了一个 User_Book 表，用于实现多对多关联</p>
</li>
<li><p><strong>@MappedSuperclass</strong><br>可以将超类的 JPA 注解传递给子类，使子类能够继承超类的 JPA 注解，所以说要写在超类的上面啊</p>
</li>
<li><p><strong>@Embedded</strong><br>将几个字段组合成一个类，并作为整个 Entity 的一个属性.<br>例如 User 包括 id、name、city、street、zip 属性.<br>我们希望 city、street、zip 属性映射为 Address 对象，这样 User 对象将具有 id、name 和 address 这三个属性.<br>Address 对象必须定义为 <strong>@Embededable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;city,street,zip&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Hibernate验证注解"><a href="#Hibernate验证注解" class="headerlink" title="Hibernate验证注解"></a>Hibernate验证注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td>
</tr>
<tr>
<td>@Size(max=, min=)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits (integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
<tr>
<td>@Pattern(regex=,flag=)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
</tbody>
</table>
<h3 id="Hibernate-验证器附加的约束"><a href="#Hibernate-验证器附加的约束" class="headerlink" title="Hibernate 验证器附加的约束"></a>Hibernate 验证器附加的约束</h3><p>Validator 附加的 constraint</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@NotBlank(message =)</td>
<td>验证字符串非null，且长度必须大于0</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是电子邮箱地址</td>
</tr>
<tr>
<td>@Length(min=,max=)</td>
<td>被注释的字符串的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的必须非空</td>
</tr>
<tr>
<td>@Range(min=,max=,message=)</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
</tbody>
</table>
<p>完整版参考：<a href="http://www.cnblogs.com/afeng7882999/p/4300032.html" target="_blank" rel="noopener">http://www.cnblogs.com/afeng7882999/p/4300032.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/07e8412d577a" target="_blank" rel="noopener">http://www.jianshu.com/p/07e8412d577a</a><br><a href="http://blog.csdn.net/u010837612/article/details/47660205" target="_blank" rel="noopener">http://blog.csdn.net/u010837612/article/details/47660205</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[构建工具之Gradle]]></title>
      <url>http://bfchengnuo.com/2017/08/09/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BGradle/</url>
      <content type="html"><![CDATA[<p>Gradle 是一个基于Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言来声明项目设置，而不是传统的 XML。<a id="more"></a></p>
<p>之前其实写过一点 Gradle 的，那是因为写 Android 的时候在 AS 中使用的就是它来构建的，但是并没怎么深入，这次就来好好的看一下，当然深度感觉还是不够，下面的一些介绍直接 copy 过来的，也可以去看看当时的<a href="https://bfchengnuo.com/2017/03/16/AndroidStudio%E4%B8%AD%E7%9A%84Gradle/">原文</a></p>
<blockquote>
<p>  Groovy是一种动态语言。这种语言比较有特点，它和Java一样，也运行于Java虚拟机中。恩？？对头，简单粗暴点儿看，你可以认为Groovy扩展了Java语言。比如，Groovy对自己的定义就是：Groovy是在 java平台上的、 具有像Python， Ruby 和 Smalltalk 语言特性的灵活动态语言， Groovy保证了这些特性像 Java语法一样被 Java开发者使用。</p>
</blockquote>
<p><strong>实际上，由于Groovy Code在真正执行的时候已经变成了Java字节码，所以JVM根本不知道自己运行的是Groovy代码</strong>。<br>所以说，对于做Java的来说，可以无缝切换</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>和之前的 Maven 差不多，都是下载、添加环境变量、命令行进行测试（<code>gradle -v</code>），环境变量一般命名 <strong>GRADLE_HOME</strong> 然后在 PATH 里添加 <code>%GRADLE_HOME%\bin</code> ；当然这是 win 的方法，其他系统等用到了再补充吧</p>
<blockquote>
<p>  每次执行 Gradle 的时候都会把其 init.d 目录下的脚本文件都执行一遍</p>
</blockquote>
<p>官网：<a href="https://gradle.org/" target="_blank" rel="noopener">https://gradle.org/</a></p>
<h2 id="Groovy的补充"><a href="#Groovy的补充" class="headerlink" title="Groovy的补充"></a>Groovy的补充</h2><p>Groovy 这门语言展开说还是挺多的，也许以后会详细了解，目前只需要知道几点它的特性就行了，它应该也算是“动态语言了”</p>
<ul>
<li>完全兼容 Java 语法</li>
<li>分号是可选的</li>
<li>类、方法默认是 public</li>
<li>Grooy 编译器会自动给属性添加 getter/setter 方法</li>
<li>属性可以直接使用点号进行获取</li>
<li>最后一个表达式的值会被当作返回值</li>
<li>== 相当于  equals()，所以不会产生空指针异常</li>
<li>类型可选、括号可选、 assert 语句、字符串的定义(单引号、双引号、三个单引号)、闭包、集合API<br>比如可以直接使用 def 来定义变量：<code>def ver = 1</code> ；<code>println(ver)</code> 和 <code>println ver</code> 是一样的<br>和其他语言类似，字符串的定义上，双引号中可以使用 <code>${}</code> 引用变量，三个单引号可以换行</li>
</ul>
<p>关于集合的简单使用：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="keyword">def</span> listTest = [<span class="string">'abc'</span>,<span class="string">'aaa'</span>]</span><br><span class="line"><span class="comment">// List追加数据</span></span><br><span class="line">listTest &lt;&lt; <span class="string">'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">def</span> mapTest = [<span class="string">'aaa'</span>:<span class="number">12</span>,<span class="string">'bbb'</span>:<span class="number">13</span>]</span><br><span class="line"><span class="comment">// map追加数据</span></span><br><span class="line">mapTest.ccc = <span class="number">456</span></span><br><span class="line">println mapTest.aaa</span><br><span class="line">println mapTest[<span class="string">'bbb'</span>]</span><br></pre></td></tr></table></figure>
<p>关于闭包的简单使用，闭包简单说就是个代码块，在其他语言中比如 python 中也是了解过的：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个“闭包”，一般闭包用于复制给变量</span></span><br><span class="line"><span class="comment">// 这是一个带参数的闭包，v 就是参数</span></span><br><span class="line"><span class="keyword">def</span> c1 = &#123;</span><br><span class="line">	v -&gt;</span><br><span class="line">  		println v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带参数的闭包</span></span><br><span class="line"><span class="keyword">def</span> c2 = &#123;</span><br><span class="line">	println <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// closure 就是接收闭包函数的，注意不要导入任何 java 的包</span></span><br><span class="line"><span class="keyword">def</span> method1(Closure closure)&#123;</span><br><span class="line">	closure(<span class="string">'param'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> method2(Closure closure)&#123;</span><br><span class="line">	closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用测试</span></span><br><span class="line">method1(c1)</span><br><span class="line">method2(c2)</span><br></pre></td></tr></table></figure>
<h2 id="初探Gradle"><a href="#初探Gradle" class="headerlink" title="初探Gradle"></a>初探Gradle</h2><p>首先 Gradle 有三要素，GroupId、ArtifactId、Version<br>GroupId ：一般就是公司域名的倒写，类似包名<br>ArtifactId ：“编号”，要保证在组下面编号是唯一的（当然可以使用英文）</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>目录结构类似：</p>
<p>|-src<br>|— main<br>|— |— java<br>|— |— resources<br>|— |— webapp<br>|— test<br>|— |— java<br>|— |— resources</p>
<h3 id="构建一个项目"><a href="#构建一个项目" class="headerlink" title="构建一个项目"></a>构建一个项目</h3><p>我用 IDEA 新建了个 Gradle 项目，自动给我生成的有 build.gradle 和 settings.gradle 这两个文件，第一个就是主要的配置文件了，第二个文件主要是加载模块用的，第一个文件最终会生成一个 Project 对象，之前定义的那三要素就相当于是里面的变量了，需要说下的是，如果有多个模块就要在 settings 文件中使用 <code>include &quot;module1&quot;, &quot;module2&quot;, &quot;module3&quot;</code> 进行导入了，下面会详细说</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">group <span class="string">'com.bfchengnuo.gradletest'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"><span class="comment">// apply plugin: 'war'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义公共仓库</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义依赖关系</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置 group、version 等属性除了在 build.gradle 文件中，还可以新建一个  <strong>gradle.properties</strong> 文件，然后这么写，效果是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group=&apos;com.bfchengnuo.gradletest&apos;</span><br><span class="line">version=&apos;1.0-SNAPSHOT&apos;</span><br></pre></td></tr></table></figure>
<h2 id="关于构建脚本"><a href="#关于构建脚本" class="headerlink" title="关于构建脚本"></a>关于构建脚本</h2><p>Gradle 里的任何东西都是基于这两个基础概念:</p>
<ul>
<li>projects ( 项目 )</li>
<li>tasks ( 任务 )</li>
</ul>
<p>每一个<strong>构建</strong>都是由一个或多个 projects 构成的. 一个 project 到底代表什么取决于你想用 Gradle 做什么. 举个例子, 一个 project 可以代表一个 JAR 或者一个网页应用. 它也可能代表一个发布的 ZIP 压缩包, 这个 ZIP 可能是由许多其他项目的 JARs 构成的. 但是一个 project 不一定非要代表被构建的某个东西. 它可以代表一件XX要做的事, 比如部署你的应用.</p>
<p>每一个 project 是由一个或多个 tasks 构成的. 一个 task 代表一些更加细化的构建. 可能是编译一些 classes, 创建一个 JAR, 生成 javadoc, 或者生成某个目录的压缩文件. 我们经常使用的 tasks 多是由插件进行提供的</p>
<h3 id="构建的生命周期"><a href="#构建的生命周期" class="headerlink" title="构建的生命周期"></a>构建的生命周期</h3><p>总体可分为：初始化 —-&gt; 配置 —-&gt; 执行</p>
<p><strong>初始化阶段</strong>：就是看看配置了那些项目，把它们加进来<br><strong>配置阶段</strong>：可以说只要不是特别的都属于配置，比如 apply、repositories、task 中的语句（不包括里面的doFirst、doLast ），这些语句都是，主要是用于处理各 task 的依赖关系<br><strong>执行阶段</strong>：最简单的栗子就是 task 里的 doFirst、doLast 里面的代码，它们都属于执行阶段运行的</p>
<p>PS:每个阶段之后都会执行一个构造方法，平时一般用不到，就不说了</p>
<h2 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h2><p>首先定义一个简单的任务试试：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式，task 是小写</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123; <span class="comment">//实现doLast方法</span></span><br><span class="line">        println <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code> 就等价于 <code>doLast</code>，<code>doLast</code> 是 gradle 提供访问 task 任务的一个 API，类似的还有 <code>doFirst</code>，当一个 task 被执行的时候，可以通过 <code>doFirst</code> 和 <code>doLast</code> 向 task 中动态添加操作。<strong><code>doFirst</code> 和 <code>doLast</code> 会在 task 本身被执行之后才会被执行</strong></p>
<p>如果使用依赖关系话，定义顺序其实是无所谓的…</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line">task intro(<span class="string">dependsOn:</span> hello) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者你这么写</span></span><br><span class="line">task intro(<span class="string">dependsOn:</span> hello)&#123;</span><br><span class="line">  println <span class="string">'hello'</span> <span class="comment">// 如果你写了这句，那么无论是否有依赖，这句永远第一执行</span></span><br><span class="line">  doLast &#123;</span><br><span class="line">  	println <span class="string">"I'm Gradle"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖还可以这样写</span></span><br><span class="line">task intro() &lt;&lt; &#123;</span><br><span class="line">    dependsOn <span class="string">'hello'</span></span><br><span class="line">    println <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>对应最新的构建工具，怎么可能没有依赖管理的功能，并且它是兼容 Maven 的，也就是说，可以使用 Maven 仓库里的各种 jar 包</p>
<p>依赖同样也分为编译时依赖和运行时依赖等，以前写 Maven 时候也有写过，差不多，然后再给一个 <a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BMaven.md#依赖范围" target="_blank" rel="noopener">飞机链接</a><br>下面说下 Gradle 的依赖范围，在 Gradle 里，对依赖的定义有6种，他们分别是 compile, runtime, testCompile, testRuntime, providedCompile和 providedRuntime ；首先是 <strong>java 插件的依赖标准</strong>下，就是说一下常用的几个：</p>
<ul>
<li>compile<br>在所有的 classpath 中可用，同时它们也会被打包。大部分都是这一类</li>
<li>runtime<br>在运行和测试系统的时候需要，但在编译的时候不需要。比如 JDBC 驱动实现，默认地依赖包括 compile 时的依赖</li>
<li>testCompile<br>依赖在编译测试代码时需要，默认地依赖包括产品 class、已经 compile 时的依赖</li>
<li>testRuntime<br>依赖在运行测试时需要，默认地依赖包括 compile、runtime 以及 testCompile 时的依赖</li>
</ul>
<p>可以看到 test 依赖和程序代码依赖是分开的，<strong>也就是说 test 设置的依赖在程序代码里并不依赖它</strong> ，然后下面再来说说 <strong>war 插件使用的依赖范围</strong></p>
<ul>
<li>providedCompile<br>与 compile 作用类似，<strong>但不会被添加到最终的 war 包中</strong> ，这是由于编译、测试阶段代码需要依赖此类 jar 包，而运行阶段容器已经提供了相应的支持，所以无需将这些文件打入到 war 包中了，例如 Servlet API 就是一个很明显的例子</li>
<li>providedRuntime<br>同 providedCompile 类似，它表示一些在编译的时候不需要提供的依赖库，<strong>但是在运行的时候需要</strong>。它们一般也是已经包含到应用服务器中了。</li>
</ul>
<p>相关的配置主要就是在下面的两个闭包中，定义仓库的瞬间就是查找的顺序</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义公共仓库</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// 如果是自己的私服</span></span><br><span class="line">    maven&#123;</span><br><span class="line">        url <span class="string">'xxxx'</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义依赖关系</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 可以使用 : 进行分割，也可以使用全名</span></span><br><span class="line">    compile <span class="string">'com.hynnet:logback-classic:1.1.3'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>既然有传递依赖，那么肯定就有依赖冲突问题，Gradle 默认的处理方式是选择版本最高的，关于依赖的处理日志可以看 tasks 下的 help 下的 dependencies，当然是对于 IDEA 来说的</p>
<p>Gradle 提供了两种解决版本冲突的策略：Newest 和 Fail. 默认策略是 Newest，如果配置 Fail 模式，就需要加入下面的代码，这样 Gradle 就不会自动的处理冲突了，你也可以强制指定使用某一版本</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy.failOnVersionConflict()</span><br><span class="line">  <span class="comment">// 如果有冲突,强制依赖asm-all的3.31版本和commons-io的1.4版本</span></span><br><span class="line">  <span class="comment">// resolutionStrategy.force 'asm:asm-all:3.3.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，取消自动处理冲突</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy&#123;</span><br><span class="line">    failOnVersionConflict()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 强制指定某个版本</span></span><br><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy&#123;</span><br><span class="line">    failOnVersionConflict()</span><br><span class="line">    force <span class="string">'asm:asm-all:3.3.1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用排除传递中的依赖的方式，一般只使用一个 exclude 进行排除就行了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile(<span class="string">'org.hibernate:hibernate:3.1'</span>) &#123;</span><br><span class="line">    <span class="comment">//如果有冲突，强制使用3.1版本</span></span><br><span class="line">    force = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//排除传递中的依赖</span></span><br><span class="line">    exclude <span class="string">module:</span> <span class="string">'cglib'</span> <span class="comment">//通过 artifact 的名字排除</span></span><br><span class="line">    exclude <span class="string">group:</span> <span class="string">'org.jmock'</span> <span class="comment">//通过 artifact 的 group 名字排除</span></span><br><span class="line">    exclude <span class="string">group:</span> <span class="string">'org.unwanted'</span>, <span class="string">module:</span> <span class="string">'iAmBuggy'</span> <span class="comment">//通过artifact的名字和grop名字排除</span></span><br><span class="line">    <span class="comment">//禁止该依赖传递</span></span><br><span class="line">    transitive = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h2><p>或者说多模块，新建模块的方法就不多说了，每个模块都含有 src、build.gradle ….等文件或目录，并且有些情况下各个模块之间是互相引用的，建好后如果需要引用其他模块，在 build.gradle 文件中这样引用</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 这里是有传递依赖的</span></span><br><span class="line">    compile project(<span class="string">':modeName'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了最外层的 <strong>settings.gradle</strong> 文件中引入模块：<code>include &quot;module1&quot;, &quot;module2&quot;, &quot;module3&quot;</code><br>通常，多个模块之间都有一些通用的配置，比如插件、版本等，这些都可以在根目录下的 <strong>build.gradle</strong> 文件中进行定义</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subprojects 里面可以写的内容和正常的build.gradle文件写法一样</span></span><br><span class="line"><span class="comment">// 为所有子模块应用设置</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'eclipse-wtp'</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">       mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        testCompile <span class="string">'junit:junit:4.11'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = <span class="string">'1.0'</span></span><br><span class="line"></span><br><span class="line">    jar &#123;</span><br><span class="line">        manifest.attributes <span class="string">provider:</span> <span class="string">'gradle'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写 allprojects 貌似也可以</span></span><br><span class="line"><span class="comment">// 比如：所有模块都采用统一的版本号以及 groupName</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    group = <span class="string">'com.bfchengnuo.test'</span></span><br><span class="line">    version = <span class="string">"0.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中几个闭包的作用是：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>allprojects</td>
<td>配置当前模块以及所有子模块行为</td>
</tr>
<tr>
<td>subprojects</td>
<td>配置所有子模块行为</td>
</tr>
<tr>
<td>project</td>
<td>配置指定子模块行为</td>
</tr>
</tbody>
</table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>常用的还有自动测试，稍微提一下是如果写了相关的测试代码，在执行 build 任务的时候是先处理源码，然后处理测试代码，如果测试代码通过则再进行打包或者XXX，如果测试不通过会直接报错，测试相关的日志可以去里看，有 html 格式的，看起来还不错，根据使用的测试框架（JUnit/ TestNG）也会有些差别</p>
<p>类被认为是一个JUnit测试类：</p>
<ul>
<li>类或父类集成自TestCase或GroovyTestCase</li>
<li>类或父类有@RunWith注解</li>
<li>类或者父类中的方法有@Test注解</li>
</ul>
<hr>
<p>再来说说发布，也许会用到要发布到私服或者本地仓库，那么可以使用 <strong>maven-publish</strong> 这个插件，当然必须是 Maven 仓库</p>
<blockquote>
<p>  下面是通过 ”maven-publish” 插件来支持发布到 Maven 功能。最终这种新的发布方式会替换掉通过 Upload task 的发布方式</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven-publish'</span></span><br><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        <span class="comment">// mavenJava 可以自定义，可以设置多个，会同步到到 tasks 中去</span></span><br><span class="line">        mavenJava(MavenPublication) &#123;</span><br><span class="line">            <span class="comment">// 若是war包，就写 components.web</span></span><br><span class="line">            from components.java</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            name <span class="string">'test'</span>  <span class="comment">// 好像可以省略</span></span><br><span class="line">            <span class="comment">// change to point to your repo, e.g. http://my.org/repo</span></span><br><span class="line">            url <span class="string">"$buildDir/repo"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后找到相关的任务执行就可以了，上面的两个可以写在一个 publishing 中；关于 maven-publish 这个插件就不多说了，想进一步了解的可以去：<a href="http://blog.csdn.net/a38017032/article/details/65935573" target="_blank" rel="noopener">http://blog.csdn.net/a38017032/article/details/65935573</a></p>
<h2 id="参考-更多"><a href="#参考-更多" class="headerlink" title="参考/更多"></a>参考/更多</h2><p><a href="https://dongchuan.gitbooks.io/gradle-user-guide-/build_script_basics/projects_and_tasks.html" target="_blank" rel="noopener">https://dongchuan.gitbooks.io/gradle-user-guide-/build_script_basics/projects_and_tasks.html</a><br><a href="http://www.zhaiqianfeng.com/2017/03/love-of-gradle-dependencies-1.html" target="_blank" rel="noopener">http://www.zhaiqianfeng.com/2017/03/love-of-gradle-dependencies-1.html</a><br><a href="https://michaelliuyang.github.io/projectsupport/2014/11/04/gradle-multi-project.html" target="_blank" rel="noopener">https://michaelliuyang.github.io/projectsupport/2014/11/04/gradle-multi-project.html</a><br><a href="https://github.com/someok/gradle-multi-project-example" target="_blank" rel="noopener">一个多项目管理实例</a><br><a href="https://www.gitbook.com/book/dongchuan/gradle-user-guide-/details" target="_blank" rel="noopener">Gradle User Guide 中文版</a><br><a href="https://lippiouyang.gitbooks.io/gradle-in-action-cn/content/test-with-gradle/unit-testing.html" target="_blank" rel="noopener">Gradle 实战–单元测试</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 构建工具 </tag>
            
            <tag> Gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JUnit进行测试]]></title>
      <url>http://bfchengnuo.com/2017/08/07/%E4%BD%BF%E7%94%A8JUnit%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>JUnit 是一个 Java 语言的单元测试框架。它由肯特·贝克和埃里希·伽玛（Erich Gamma）建立，逐渐成为源于 Kent Beck 的 sUnit 的 xUnit 家族中为最成功的一个。 JUnit 有它自己的 <a href="http://www.junit.org/news/extension/index.htm" target="_blank" rel="noopener">JUnit 扩展</a>生态圈。<a id="more"></a></p>
<p>JUnit 是一个<strong>回归测试框架</strong>，被开发者用于实施对应用程序的<strong>单元测试</strong>，加快程序编制速度，同时提高编码的质量。<br><strong>JUnit 提供：</strong></p>
<ul>
<li>断言测试预期结果。</li>
<li>测试功能共享通用的测试数据。</li>
<li>测试套件轻松地组织和运行测试。</li>
<li>图形和文本测试运行。</li>
</ul>
<p><strong>JUnit用于测试：</strong></p>
<ul>
<li>整个对象</li>
<li>对象的一部分 - 交互的方法或一些方法</li>
<li>几个对象之间的互动(交互)</li>
</ul>
<p>我们常用的它的两个特点应该就是注解和断言了吧.</p>
<blockquote>
<p>  一般来讲，源代码中包含明确的输入和输出的每一个方法被认为是一个可测试的单元<br>  一般来说，有两种类型的测试，一是所谓的黑盒测试（black-box testing），另一种 便是所谓的白盒测试（white-box testing），也有称为透明盒（clear-box/glass-box）或结构（structural）测试的。<br>  在黑盒测试中，我们的测试只针对程序的功能说明，而不管程序的具体实现，即不看程序代码。黑盒测试的最大好处是其测试过程不受实现的 潜在影响。如编码者可能对输入数据的一些不合理的假设，例如，输入参数是整数， 编码者可能假设只有正整数，而对0和负数则没作处理。如果读了代码后再去产生输入数据，很可能会受到这种错误假设的误导。黑盒测试的第二个好处是其测试数据与实现 无关，实现如有改变，只要功能说明不变，测试就保持不变。<br>  与黑盒测试相反，白盒测试则需要审阅程序代码。其主要的目的是要产生一些输入 数据，能够测试代码的每个语句（statement coverage）、分支（decision coverage），使得每条路径都能走到，即所谓的”路径完全（path-complete）”。</p>
<p>  每次修改程序代码后，所有的测试都需要重新运行，这通常称为<strong>回归测试</strong>（regression testing）。</p>
</blockquote>
<h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><p>主要是 JUnit3 和 JUnit4 的使用区别，目前使用的也就这两个版本，多数还是 JUnit4，虽然现在已经有 JUnit5 了，这个…..以后再补充</p>
<ol>
<li>在 JUnit3 中需要继承 TestCase 类，但在 JUnit4 中已经不需要继承任何类</li>
<li>在 JUnit3 中需要覆盖 TestCase 中的 setUp 和 tearDown 方法，其中 setUp 方法会在测试执行前被调用以完成初始化工作，而 tearDown 方法则在结束测试结果时被调用，用于释放测试使用中的资源，而在 JUnit4 中，只需要在方法前加上 @Before，就代表这个方法用于初始化操作，方法名是随意的</li>
<li>在 JUnit3 中对某个方法进行测试时，测试方法的命令是固定的，例如对 addBook 这个方法进行测试，需要编写名字为 tetAddBook 的测试方法，而在 JUnit4 中没有方法命令的约束，例如对 addBook 这个方法进行测试，那么可以编写 addBookToLibrary 的方法，然后在这个方法的前面加上 @Test,这就代表这个方法是测试用例中的测试方法</li>
<li>编写 JUnit4 的测试用例和编写一个普通的类没有什么区别，只是需要加上 Annotation 指定要测试的方法，这种松偶合的设计理念相当优秀，能很好把测试分离出来.使用 JUnit4 的 Annotation 功能，需要 JDK 1.5 或以上版本</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>现在基本都是4版本了，所以我也是使用的 JUnit4，一般的习惯是新建一个 test 文件夹保存测试代码，和 src 源代码目录得以区分，最后发布的时候也好删除；要测试那个类写的测试类后面加 Test，比如 MainTest 是 Main 类的测试类，测试类中的方法也是对应的，比如测试类中的 testAdd 方法就是对原始类中 add 方法的测试方法</p>
<p>测试方法一般是使用 public void 来进行修饰的，并且不需要任何参数，各个方法直接也没有关联，稍微想一下就能理解这样设计是很合理的<br>进行测试的时候可以一起执行也可以单个方法执行，只要你加了 @Test 注解</p>
<p>测试 web 项目也是差不多，只是在 @BeforeClass 的方法中初始化一些对象方便下面测试方法的使用，比如初始化 Spring、Hibernate 等</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li>@Test:<br>将一个普通的方法修饰成为一个测试方法<br>测试方法我认为最主要的特点是不是 main 也可以执行</li>
<li>@Test(expected=XXX(异常类).class)：<br>确定会抛出该异常，设定后出现该异常也是绿条通过</li>
<li>@Test(timeout=毫秒 )：<br>设置执行的时间，用于结束死循环或是性能测试</li>
<li>@Ignore:<br>所修饰的测试方法会被测试运行器忽略</li>
<li>@RunWith:<br>可以更改测试运行器默认为 org.junit.runner.Runner</li>
<li>@BeforeClass:<br>他会在所有的方法运行前被执行，并且只会执行一次，static 修饰，所以是单实例<br>适合配置文件的加载或者初始化</li>
<li>@AfterClass:<br>他会在所有方法运行结束后被执行，只执行一次，static 修饰;一般用于释放资源、关闭连接等</li>
<li>@Before：<br>会在<strong>每一个</strong>测试方法被运行前执行一次</li>
<li>@After：<br>会在<strong>每一个</strong>测试方法被运行后执行一次</li>
</ul>
<h2 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h2><p>测试套件简单说就是把一堆测试类整合起来，一起执行，主要使用了 @RunWith 注解更改默认的测试运行器，并且作为入口类，是不允许这个类中有其他方法的，具体的使用方法在下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Suite.class)  <span class="comment">//将测试类改为测试套件类</span></span><br><span class="line"><span class="meta">@Suite</span>.Suite.class(&#123;TaskTest1,TaskTest2...&#125;) <span class="comment">//用数组的形式将测试的类添加到测试套件中</span></span><br><span class="line"><span class="keyword">public</span> classSuiteTest&#123;</span><br><span class="line">  <span class="comment">//要用public修饰，套件测试类要为空。不能有方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以进行参数化设置，也就是批量测试，测试一堆数据，一般放在数组或者集合里，使用前也需要使用 @RunWith 注解更改默认的测试运行器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明变量用来存预期值和结果值</span></span><br><span class="line">    <span class="keyword">int</span> expected = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个返回值为 Collection 的公共静态方法，并使用 @Parameters 进行修饰</span></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; t()&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置构造函数，作用就是进行循环赋值了，注意顺序和构造的数组顺序是一致的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterTest</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> input1, <span class="keyword">int</span> input2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expected = expected;</span><br><span class="line">        <span class="keyword">this</span>.input1 = input1;</span><br><span class="line">        <span class="keyword">this</span>.input2 = input2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(expected,<span class="keyword">new</span> MainTest().add(input1,input2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 testAdd 会循环执行两次，每次的参数就是数组设置的那个</p>
<h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><p>Java 中的断言就不说了，用的很少，也是比较简单的，感兴趣的可以看看：<a href="http://lavasoft.blog.51cto.com/62575/43735/" target="_blank" rel="noopener">http://lavasoft.blog.51cto.com/62575/43735/</a></p>
<p>JUnit 中的所有的断言都包含在 Assert 类中，这个类提供了很多有用的断言方法来编写测试用例，一些常用的断言看下面的表格，当然最全的还是去看官方的 API</p>
<table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:left">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">检查两个变量或者等式是否平衡</td>
<td style="text-align:left"><strong>void assertEquals(boolean expected, boolean actual)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查条件为真</td>
<td style="text-align:left"><strong>void assertTrue(boolean expected, boolean actual)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查条件为假</td>
<td style="text-align:left"><strong>void assertFalse(boolean condition)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查对象不为空</td>
<td style="text-align:left"><strong>void assertNotNull(Object object)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查对象为空</td>
<td style="text-align:left"><strong>void assertNull(Object object)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查两个相关对象是否指向同一个对象</td>
<td style="text-align:left"><strong>void assertSame(boolean condition)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查两个相关对象是否不指向同一个对象</td>
<td style="text-align:left"><strong>void assertNotSame(boolean condition)</strong></td>
</tr>
<tr>
<td style="text-align:left">检查两个数组是否相等</td>
<td style="text-align:left"><strong>void assertArrayEquals(expectedArray, resultArray)</strong></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[构建工具之Maven]]></title>
      <url>http://bfchengnuo.com/2017/07/27/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B9%8BMaven/</url>
      <content type="html"><![CDATA[<p>Maven 是一个强大的 <strong>Java 项目构建工具。</strong> 对于其他语言也是可以的，但是主要是 Java，是由 Apache 开发的。<br>主要作用就是：<strong>项目的构建和依赖管理</strong><br>项目构建体现在：在项目编码完成后，要对项目进行编译、测试、打包、部署；这些工作 Maven 都可以做到<a id="more"></a><br>依赖管理它的好处体现于：<br>不需要再导入 jar 包，大大降低了项目文件的占用大小（它会根据配置的“坐标”去 Maven 仓库里去寻找对应的 jar 包）</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Maven 是用 Java 开发的，所以它的运行需要 JDK 支持，和 Java（JAVA_HOME） 类似，只需要把解压后的目录放进环境变量就行了，名称可以叫 <strong>MAVEN_HOME</strong>，然后再配进 path 里<br>然后在 CMD 命令行中输入 <code>mvn -v</code> 测试下是否正常</p>
<h2 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a>配置本地仓库</h2><p>Maven 仓库存的是各种各样的 jar 包，可以在本地搭建也可以在局域网中搭建，或者直接用互联网上的中央仓库<br>配置本地仓库去修改 Maven 目录下的 conf 目录下的 <code>settings.xml</code> 文件，将 localRepository 标签配好即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven_new_repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是 Eclipse 然后可以找到 Maven 的视图生成下索引，这样有利于 jar 包的快速获取</p>
<h2 id="新建一个Maven项目"><a href="#新建一个Maven项目" class="headerlink" title="新建一个Maven项目"></a>新建一个Maven项目</h2><p>首先选择 <code>Create a simple project (skip archetype selection)</code> 简单来说它的作用是给你创建好相应的文件目录，也就是骨架，如果不选择，你要手动选择一个模型，然后说下新建项目中需要填写的几个：</p>
<ul>
<li>Group Id<br>针对一个项目的普遍唯一识别符。是项目组织唯一的标识符，实际对应 JAVA 的包的结构，相当于我们日常使用的包名，例如：com.bfchengnuo</li>
<li>Artifact Id<br>要新建的项目的名字，就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。</li>
<li>Version<br>版本号，默认 <code>0.0.1-SNAPSHOT</code> ，也就是测试版本</li>
<li>Packing<br>要将该项目生成什么类型，有 jar、war、ejb、rar、pom（父工程）、eclipse-plugin 等等</li>
<li>Name<br>名字(估计是模板的名字)</li>
<li>Description<br>说明</li>
</ul>
<h2 id="Maven项目目录结构"><a href="#Maven项目目录结构" class="headerlink" title="Maven项目目录结构"></a>Maven项目目录结构</h2><p>和一般的项目也没啥区别，都有 src 源码文件夹，只是多了一个 <code>pom.xml</code> 文件，这个是 Maven 项目的核心配置文件，里面可以配置 JDK 的版本、jar 包的相关信息。<br>另外，Maven 下的 src 文件夹是有一定结构的，里面分为两个文件夹，main 和 test，从名字可以看出一个是主要，一个是测试；main 里面继续分，分为 java、resources(项目所需的配置文件) 和 webapp 文件夹；没有 lib 了，因为没有 jar 包什么事了</p>
<p>|-ProjectName<br>|– <em>pom.xml</em><br>|– <em>src</em><br>|–|– <strong>main</strong><br>|–|–|– java<br>|–|–|– resources<br>|–|–|– [ webapp/WEB-INF/web.xml ]<br>|<br>|–|– <strong>test</strong><br>|–|–|– java<br>|–|–|– resources</p>
<p>最终 java 、resource 目录下的文件默认还是会发布在一起，和原来的结构类似，所以 classpath 后可以直接引用 resource 下的文件（貌似是可以手动设置 classpath 的位置的，和 Gradle 应该类似，待研究）</p>
<h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><ul>
<li><code>mvn clean</code> 清理编译后的文件，也就是 targen 目录</li>
<li><code>mvn compile</code> 编译；编译后的文件在 targen 目录下</li>
<li><code>mvn test</code> 进行测试；运行测试目录下类的所有测试方法<br>注意类名的规范：<code>xxxTest.java</code></li>
<li><code>mvn package</code> 打包；默认会先编译再进行测试，最后执行打包，如果是 web 项目会自动打成一个 war 包，放在 targen 目录下</li>
<li><code>mvn install</code> 安装；把 jar 包安装到本地仓库中去，便于其他项目使用<br>过程还是先编译再测试，然后打包，最后再安装。也可以说是打包到本地仓库</li>
<li><code>mvn tomcat:run</code> 部署到 Tomcat （通过 war 包），并且启动</li>
</ul>
<h2 id="Maven项目生命周期"><a href="#Maven项目生命周期" class="headerlink" title="Maven项目生命周期"></a>Maven项目生命周期</h2><p>在 Maven 中存在三套生命周期，它们相互独立，互不影响（不同周期里的命令不会互相调用），<strong>在一套生命周期中，执行后面的命令，前面的命令会自动执行</strong></p>
<ul>
<li>CleanLifeCycle：清理生命周期<br>包含命令：clean</li>
<li>DefaultLifeCycle：默认生命周期<br>包含命令：compile –&gt; test –&gt; package –&gt;install –&gt;deploy（上传到私服）</li>
<li>siteLifeCycle：站点生命周期<br>包含命令：site</li>
</ul>
<h2 id="POM常见配置"><a href="#POM常见配置" class="headerlink" title="POM常见配置"></a>POM常见配置</h2><p>比如我们需要设置 JDK 的版本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 名字可以省略的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myweb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JDK版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">showWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWarnings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定 JDK 版本的简便方式，编译插件会自动读取这两个值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定 JDK 的版本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实就是添加了一个插件，通常所有的项目都要定义一个共同的父工程，这个父工程没有代码仅仅是为了统一版本号和 jar 等问题，所以最终要的是 pom.xml 文件，还有一个空壳的 src 文件夹，那么就来看看常用的一些配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 集中定义依赖版本号 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.1.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.2.8<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 设置deploy地址 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.taotao.com:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.taotao.com:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 省略.... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 资源文件拷贝插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- java编译插件省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置Tomcat插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prot</span>&gt;</span>80<span class="tag">&lt;/<span class="name">prot</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这样就不需要输 webAPP 的 name 了 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最重要的是 dependencyManagement 标签，它起到了统一管理依赖版本号的作用，使用这个标签后在子项目也必须配置 dependency 标签后相关的 jar 才会被导入到项目中，但是不用指定其版本，如果不加 dependencyManagement 在父工程定义的依赖都会自动导入到子工程中…..<br>子工程继承父工程非常简单，只需要加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就相当于是继承了~解决了指定版本号的问题；另外 Maven 会自动处理 jar 的依赖，也就是说如果此 jar 依赖其他 jar ，会自动把所需的 jar 导入，不用再配。</p>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围可分为：编译依赖范围、测试依赖范围、已提供依赖范围、运行依赖范围、系统依赖范围、导入依赖范围；<br><strong>默认的依赖范围是 compile</strong>，手动指定就是在 dependency 中加一个 scope 标签，例如： <code>&lt;scope&gt;test&lt;/scope&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">依赖范围</th>
<th style="text-align:center">对于编译有效</th>
<th style="text-align:center">对于测试有效</th>
<th style="text-align:center">对于运行有效</th>
<th style="text-align:center">栗子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">spring-core</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:center">-</td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
<td style="text-align:center">junit</td>
</tr>
<tr>
<td style="text-align:center"><strong>provided</strong></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
<td style="text-align:center">servlet-api</td>
</tr>
<tr>
<td style="text-align:center">runtime</td>
<td style="text-align:center">-</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">JDBC 驱动</td>
</tr>
<tr>
<td style="text-align:center">system</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Maven仓库之外的</td>
</tr>
<tr>
<td style="text-align:center">import</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>系统依赖范围通过 systemPath 显式指定；再说导入依赖范围，它不会对 classpath 产生影响。<br>servlet 相关的 API 一定要设置为 provided，否则会和 web 服务器中的 jar 冲突。</p>
<hr>
<p>依赖范围除了控制 classpath，还会对依赖传递产生影响。如果 A 依赖 B，B 依赖 C，则 A 对于 B 是第一直接依赖。B 对于 C 是第二直接依赖。 A 对于 C 是传递性依赖。<strong>结论是：第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">第一依赖\第二依赖</th>
<th style="text-align:center">compile</th>
<th style="text-align:center">test</th>
<th style="text-align:center">provided</th>
<th style="text-align:center">runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">compile</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">runtime</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:center">test</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">test</td>
</tr>
<tr>
<td style="text-align:center">provided</td>
<td style="text-align:center">provided</td>
<td style="text-align:center">-</td>
<td style="text-align:center">provided</td>
<td style="text-align:center">provided</td>
</tr>
<tr>
<td style="text-align:center">runtime</td>
<td style="text-align:center">runtime</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">runtime</td>
</tr>
</tbody>
</table>
<p>第一列是第一直接依赖，第一行是第二直接依赖，中间表示传递性依赖范围。<br>可以理解为：第一行为 B 和 C 的范围；第一列为 A 和 B 的范围；中间围起来的区域就是 A 和 C 的范围</p>
<h2 id="传递依赖冲突"><a href="#传递依赖冲突" class="headerlink" title="传递依赖冲突"></a>传递依赖冲突</h2><p>根据上面的传递依赖，比如项目同时依赖 A 和 B，A 又依赖于 C 并且版本是 1.0；B 也依赖于 C ，但是版本是 2.0；如果都导入肯定会发生冲突<br>Maven 会自动处理一些冲突，其遵循两个原则：</p>
<ol>
<li>第一声明者优先<br>就是谁先定义的就用谁的</li>
<li>路径近者优先<br>例如，项目中引入了 B 依赖，B 又间接引入了 C 依赖；如果后面单独定义了一个 C 的依赖，那么就会按照这个独立的依赖（第一依赖）的版本来</li>
</ol>
<p>或者可以手动<strong>排除</strong>掉其中一个，这样就相当于只有一个，具体在 <strong>pom.xml</strong> 文件中配置，使用 exclusion 标签，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.china.shared<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alibaba.apollo.webx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.slf4j.slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.external<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以进行<strong>版本锁定</strong>这样就能确保只使用某一个版本：使用的是 <strong>dependencyMangedent</strong> 标签；它只起一个锁定的作用，<strong>不会进行导入包操作</strong>【推荐使用】</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javaee-api.version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">javaee-api.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaee-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;javaee-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下 dependencyManagement 都会定义在父工程下的，子工程引用时就不需要指定版本了。</p>
<p><strong>注意：在 pom.xml 文件中可以定义属性，并且可以使用 OGNL 表达式，详细的栗子不表</strong></p>
<h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><p>用一幅图片来表示就是：<br><img src="/image/dev/maven概念模型.png" alt="maven概念模型.png"></p>
<p>上面的部分是处理依赖关系，下面的就是项目构建了…<br>可以看出项目构建依赖的是我们配置的插件</p>
<h2 id="项目拆分"><a href="#项目拆分" class="headerlink" title="项目拆分"></a>项目拆分</h2><p>Maven 两个重要的特性就是继承和聚合（它们的类型都是 pom 工程），对于传统的 SSH 架构，<strong>可以对每一层进行拆分</strong>，然后还需要一个父工程来进行统一，例如可以把 Dao 层和相关配置文件拆成一个工程，这样可以进一步降低耦合度。<br>要知道 Spring 配置文件可以拆的，所以就好办了，可以把 dao 层相关的配置放到 spring-dao.xml 中，最后在 web.xml 配置中使用通配符配下就行了（<code>classpath*:spring-*.xml</code>）。<br><strong>如果拆成多个子工程，子工程之间有依赖，那么记得先安装到本地仓库（install）然后加入其依赖。</strong> 因为依赖的传递性，所以 web 层引用 service 层的 jar 后，就不需要再单独加 dao 层的依赖了。<br>并且所有的工程一般都会有一个顶级父工程，它并不含有代码，最大的作用就是进行版本的统一了吧，按照上面的拆分，它就有了三个孩子，对应那三层（Dao 和 Service 打成 jar 包）。</p>
<h3 id="关于父工程"><a href="#关于父工程" class="headerlink" title="关于父工程"></a>关于父工程</h3><p>创建父工程和创建普通的 Maven 项目一样，<strong>就是选择打包的时候选择 pom</strong><br><strong>父工程不进行编码，只有一个 pom.xml 文件</strong><br>既然不进行编码，那么它的作用是什么呢？</p>
<ol>
<li>定义所需要的依赖信息，子模块可以直接继承使用</li>
<li>将各个子模块聚合到一起</li>
</ol>
<p>一般都是把父工程安装到版本库中去的，就是前面的 install 命令，因为最终项目运行的时候第一步会去本地仓库找依赖，如果父工程不发布子工程也没法玩（找不到“依赖”），POM 文件中一般都会用上面说的解决冲突中的版本锁定方式来锁定版本。</p>
<p><strong>注意：创建子工程的时候就要选择 Module 了，新建模块！</strong></p>
<p>对于 service 和 dao 层，打成 jar 包就可以了，为了避免报错在 service 中引用 dao 层的依赖就行了，在 pom.xml 文件里配置，和一般的加依赖一样。执行的 install 命令其实就是打包到本地仓库啦~<br>对于 web 层，打包选择打 war 包；<br><strong>部署测试的时候，记得先把父工程给安装（install ）到本地仓库，要不就提示 “404” 错误</strong> ；第一次运行会下载一些东西，后面就不会了</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><strong>运行调试的时候可以直接运行父工程，也可以运行 web 层的子工程，还可以传统方式部署到 Tomcat 运行</strong><br>Maven 项目的运行在右键菜单有两个选项，build 和 build… ，它们的区别是第一个是执行历史运行记录；第二个是手动输入指令运行，一般在 Goals 输入 <code>tomcat:run</code> 即可。<br>或者在 RunConfigurations 设置里直接 new 一个 Maven build 进行配置，比如最新的 tomcat7：<code>tomcat7:run</code><br>当进行 debug 调试的时候，需要在 source 选项卡下关联本项目才行，否则断点进不了（Eclipse），所以一般还是部署到 Tomcat 调试比较省事，虽然 Maven 提供 build 方式</p>
<h2 id="properties-Maven属性"><a href="#properties-Maven属性" class="headerlink" title="properties(Maven属性)"></a>properties(Maven属性)</h2><p>通过 <code>&lt;properties&gt;</code> 元素用户可以自定义一个或多个 Maven 属性，然后在 POM 的其他地方使用 <code>${属性名}</code> 的方式引用该属性，这种做法的最大意义在于消除重复和统一管理。<br>Maven 总共有 6 类属性：内置属性、POM属性、自定义属性、Settings属性、java系统属性和环境变量属性</p>
<ul>
<li><p>内置属性<br>两个常用内置属性 <code>${basedir}</code> 表示项目跟目录，即包含 pom.xml 文件的目录；<code>${version}</code> 表示项目版本</p>
</li>
<li><p>POM属性<br>用户可以使用该类属性引用 POM 文件中对应元素的值。如 <code>${project.artifactId}</code> 就对应了 <code>&lt;project&gt;</code> 中 <code>&lt;artifactId&gt;</code> 元素的值；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$&#123;project.build.sourceDirectory&#125;:项目的主源码目录，默认为 src/main/java/</span><br><span class="line"></span><br><span class="line">$&#123;project.build.testSourceDirectory&#125;:项目的测试源码目录，默认为src/test/java/</span><br><span class="line"></span><br><span class="line">$&#123;project.build.directory&#125; ： 项目构建输出目录，默认为target/</span><br><span class="line"></span><br><span class="line">$&#123;project.outputDirectory&#125; : 项目主代码编译输出目录，默认为target/classes/</span><br><span class="line"></span><br><span class="line">$&#123;project.testOutputDirectory&#125;：项目测试主代码输出目录，默认为target/testclasses/</span><br><span class="line"></span><br><span class="line">$&#123;project.groupId&#125;：项目的groupId</span><br><span class="line"></span><br><span class="line">$&#123;project.artifactId&#125;：项目的artifactId</span><br><span class="line"></span><br><span class="line">$&#123;project.version&#125;：项目的version,与$&#123;version&#125; 等价</span><br><span class="line"></span><br><span class="line">$&#123;project.build.finalName&#125;：项目打包输出文件的名称，默认为$&#123;project.artifactId&#125;-$&#123;project.version&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义属性<br>上面版本锁定的时候用过了，就是 properties 标签里定义的那些；子模块继承后也是可以继续使用的。</p>
</li>
<li><p>Settings属性<br>与 POM 属性同理，用户使用以 <code>settings.</code> 开头的属性引用 settings.xml 文件中的 XML 元素的值</p>
</li>
<li><p>Java系统属性<br>所有 java 系统属性都可以用 Maven 属性引用，如 <code>${user.home}</code> 指向了用户目录</p>
</li>
<li><p>环境变量属性<br>所有环境变量属性都可以使用以 <code>env.</code> 开头的 Maven 属性引用，如 <code>${env.JAVA_HOME}</code> 指代了 <strong>JAVA_HOME</strong> 环境变量的的值</p>
</li>
</ul>
<h2 id="配置默认JDK版本"><a href="#配置默认JDK版本" class="headerlink" title="配置默认JDK版本"></a>配置默认JDK版本</h2><p>在 Maven 的配置文件中加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样在创建项目的时候就是指定的版本了，默认好像是 1.5 来</p>
<h2 id="私服搭建"><a href="#私服搭建" class="headerlink" title="私服搭建"></a>私服搭建</h2><p>关于局域网（私服）的搭建工具可以使用 <strong>nexus</strong> ；谷歌搜一下就有了。<br><code>nexus install/start</code> 可以安装、启动服务（nexus.properties 中可更改端口）<br>启动后可以通过浏览器来访问管理界面，默认账户、密码为：admin / admin123；<br>仓库类型分为四种，一种已经废弃了，就不说了</p>
<ul>
<li>hosted 宿主仓库<br>一般存放本公司开发的 jar 包，包括正式版、测试版、第三方版等</li>
<li>proxy 代理仓库<br>中央仓库（主仓库）以及 Apache 下的测试版本 jar 包</li>
<li>group 组仓库<br>组嘛，可以包含其他的仓库，比如上面的两个</li>
</ul>
<p>上传命令：<code>mvn deploy</code> ;<br>当然在上传的前面需要先配置下 <strong>pom.xml</strong> 文件确定上传路径，还有在 Maven 客户端的配置文件中 写入认证信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--pom 文件！将ssm_dao上传私服  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--pom.xml这里 &lt;id&gt; 和 settings.xml 配置 &lt;id&gt; 对应  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>会根据项目设置的版本上传到对应的仓库；如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库。<br>私服设置好后需要在本地 Maven 客户端中（<strong>settings.xml</strong>）配置，让其能连接到私服：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--配置仓库镜像--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后这样 jar 包就会优先从私服寻找，找不到的时候再去互联网仓库；<code>&lt;server&gt;</code> 节点配置服务的账户密码，用于发布构件时进行身份和权限的认证。<br>下载构件这里使用的是 mirrors ，还有其他方案，但是推荐这种，算是简单的吧，mirror 相当于一个拦截器，它会拦截 maven 对 remote repository （包括私服和中央仓库）的相关请求，把请求里的 remote repository 地址，重定向到 mirror 里配置的地址。<br>这样一来，Maven 在找不到的情况下也不会访问中央仓库了，那本是 nexus 该做的事情。最好也配置下 profiles：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>crop-nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://你的NexusIP:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- true表示开启仓库发布版本下载，false表示禁止 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- true表示开启仓库快照版本下载，false表示禁止 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://你的NexusIP:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 禁止快照版本，防止不稳定的插件影响项目构建 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 激活nexus私服 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后来解释下上面出现的几个标签的意思：</p>
<blockquote>
<p>  <strong>Profiles</strong><br>  作用：根据环境参数来调整构建配置的列表。<br>  settings.xml 中的 profile 元素是 pom.xml 中 profile 元素的裁剪版本。<br>  它包含了 id、activation、repositories、pluginRepositories 和 properties 元素。<br>  <strong>如果一个 settings.xml 中的 profile 被激活，它的值会覆盖任何其它定义在 pom.xml 中带有相同 id 的 profile。</strong></p>
<p>  <strong>Repositories</strong><br>  作用：远程仓库列表，它是 maven 用来填充构建系统本地仓库所使用的一组远程仓库。</p>
<p>  <strong>pluginRepositories</strong><br>  作用：发现插件的远程仓库列表。<br>  和 repository 类似，只是 repository 是管理 jar 包依赖的仓库，pluginRepositories 则是管理插件的仓库。<br>  maven 插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories 元素的结构和 repositories 元素的结构类似。每个 pluginRepository 元素指定一个 Maven 可以用来寻找新插件的远程地址。</p>
<p>  <strong>ActiveProfiles</strong><br>  作用：手动激活 profiles 的列表，按照 profile 被应用的顺序定义 activeProfile。</p>
</blockquote>
<p>最后来补充个 repositories 的详细配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于 Maven 的其他配置就自行搜索吧</p>
<h2 id="使用阿里云镜像"><a href="#使用阿里云镜像" class="headerlink" title="使用阿里云镜像"></a>使用阿里云镜像</h2><p>当你没有私服，中央仓库由于一些原因特别的慢，不能浪费青春，可以换用阿里的镜像，能大幅提高下载速度，只需要加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 被镜像的服务器的id，这里选择中央仓库相同的 id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就相当于“替换”了中央仓库，速度是不是明显加快了？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://mushanshitiancai.github.io/2016/07/29/java/%E8%AF%B4%E8%AF%B4maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81-%E4%BE%9D%E8%B5%96%E8%B0%83%E8%A7%A3-%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92%E5%92%8C%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4/" target="_blank" rel="noopener">木杉</a><br><a href="http://www.cnblogs.com/youzhibing/p/5427130.html" target="_blank" rel="noopener">http://www.cnblogs.com/youzhibing/p/5427130.html</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 构建工具 </tag>
            
            <tag> Maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/07/21/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Spring Framework 是一个开源的 Java/Java EE 全功能栈（full-stack）的应用程序框架，以 Apache 许可证形式发布，也有 .NET 平台上的移植版本。<br>关键字：<code>轻量级</code>、<code>非侵入式</code>、<code>一站式</code>、<code>模块化</code>，其目的是用于简化企业级应用程序开发。<br>可以说 Spring 是一个容器框架，用于配置 bean、处理和维护 bean 之间的关系的框架<a id="more"></a><br><strong>注意：Spring 中的 bean 概念可以是 java 中的任何一种对象，比如可以是 javabean、service、action、数据源、dao、ioc（控制反转）、di（依赖注入）等</strong><br>可以说 Spring 贯穿各个层，上至 web 下至持久层，很厉害…</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>一般来说，当 Spring 加载的时候，会自动创建配置的 bean 对象（当作用域是 singleton 的时候），并加载到内存中去；使用 property 标签来注入对象（属性）<br>最简单的栗子，使用 Spring 获取一个对象，不需要再 new 了，首先定义一个简单的 bean，这里不多说就写一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Name --&gt;"</span> + name + <span class="string">"Age --&gt;"</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是在 xml 进行配置，文件名一般写 applicationContext 放在 src 目录下，如果 bean 对象引用了其他对象，可以使用 property 的 ref 属性设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.domain.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"佳芷"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loli"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.domain.Loli"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"desc"</span> <span class="attr">value</span>=<span class="string">"lovely"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">ref</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进行测试下，在启动时 Spring 就给你创建好对象了，并且是单例的，默认情况下；最好是使用接口，这样以后就不需要改动代码了，只改配置文件即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析配置文件并且创建其中的 bean 到内存中，非常耗费资源，一般写成工具类 单例模式</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">Loli loli = (Loli) ac.getBean(<span class="string">"loli"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(loli);</span><br></pre></td></tr></table></figure>
<h2 id="bean的作用域相关"><a href="#bean的作用域相关" class="headerlink" title="bean的作用域相关"></a>bean的作用域相关</h2><p>配置 bean 的时候有一个属性是 scope ，用来配置作用域，有五种可选值</p>
<ul>
<li>singleton<br>在 IOC 容器中，每一个 bean 定义对应<strong>一个</strong>对象实例，也就是单例 【默认】</li>
<li>prototype<br>一个 bean 定义可以对应多个实例，并且在获取（getBean）的时候才会被实例化</li>
<li>request<br>request 表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP request 内有效</li>
<li>session<br>session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP  session 内有效</li>
<li>global session<br>类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。<br>Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。<br>在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>然后获取 bean 的方法上面提到了一种，就是使用 ac 的 getBean 方法，除了这种还可以通过工厂的方式获得，但是不推荐使用，因为<strong>通过工厂获取会进行懒加载</strong>，也就是说当 get 的时候才会创建相应的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory bf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">User user = (User) bf.getBean(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>在默认情况下，也就是当作用域是 singleton 的时候，bean 对象是单例的，这种情况生命周期相对复杂一点，下面的顺序</p>
<ol>
<li>首先是实例化，当配置文件加载的时候，默认调用无参的构造函数</li>
<li>根据配置文件中的 property 进行属性注入，必须要有相应的 set 方法</li>
<li>如果 bean 对象实现了 BeanNameAware 接口，会调用其 setBeanName 方法，这个方法必须复写，通过这个方法可以获得配置的 id 名称<br>和前面的 struts2 有点相似，实现这个接口可以获得配置的 id 名称</li>
<li>如果 bean 对象实现了 BeanFactoryAware 接口，会调用其 setBeanFactory 方法，通过这个方法可以获得 bean 工厂</li>
<li>如果 bean 对象实现了 ApplicationContextAware 接口，会调用其 setApplicationContext 方法，通过这个方法可以获得上下文对象</li>
<li>调用 BeanPostProcessor (后置处理器)的 postProcessBeforeInitialization 方法，如果配置了处理器的话<br>后置处理器类似过滤器，每个 bean 实例化时（前、后）都要调用此处理器，有点像拦截器<br>设置处理器需要建一个类实现 BeanPostProcessor 接口即可，再配置到 xml 文件中（一切皆是 bean）</li>
<li>如果 bean 对象实现了 InitializingBean 接口，会调用其 afterPropertiesSet 方法</li>
<li>如果在 xml 配置文件中的 bean 标签定义了 <strong>init-method</strong> 属性，那么会在这时调用其指定的方法<br>使用这种方式耦合性比较低</li>
<li>调用 BeanPostProcessor (后置处理器)的 postProcessAfterInitialization 方法</li>
<li>然后就可以使用 bean 了！！</li>
<li>容器关闭….</li>
<li>如果 bean 对象实现了 DisposableBean 接口，这时会调用其 destroy 方法</li>
<li>如果在 xml 配置文件中的 bean 标签定义了 <strong>destroy-method</strong> 属性，那么会在这时调用其指定的方法<br>使用这种方式耦合性比较低</li>
</ol>
<p>如果不是用上下文获取的 bean，而是采用的工厂方法，那么就简单一些了，上面的5、6、9 就没有了<br>然后下面是两幅图，第一张比较详细，第二张比较简洁</p>
<p><img src="/image/dev/bean生命周期（全）.png" alt="bean生命周期（全）.png"></p>
<p><img src="/image/dev/bean生命周期.png" alt="bean生命周期.png"></p>
<h3 id="使用注解指定"><a href="#使用注解指定" class="headerlink" title="使用注解指定"></a>使用注解指定</h3><p>在配置文件中加入：<code>&lt;context:annotation-config/&gt;</code> 来启用注解<br>比如第八点自定义的 init 方法可以使用 <code>@PostConstruct</code> 注解来指定，不需要在 xml 文件中配置了<br>destroy 方法可以通过 <code>@PreDestroy</code> 注解来指定<br>更多注解的使用后面再说</p>
<h2 id="装载bean"><a href="#装载bean" class="headerlink" title="装载bean"></a>装载bean</h2><p>普通属性就不说了，主要是对于数组、集合的装填，首先看下配置的 xml 文件，后面用注解可能会更轻松</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"collectionTest"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.domain.CollectionTest"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--装载数组数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"strs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>str2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>str3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>str4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--装载 List 数据，根据特性可以重复引用，并且是有顺序的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"users"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--装载 Map 集合数据，根据特性不能有重复，后面会覆盖前面，当然只是 key 不同就行，无序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"user"</span> <span class="attr">value-ref</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"user2"</span> <span class="attr">value-ref</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"test"</span> <span class="attr">value-ref</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--装填 set 集合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userSet"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以跑一下，测试看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collectionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = ApplicationContextUtil.getAc();</span><br><span class="line">    CollectionTest collectionTest = (CollectionTest) ac.getBean(<span class="string">"collectionTest"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    System.out.println(<span class="string">"-----------数组遍历-----------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : collectionTest.getStrs()) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 List</span></span><br><span class="line">    System.out.println(<span class="string">"-----------List遍历-----------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user : collectionTest.getUsers()) &#123;</span><br><span class="line">        System.out.println(user.getName() + <span class="string">"::"</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 Map</span></span><br><span class="line">    System.out.println(<span class="string">"-----------Map遍历-----------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : collectionTest.getMap().entrySet()) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"::"</span> + entry.getValue().getName() + <span class="string">"-"</span> + entry.getValue().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历 Set</span></span><br><span class="line">    System.out.println(<span class="string">"-----------Set遍历-----------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user : collectionTest.getUserSet()) &#123;</span><br><span class="line">        System.out.println(user.getName() + <span class="string">"::"</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>property 标签中还可以继续再套一个 bean 标签，这样就相当于内部类，在其他地方就不能通过 ref 进行引用了</p>
<p>如果有继承关系可以使用 bean 的 parent 属性指定父 bean，配置的相关属性会被继承过来，当然你可以进行覆盖</p>
<p>如果需要设置值为空，可以使用 <code>&lt;null/&gt;</code> 标签</p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>使用 bean 标签中的 <strong>autowire</strong> 属性为一个 bean 定义指定自动装配模式，也就是说指定了自动装配就不需要注入对象了，它会自动根据设置去 IoC 容器中寻找合适的 bean 然后自动注入。但是并不推荐使用，仅作为了解；但是我看经常配合注解使用，尤其是在 SSH 的项目中</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:left">这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。</td>
</tr>
<tr>
<td style="text-align:center">byName</td>
<td style="text-align:left">由属性名自动装配。当找不到相应的连接关系时会尝试使用属性名去搜寻对应的 bean （id 和 name 相匹配）；如果找不到或者找到多个则抛异常</td>
</tr>
<tr>
<td style="text-align:center">byType</td>
<td style="text-align:left">由属性数据类型自动装配。当找不到相应的连接关系时会尝试使用属性的类型搜寻对应的 bean （class 相匹配）；如果找不到或者找到多个则抛异常</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://wiki.jikexueyuan.com/project/spring/beans-auto-wiring/spring-autowiring-by-Constructor.html" target="_blank" rel="noopener">constructor</a></td>
<td style="text-align:left">类似于 byType，但该类型适用于<strong>构造函数参数类型</strong>。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。</td>
</tr>
<tr>
<td style="text-align:center">autodetect</td>
<td style="text-align:left">Spring 首先尝试通过 <em>constructor</em> 使用自动装配来连接，如果它不执行，Spring 尝试通过 <em>byType</em> 来自动装配。</td>
</tr>
</tbody>
</table>
<p>默认值也是可以设置的，在 beans 标签的 <strong>defualt-autowire</strong> 属性指定</p>
<h3 id="分散配置"><a href="#分散配置" class="headerlink" title="分散配置"></a>分散配置</h3><p>使用 Spring  的特殊 bean 来达到分散配置的目的，占位符使用 <code>${name}</code> 的形式；前面说生命周期的时候说的那几个接口就是体现的这个功能<br>首先新建个 properties 文件，然后引入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分散配置，引入 prop 文件；如果引入多个文件可以用逗号分割--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"temp.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以使用占位符来引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user3"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.domain.User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;name&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"$&#123;age&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="获取ApplicationContext"><a href="#获取ApplicationContext" class="headerlink" title="获取ApplicationContext"></a>获取ApplicationContext</h2><p>首先要明确的是 ApplicationContext  是个接口；其实它也是 BeanFactory 的子类，获取 ApplicationContext 实现类常用的有下面几种方式：</p>
<ol>
<li>ClassPathXmlApplicationContext 通过类路径，上面写过了，通常用在“桌面”系统开发</li>
<li>FileSystemXmlApplicationContext 通过文件系统获取，需要指明绝对路径，用的很少</li>
<li>XmlWebApplicationContext 通过 web 方式获取，传统项目这个用的还是比较多的</li>
<li>AnnotationConfigApplicationContext 使用 Java 配置的方式来构建 ApplicationContext，例如 SpringBoot</li>
<li>AnnotationConfigWebApplicationContext 使用 Java 配置方式的 Web 应用，可以在 web.xml 中指定。</li>
</ol>
<h2 id="AOP编程和IoC"><a href="#AOP编程和IoC" class="headerlink" title="AOP编程和IoC"></a>AOP编程和IoC</h2><p>AOP 和 IoC 是 Spring 的两大特点</p>
<p><strong>AOP</strong>（Aspect Orient Programming），也就是<strong>面向切面编程</strong>。 可以这样理解，面向对象编程（OOP）是从静态角度考虑程序结构，面向切面编程（<strong>AOP</strong>）是从动态角度考虑程序运行过程。<br><strong>这种在运行时，动态地将代码“切入”到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong><br>或者说在不增加代码的基础上增加新的功能；面向（作用于）全部对象，或者一类对象（想一下学过的监听器、拦截器、过滤器）</p>
<p>下面就说说常见的几个术语：</p>
<ul>
<li><strong>通知/增强（Advice）</strong><br>切面的工作被称为通知，通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只是在方法抛出异常时调用？<br>简单说就是你想要（切入）的具体功能实现(想要干啥)，比如安全，事物，日志操作等。</li>
<li><strong>连接点(JoinPoint)</strong><br>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br>就是 Spring 允许你使用通知的地方</li>
<li><strong>切点(Pointcut)</strong><br>一组连接点的总称，用于指定某个通知（增强）应该在何时被调用。<br>切入点是「在哪干」，你可能在很多地方（连接点）都可以干，但并不是每个地方都要干，要干的地方叫切点</li>
<li><strong>切面（Aspect）</strong><br>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——<strong>它是什么，在何时和何处完成其功能</strong><br>通知说明了干什么和什么时候干（什么时候通过方法名中的before、after、around 等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</li>
<li><strong>织入(weaving)</strong><br>把切面应用到目标对象来创建新的代理对象的<strong>过程</strong>。有3种方式，spring 采用的是运行时</li>
</ul>
<p>Spring 中的通知有五种类型：</p>
<ol>
<li>前置通知(Before)：在目标方法被调用之前调用通知功能；[接口： MethodBeforeAdvice]</li>
<li>后置通知(After)：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；[接口： AfterReturningAdvice]</li>
<li>返回通知/最终通知(After-returning)：在目标方法成功执行之后调用通知，如果有后置通知会在其之后执行；</li>
<li>异常通知(After-throwing)：在目标方法抛出异常后调用通知；[接口： ThrowsAdvice]</li>
<li>环绕通知(Around)：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。[接口： MethodInterceptor]</li>
</ol>
<p>运行顺序：<strong>前置通知/环绕通知</strong>–<strong>目标方法执行</strong>–<strong>返回通知/异常通知</strong>–<strong>后置通知/环绕通知</strong><br>这里需要注意的是：环绕通知由于和前置、后置处于同一个 aspect 内，所以是无法确定其执行顺序的，当然可以通过其他手段来解决<br>实际开发中，一般会将顺序执行的 Advice 封装到不同的 Aspect，然后通过注解或者实现接口的方式控制 Aspect 的执行顺序，二选一（对于在同一个切面定义的通知函数将会根据在类中的声明顺序执行）<br>关于 AOP 的更详细介绍：[1]:<a href="http://cometzb-xujun.iteye.com/blog/1537274；[2]:http://www.jianshu.com/p/66d21dae6a68" target="_blank" rel="noopener">http://cometzb-xujun.iteye.com/blog/1537274；[2]:http://www.jianshu.com/p/66d21dae6a68</a></p>
<hr>
<p>简单解释下什么是 IoC（控制反转 Inversion of Control），它是一种设计思想，和依赖注入有些相似之处（<del>或者说不同名称，相同含义</del>），就是说把创建对象和维护对象关系的控制权从程序中转移到了 Spring 容器中（applicationContext.xml），程序本身不再维护，换句话说就是<strong>从代码移到了配置文件中</strong> ，对象的创建交给外部容器处理</p>
<p><strong>你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制</strong> ,所以说这个容器很重要，IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建<br>简单总结：<br><strong>控制反转解决对象的创建问题（交给别人创建），依赖注入解决在创建对象后，对象关系的处理问题（通过 set 方法依赖注入）</strong></p>
<p>参考：<a href="http://luanxiyuan.iteye.com/blog/2279954" target="_blank" rel="noopener">http://luanxiyuan.iteye.com/blog/2279954</a></p>
<h3 id="AOP快速入门"><a href="#AOP快速入门" class="headerlink" title="AOP快速入门"></a>AOP快速入门</h3><p>Spring 中“使用” AOP 的步骤一般是：</p>
<ol>
<li>定义接口</li>
<li>编写对象（目标对象、被代理对象）</li>
<li>编写通知</li>
<li>XML 文件中进行配置，包括被代理对象、通知、代理对象（ProxyFactoryBean）</li>
<li>通过代理对象进行使用</li>
</ol>
<p>如果看过动态代理相关的知识，还是很好理解的，那就搞一个简单的前置通知来玩玩，前两部就省略了，很简单；主要是通知和 XML 的配置，这种 XML 的配置好像很 low 了，随便看看就好，稍后我会专门更新一篇新版的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在被代理对象的前面执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法对象--被调用方法的方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 传入被调用方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 目标对象（被代理对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before...记录..."</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是相关的配置文件，如果代理了多个接口记得要在 proxyInterfaces 都写进去，这样就可以在 getBean 后随意进行切换</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置目标对象（被代理对象）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"standardLoli"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.aop.StandardLoli"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"flag"</span> <span class="attr">value</span>=<span class="string">"欧尼酱"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myMethodBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.aop.MyMethodBeforeAdvice"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置代理对象，Spring 提供--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"proxyFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--代理接口集--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.bfchengnuo.aop.Loli<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将通知织入代理对象,相当于把通知和代理对象建立关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"myMethodBeforeAdvice"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置被代理对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"standardLoli"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后测试了下，还是挺不错的，如果之前写了多个接口，可以直接进行各种强转，当然你的通知要都实现了这些接口，终究还是多态的特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/bfchengnuo/aop/beans.xml"</span>);</span><br><span class="line">    Loli loli = (Loli) ac.getBean(<span class="string">"proxyFactoryBean"</span>);</span><br><span class="line">    loli.hug();</span><br><span class="line">    System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">    System.out.println(loli.speak(<span class="string">"bfchengnuo"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再来补充一个，就是定义切点，是自定义，也就是说指定某个通知在指定的方法切入，配置完后记得在代理对象中将通知换成这个就可以了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义切入点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myPointcutAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置的是前置通知的切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"myMethodBeforeAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置在那个方法进行切入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是可以使用通配符的--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>hug<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate学习笔记(二)]]></title>
      <url>http://bfchengnuo.com/2017/07/09/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>对于数据量大，性能要求高的系统，是<strong>不适合</strong>使用 Hibernate 的；主要用于事务操作比较多的系统（比如 OA/CRM 行业软件）<br>忽然想起来，现在已经是 Hibernate5.x 了，有些配置方面已经做了更改，比如 SessionFactory 的获取方式，我也刚刚才意识到，这个版本的问题我准备以后单独搞一篇来说<a id="more"></a></p>
<h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p>级联是什么学过数据库的都懂，应用在 Hibernate 下就是：当对主对象进行操作的时候，是否对从对象也进行类似的操作<br>在 Hibernate 中只需要在配置文件里配一下就可以了<br>比如可以在 set 标签设置 <strong>cascade</strong> 属性，一般有五个可选值，<del>如果设置多个可以用逗号分割</del>：</p>
<ul>
<li>save-update<br>级联保存或者更新(也就是说 load 以后如果子对象发生了更新,也会级联更新数据库). 但它不会级联删除</li>
<li>delete<br>级联删除, 但不具备级联保存和更新</li>
<li>all-delete-orphan<br>在解除父子关系时,自动删除不属于父对象的子对象, 也支持级联删除和级联保存更新.</li>
<li>all<br>能够级联删除和级联更新，但解除父子关系时不会自动删除子对象.</li>
<li>delete-orphan<br>删除所有和当前对象解除关联关系的对象</li>
</ul>
<div class="note warning"><p>以上设在哪一段就是指对哪一端的操作而言，比如 delete，如果设在 one 的一端的 <code>&lt;set&gt;</code> 属性里，就是当 one 被删除的时候，自动删除所有的子记录；<br>如果设在 many 一端的 <code>&lt;many-to-one&gt;</code> 标签里，就是在删除 many 一端的数据时，<strong>会试图删除 one 一端的数据，如果仍然有 many 外键引用 one，就会报“存在子记录”的错误</strong>；<br>如果在 one 的一端同时也设置了<code>cascade＝&quot;delete&quot;</code> 属性，就会发生很危险的情况：删除 many 一端的一条记录，会试图级联删除对应的 one 端记录，因为 one 也设置了级联删除 many，所以其他所有与 one 关联的 many 都会被删掉。</p>
<p><strong>所以，千万谨慎在 many-to-one 的 many 一端设置 <code>cascade＝&quot;delete&quot;</code> 属性。故此 cascade 一般用在 <code>&lt;one-to-one&gt;</code> 和<code>&lt;one-to-many&gt;</code> 中</strong></p>
</div>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>关于这个问题在上一篇中提到过，就是在获取 Session 的时候，get 和 load 方式；load 方式就是使用的懒加载<br>所带来的问题就是：如果 domain 对象中存在其他对象的引用，默认这个引用的对象数据是空的，它以为你不会用，所以并没有去数据库查；等你用的时候，它会试图去数据库查，但是用数据的时候 Session 可能已经关闭了，所以只能抛异常了</p>
<p>常见的解决方案有：</p>
<ol>
<li>关闭懒加载，就是在配置文件设置 lazy 属性为 false</li>
<li>显式的进行加载<br>初始化代理对象 <code>Hibernate.initialize(bean.getBean);</code>  就是相当于手动调用了一下 domain 对象中的”对象“</li>
<li>使用 openSessionInViewFilter<br>前面貌似也说过，通过过滤器实现拦截所有请求，扩大 Session 的范围，在请求开始的时候开启 Session 与事务，在请求结束的时候提交事务、关闭连接<br>过滤器最好配置在 Struts2 核心过滤器的前面</li>
<li>在 SSH 项目中可以使用注解来解决</li>
</ol>
<p>然后再多说点关于第一点的，因为如果配置不好反而效率会降低，Hibernate 的配置很关键！<br>在 many-to-one 也就是多对一的 many 方，如果配置了 <code>&lt;class ... lazy=&quot;false&quot;&gt;</code> ，那么 Hibernate 就会在查询 many 方的时候把它相互关联的对象也进行查询，对 select 的影响并不是很大，毕竟是多对一<br>在 one-to-many 的 one 这一方，如果配置了 <code>&lt;set ... lazy=&quot;false&quot;&gt;</code> ，那么当你查询这个 one 的时候，会把相关联的 many 全部查询回来，不管你是否使用（都会发一大堆的 select 语句）</p>
<p>所以说，不要在 one-to-many 的 many 的一方设置 lazy 为 false ，效率会大大降低，<strong>可以</strong>用的是在 set、list 标签中设置属性 lazy 为 extra；这样会比较智能，在使用 list.size() 方法的时候会发送 <code>select count(*)...</code> 语句，而不是一条条的查回来<br>如果要使用第一种方案，<strong>少在</strong> many-to-one 和 one-to-one 标签里设置 lazy；<strong>不要</strong>在 class 和 property 标签里设 lazy</p>
<p>懒加载其实是依赖的动态代理，前面也提到过，返回的其实是个代理对象，也就是说如果要使用懒加载在设计 domain 对象的时候就不能设置为 final</p>
<blockquote>
<p>  懒加载除了设置 true 和 false，还有一个值：extra<br>  它一般设置在配置文件中集合标签的属性中（如 set 标签中），意义是当使用集合的 size、isEmpty 等函数时，并不把所有的数据查询回来，而是使用相应的 sql 函数进行查询<br>  <strong>extra 也是使用懒加载，只不过是更智能的懒加载，一般设置这个就行</strong></p>
</blockquote>
<h2 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h2><p>前面提到过一点，Hibernate 的缓存常用的就是一级和二级缓存，一级缓存又称 Session 缓存（存在于内存），因为它伴随着 Session，会话结束了缓存也就不存在了<br>对于 Session 的那些操作会使其放进一级缓存？<br><strong>save、update、saveOrUpdate、load、get、list、lock、iterate</strong><br>在执行上面的这些方法的时候会先将对象加入到一级缓存，然后在事务提交的时候发送相应的 sql 语句，同步到数据库<br>都知道使用 get、load 方法会从一级缓存中获取数据，<strong>但是 list（或者 uniqueResult）并不会从缓存获取数据，它只放进缓存不会主动取缓存数据</strong><br>然后如果频繁的调用上面的方法，为了防止内存溢出，<strong>记得调用 evict 或者 clear 来清除缓存</strong> ；分别对应的是清除单个对象和所有对象；此外还有一个  flush 的方法，用来刷新缓存，让一级缓存和数据库进行同步。<br>所以说，一级缓存只有在短时间内频繁的操作数据库的情况下，效果才比较明显；处于持久化的对象一般都存在于 Session 缓存中</p>
<blockquote>
<p>  关于 List 和 iterate 这里简单说下，list 会一次性把所有的记录都查出来；而 iterate 会查询 n +1 次，也就是如果有五条数据，那么会查询六次。<br>  第一次会查询全部的 id ，然后每一次的 next 会根据这个 id 进行查询，所以总共是 n +1 次查询；但是它会从缓存中获取，List 不会从缓存中获取<br>  所以说，当你第一次用 List 获取后会放入缓存，如果第二次你用 iterate 获取，他会从缓存中获取（List 放进去的数据）数据，这样也验证了 List 是会把数据放进缓存中去的</p>
</blockquote>
<hr>
<p>然后再来说说二级缓存，又叫 SessionFactory  缓存，为什么应该也能猜到了，肯定和其的生命周期有关；不同于一级缓存（生命周期短，大小限制），二级缓存<strong>必须配置后才可以使用，并且其是交给第三方进行处理的</strong> ；当然 hibernate 也带一个。<br>它是全局性的，应用中的所有 Session 都共享这个二级缓存。<br>常用的二级缓存插件有：Ehcache、OSCache、JBossCache；这些缓存有可能存在内存中，也有可能存在于硬盘中<br>开启二级缓存首先在 cfg 配置文件中（可以从 hibernate.properties 文件中查找）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启动二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 启动命中率统计 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.generate_statistics"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定使用哪种二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.cache.region.factory_class"</span>&gt;</span>org.hibernate.cache.ehcache.EhCacheRegionFactory<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定哪个domain启用二级缓存 </span></span><br><span class="line"><span class="comment">  特别说明二级缓存策略:</span></span><br><span class="line"><span class="comment">  1. read-only</span></span><br><span class="line"><span class="comment">  2. read-write</span></span><br><span class="line"><span class="comment">  3. nonstrict-read-write</span></span><br><span class="line"><span class="comment">  4. transcational</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class-cache</span> <span class="attr">usage</span>=<span class="string">"read-write"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.ssh.domain.User"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 集合缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection-cache</span> <span class="attr">usage</span>=<span class="string">"read-write"</span> <span class="attr">collection</span>=<span class="string">"com.bfchengnuo.ssh.domain.User.set"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>缓存策略的配置除了 class-cache 标签还可以在 hbm 映射配置文件中的 cache 标签里配，但是为了便于管理多数还是在 cfg 文件中配置。</p>
<ul>
<li>read-only<br>只读缓存，提供 serializable 事务隔离级别，<strong>对于从来不会修改的数据</strong>，可以采用这种访问策略，可以避免脏读，不可重复读和幻读。 </li>
<li><strong>read-write</strong><br>读写缓存，提供 read committed 事务隔离级别。<strong>对于经常读但是很少被修改的数据</strong>，可以采用这种隔离类型，它可以防止脏读。（通常选用的策略）</li>
<li>nonstrict-read-write<br>不严格的读写，不保证缓存与数据库种数据的一致性。提供 read uncommitted 事务隔离级别。<strong>对于极少被修改，而且允许脏读的数据</strong>，可以采用这种策略。</li>
<li>transcational<br>仅在受管理环境下适用。它提供了repeatable read 的事务隔离级别。<strong>对于经常读，但是很少被修改的数据</strong>，可以采用这种隔离类型，它可以防止脏读和不可重复读。 </li>
</ul>
<p>在查询数据的时候，会放进二级缓存和一级缓存（前提是你配置过这个实体），就是都放一份，还可以通过 statistics 查看命中率 (通过 SessionFactory  获取)<br>如果配置了集合缓存，记得集合里面的实体也必须是配置过 class-cache 的，否则是没有效果的。<br>如果使用的是 EHcache 就要在 src 目录下加入 <code>ehcache.xml</code> 文件来具体配置缓存策略，具体的配置不写了，也不是很常用，也就配个大小<br>放入二级缓存的数据必须是很少被修改的内容</p>
<p>其实还有一个查询缓存…..他可以让 query.list() 方法从二级缓存中取数据。<br>查询缓存的开启是：<code>&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;</code>；需要定义在 class-cache 之前，并且 list 如果要使用的话需要手动调用一下 <code>q.setCacheable(true)</code> 才行。</p>
<h2 id="主键增长策略"><a href="#主键增长策略" class="headerlink" title="主键增长策略"></a>主键增长策略</h2><p>至于在那配置我想都是知道的，就是在 id 标签里的 generator 标签的 class 属性中设置；貌似总共有16+，常用的也就 8、9种，比如：</p>
<ul>
<li><strong>increment</strong><br><strong>用于 long、short 或 int 类型（下面就称数值型吧）</strong>，适用于所有数据库，每次增量为1。只有当没有其他进程向同一张表中插入数据时才可以使用，不能在集群环境下使用。适用于代理主键。<br>实质其实就是用 sql 的 max 函数计算出最大的 id 然后 +1，所以自然不能用字符串</li>
<li><strong>identity</strong><br>采用底层数据库本身提供的主键生成标识符，每次增长1，条件是<strong>数据库支持自动增长数据类型（MySQL、SQL server）</strong>。在 MySQL 数据库中可以使用该生成器，<strong>该生成器要求在数据库中把主键定义成自增长类型</strong>。适用于代理主键。<strong>Oracle 数据库并不适用。</strong></li>
<li><strong>sequence</strong><br>Hibernate 根据底层数据库序列生成标识符。<strong>条件是数据库支持序列</strong>。适用于代理主键。在 oracle 数据库中可以使用该生成器。类型也是数值型</li>
<li>native<br>根据底层数据库对自动生成表示符的能力来选择 identity、sequence、hilo 三种生成器中的一种，适合跨数据库平台开发。适用于代理主键。 主键类型一般是数值型</li>
<li><strong>uuid</strong><br>基于128 位(bit)唯一值算法，根据当前 IP，时间，jvm 启动时间，内部自增量产生等多个参数生成 16 进制数值（编码后以长度为 32 的字符串表示）作为主键，注意类型是字符串哦</li>
<li>assigned<br>使用这种方法，主键要提前设置，就是交给用户自己定义，可以是数值型或者字符串</li>
<li><strong>foreign</strong><br>使用另外一个相关联的对象的主键作为该对象主键。<strong>主要用于一对一关系中。</strong><br>或者说是用其他表的主键来决定自己的 id</li>
<li>hilo<br>高低位算法生成，类型为数值型，生成方法不依赖数据库，所以适用于全部数据库，但是需要新建表并且在配置文件配置，不太常用</li>
</ul>
<p>Oracle：数值型的话，可以使用 sequence；如果是字符串类型使用 uuid 或者 assigned<br>MySQL：数值型的话，可以使用 increment ；字符串类型使用 uuid 或者 assigned<br>SQL Server：数值型的话，可以使用 identity 或者 native；字符串类型使用 uuid 或者 assigned</p>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>都知道从 JAVA5.0 之后，可以利用注解来简化配置，所以自然可以用在 Hibernate 上，可以不再写 hbm 文件了，但是 cfg 文件还是要写的…<br>其实大部分实体对象都是用工具生成的，我感觉看懂就行了，并且现在多是用 JPA 的注解了，它们基本是一致的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>　<span class="comment">//如果我们当前这个bean要设置成实体对象，就需要加上Entity这个注解</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"t_user"</span>)　<span class="comment">//设置数据库的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date registerDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//　Column中的name属性对应了数据库的该字段名字，里面还有其他属性，例如length，nullable等等</span></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"register_date"</span>)　</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getRegisterDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registerDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegisterDate</span><span class="params">(Date registerDate)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registerDate = registerDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义为数据库的主键ID</span></span><br><span class="line">    <span class="comment">// 建议不要在属性上引入注解，因为属性是private的，如果引入注解会破坏其封装特性，所以建议在getter方法上加入注解</span></span><br><span class="line">    <span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue</span>　<span class="comment">//ID的生成策略为自动生成　　</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> 　　............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用了注解就不需要写映射文件了，但是需要让 hibernate 知道这是一个实体，所以还要在 cfg 配置文件中这样写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于annotation的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.xiaoluo.bean.User"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于hbm.xml配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/xiaoluo/bean/User.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然这是最简单的，后面还有更多的对应关系的注解，移步这里吧：<a href="http://www.cnblogs.com/xiaoluo501395377/p/3374955.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaoluo501395377/p/3374955.html</a></p>
<h2 id="关于连接池"><a href="#关于连接池" class="headerlink" title="关于连接池"></a>关于连接池</h2><p>Hibernate 有自带的连接池，也支持第三方的连接池，推荐使用 C3P0，无论使用那个，记得导包（hibernate 中就有）<br>默认情况下（<strong>即没有配置连接池的情况下</strong>），Hibernate 会采用内建的连接池。但这个连接池性能不佳，且存在诸多 BUG，因此官方也只是建议仅在开发环境下使用。<br>比如配置 C3P0 连接池，除了必须的数据库连接信息，只需要在 cfg 配置文件中添加一小部分配置信息即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC  </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  </span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">&lt;!-- 配置c3p0连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.provider_class"</span>&gt;</span>org.hibernate.connection.C3P0ConnectionProvider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在连接池中可用数据库连接的最小数目--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.min_size"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在连接池中所有数据库连接的最大数目--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_size"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定数据库连接的超时时间--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.time_out"</span>&gt;</span>1800<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以被缓存的PreparedStatement的最大数目--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"c3p0.max_statement"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"domain/Customer.hbm.xml"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面说的那个是连接池的最大连接数目，不要当成是连接的最大数目，如果不知道怎么配可以从 hibernate 的 project/etc 目录下的 <strong>hibernate.properties</strong> 文件中抄<br>记得一定要配置 provider_class ，这一句用于指定 Hibernate 的连接提供方式，如果没有将不会使用 c3p0 作为 Hibernate 的连接池。那么如何知道连接池是否生效了呢，比如可以在 MySQL 中使用 <code>SHOW PROCESSLIST</code> 来查看活跃的连接数。<br>或者可以尝试下评价比较高的 Proxool 连接池，对于它，配置可能会有些复杂，还需要配置单独的 proxool.xml 文件，这里不多说了，或者看看阿里的 druid ？</p>
<hr>
<p>另外还有一种比较特殊的，就是使用 Tomcat 自带的（JNDI），这种用法应该比较少见，关于自带连接池的配置我在 <a href="https://bfchengnuo.com/2017/05/04/JDBC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0/">这篇文章</a> 说过了，配置好了在 cfg 文件中加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.datasource"</span>&gt;</span></span><br><span class="line">java:comp/env/jdbc/name</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span></span><br><span class="line">com.huatech.sysframe.webapp.common.dao.hibernate.dialet.BaseInformixDialect</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.generate_statistics"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>jdbc/name</strong> 就是你配置的数据源（连接池）的名字，后面其实还有 Spring 中配置的方式，这个下次再说吧，可以看看参考的最后一个连接，挺全的</p>
<h2 id="关于映射文件"><a href="#关于映射文件" class="headerlink" title="关于映射文件"></a>关于映射文件</h2><p>hbm 映射文件我感觉大部分都是自动生成的，因为我们多数还是习惯于先设计数据库，hbm 配置文件也很少见了，大多都使用 JPA 的注解了；<del>所以我就没写这方面的</del></p>
<p>但还是要提一点，在一对多或者多对一等这种遇到使用集合的时候，我们有四种选择：数组、Set、List、Map；配置文件中也有对应的标签（在一对多对象引用时选择 one-to-many 标签）。<br>数组和 List 差不多，都是要保证顺序，所以在配置的时候需要指定一个 index 额外字段来标识顺序，它们的区别也就是可变于不可变的差别；<br>Set 应该是最常用的，它不需要保证顺序，所以不需要额外的字段，配置比较简单，只需要配置个外键字段和相应的列（对象）即可；<br>Map 虽然没顺序，但是需要配置一个 key，这个 key 也会存在于数据库的表中。</p>
<blockquote>
<p>  但是，一般不会在配置文件中进行配置这些集合，而是只维护多的一方（一对多、多对一）；因为如果多的一方很多，在查询“一” 的一方时会大量的消耗资源来查询多的对象，并且还不一定用得到</p>
</blockquote>
<hr>
<p>inverse，可翻译为控制反转，就是说把控制器交出去了<br>设置位 false 代表有控制器；设置位 true 说明交出了控制权<br>所谓的控制权就是维护关系（外键）的权利了，比如只能在一对多的一的一方设置，如果设置了为 true ，那么它就没有权利更新外键了（数据都是保存的，只是它内部的集合中的实体不会保存引用了）<br>此属性对获取数据没有影响</p>
<hr>
<p>关于组合与继承映射<br>组合简单说就是一个类中包含有另一个类，映射到数据库中对应的是一张表；继承就继承了…..额<br>组合使用 component 标签，name 属性为组合类类型的属性名，使用子标签 property 指定到底是组合了那些属性</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/sinlff/article/details/7342527" target="_blank" rel="noopener">http://blog.csdn.net/sinlff/article/details/7342527</a><br><a href="http://tracylihui.github.io/2015/07/20/Hibernate%EF%BC%9A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">缓存机制学习</a><br><a href="http://www.imooc.com/article/17686" target="_blank" rel="noopener">注解大全</a><br><a href="http://www.cnblogs.com/oumyye/p/4442764.html" target="_blank" rel="noopener">http://www.cnblogs.com/oumyye/p/4442764.html</a><br><a href="https://teakki.com/p/57df75a21201d4c1629b86c1" target="_blank" rel="noopener">https://teakki.com/p/57df75a21201d4c1629b86c1</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/07/01/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>SSH 框架系列笔记，看到第二个了，Struts 原来是最简单的，后面的 Hibernate 和 Spring 都很有道道呢，尤其是 Spring ，连接了 Struts 和 Hibernate，本来是想看 Spring 的，但是发现 Hibernate 是前提，于是…..学习 Hibernate 其实就是在学习怎么配 xml 文件，因为大部分都是通过配配置文件来实现的，所以说，官方文档很重要！英语很重要！ ╮(╯▽╰)╭<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hibernate 是一种 Java 语言下的<strong>对象关系映射（object relation mapping）解决方案，或者说框架</strong>。它是使用 GNU 宽通用公共许可证发行的自由、开源的软件。它为面向对象的领域模型到传统的关系型数据库的映射，提供了一个使用方便的框架。<br>它的设计目标是将软件开发人员从大量相同的<strong>数据持久层相关编程工作中解放出来</strong>。无论是从设计草案还是从一个遗留数据库开始，开发人员都可以采用 Hibernate。<br>Hibernate 不仅负责从 Java 类到数据库表的映射（还包括从 Java 数据类型到 SQL 数据类型的映射），还提供了面向对象的数据查询检索机制，<strong>从而极大地缩短的手动处理 SQL 和 JDBC 上的开发时间。</strong></p>
<p>数据持久化…简单说就是把数据（比如对象）保存起来，保存到文件也好数据库也好，都是持久化的体现，也许你会想到序列化，它们两个很相似，但是是两个完全不同的应用场景，持久持久，久….序列化多是为了能将对象更好的交换、传输（比如从这个线程到那个线程）</p>
<h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><p>Hibernate 一般有三种开发方式：</p>
<ol>
<li>由 Domain object –&gt; Mapping –&gt; db ；这是官方推荐的方式<br>Domain 对象设计好了，Mapping 配置好了可以直接自动生成数据表</li>
<li>由 DB 开始，然后用工具生成 Domain object 和 Mapping，这种方式用的比较多<br>同样，数据库设计好了，也有相关的工具可以自动生成 Domain 对象和映射文件</li>
<li>由映射文件开始</li>
</ol>
<p>然后具体解释下，Domain object 其实指的就是 javabean，也叫做 Domain 对象；Mapping 是映射文件；db 就是数据库了<br>它们的关系是：每一个 Domain 对象对应数据库中的一张表，每一个实例化的 Domain 对象就是数据库中对应表中的一条数据，将 Domain 对象和数据库联系起来的是数据持久层，它依赖于ORM-<strong>对象</strong>关系映射文件（Mapping）；该文件会说明表和对象的关系，以及对象的属性和表字段的对应关系<br>对象关系映射嘛，使用了 Hibernate 基本都是操作对象了…..</p>
<p>Mapping 映射文件在命名上有一定规范：<code>对象名.hbm.xml</code> 一般放在 Javabean/Domain 对象目录（包）下，原理也都知道，就是反射，反射必须依赖于这个配置文件</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>Javabean 对象和数据库就跳过了，这个很简单没啥可说的，导入相关 jar 包也不说了，关键就剩下那个 Mapping 映射文件了，当然这个完全可以自动生成，实际开发没必要手写，我第一次就手写吧</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.bfchengnuo.domain"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 Javabean 对应那张表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id 是指定主键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定主键值的生成策略，用于主键的自增长，一般有7种方式，mysql用下面的这个就行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--其他属性的映射--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">not-null</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">not-null</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hiredate"</span> <span class="attr">type</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"hiredate"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于主键的策略，想深入的可移步：<a href="http://www.cnblogs.com/kakafra/archive/2012/09/16/2687569.html" target="_blank" rel="noopener">http://www.cnblogs.com/kakafra/archive/2012/09/16/2687569.html</a><br>上面设置的 type 除了设置 Java 类型，还可以设置 Hibernate 类型，不过一般习惯于 Java 类型</p>
<p>除了配置映射文件，还有一个重要的配置文件 <strong>hinernate.cfg.xml</strong> ，它用来配置数据库的类型、驱动、用户名、密码、URL 、连接池等信息；放在工程目录的根目录下，就是 Src 下，前面说的 Struts 也是<br>hinernate.cfg.xml 它同时还负责管理 Mapping 映射文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>******<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernatetest?useUnicode=true&amp;amp;characterEncoding=UTF-8 <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置方言,让 Hibernate 明确使用的是那种数据库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--显示 sql 语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--要管理的映射文件，放在最后--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/bfchengnuo/domain/User.hbm.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样操作数据库就不需要再使用 JDBC 相关的对象了，都已经被封装了；现在我们操作数据库使用的是 Hibernate 给提供的一些类和接口，最常用的有 Configuration、SessionFactory、Session、Transaction；除了第一个是类其他全是接口<br>使用的时候注意别导错包了，是 <code>org.hibernate</code> 下的包！！！<br>下面举个简单的栗子，使用步骤就那么几步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Configuration，用来读取配置文件，并完成初始化</span></span><br><span class="line">    <span class="comment">// 如果文件名没按照规范，可以手动指定</span></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 SessionFactory 会话工厂，重量级，耗资源，最好要保证只有一个</span></span><br><span class="line">    SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建会话（Session），相当于 JDBC 中的 connection</span></span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 开启事务，对 Hibernate 而言，要求程序猿在进行 增删改 的时候使用事务</span></span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一条数据</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"佳芷"</span>);</span><br><span class="line">    user.setAge(<span class="number">12</span>);</span><br><span class="line">    user.setEmail(<span class="string">"loli@163.com"</span>);</span><br><span class="line">    user.setHiredate(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    session.save(user);</span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这四步走，要注意的就是进行增删改一定记得使用事务，否则不会生效，最后操作完了记得关闭连接（session）<br>如果不想用一个单独的变量来保存事务可以直接从 session 中获得，因为它们是绑定在一起的：<code>session.getTransaction().commit();</code></p>
<p>按照规范，所定义的 Javabean 需要进行序列化以便可以唯一的标识该对象，并且可以进行传输</p>
<h2 id="核心类和接口"><a href="#核心类和接口" class="headerlink" title="核心类和接口"></a>核心类和接口</h2><p>上面提到过的，一个类和三个接口，此外还有一个非常重要的接口 Query ，非常强大</p>
<h3 id="Configuration类"><a href="#Configuration类" class="headerlink" title="Configuration类"></a>Configuration类</h3><p>这是唯一的一个类了，它的作用就是读取（加载）配置文件的，当然也包括映射文件，加载一些驱动啥的<br>这个类还是很简单的，就不多说了</p>
<h3 id="SessionFactory接口"><a href="#SessionFactory接口" class="headerlink" title="SessionFactory接口"></a>SessionFactory接口</h3><p>它的一些特点：</p>
<ul>
<li>缓存 SQL 语句和某些数据（一级缓存，又叫 Session 缓存）</li>
<li>在程序初始化的时候创建，因为特别吃资源，一般采用单例模式保证一个应用中只有一个</li>
<li>如果一个应用要使用多个数据库，那么可以一个数据库对应一个 SessionFactory</li>
</ul>
<p>通过 SessionFactory 获取 Session 实例有两个方法， <code>openSession()</code> 和 <code>getCurentSession()</code><br>openSession 获取的是一个全新的 Session<br>getCurentSession 获取和当前线程绑定的 Session，利于事务的控制，可以猜出，第一次调用的时候其实也是调用的 openSession 方法，只不过会做一些处理</p>
<blockquote>
<p>  如果要使用 getCurentSession 的方式获得 Session，需要事先在 cfg 配置文件中配置<br>  <code>&lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;</code><br>  使用 getCurentSession 创建的 Session，在 commit 或者 rollback 后会自动关闭，但是最好还是手动关一下<br>  使用 openSession 查询数据不需要使用事务，但是如果使用的是 getCurentSession 查询也需要开事务</p>
</blockquote>
<p>事务通常有两种，本地事务和全局事务<br>本地事务：针对一个数据库的事务（比如上面所配的 thread）<br>全局事务：跨数据库的事务（可以配 jta）<br>简单说说全局事务的实现，其实就是利用了一个 List ，每次执行数据库操作都会进行检测，如果发现里面含有未完成事务（会有一个标识），无论是那个数据库的事务没有成功都会进行回滚，这样就达到了全局事务的功能，不过一般都是在 web服务器中进行配置</p>
<h3 id="Session接口"><a href="#Session接口" class="headerlink" title="Session接口"></a>Session接口</h3><p>看过 SessionFactory 再看 Session 就简单了，就是用来操作数据库的，和 JDBC 中的 connection，进行 CRUD 操作<br>Session 可以看作是持久化管理器，它是与持久化操作相关的接口</p>
<ul>
<li>删除一个对象（记录）：delete 方法</li>
<li>查询一个对象（记录）：get/load 方法<br>说说这两个方法的区别：<br>get 方法：直接返回实体类，<strong>如果查不到数据就返回 Null</strong><br>get 先到缓存（Session 缓存/二级缓存）去查找，如果没找到就<strong>立即</strong>向 DB 发送 SQL 去查<br>​<br>load 方法：会返回一个<strong>实体代理对象</strong> ，可以自动转换成实体对象；但当代理对象被调用的时候，<strong>如果数据不存在就会抛异常</strong><br>load 也先到缓存（Session 缓存/二级缓存）去查找，如果没有就返回一个代理对象，等后面<strong>使用到这个代理对象的时候再去 DB 查</strong>，所以是支持<strong>延迟加载</strong>的（lazy）<br><strong>所以，如果你能确定数据库中有这个对象就用 load ，否则就用 get，这样效率高</strong><br>通过修改配置文件可以取消延迟加载（懒加载）在 class 标签里设属性 lazy</li>
<li>修改一个对象（记录）：update 方法</li>
<li>保存一个对象（记录）：save 方法</li>
</ul>
<h3 id="Query接口"><a href="#Query接口" class="headerlink" title="Query接口"></a>Query接口</h3><p>查询简单的可以使用 get/load 方法，如果需要复杂的查询，就要用 Query 这个接口了<br>先简单说下 hql 语言，是用来操作数据库的，不用担心数据库的类型，会进行自动转换，所以，只需要会写 hql 大部分操作就可以搞定了，多使用在业务逻辑层<br>下面是一个简单的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtil.openSession();</span><br><span class="line"><span class="comment">// 获取 Query 引用，使用 hql 语句， User 是实体类名不是表名，id 是属性不是字段</span></span><br><span class="line"><span class="comment">// id 位置也可以使用字段名，但是推荐使用属性</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"from User where id=1"</span>);</span><br><span class="line"><span class="comment">// 可以使用泛型，会被自动封装</span></span><br><span class="line">List&lt;User&gt; list = query.list();</span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(user.getName() + <span class="string">"---"</span> + user.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展下，除了 Query 还有一个用于查询的是 Criteria，它是纯面向对象的，但是并不常用，不多说，还有一种叫本地化 SQL 查询，说白了就是使用原生的 SQL 语句（返回的也是每一行的记录数组，可以使用 addEntity 方法来注入到对象中），也是不推荐使用，因为和数据库耦合了，除非是非常复杂的 SQL 语句，HQL 无法胜任的时候使用</p>
<p><code>query.executeUpdate()</code> 可以执行更新、删除操作</p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>使用 Query 可以很简单的达到分页查询的效果，类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一条开始取，取 2 条，索引从 0 开始哦（MySQL 中使用的就是 limit）</span></span><br><span class="line">session.createQuery(<span class="string">"from User"</span>).setFirstResult(<span class="number">0</span>).setMaxResult(<span class="number">2</span>).list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取总记录数</span></span><br><span class="line">ScrollableResults scroll = q.scroll();  <span class="comment">// 得到滚动的结果集</span></span><br><span class="line">scroll.last();  <span class="comment">// 滚动到最后一行</span></span><br><span class="line"><span class="keyword">int</span> totalCount = scroll.getRowNumber() + <span class="number">1</span>;  <span class="comment">// 得到滚动的记录数，即总记录数</span></span><br></pre></td></tr></table></figure>
<h2 id="HQL语句"><a href="#HQL语句" class="headerlink" title="HQL语句"></a>HQL语句</h2><p>HQL（Hibernate Query Language）官方推荐使用的，功能强大<br>首先补充知识：<br>在设计数据表的时候，尽量保证每一张表都有一个主键，有利于对象的标识；如果表有主外键联系，先搞主表<br>关于主从表的设计，前面说过，简洁表示就是：从表依赖于主表（一般在从表建立外键，依赖主表的主键），从表对象直接引用从表对象，主表使用 set 集合引用从表，因为主表可能对应多个从表<br>HQL 语句的形式类似是：<code>Select/update/delete…… from …… where …… group by …… having …… order by …… asc/desc</code> 这样；另外就是 <strong>HQL 语句是区分大小写的</strong>，毕竟是面向对象的<br>和传统 SQL 不同，<strong>使用 Hibernate 的时候，建议是把表中的所有数据都查回来</strong></p>
<p>使用 <strong>uniqueResult</strong> 默认只查一条，也就是说找到一条就不会再找了，提高效率：<code>session.createQuery(&quot;...&quot;).uniqueResult()</code> ；返回的也就是单个对象而不是 List 了</p>
<p>大部分语句和 SQL 还是很相似的，举几个常用的：<br><code>from User</code><br><code>distinct from User</code><br><code>delete Person as p where p.id=?</code><br><code>from User where age between 12 and 16</code> // 范围查询<br><code>from User where age in (12,13,14)</code> ；in /not in<br><code>select avg(age),name from User group by name</code><br><code>from Lolicon where loli.age=16</code> // 因为 HQL 是代指的对象，可以直接用 <code>.</code> 来调用，前面的语句条件就是 Lolicon 对象里引用的 loli 对象的 age 属性</p>
<p>如果是部分查询的话，就是不查所有字段，那么 Hibernate 不会给你封装成 Bean 对象的，返回的 List 是一个 Object[] 的 List；获取数据需要先通过 <code>list.get(index)</code> 获取 Object 数组，然后再从数组里取出值</p>
<blockquote>
<p>  特别注意：如果查询返回的数据只有<strong>一列</strong> ，那么 List 中存的就不是 Object 数组了，是单个的 Object 对象<br>  因为只有一列，List 中存的每一个对象表示一行数据，既然只有一列就不需要数组了</p>
<p>  查询外的语句（增删改）需要使用 <strong>executeUpdate</strong> 方法才行</p>
</blockquote>
<p>Hibernate 还支持把 HQL 语句配置到 xml 文件（一般是 hbm 配置文件）中去，使用 query 标签存储，获取的时候使用 getNamedQuery 方法获取，这样可以在不修改源码的情况下更改查询语句，实际中用的并不多</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>在 JDBC 中都用过，使用参数绑定有三个很大的好处，1.可读性强 ；2.效率高 ；3.防止 SQL 注入</p>
<p>参数绑定可分为两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数绑定 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parameterBind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">// :xxx 形式，xxx 是自定义的，一般和前面保持一致</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from User where id=:id"</span>)</span><br><span class="line">            .setParameter(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// query.executeUpdate();  执行更新、删除操作</span></span><br><span class="line">    <span class="comment">// 可以使用泛型，会被自动封装</span></span><br><span class="line">    List&lt;User&gt; list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user.getName() + <span class="string">"---"</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数绑定 2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parameterBind2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtil.openSession();</span><br><span class="line">    <span class="comment">// 和 JDBC 中保存一致，使用 ？ 占位符</span></span><br><span class="line">    Query query = session.createQuery(<span class="string">"from User where id=?"</span>)</span><br><span class="line">            .setParameter(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 可以使用泛型，会被自动封装</span></span><br><span class="line">    List&lt;User&gt; list = query.list();</span><br><span class="line">    <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(user.getName() + <span class="string">"---"</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说就是 <code>:key</code> 和 <code>?</code> 的区别，第一个设置参数只能使用 key，第二个只能使用索引</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>内连接：如果使用的对象中已经引用了其他对象（通过映射文件可以确定其表）是可以直接用的：<code>from User u inner join u.boss</code><br>左外连接和右外连接也是类似就不说了，左外连接就是始终显示左表的数据（Null 不会被过滤）</p>
<hr>
<p>其他的，还有就是<strong>迫切内连接</strong> ；他会把右表的数据填充到左表中去，使用 fetch 关键字：<code>from User u inner join fetch u.boss</code><br>迫切左外连接和右外连接也是类似，记住 <strong>右表填充到左表</strong> 就行了</p>
<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>关于 HQL 还有些神奇的用法，比如可以这样用：<br><code>select new User(user.name,user.age) from User user</code><br>但是这里有一个问题必须注意，那就是这时所返回的 User 对象，仅仅只是一个普通的 Java 对象而以，除了查询结果值之外，其它的属性值都为 null（包括主键值id），也就是说不能通过 Session 对象对此对象执行持久化的更新操作，并且需要有相应的构造函数</p>
<p><del>其实没必要这么麻烦</del><br>更多关于 HQL 的内容参见：<a href="http://www.hongyanliren.com/1901.html" target="_blank" rel="noopener">http://www.hongyanliren.com/1901.html</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Hibernate 使用到的缓存也就两级，Session 缓存也被称为是一级缓存，存在内存里<br>除此外还有个二级缓存，存放于内存和硬盘之间</p>
<p>使用 load 查询只是在缓存里查，等使用的时候才去 DB 里找，并且会返回一份存在二级缓存中，如果再进行反复查询，到达一定频率后会被转移到一级缓存中去</p>
<p>关于二级缓存，可以在配置文件中配置是否开启，使用缓存能减少对数据库的访问次数</p>
<h2 id="对象状态"><a href="#对象状态" class="headerlink" title="对象状态"></a>对象状态</h2><p>Hibernate 中的对象分为三种状态：</p>
<ul>
<li>瞬时（transient）<br>数据库中<strong>没有数据与之对应</strong>，超过作用域会被 JVM 回收；一般是 new 出来的，并且与 Session 没有关联的对象</li>
<li>持久（Persistent）<br>数据库中<strong>有数据与之对应</strong>，<strong>与 Session 有关联</strong>，并且相关联的 Session 没有关闭，事务没有提交<br>持久状态对象发生变化，在事务提交时会影响数据库中的数据（Hibernate 会自动检测到）</li>
<li>脱管/游离（detached）<br>数据库中<strong>有数据与之对应</strong>，但是当前<strong>没有 Session 与之关联</strong>；当对象发生变化时，Hibernate 并不能检测到</li>
</ul>
<p>比如，现在创建了一个 Domain 对象，那么就是处于瞬时状态，随时有可能消失；<br>当调用了 Session 的 save 方法后，就变成了持久态，这时数据库已经有一些数据了；也就是说 save 以后还是可以更改数据的，最后事务提交的时候还是会反映到数据库中<br>当调用了 commit、close 方法后就变成了游离态（commit 后一般会自动关闭连接），当数据改变后必须进行 update 才能反映到数据库中去</p>
<p>和线程的几种状态比较类似，可运行啊、阻塞啊</p>
<p><img src="/image/dev/对象状态.png" alt="对象状态.png"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h3><p>前面说的 Javabean 也好、Domain对象也好都是一个东西，它其实还有个名字叫 pojo<br>不过它比较特殊，它在 bean 的基础上有几个要求，我可能重复了一些：</p>
<ol>
<li>和一张表对应</li>
<li>需要一个主键属性，用来标识一个 pojo 对象</li>
<li>除了主键属性，还有其他的属性</li>
<li>有一个空的构造方法</li>
</ol>
<h3 id="连接-会话"><a href="#连接-会话" class="headerlink" title="连接/会话"></a>连接/会话</h3><p>如何判断目前开了几个数据库连接，可以看看进程，查查数据库端口的进程有几个，比如在 win 或者 linux 都可以使用命令：<code>netstat -an</code> 来判断</p>
<h3 id="关于表设计"><a href="#关于表设计" class="headerlink" title="关于表设计"></a>关于表设计</h3><p>这个我记得在前面是说过的，尤其注意下多对多的情况，实际中<br>如果出现了多对多的情况，通常都会转换成两个一对多或者多对一的情况，也就是往两张表中间再加一个映射表，其实就是数据库设置中的那三范式；在 Hibernate 的 hbm 配置文件中可以看到相关的配置</p>
<p>多对一(或者一对多)和一对一的主要区别就是一对一的外键多了个唯一约束，并且外键列还多用于设置为主键（基于主键）</p>
<h3 id="自动建表"><a href="#自动建表" class="headerlink" title="自动建表"></a>自动建表</h3><p>开始提到的有种开发方式是先建立 Domain 对象，然后 Hibernate 会自动帮你建表，这个需要在 cfg 配置文件中进行配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>create ：每次加载配置文件都会创建，如果存在就会先删除，然后重新创建</li>
<li>update ：如果表不存在就会创建；如果表存在，并且表结构没变化就保留，如果表结构有变化就更新</li>
<li>create-drop ：在<strong>显式</strong>关闭 SessionFactory 的时候会把表给删除，用的很少</li>
<li>validate ：每次在插入数据之前都会检查表结构是否一致，用的很少</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL报Invalid default value错误]]></title>
      <url>http://bfchengnuo.com/2017/06/26/MySQL%E6%8A%A5Invalid-default-value%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<p>今天在还原数据库的时候给我抛了这样一个错误：</p>
<blockquote>
<p>  Invalid default value for ‘upload_time’</p>
</blockquote>
<p>因为我是用 Navicat Premium 进行还原的，在我同学的 PC 上用 Navicat for MySQL 进行还原是可以的，所以我以为是版本的问题，后来换了 Navicat for MySQL 依然无果<a id="more"></a></p>
<p>还搜到了一堆说<strong>将 DATETIME 改为 TIMESTAMP</strong>；对于我来说这就是误导….</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>最终发现是 MySQL 版本的问题，我所用的版本太高了，备份文件是在低版本中备份的，在高版本中（从 5.6.17 这个版本开始）就默认设置了<strong>不允许插入 0 日期了</strong>；<br>术语是 <code>NO_ZERO_IN_DATE</code> 、 <code>NO_ZERO_DATE</code></p>
<p>可以在 MySQL 的命令行中使用下面的命令进行查询：<br><code>SHOW VARIABLES LIKE &#39;sql_mode&#39;;</code><br>看看有木有 ：<strong>NO_ZERO_IN_DATE</strong>、<strong>NO_ZERO_DATE</strong> 这两个参数，这两个参数限制不能为 0</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>这是我采用的，实测有效！<br>在命令行或者 Navicat 下新建查询(必须是在 mysql 数据库下)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这就是临时取消全部了…然后再执行还原备份操作就 OK 了</p>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>在 MySQL 的配置文件中的 <strong>[mysqld]</strong> 下面添加如下列：<br><code>sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</code></p>
<p>这样就永久生效了<br>不过此方法我未测试，因为我也就是临时改改</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/myboyliu2007/article/details/50583088" target="_blank" rel="noopener">http://blog.csdn.net/myboyliu2007/article/details/50583088</a><br><a href="http://www.youyong.top/article/1158cf96a49" target="_blank" rel="noopener">http://www.youyong.top/article/1158cf96a49</a></p>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2学习笔记(二)]]></title>
      <url>http://bfchengnuo.com/2017/06/16/Struts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>主要说了些拦截器相关的内容，还有大量的 OGNL 相关的东西，最后补充了个注解，不过看到有人说 sturt2 几乎现在很少用了，大多数公司都用 springMVC ，还得抓紧时间继续学呐<a id="more"></a><br>还有一个模型驱动拦截器放在了<a href="https://bfchengnuo.com/2017/06/07/Struts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">笔记一</a>中，因为这篇已经太长了….</p>
<h2 id="注入对象"><a href="#注入对象" class="headerlink" title="注入对象"></a>注入对象</h2><p>Action 既然只是普通的一个 java 类，如果想要获得 request 等内的数据应该怎么做的，这时候就用到反射技术来注入对象了；具体的注入实现是 <strong>ServletConfigInterceptor</strong> 这个拦截器，支持注入那些对象可以进这个的源码看看，就是一连串的 if<br>Action 中注入对象只需要实现特定的接口即可：<br>实现 RequestAware 接口注入 request 中的 map 集合，大多数都是用的这个吧<br>实现 ServletRequestAware 注入 request 对象<br>实现 ApplicationAware 注入 Application 对象<br>实现 ServletContextAware 注入 ServletContext 对象<br>另外还有 session 的，等等….</p>
<p>那么什么时候用注入对象的方式呢，ActionContext 和 ServletActionContext 都不能在构造器中初始化，因为拦截器是在实例化 Action 之后执行的，如果用的很频繁每个方法都来一遍太 low 了，于是可以使用这种注入的方式保存成全局变量<br>在后期优化的时候对 BestAction 进行注入也是不错的选择</p>
<h2 id="Token拦截器"><a href="#Token拦截器" class="headerlink" title="Token拦截器"></a>Token拦截器</h2><p>在表单防止重复提交中，这个是必用的吧；一般会用到两个域：一个是 page ，一个是 session，对应客户端和服务端吧<br>相比 Struts1 在 Struts2 中使用更加的简单：<br>首先在 JSP 页面添加 Token 标签，它会在被访问的时候创建令牌，是在 form 里面哦，另外最后也加个显示错误的标签，因为抛的错误是 Action 错误，所以…</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:debug</span> /&gt;</span></span><br><span class="line">    这是一个测试页面 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--显示</span> <span class="attr">Token</span> 认证错误信息<span class="attr">--</span>%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:actionerror</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:form</span> <span class="attr">namespace</span>=<span class="string">"/reg"</span> <span class="attr">action</span>=<span class="string">"TokenAction_reg"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:token</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">label</span>=<span class="string">"用户名"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:submit</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">s:form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其次配置 Action 的时候需要指定下栈排除一些不需要校验的方法，然后添加个校验失败跳转的页面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"TokenAction_*"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.TokenAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/reg/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"regView"</span>&gt;</span>/reg/tokenReg.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定 Token 验证失败后怎么办--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"invalid.token"</span>&gt;</span>/reg/tokenReg.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定拦截器栈，这样会覆盖默认栈，所以需要手动再添加一次--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"token"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"excludeMethods"</span>&gt;</span>toReg<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>嗯….基本就是这样了，另外；如果想要替换错误信息为中文，可以在当前目录建立 Action 相关文件，修改 <code>struts.messages.invalid.token</code> 为你想要的值即可</p>
<blockquote>
<p>  看网上的帖子说还需要在 struts.xml 中修改 struts.custom.i18n.resources 常量；但是我测试不用修改也完全有效，版本好像是 2.3</p>
</blockquote>
<h2 id="execAndWait拦截器"><a href="#execAndWait拦截器" class="headerlink" title="execAndWait拦截器"></a>execAndWait拦截器</h2><p>常叫做为<strong>执行等待拦截器</strong>，从名字也可以看出了，就是在执行耗时操作的时候跳转到一个预设的界面，等耗时操作结束后再跳回；这个过程是个伪异步，因为在等待页面是通过定义 meta 的方式进行定时刷新检测的，下面来简单的模拟下，首先是 Action ，非常简单就是让线程休眠下…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是配套的配置文件了，execAndWait 是不在默认栈里的，以及需要配一个等待页面 wait：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"WaitAction"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.WaitAction"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/reg/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"wait"</span>&gt;</span>/wait.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行等待拦截器不在默认栈中，一般添加到最后就行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"execAndWait"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那个等待页面和成功页面就不写了，就是很简单的一句话而已，这样就能看出效果了</p>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>搞一个简单的拦截器测试看看，自定义的拦截器要实现 Interceptor 接口，注意导包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用来反序列化的，写不写无所谓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5175604343895716587L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object action = actionInvocation.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action <span class="keyword">instanceof</span> LoginAction) &#123;</span><br><span class="line">            <span class="comment">// 直接放行</span></span><br><span class="line">            <span class="keyword">return</span> actionInvocation.invoke();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; sessionMap = actionInvocation.getInvocationContext().getSession();</span><br><span class="line">        <span class="keyword">if</span> (sessionMap.get(<span class="string">"username"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有登陆，跳转到登陆</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> actionInvocation.invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看以看出，逻辑非常简单，判断是否是 LoginAction 如果是就直接放行了，如果不是就判断 session 是否存有用户信息，没有就跳转到登陆界面上去，但是总感觉这样写不是很优雅呢……嘛~先这样吧<br>优雅一点的可以通过 ActionInvocation 对象获取 Action 的代理对象（<code>ac.getProxy()</code>），然后通过代理对象可以拿到当前执行 Action 的方法名等信息，然后进行相应的拦截<br>拦截器的 init 方法是在服务器启动的时候就会执行的（过滤器也是如此），并且一般只执行一次，而 intercept 方法会执行多次；<strong>如果你不需要初始化或清理代码，可以继承自扩展的 AbstractInterceptor 类，它提供了一个对 init() 和 destroy() 方法的默认的无操作实现。</strong><br>接下来是测试 Action 了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">SessionAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9178854276859257157L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 实现了 SessionAware 接口，以此来获得 session 中的 map</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; sessionMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSession</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        sessionMap = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单模拟，只要用户名对就通过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            sessionMap.put(<span class="string">"username"</span>, name);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LOGIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"toLoginView"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之相关的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"Login"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/login"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置自定义拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注册拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"loginInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.interceptor.LoginInterceptor"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置自定义拦截器栈--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">"loginStack"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"loginInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可以定义默认的栈（所有的 Action 都执行这个默认的栈）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">"loginStack"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义全局的返回结果--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;global-results&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;result name="login"&gt;/login.jsp&lt;/result&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/global-results&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"Login_*"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.interceptor.LoginAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span>&gt;</span>/reg/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"toLoginView"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>嗯….这样应该就差不多了吧….<br>需要注意的是：配置自定义拦截器（interceptors）要放在 package 中的最前面，如果使用 <strong>default-interceptor-ref</strong> 那么所有的 Action 都会执行其中定义的栈，如果只需要特定的 Action 执行自定义的栈，可以在相应的 Action 中进行配置，这样其他的 Action 就还是执行默认的栈。<!-- 自定义的拦截器栈中默认的（defaultStack）要放在最下面，因为默认的拦截器执行后并不会再放行的 --></p>
<h2 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h2><p>OGNL 也是一个开源的项目，Struts2 融合了 OGNL 并且将它作为默认的表达式语言，它必须依赖于 Struts 的标签才能使用<br>OGNL 由表达式语言和类型转换器组成，就是为了方便数据的访问；总体来说和 EL 表达式是很像的，并且兼容 EL 表达式，大多数表达式不需要进行转义，如果用到了使用 <code>%{xxx}</code> 进行转义，也叫做强制表达式解析（在不自动进行 OGNL 解析的地方强制解析），多用于非 String 对象<br>举个简单使用的栗子，首先是主要的 JSP 页面部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:form</span> <span class="attr">namespace</span>=<span class="string">"/ognl"</span> <span class="attr">action</span>=<span class="string">"OgnlAction"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"names[0]"</span> <span class="attr">label</span>=<span class="string">"names[0]"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"names[1]"</span> <span class="attr">label</span>=<span class="string">"names[1]"</span>/&gt;</span></span><br><span class="line">        &lt;%--&lt;s:textfield name="names" label="names"/&gt;--%&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"nameList[0].name"</span> <span class="attr">label</span>=<span class="string">"nameList-name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"nameList[0].age"</span> <span class="attr">label</span>=<span class="string">"nameList-age"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">label</span>=<span class="string">"user-conver"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">name</span>=<span class="string">"nameMap.key.name"</span> <span class="attr">label</span>=<span class="string">"Map-name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">s:submit</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">s:form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在测试的时候还掉进了一个坑，就上面所示： 如果直接写 names 默认会存一个值（数组大小也被置为1），<strong>但是不要 names 和 names[0] 同时出现</strong>，这样会被覆盖，当时就被坑了好久…..竟然犯这样的低级错误<br>数组、集合都可以和 EL 一样使用，属性链也 OK；当然 map 也是可以的：<br>map 的 key 如果是字符串可以直接用 <code>.</code> 连接：<code>map.key.name</code> ；否则就使用 <code>map[&#39;key&#39;].name</code> 这样的形式<br><strong>我是把把表单提交后的页面再指向回此 JSP ，这样数据会回显，以此来观察效果</strong></p>
<p>相关的 Action 没啥好说的，就是定义上面所述的属性，List、Map 可以不指定泛型，在 <code>OgnlAction-conversion.properties</code> Action 相关文件中指定，如果指定了泛型，那么就会自动进行转换的，转换并不只是八种基本类型，还要强大些，关于 conversion 文件，这是指定前台提交的数据如何进行转换的，毕竟前台提交的都是 String：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 指定 List 内装的是什么类型</span><br><span class="line">Element_nameList=com.bfchengnuo.domain.User</span><br><span class="line">Element_nameMap=com.bfchengnuo.domain.User</span><br><span class="line"></span><br><span class="line"># 还可以定义 Map 指定类型的 key</span><br><span class="line">#Key_nameMap=java.lang.Integer</span><br><span class="line"></span><br><span class="line"># 指定转换器</span><br><span class="line">user=com.bfchengnuo.ognl.UserConverter</span><br></pre></td></tr></table></figure>
<p>通过这个文件就可以确定前面表单中的 <code>nameList[0].name</code> 指的就是 List 中第一个 user 对象中的 name 属性；<br>表单中还有一个 name 叫 user 的，这个是我编写的一个简单的 javabean，正常来说需要这样写：<code>user.name</code> 才能正确的赋值，总不能把一个字符串赋值给一个 user 对象吧，如果硬要这样那就必须定义一个转换器了，就是上面 properties 文件指定的那个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConverter</span> <span class="keyword">extends</span> <span class="title">StrutsTypeConverter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符串转成对象，客户端提交时</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convertFromString</span><span class="params">(Map map, String[] strings, Class aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings != <span class="keyword">null</span> &amp;&amp; strings.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] ss = strings[<span class="number">0</span>].split(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ss.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setName(ss[<span class="number">0</span>]);</span><br><span class="line">                user.setAge(ss[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象转成对象，服务器返回时</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToString</span><span class="params">(Map map, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用自定义的 tostring 方法</span></span><br><span class="line">        <span class="keyword">return</span> o.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义转换器需要继承 StrutsTypeConverter ，复写两个方法，一个是用于客户端提交数据时转换，一个是服务器返回数据回显时转换；它和值栈挨着，提交数据时经过转换后存到值栈，回显数据时经过转换输出到客户端</p>
<blockquote>
<p>  对于转换器来说，每个 Action 都搞一个太累，可以在 src 根目录下定义 <code>xwork-conversion.property</code> 全局的类型转换器</p>
</blockquote>
<h3 id="OGNL中重要的3个符号"><a href="#OGNL中重要的3个符号" class="headerlink" title="OGNL中重要的3个符号"></a>OGNL中重要的3个符号</h3><p><code>#</code>、<code>%</code> 和 <code>$</code> 符号在 OGNL 表达式中经常出现，他们的意义嘛</p>
<ul>
<li><code>#</code><br>它的用途一般有三种，最常用的就是用来<strong>访问非根对象属性</strong> ，比如：<code>#session/#request/#application</code> 等；<code>#</code> 相当于 <code>ActionContext.getContext()</code> 默认会自动搜索各个域<br>第二种是用于过滤和投影（projecting）集合<br>第三种是用来构造集合，Map 和 List ：<code>#{key1:val1,key2:val2}/{1,2,3}</code></li>
<li><code>%</code><br>% 符号的用途是在标志的属性为字符串类型时（或者说值类型的标签中），计算 OGNL 表达式的值，相当于提供了一个 OGNL 的解析环境，就是所谓的强制（暴力）解析了；<br>如果本来默认解析 OGNL 的标签（对象类型标签）想让其单纯的输出值，就需要在双引号里加一层单引号</li>
<li><code>$</code><br>主要用途有两个：在国际化资源文件中，引用 OGNL 表达式；在 Struts2 配置文件中，引用 OGNL 表达式<br>比如在使用重定向时，传参只能通过 url；通过这个就可以获得 Action 中的数据</li>
</ul>
<h3 id="关于值栈"><a href="#关于值栈" class="headerlink" title="关于值栈"></a>关于值栈</h3><p>OGNL 和值栈有密切的关系，既然用户要获取一些必要的数据（JSP 中）那么怎么才能把 Action 中的数据传给用户呢，就是用的值栈<br>Action 创建的同时也会创建值栈以及 ActionContext，然后会把 Action 对象封装进值栈中（在根元素），通过 Request 传给用户（key 为 <strong>struts.ValueStak</strong>）；获取值栈可以通过 ActionContext，也可以通过 Request<br>值栈当中维护了一个 OgnlContext 对象（request、session 等对象的数据就存在这里，Action 对象在根元素），就是 OGNL 表达式所用的，其实是一个 Map<br>从上面可以看出，Action 是放进了值栈的根节点，那么 Action 中的属性也毫无疑问的放在了根节点，而 OGNL 表达式取根节点的值是不需要加 <code>#</code> 符号的，所以可以使用 <code># + 属性名</code> 直接取</p>
<h2 id="OGNL标签"><a href="#OGNL标签" class="headerlink" title="OGNL标签"></a>OGNL标签</h2><p>如同 JSTL ，OGNL 也自带了一些标签供使用；首先还要明确一点：<br>struts2 接收到请求后马上创建一个 ActionContext，一个 ValueStak 和一个 Action 对象；Action 对象立即放到值栈上便于 OGNL 的访问<br>顶层对象会覆盖底层对象，也就说从上往下找，<strong>找到了就不会继续往下了</strong><br>默认是从栈顶的对象里寻找，是栈顶对象！所以，一般是 Action 在栈顶；但是如果 user 对象在栈顶（前面所说的模型驱动），可以直接用其属性<br>OGNL 不仅可以访问 bean 的属性，还可以访问方法，但是不建议用</p>
<p>Struts2 的标签库都是使用 OGNL 表达式来访问 ActionContext 中的对象数据的；并且将 ActionContext 设置为 OGNL 上下文，默认的根对象为值栈</p>
<h3 id="s-property"><a href="#s-property" class="headerlink" title="s:property"></a>s:property</h3><p>首先是有关获取数据的几个标签，也就 ActionContext 中的六个“域”，我事先在 Action 初始化了一波数据，后面会用到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initData();</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 往各个域中存储数据</span></span><br><span class="line">    ServletActionContext.getRequest().setAttribute(<span class="string">"name"</span>,<span class="string">"request-name"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ServletActionContext.getRequest().getSession() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"session--Null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ServletActionContext.getRequest().getSession().setAttribute(<span class="string">"name"</span>,<span class="string">"session-name"</span>);</span><br><span class="line">    ServletActionContext.getServletContext().setAttribute(<span class="string">"name"</span>,<span class="string">"application-name"</span>);</span><br><span class="line">    ServletActionContext.getContext().getValueStack().set(<span class="string">"name"</span>,<span class="string">"vs-name"</span>);</span><br><span class="line"></span><br><span class="line">    popList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充 List</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">popList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nameList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"Loli-No"</span> + i);</span><br><span class="line">        user.setAge((i+<span class="number">8</span>) + <span class="string">""</span>);</span><br><span class="line">        nameList.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 JSP 页面中直接获取就可以了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:debug</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    request.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#request.name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    session.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#session.name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    application.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#application.name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 从小到大依次搜索 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    attr.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#attr.name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    parameters.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#parameters.name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 值栈 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    vs.name:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"name"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    强制表达式解析： <span class="tag">&lt;<span class="name">s:textfield</span> <span class="attr">label</span>=<span class="string">"%&#123;#request.name&#125;"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 使用单引号输出常量 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    输出常量：<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"'is constant'"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 关闭自动转义 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"'&lt;h1&gt;取消了转义&lt;/h1&gt;'"</span> <span class="attr">escape</span>=<span class="string">"false"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>强制表达式解析前面已经提过了，就是用在默认不会进行 OGNL 解析的地方，让其强制进行解析；<br>还有那个输出常量，加单引号，就是不让其进行 OGNL 解析，但是内容会被 Html 编码，这里我就被坑了…..<strong>请记得：在默认进行解析的属性中，如果不使用 OGNL 的时候记得加单引号！</strong></p>
<h3 id="s-set"><a href="#s-set" class="headerlink" title="s:set"></a>s:set</h3><p>它是用来存储数据的，并且可以存储到指定的域中；如果没有指定范围则默认保存在 ActionContext 的大 Map 中，可以使用 <code>#name</code> 来获取，也可以不加 # ，那样就会先从值栈中搜寻，找不到了再去大 Map 中去找</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:set</span> <span class="attr">var</span>=<span class="string">"s_setName"</span> <span class="attr">value</span>=<span class="string">"'loli'"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#s_setName"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>无论是从那个域取数据，<strong>如果找不到最终都会到这个大 Map 自身中去找</strong>,<br>当然还可以存取 List：<code>&lt;s:set name=&quot;miloList&quot; value=&quot;{‘java’,’php’,’C#’}&quot;/&gt;</code><br><code>#</code> 可以理解为是 <code>ActionContext.getContext()</code></p>
<h3 id="s-push"><a href="#s-push" class="headerlink" title="s:push"></a>s:push</h3><p>同样是用来存储数据的，将对象放到值栈的栈顶，标签结束后会自动删除，不过不能指定存储位置，必须是值栈</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:push</span> <span class="attr">value</span>=<span class="string">"'Lolicon'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:property</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:push</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>property 不指定 value 的话会自动获取栈顶的对象（值栈），并且会调用其的 toString 方法；另外，不使用 OGNL 的话千万记得加单引号！</p>
<h3 id="s-bean"><a href="#s-bean" class="headerlink" title="s:bean"></a>s:bean</h3><p>创建新的 javabean 到栈顶(说的当然是值栈)；如果指定了 var 属性，同时还会保存<strong>引用</strong>到 ActionContext 中，如果不指定，在标签结束后从值栈移除<strong>引用</strong>后就无法取得数据了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:bean</span> <span class="attr">name</span>=<span class="string">"com.bfchengnuo.domain.User"</span> <span class="attr">var</span>=<span class="string">"mybean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 属性赋值 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:param</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"'小奏'"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">存储的 name 为（ActionContext 中）：<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#mybean.name"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 s:bean 标签中的 property 可以直接写 属性名 获取数据….</p>
<h3 id="s-action"><a href="#s-action" class="headerlink" title="s:action"></a>s:action</h3><p>作用就是在 JSP 中直接调用某个 Action，executeResult 属性可以指定是否把页面包含进来</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:action</span> <span class="attr">name</span>=<span class="string">"HelloWorldAction"</span> <span class="attr">namespace</span>=<span class="string">"/one"</span> <span class="attr">executeResult</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:param</span> <span class="attr">name</span>=<span class="string">"user.name"</span> <span class="attr">value</span>=<span class="string">"'Lolicon'"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:param</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"'Loli'"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:param</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"'14'"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:action</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在调用的时候我还传了几个参数过去…..<br>在调用 Action 的时候是在一个线程中，也是一个栈中，后来的 Action 在栈顶 （HelloWorldAction）</p>
<h3 id="s-iterator"><a href="#s-iterator" class="headerlink" title="s:iterator"></a>s:iterator</h3><p>迭代器….已经很熟了吧，在 JSTL、Struts1 中都见过，就是用来迭代集合的，包括 Map；Struts2 中的迭代器也很好用，非常强大<br>每次迭代都会把数据放在栈顶</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"1"</span> <span class="attr">bgcolor</span>=<span class="string">"#db7093"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>索引<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>是否偶数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:iterator</span> <span class="attr">value</span>=<span class="string">"nameList"</span> <span class="attr">status</span>=<span class="string">"st"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"&lt;s:property value="</span>#<span class="attr">st.even</span>?'<span class="attr">even</span>'<span class="attr">:</span>'<span class="attr">odd</span>'"/&gt;</span>"&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"name"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"age"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#st.count"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#st.index"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#st.even"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">%--</span> 状态还可以是 <span class="attr">isFirst</span> <span class="attr">isLast</span> 等 <span class="attr">--</span>%&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">s:iterator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>status 这个对象确实能省不少事呢</p>
<h3 id="s-if-s-elseif-s-else"><a href="#s-if-s-elseif-s-else" class="headerlink" title="s:if/s:elseif/s:else"></a>s:if/s:elseif/s:else</h3><p>这个标签就爽了，相比 JSTL 里的简直太爽，可想像在写 java 一样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:set</span> <span class="attr">var</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"14"</span>/&gt;</span></span><br><span class="line">age:<span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"#age"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:if</span> <span class="attr">test</span>=<span class="string">"#age &lt; 10"</span>&gt;</span>小于10<span class="tag">&lt;/<span class="name">s:if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:elseif</span> <span class="attr">test</span>=<span class="string">"#age &gt; 20"</span>&gt;</span>大于20<span class="tag">&lt;/<span class="name">s:elseif</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:else</span>&gt;</span>10-20<span class="tag">&lt;/<span class="name">s:else</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以后做逻辑判断就简单多了<br>需要注意的是，第一行代码的 set 没有用把数字放单引号里，这说明它是一个整型，<strong>在使用的时候记得加 <code>#</code> </strong></p>
<h3 id="s-url"><a href="#s-url" class="headerlink" title="s:url"></a>s:url</h3><p>在前面的标签库里也见过，就是用来构件 url  的，避免重复写那繁琐的代码，同样；如果加 var 属性就会存到大 Map 中去；最简单的：<code>&lt;s:url /&gt;</code> 表示当前的地址</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 当前地址（带参数）：<span class="tag">&lt;<span class="name">s:url</span> <span class="attr">includeParams</span>=<span class="string">"all"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:url</span> <span class="attr">action</span>=<span class="string">"WaitAction"</span> <span class="attr">namespace</span>=<span class="string">"/reg"</span> <span class="attr">var</span>=<span class="string">"waitUrl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 如果有参数的话可以这样赋值 <span class="attr">--</span>%&gt;</span></span><br><span class="line">    &lt;%--&lt;s:param name="key" value="lalala"/&gt;--%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">s:url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;s:property value="</span>#<span class="attr">waitUrl</span>"/&gt;</span>"&gt;跳转等待页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了访问 Action 可以直接在 value 属性里写 http 地址</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在迭代的时候，可以快速的定义集合，使用 {}</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">s:iterator</span> <span class="attr">value</span>=<span class="string">"&#123;'loli','2','ll','gt'&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s:property</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:iterator</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于 Map，也差不多，不过需要加 <code>#</code> ，也就是这样：<code>#{&#39;key&#39;:&#39;val&#39;,&#39;key2&#39;:&#39;val&#39;}</code><br>使用 property 标签取的时候直接 value=key 、 value=value 这样就行了，因为放在栈顶的就是 Entry 啊，其中就有 getKey、getValue 这样的方法啊</p>
<hr>
<p>为了证明可以调用方法，可以这样调用看看：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameList.size: <span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"nameList.size"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">nameList.isEmpty: <span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"nameList.isEmpty"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">nameList.isEmpty: <span class="tag">&lt;<span class="name">s:property</span> <span class="attr">value</span>=<span class="string">"methodName('para')"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果需要调用静态内容，需要指定包名，类似：<code>@java.util.Locale@CHINA</code><br>调用静态对象的有参方法：<code>@java.util.Locale@CHINA.getDisplayName(@java.util.locale@CHINA)</code><br>注意：静态方法使用 <code>@</code> 连接，如果非静态用 <code>.</code> 就可以了，上面栗子是调用的静态对象 CHINA 中的非静态方法 getDisplayName<br><strong>由于 Math 比较常用，默认是可以省略的</strong>，比如：<code>@@floor(10.09)</code></p>
<hr>
<p>除此之外，还有一些 UI 标签，比如上面用到的 <code>&lt;s:form action=&#39;&#39;&gt;</code> ，总的来说其实和 html 标签并没有什么区别，并且应该是更方便的，上面的这个 form 标签直接在 action 中填 <code>/actionName</code> 就好了，不需要那一串了<br>但是在使用 <code>s:a</code> 标签的时候地址写上 <code>/</code> 反而不正确了，而上面的 form 标签就不会；至于到底加不加 <code>/</code> 最好的方法就是试一下了…..emmmm<br>使用这些标签的时候总是会带一些比较迷的样式（虽然可以设置 theme 属性为 simple），所以一般情况下这类标签是不用的，除非用到了其特别的功能</p>
<p><code>&lt;s:textfield name=&#39;&#39; /&gt;</code> 标签会自动回显数据，也就是会自动根据 name 属性来从值栈（只有根元素中才是栈，其他的域都是在 Map 中）获取相应的值，某些时候，只需要在值栈中 push 相应的数据就可以了</p>
<hr>
<p>有一点还是在这里写下吧，大概：<br>OGNL 中还可以使用类似 <code>[1].user.name</code> 来获取数据，意思就是栈中第二个对象的 user 对象的 name 属性</p>
<h2 id="OGNL过滤和投影"><a href="#OGNL过滤和投影" class="headerlink" title="OGNL过滤和投影"></a>OGNL过滤和投影</h2><p>不想说太多，因为我还没看到….</p>
<ul>
<li><code>?</code>：选择满足条件的所有元素</li>
<li><code>^</code>：选择满足条件的第一个元素</li>
<li><code>$</code>：选择满足条件的最后一个元素</li>
</ul>
<p>语法为：<code>collection.{?expression}</code> 或 <code>collection.{^expression}</code> 或 <code>collection.{$expression}</code>；栗子大概是这样的：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:property value=<span class="string">"array.&#123;?#this &gt; 5&#125;"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"array.&#123;^#this &gt; 5&#125;"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"array.&#123;$#this &gt; 5&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>如果把集合中的数据想象成是数据库表中的数据，投影简单说就是从这表中<strong>选取某一列所构成的一个新的集合</strong>，感觉和 VO 差不多；投影的语法：<code>collection.{expression}</code> ；比如： <code>&lt;s:property value=&quot;personList.{name}&quot;/&gt;</code></p>
<p>多数情况下，过滤和投影是联合起来用的，使用起来还算简单：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:property value=<span class="string">"personList.&#123;?#this.sex.equals('female')&#125;.&#123;name&#125;"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"personList.&#123;^#this.sex.equals('female')&#125;.&#123;name&#125;"</span>/&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"personList.&#123;$#this.sex.equals('female')&#125;.&#123;name&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>如果厌倦了在配置文件中写一大堆的配置，可以选择使用注解，当然有利有弊，在前面的文章已经说过，下面来看看常用的注解：<br>另：使用注解需要 <code>struts2-convention-plugin</code> 的 jar 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParentPackage</span>(<span class="string">"struts-default"</span>)</span><br><span class="line"><span class="meta">@Namespace</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@Results</span>( &#123; <span class="meta">@Result</span>(name = <span class="string">"success"</span>, location = <span class="string">"/main.jsp"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(name = <span class="string">"error"</span>, location = <span class="string">"/error.jsp"</span>) &#125;)</span><br><span class="line"><span class="meta">@ExceptionMappings</span>( &#123; <span class="meta">@ExceptionMapping</span>(exception = <span class="string">"java.lange.RuntimeException"</span>, result = <span class="string">"error"</span>) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Action</span>(<span class="string">"login1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Action</span>( <span class="comment">//表示请求的Action及处理方法  </span></span><br><span class="line">      value=<span class="string">"login2"</span>,  <span class="comment">//表示action的请求名称  </span></span><br><span class="line">      results=&#123;  <span class="comment">//表示结果跳转  </span></span><br><span class="line">              <span class="meta">@Result</span>(name=<span class="string">"success"</span>,location=<span class="string">"/success.jsp"</span>,type=<span class="string">"redirect"</span>),  </span><br><span class="line">              <span class="meta">@Result</span>(name=<span class="string">"login"</span>,location=<span class="string">"/login.jsp"</span>,type=<span class="string">"redirect"</span>),  </span><br><span class="line">              <span class="meta">@Result</span>(name=<span class="string">"error"</span>,location=<span class="string">"/error.jsp"</span>,type=<span class="string">"redirect"</span>)  </span><br><span class="line">      &#125;,  </span><br><span class="line">      interceptorRefs=&#123; <span class="comment">//表示拦截器引用  </span></span><br><span class="line">              <span class="meta">@InterceptorRef</span>(<span class="string">"defaultStack"</span>),  </span><br><span class="line">              <span class="meta">@InterceptorRef</span>(<span class="string">"timer"</span>)  </span><br><span class="line">      &#125;,  </span><br><span class="line">      exceptionMappings=&#123;  <span class="comment">//映射映射声明  </span></span><br><span class="line">              <span class="meta">@ExceptionMapping</span>(exception=<span class="string">"java.lang.Exception"</span>,result=<span class="string">"error"</span>)  </span><br><span class="line">      &#125;  </span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体就是这样使用了….. <del>@Action(url) 中的url，如果以 <code>/</code> 开头那是绝对路径，访问的时候不需要加命名空间，否则就要加命名空间，应该是吧，未测试</del></p>
<p>常用的注解：</p>
<blockquote>
<p>  Namespace：指定命名空间。<br>  ParentPackage：指定父包。<br>  Result：提供了Action结果的映射。（一个结果的映射）<br>  Results：“Result”注解列表<br>  ResultPath：指定结果页面的基路径。<br>  Action：指定Action的访问URL。<br>  Actions：“Action”注解列表。<br>  ExceptionMapping：指定异常映射。（映射一个声明异常）<br>  ExceptionMappings：一级声明异常的数组。<br>  InterceptorRef：拦截器引用。<br>  InterceptorRefs：拦截器引用组。</p>
</blockquote>
<p>其他的一些用到再补充吧，比如那些拦截注解 Before 、After 之类的，类型转换注解啊。。。总之；注解能做很多事</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>当我们需要把返回的内容转成 JSON 时，可以使用 Struts 提供的插件完成，导包就不说了（struts2-json-plugin）<br>配置文件中的 package 继承 json-default，返回值的 type 填 json ；<br>在 Action 中对应的方法中，把相应的数据保存到集合里，通常使用 List，这个集合要是全局的才行，因为要提供 getter/setter 方法，这样 Struts 就会自动进行处理了</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/struts-2/annotations-types.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/struts-2/annotations-types.html</a><br><a href="http://www.blogjava.net/fancydeepin/archive/2014/03/17/struts-ognl.html" target="_blank" rel="noopener">http://www.blogjava.net/fancydeepin/archive/2014/03/17/struts-ognl.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2学习笔记]]></title>
      <url>http://bfchengnuo.com/2017/06/07/Struts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>这两天看 Struts 真是看的一脸懵逼，一方面不禁感叹牛人的思想就是超前啊，这篇笔记写的很急，其中的理解可能有些错误，想以后有了深入认识再回来修正的…..<br>不禁感叹 Struts2 与 Struts1 真是天差地别啊…. webwork 真厉害呢…<a id="more"></a></p>
<h2 id="Struts1和Struts2"><a href="#Struts1和Struts2" class="headerlink" title="Struts1和Struts2"></a>Struts1和Struts2</h2><p>这个网上随便一搜就有N多的文章，分析的都挺详细的，我呢就说说主要的（<del>我知道的</del>）几点<br>关于 Struts1 我也写了一篇，不过没放在博客上，因为毕竟现在基本已经没人用了啊…..<br>地址在这：<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Struts1%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.md" target="_blank" rel="noopener">Github</a></p>
<h3 id="Struts1-基于Servlet"><a href="#Struts1-基于Servlet" class="headerlink" title="Struts1-基于Servlet"></a>Struts1-基于Servlet</h3><p>为什么会被淘汰，这当然是因为有缺点的，抛开它奇葩的命名不说，重要的是架构不是很好，体现在下面的几点</p>
<ul>
<li><strong>ActionServlet 的任务过于集中，压力大，不容易扩展和维护</strong><br>它主要做的有：处理请求、实例化 formBean，往里封装数据、然后根据配置文件决定是否进行校验，对结果进行处理，最终把结果封装到 request 中、实例化相应的 Action ，调用相应的方法，传递相关的对象、对 Action 返回的结果进行处理,如转发到指定页面…..;<br>如此多的功能集中在一起必然扩展性很差，也容易出问题</li>
<li><strong>Action 是单例的，线程不安全的</strong><br>Action 被创建出来后会一直存在，并且只存在一个，就像 Servlet，一个 Action 处理所有的请求（数据不安全，不要在 Action 中声明实例变量）</li>
<li><strong>ActionForm 造成类的爆炸</strong><br>因为一个表单就对应一个，虽然可以使用动态 formbean ；一个用户（请求）可能对应好几个…因为 formBean 是随 Action 存在的，一个 Action 可能会处理多个表单</li>
<li><strong>耦合性高</strong><br>从 <code>execute(ActionMapping mapping,ActionForm form,HttpServletRequest request, HttpServletResponse response)</code> 这个从方法的参数就可以看出，需要传入四个参数呐！</li>
</ul>
<h3 id="Struts2-基于Filter"><a href="#Struts2-基于Filter" class="headerlink" title="Struts2-基于Filter"></a>Struts2-基于Filter</h3><p>新一代，然而和一代并没多大关系，倒是和 webwork 的关系挺大</p>
<ul>
<li><strong>分离关注思想</strong><br>和 aop 挺像，嗯？反正就是不像一代那样集中在一个组件上了；将 web 开发中的常规任务剥离开来，分别交给不同的组件（拦截器）进行处理，比如：文件上传、表单的处理、国际化、参数传递、类型转换等等</li>
<li><strong>Action 是原型、独占的，不共享</strong><br>意思就是说一个请求对应一个 Action，所以可以存放客户端的状态信息了！</li>
<li><strong>取消了 ActionForm ，使用 pojo（action、javabean）接收数据</strong></li>
<li><strong>松耦合，可维护性高</strong><br>action 就是个普通的 pojo 也就是普通的 javabean，也就是说 struts2 api 和 原生的 servlet api 关系不大【非侵入性，不用实现你的接口也不用继承你的类，这是理想条件下】</li>
</ul>
<h2 id="Struts2的使用"><a href="#Struts2的使用" class="headerlink" title="Struts2的使用"></a>Struts2的使用</h2><p>搭建就不说了，就是拷进去相应的 jar包，创建的 action 不需要继承任何类或者实现任何的接口<br>下面说下配置，Struts2 是基于过滤器的，所以需要在 <strong>web.xml</strong> 文件里配一个过滤所有请求的过滤器，我用 IDEA 建了个项目，发现都给配好了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>先来写个简单的 Action，相比 Struts1 就简单多了，不需要继承任何类，方法名默认还是用 execute （应该是 webWork 规定的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每一次请求都会实例化哦</span></span><br><span class="line">        System.out.println(<span class="string">"实例化啦！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 不进行任何跳转；返回值也叫做路由串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 Struts 的配置文件，默认在 src 下名字为 <strong>struts.xml</strong> ；至于这个文件怎么写，不知道，那就抄吧，在 Struts 的核心包里有相关的配置文件，照着写写就差不多（<strong>struts2-core.jar</strong> 下的 <strong>struts-default.xml</strong> 有返回值等大部分配置；<strong>struts2-core.jar/org.apache.struts2/default.properties</strong> 文件下有绝大部分的变量说明）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置常量，这个是设置请求后缀的，默认是 .action ；最后的 “,,” 表示结尾空也可以 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"do,,"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置开发模式，可以自动重新加载国际化资源文件和配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可以继承，它配置了很多默认值，如 type 等--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"HelloWorld"</span> <span class="attr">namespace</span>=<span class="string">"/one"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置默认的 action 也就是在当前的命名空间下，如果找不到 action 的时候访问这个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default-action-ref</span> <span class="attr">name</span>=<span class="string">"HelloWorldAction"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置默认的 class 引用，也就是 action 可以不用配 class 了--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.HelloWorld"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"HelloWorldAction"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.HelloWorld"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置返回值相关，name 就是返回值，如果是 success 可以省略--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--父类中指定了默认的 type 为 dispatcher 也就是转发--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"ActionNoClass"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--使用通配符来实现动态方法的调用；避免使用 ！--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"HWAction_*"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.HelloWorld"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--每一个返回值对应一个方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"save"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于 namespace 命名空间的作用，就是在输入网址的时候用的，比如： <code>http://xxx:8080/webAppName/namesPace/Action</code><br>最后配置的那个 action 是动态调用，它对应多个返回值，也就是对应多个方法，可以接受很多的请求，并且使用了通配符，通配符匹配到的会传给后面的 <code>{1}</code> 中，比如这样用：<code>http://xxx:8080/webAppName/namesPace/HWAction_save</code> ；<strong>下划线后面跟的是方法名，如果省略将会匹配默认的 execute 方法</strong></p>
<blockquote>
<p>  对于多个方法的访问，除了写多个 action 外<br>  还可以使用这样的地址访问：<code>http://xxx:8080/webAppName/namesPace/Action!methodName</code><br>  这样的话只需要在 method 里指明方法名就行了，不过用叹号分割总感觉怪怪的，并且在 Struts 的配置文件中<strong>开启动态方法调用</strong>才会生效。所以还是像上面那样配置吧</p>
</blockquote>
<p>上面提到了可以不配 class 走默认设置的全局 class，这个具体是应用在请求 WEB-INF 目录下的文件的，因为默认的 class 是 ActionSupport ，它实现了 Action 的接口，所有有一个 execute 方法，这个方法返回字符串 success，所以说只需要配置：<code>&lt;result name=&quot;success&quot;&gt;/WEB-INF/index.jsp&lt;/result&gt;</code> 就可以实现请求保护目录下的文件，而不需要写相应的 Action</p>
<h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><p>url 可以传参，但是 action 中并没有继承任何类，如何获取 request 等对象呢，是通过 ServletActionContext 的静态方法获取的；但是获取 url 中的值并不需要这么麻烦，前面说过，action 其实就是一个 javabean，那么就可以设置属性，属性名对应传进来的参数名，调用的时候会自动用反射技术进行设置的；所以说在方法中直接用就行了<br>如果需要数据回显，还是用标签库（其实是从值栈中获取）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;测试页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    这是一个测试页面</span><br><span class="line">    name:&lt;s:property value=<span class="string">"name"</span>/&gt; &lt;br&gt;</span><br><span class="line">    age:&lt;s:property value=<span class="string">"age"</span>/&gt; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>再来说说 ServletActionContext ，它可以获取到绝大数需要的对象，它其实是 ActionContext 的孩子，下面会详细说</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>我们知道开发的 web 应用中存储数据有四个域，从小到大依次是：page 、 request 、 session 、 application</p>
<p>在 struts 有个比较常用的是 ActionContext 说到 Context 也就是上下文，指的其实就是环境，也就是当前的环境，同时还可以说是数据中心<br>在 ActionContext 中封装了其他域的引用，具体有：</p>
<ol>
<li>request</li>
<li>session</li>
<li>application</li>
<li>valuestack(值栈)<br>值栈肯定是个栈，然而其实是通过 arrayList 进行模拟的；值栈其实存在于 request 一个特殊的属性 <strong>struts.ValueStak</strong> 独立出来是为了方便<br><strong>s:property</strong> 标签默认就是去值栈里进行寻找</li>
<li>parameters</li>
<li>attr<br>会自动从 session/request/application 域中去寻找</li>
</ol>
<p>ActionContext  于内部的六个“域”是<strong>双向引用</strong>！<strong>ActionContext 属于 threadlocal 俗称线程本地化</strong>；ServletActionContext 是 ActionContext 的子类，进行了一些简单的封装；所以有了很多的 get 的方法获取到相应的<strong>对象</strong><br><strong>通常还是推荐尽量使用 ActionContext 来获取数据，因为获取的是 Map 集合，不需要加入 servlet API 的 jar 包，也就是说解耦了；但是有些功能实现不了的话还是需要用 servlet 中的对象（比如获取路径）</strong><br>另外，ActionContext  还可以这样用：<code>Map&lt;K,V&gt; map = ActionContext.get(&quot;request&quot;)</code> 这样获取到的是 request 的 Map 集合</p>
<blockquote>
<p>  ActionContext 的 put 方法默认是直接存到 request 域<br>  get(“request”).put 方式是存到 request 的 map 集合中去<br>  所以说，在用 OGNL 表达式取的时候，第一种可以直接 <code>#key</code> 这样取；而第二种要使用 <code>#request.key</code> 或者 <code>#attr.key</code> 的方式来取值</p>
<p>  put 方法像是 Struts 的一种优化，为了方便取值，因为值栈说白了就是存在于 request 域中的</p>
</blockquote>
<p>通常，Action 会被放在值栈根节点的栈顶（双向引用哦），这个操作是在执行过程中执行的（下面的工作原理），表单的提交、数据的回显都是依赖于值栈</p>
<hr>
<p>然后再说下属性链，Action 其实是个 javabean，在 Action 中还可以再引用一个 bean 作为属性，传参的时候就需要指明了：<br><code>http://xxx:8080/webName/action?user.name=loli</code> 这就是给 action 中的 user 属性的 name 属性赋值，额…说的这么别扭<br><div class="note warning"><p>这里有个坑，当你在 action 用 javabean 类型的属性时，千万别用一个小写字母开头，比如：mUser<br>因为这样在生成属性的时候会变成这样：getMUser() ；这就很尴尬了….这是不符合规范的，所以，别这么搞</p>
</div></p>
<p>补充一个专业术语：<strong>action 相关</strong><br>说的是很多资源文件需要<strong>和 action 放在一起，文件名相同，扩展名不同</strong>，至于什么用处，相当于一代的国际化资源文件吧，下面的表单校验中用得到</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/image/dev/struts2.jpg" alt="struts2.jpg"></p>
<p>图画的不是很准确，差不多这意思，请求来了都要进入 StrutsPreparreAndExecuteFilter 这个核心过滤器，StrutsPreparreAndExecuteFilter 主要有两个操作（对象），一个是准备（prepare 图的右边）；另一个是执行（excute 图的左边）；<br>prepare 会注册国际化资源文件，并且会创建 ActionContext 对象，顺便绑定到当前线程中去….(创建的过程还是蛮复杂的，想知道的看源码….)<br>接下来会查找 ActionMapping，如果没有就创建（<strong>通过 ActionMapper 来寻找/创建</strong>），最后存到 request 中去<br>另外还会参与过滤模式的处理，就是过滤出 Action 的请求，其他的请求（jsp、img等）直接放行</p>
<blockquote>
<p>  在核心过滤器中，会发现刚开始是加载配置文件，如果没有特别的指定会自动加载3个配置文件，第一个是 Struts2 核心包下的 struts-default.xml 文件，最后一个是我们自己配置的 struts.xml 文件<br>  struts-default.xml 文件里配了一些东西，比如刚开始的一堆 bean，后面就是定义了一些 Type（result-types）比如最常用的 dispatcher 和 redirect，其中可以看到 dispatcher 被设置为了默认，所以在我们自己配的配置文件中如果设置转发不需要配 Type<br>  再下面就是初始化拦截器（拦截器只能拦截 Action，是 Struts 中的概念），这应该就是 Struts2 的核心了；定义默认的拦截器、默认执行的 Action</p>
</blockquote>
<hr>
<p>上面的操作完成后最终会到达 excute；判断如果 mapping 不为空，就调用 excute 执行 Action 会把 mapping 一起传过去，执行玩后到此终止，也就是说它没放行，<strong>后面的过滤器不会自动执行！</strong><br>在调用 Action 的方法中 excute 会创建出 ActionProxy ，它依赖于 ConfigurationManager 把配置文件（Struts.xml）读取出来进行一些处理，然后会请求一个中间人（Action Invocation）来调用那 N 个过滤器（应该是13个，具体看配置文件，叫做过滤器栈），使用的是递归方式，也就是上图的虚线，调用 1 然后返回（返回时再次调用此方法，也就是调用第二个拦截器），再继续调用 2 再返回….<br>在 Action 调用之前处理的叫预处理，之后处理的叫后处理，大部分后处理是空实现，文件上传的过滤器比较特殊，因为需要在后处理里删除缓存文件</p>
<p>应该是在调用拦截器之前 excute 会把 action 置为栈顶（值栈）</p>
<p><strong>如果配置自己的拦截器，一定要放在 Struts 拦截器的上面，因为 Struts 拦截器并不会放行</strong></p>
<h2 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h2><h3 id="ActionSupport"><a href="#ActionSupport" class="headerlink" title="ActionSupport"></a>ActionSupport</h3><p>这个类实现了 action 和其他几个有用的接口，比如数据的校验、国际化；你的 action 继承它后会自动获得这些能力</p>
<h3 id="基本校验-amp-文件上传"><a href="#基本校验-amp-文件上传" class="headerlink" title="基本校验&amp;文件上传"></a>基本校验&amp;文件上传</h3><p>主要是通过拦截器和接口实现的 ActionSupport 实现了两个接口和默认栈中一个拦截器配合使用<br>DefaultWorkflowInterceptor 提供了基本的校验功能（其实它只是判断是否有错误，有就跳转到 input 设定的页面，而不会再执行 Action 了）<br>关键的<strong>调用</strong>在校验拦截器；<del>所以 DefaultWorkflowInterceptor 就是工作流嘛，应该可以理解为重新定义路由….额</del></p>
<p>先来写个注册页面，使用到了标签库，很贴心的会自动显示校验错误，不需要任何标签：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;注册的测试页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    这是一个测试页面 &lt;br&gt;</span><br><span class="line">    &lt;s:form namespace=<span class="string">"/reg"</span> action=<span class="string">"RegAction_reg"</span> method=<span class="string">"POST"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">        &lt;s:textfield name=<span class="string">"name"</span> label=<span class="string">"用户名"</span>/&gt;</span><br><span class="line">        &lt;s:textfield name=<span class="string">"age"</span> label=<span class="string">"年龄"</span>/&gt;</span><br><span class="line">        &lt;s:file name=<span class="string">"img"</span> label=<span class="string">"上传文件"</span>/&gt;</span><br><span class="line">        &lt;s:submit value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">    &lt;/s:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>为了兼容直接访问 JSP 的情况（虽然极少）最好把 namespace 写上，这里顺便使用了文件上传的过滤器，文件的信息会自动装填到相应的字段，比如文件的类型会自动装填到下面的 imgContentType 字段，类型是 MIME 的，在服务器的 web.xml 中有相应的定义，相应处理请求的 Action ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传文件相关，以及获取的文件名和类型</span></span><br><span class="line">    <span class="keyword">private</span> File img;</span><br><span class="line">    <span class="keyword">private</span> String imgFileName;</span><br><span class="line">    <span class="keyword">private</span> String imgContentType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达注册页面,本方法不应该被校验</span></span><br><span class="line">    <span class="meta">@SkipValidation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toReg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"regView"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取上传的文件</span></span><br><span class="line">        String dir = ServletActionContext.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">        System.out.println(dir);</span><br><span class="line">        String ext = imgFileName.substring(imgFileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(dir, l + ext);</span><br><span class="line">        <span class="comment">// 或者使用 FileUtils.copyFile(a,b);</span></span><br><span class="line">        img.renameTo(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isEmpty()) &#123;</span><br><span class="line">            addFieldError(<span class="string">"name"</span>,getText(<span class="string">"error.name.empty"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImg</span><span class="params">(File img)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.img = img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getImgFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imgFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgFileName</span><span class="params">(String imgFileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imgFileName = imgFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getImgContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imgContentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgContentType</span><span class="params">(String imgContentType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.imgContentType = imgContentType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Action 中，validate 校验方法优先于其他方法执行，但是校验过滤器是在参数过滤器之后的，没有参数校什么校；相应的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"regPkg"</span> <span class="attr">namespace</span>=<span class="string">"/reg"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"RegAction_*"</span> <span class="attr">class</span>=<span class="string">"com.bfchengnuo.web.action.RegAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/reg/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/reg/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 校验失败自动跳回的路由 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/reg/reg.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"regView"</span>&gt;</span>/reg/reg.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  关于 addFieldError 方法，它是先由校验拦截器调用的，然后才是 DefaultWorkflowInterceptor 进行判断，就是判断是否有错误消息啦；如果有就路由到 input 设置的界面了<br>  addFieldError 方法会将错误信息加入到一个 Map 集合中去，然后在后续的 JSP 页面中就可以从这个集合中取出这些信息</p>
</blockquote>
<p>关于配置文件，可以采用模块化思想，就是有多份文件，在主文件中使用 include 引用；</p>
<h3 id="校验-amp-文件上传的补充"><a href="#校验-amp-文件上传的补充" class="headerlink" title="校验&amp;文件上传的补充"></a>校验&amp;文件上传的补充</h3><p>上面使用的注解的方式避免 toReg 方法被校验，这种方法只限于在这个环境（拦截器）下使用；除了这一种还有其他两种方式，并且这两种方式是通用的，在其他的拦截器也可以使用</p>
<ul>
<li><p>加后缀法指定校验方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看方法名，后面跟需要校验的方法名，或者使用 validateDoReg 也可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateReg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isEmpty()) &#123;</span><br><span class="line">        addFieldError(<span class="string">"name"</span>,getText(<span class="string">"error.name.empty"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件法：在需要处理的 Action 下覆盖默认的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 去校验的第三种方式：覆盖法指定跳过的方法，这个写法在配置文件中也可以找到 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"validation.excludeMethods"</span>&gt;</span>input,back,cancel,toReg<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>在文件上传的时候，我们可能要限制文件上传的大小，这个在 Struts 的配置文件中设置下 <code>struts.multipart.maxSize</code> 的值就可以了<br>还比较常用的是限制文件类型，也就是指定某些类型的文件才能上传，这个用 fileUpload 拦截器就可以做到，这种方式类似是注入了，可以找到其类中具体对应的属性，具体配置是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 覆盖原拦截器的属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- allowedTypes 就是设置限制的 MIME 了，更严格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"fileUpload.allowedExtensions"</span>&gt;</span>txt,jpg,jpeg<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里提一下，一旦配置了 Action 的拦截器（interceptor-ref）就不会继承包配置的默认的拦截器栈了，所以如果配置其他的拦截器别忘了加入 defaultStack</p>
<p>这些内容在测试代码中都有，还有文件的下载，篇幅太长就不写了，详见 <a href="https://github.com/bfchengnuo/java_learn/blob/master/XC/Struts2/bfchengnuo/web/action/FileAction.java" target="_blank" rel="noopener">Github</a></p>
<h3 id="使用验证框架"><a href="#使用验证框架" class="headerlink" title="使用验证框架"></a>使用验证框架</h3><p>上面所写的是实现 validate 方法，其实还可以用 Struts2 提供的框架，配置下 xml 文件就行了，具体的约束在：<code>lib/xwork-core.jar!/xwork-validator-1.0.2.dtd</code> ；嗯….是的，在 xwork 下</p>
<p>然后创建 Action 相关文件，在需要进行校验的 Action，名字类似：<code>ValidateAction-validation.xml</code> ；其他的都一样，都是用 ValidationAware 接口存储错误信息，用 workflow 拦截器导向 input 界面，一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE validators PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Struts//XWork Validator 1.0.2//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">validators</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field-validator</span> <span class="attr">type</span>=<span class="string">"requiredstring"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>&gt;</span>用户名不能为空<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field-validator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field-validator</span> <span class="attr">type</span>=<span class="string">"stringlength"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"minLength"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"maxLength"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>&gt;</span>name:$&#123;name&#125; 必须 $&#123;minLength&#125; - $&#123;maxLength&#125;<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field-validator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;field-validator type="email"&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;message&gt;xxxx&lt;/message&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/field-validator&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field-validator</span> <span class="attr">type</span>=<span class="string">"required"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>&gt;</span>年龄不能为空<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field-validator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field-validator</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"min"</span>&gt;</span>12<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max"</span>&gt;</span>16<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span>&gt;</span>必须 12 - 16<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">field-validator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 OGNL 表达式校验两次密码是否相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">validator</span> <span class="attr">type</span>=<span class="string">"expression"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"expression"</span>&gt;</span>pwd==confirmPwd<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span>&gt;</span>两次密码不同<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">validator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">validators</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>msg 可以使用其 key 属性从国际化资源文件中提取，当然在其中也是可以使用 OGNL 的<br>如果验证指定方法文件名就要改成：<code>ClassName-ActionName-validation.xml</code></p>
<h2 id="主题与国际化"><a href="#主题与国际化" class="headerlink" title="主题与国际化"></a>主题与国际化</h2><p>这两方面简单说下吧，我没仔细看呢….Orz<br>struts2 默认带了 4 套主题；可以通过设置常量的方式来指定框架使用那个主题：<code>struts.ui.theme=xhtml</code> ；默认就是 xhtml<br>不同的主题在生成 html 的时候会有所差异。这几个主题什么区别自行搜索吧<br>如果某个标签 Struts 渲染的你不爽，那么是可以修改的，比如说错误的那个标签；因为 JVM 是先加载 jar 包，然后加载 src 里面的代码，如果在 src 里有相同的包，相同的文件，那么就会覆盖之前的（改 ftl 模板文件就行）</p>
<hr>
<p>关于国际化拦截器，他会检测请求是否传入了 <code>request_locale</code> 参数，如果有就将其存储到 session 中，并且更改其对应的语言（就是加载相应的国际化资源文件）并且其实还存了一份到 ActionContext 中，就是那个大 Map，便于数据的回显<br>资源文件按照：<code>文件名_语言_地区</code> 的形式，比如：<code>name_zh_CN</code> ，类型当然是 properties；加载国际化资源使用的是常量的方式，键是 <code>struts.custom.i18n.resources</code> 值就是你写的 prop 文件的位置了，同一类加载一个就行（默认的那个 name.properties），多个用逗号分割；记得在 JSP 的标签中使用 <code>&lt;s:text&gt;</code> 标签的 name 属性获取值</p>
<h2 id="模型驱动拦截器"><a href="#模型驱动拦截器" class="headerlink" title="模型驱动拦截器"></a>模型驱动拦截器</h2><p>也许配合 <a href="https://bfchengnuo.com/2017/06/16/Struts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/">笔记2</a> 效果更好，因为哪一篇太长了（这一篇好像更长了），写在这里了….<br>先说它的作用，其一：<br>OGNL 表达式是从栈顶的对象里找数据，对象里的对象里的值是没办法直接用的，只能使用属性链，使用模型驱动后，会在栈中压入一个自定义的对象，在 Action 的上面，所以在 JSP 中可以直接用这个对象里的属性，表单提交的数据也是进这个对象<br>其二，也是主要作用：<br>对所有的 Action 模型对象进行批处理；比如：在一个可以拦截所有 Action 的拦截器中判断(instanceof)是否是 ModelDriven，如果是就强转成 ModelDriven，调用其 getModel 方法就可以获得其要操作的对象；然后就可以利用反射进行实例化….等</p>
<p>使用模型驱动需要实现接口 <code>ModelDriven&lt;T&gt;</code>,以及实现 getModel 方法，这个方法返回的就是要压入栈顶的那个对象<br>更进一步使用：<br>模型驱动拦截器是在参数拦截器之前的，如果想要在模型驱动将对象压入栈顶之前初始化（填充）对象，可以使用准备拦截器（翻译不是很准确）；需要实现 Preparable 接口，此方法会在模型驱动拦截器之前调用<br>如果需要传进的参数数据，要用 paramsPrepareParamsStack 栈，因为如果用默认栈，准备拦截器是优于参数拦截器的，那样就会取不到参数</p>
<p>具体的测试代码我放在 <a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/Struts2" target="_blank" rel="noopener">Github</a></p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>发现一个标签对于调试很爽，并且使用简单：<code>&lt;s:debug /&gt;</code><br>加上后会显示一个连接，点击会展示值栈、ActionContext 等的情况</p>
<p>Action 类中，如果加上 <code>private static final long serialVersionUID = 1006766693264599611L;</code> 是反序列化时用的，具体还没研究</p>
<p>关于校验详细的流程写的不太详细，先这样吧….</p>
<hr>
<p>Struts2 的根配置文件除了前面所说的，可能还会用到的有：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 请求参数的编码方式 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.i18n.encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 指定被struts2处理的请求后缀类型。多个用逗号隔开 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,do,htm"</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 当struts.xml改动后，是否重新加载。默认值为false(生产环境下使用),开发阶段最好打开  --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.configuration.xml.reload"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 是否使用struts的开发模式。开发模式会有更多的调试信息。默认值为false(生产环境下使用),开发阶段最好打开  --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- 设置浏览器是否缓存静态内容。默认值为true(生产环境下使用),开发阶段最好关闭  --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.serve.static.browserCache"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 指定由 spring 负责action对象的创建     </span></span><br><span class="line"><span class="comment">    &lt;constant name="struts.objectFactory" value="spring" /&gt;  </span></span><br><span class="line"><span class="comment">    --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 是否开启动态方法调用 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后补充：关于转发，如果是使用链式（type=chain）转发到另一个 Action，那么它们两个都是在一个线程中</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3学习笔记(二)]]></title>
      <url>http://bfchengnuo.com/2017/05/27/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>CSS3 增加的东西确实不少，额，起码我感觉不少，如果真的用好了能做出非常炫酷的东西；然而我感觉是非常难的，到最后差点都勇气看完了<br>3D 方面的东西没说，要使用高级特效，首先把矩阵学好吧…..还有，浏览器兼容问题真是一大璀璨，像我，从不考虑 IE10 以下的，毕竟看前端只是兴趣<br><del>果然还是 ctrl + c and ctrl + v 大法好啊！</del><a id="more"></a><br>这篇笔记从9号开始记录的，一直到….27，虽然是想起来才看一点这样的”策略“</p>
<h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><ul>
<li><strong>旋转 rotate() 函数</strong><br>通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为<strong>正值</strong>，元素相对原点中心<strong>顺时针</strong>旋转；如果这个值为<strong>负值</strong>，元素相对原点中心<strong>逆时针</strong>旋转。<code>transform: rotate(45deg);</code></li>
<li><strong>扭曲 skew() 函数</strong><br>能够让元素<strong>倾斜显示</strong>。它可以将一个对象以其中心位置围绕着<strong>X轴</strong>和<strong>Y轴</strong>按照一定的角度倾斜。这与 rotate() 函数的旋转不同，rotate() 函数只是旋转，而不会改变元素的形状。skew() 函数不会旋转，而只会改变元素的形状。<br>skew 有三种形式：1.<code>skewX(x)</code> ; 2.<code>skewY(y)</code> ; 3.<code>skew(x,y)</code> (如果只写一个第二个参数默认0)<br>分别是让其在水平方向扭曲；垂直方向扭曲；在水平和垂直方向都扭曲，单位写 deg 即可</li>
<li><strong>缩放 scale()函数 </strong><br>让元素根据中心原点对对象进行缩放，同样有三种形式，和上面的扭曲类似，就不多说了，但是如果使用 scale(x,y) 的时候只写一个值，指的是水平、垂直都是这个值<br><strong>注意：</strong> <strong>scale() 的取值默认的值为1</strong>，当值设置为<strong>0.01</strong>到<strong>0.99</strong>之间的任何值，作用使一个元素缩小；而任何大于或等于<strong>1.01</strong>的值，作用是让元素放大。</li>
<li>位移 <strong>translate()函数</strong><br>可以将元素向指定的方向移动，类似于 position 中的 relative。或以简单的理解为，使用  translate() 函数，可以把元素从原来的位置移动，<strong>而不影响在X、Y轴上的任何Web组件。</strong><br>同样有三种形式，可以使用百分比，比如：<code>transform:translate(-50%,-50%);</code> 就算参数一样也不要省略</li>
<li><strong>原点 transform-origin</strong><br>任何一个元素都有一个中心点，默认情况之下，其中心点是居于元素 X 轴和 Y 轴的 50% 处，也就是所谓的中心。<br>在没有重置 transform-origin 改变元素原点位置的情况下，CSS 变形进行的旋转、位移、缩放，扭曲等操作都是以元素自己中心位置进行变形。比如：<code>transform-origin: left top;</code></li>
<li><strong>矩阵 matrix()</strong><br>它是一个含六个值的 (a,b,c,d,e,f) 变换矩阵，用来指定一个2D变换，上面的几种变换其实还是调用的它，2D 变换是个 3X3 的矩阵，3D 是 4X4 的矩阵<br><a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/</a></li>
</ul>
<h2 id="动画-过渡属性"><a href="#动画-过渡属性" class="headerlink" title="动画-过渡属性"></a>动画-过渡属性</h2><p>它可以通过一些简单的 CSS 事件来触发元素的外观变化，让效果显得更加细腻。简单点说，<strong>就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。</strong></p>
<p>在CSS中创建简单的过渡效果可以从以下几个步骤来实现：</p>
<ol>
<li>在默认样式中声明元素的<strong>初始状态样式；</strong></li>
<li>声明过渡元素<strong>最终状态样式</strong>，比如悬浮状态( hover )；</li>
<li>在默认样式中通过添加<strong>过渡函数</strong>，添加一些不同的样式。</li>
</ol>
<p>CSS3的过度 transition 属性是一个复合属性，主要包括以下几个子属性：</p>
<ul>
<li><strong>transition-property</strong> : 指定过渡或动态模拟的CSS属性</li>
<li><strong>transition-duration</strong> : 指定完成过渡所需的时间</li>
<li><strong>transition-timing-function</strong> : 指定过渡函数</li>
<li><strong>transition-delay</strong> : 指定开始出现的延迟时间</li>
</ul>
<p>简单的栗子最直接：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">-webkit-transition-property</span>: width;</span><br><span class="line">  <span class="attribute">transition-property</span>: width;</span><br><span class="line">  <span class="attribute">-webkit-transition-duration</span>:.<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">transition-duration</span>:.<span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition-timing-function</span>: ease-in;</span><br><span class="line">  <span class="attribute">transition-timing-function</span>: ease-in;</span><br><span class="line">  <span class="attribute">-webkit-transition-delay</span>: .<span class="number">18s</span>;</span><br><span class="line">  <span class="attribute">transition-delay</span>:.<span class="number">18s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 合在一起也是可以的 */</span></span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: background-color .<span class="number">5s</span> ease .<span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: background-color .<span class="number">5s</span> ease .<span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>“transition-property”</strong> 属性设置为 <strong>all</strong> 时，表示的是所有中点值的属性，也就是你初始状态设的什么属性就代指的什么属性。<br>关于过渡函数：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>linear</td>
<td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>
</tr>
<tr>
<td>ease</td>
<td>规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</td>
</tr>
<tr>
<td>ease-in</td>
<td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>
</tr>
<tr>
<td>ease-out</td>
<td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>
</tr>
<tr>
<td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>
</tr>
</tbody>
</table>
<p>有时我们想改变两个或者多个 css 属性的 <strong>transition效果</strong> 时，只要把几个 transition 的声明串在一起，用<strong>逗号</strong>（“，”）隔开，然后各自可以有各自不同的<strong>延续时间</strong>和其<strong>时间的速率变换方式</strong>。但需要值得注意的一点：第一个时间的值为 transition-duration，第二个为 transition-delay。<br>例如：<code>a{ transition: background 0.8s ease-in 0.3,color 0.6s ease-out 0.3;}</code></p>
<p>如果需要鼠标点击触发，那就只能通过设置 onclick 事件，使用 JS 来改变其 style 的属性</p>
<h2 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h2><p>Keyframes 被称为关键帧，其类似于 Flash 中的关键帧。在 CSS3 中其主要以 <code>“@keyframes”</code> 开头，后面紧跟着是动画名称加上一对花括号 <code>“{…}”</code>，括号中就是一些<strong>不同时间段</strong>样式规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> wobble &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:green;</span><br><span class="line">  &#125;</span><br><span class="line">  40% &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background</span>:orange;</span><br><span class="line">  &#125;</span><br><span class="line">  60% &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>:red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: wobble <span class="number">5s</span> ease .<span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  在 @keyframes 中定义动画名称时，其中 0% 和 100% 还可以使用关键词 from 和 to 来代表，其中 0% 对应的是 from，100% 对应的是 to。</p>
<p>  <strong>Chrome</strong> 和 <strong>Safari</strong> 需要前缀 <strong>-webkit-</strong>；<br>  <strong>Foxfire</strong> 需要前缀 <strong>-moz-</strong>。</p>
</blockquote>
<h3 id="调用分解"><a href="#调用分解" class="headerlink" title="调用分解"></a>调用分解</h3><p>通过上面的 css 代码也能看出来，是使用 animation 进行调用的，animation-name 属性主要是用来调用 @keyframes 定义好的动画。<br>需要特别注意: animation-name 调用的动画名需要和 “@keyframes” 定义的动画名称完全一致（区分大小写），如果不一致将不具有任何动画效果。<br>其实和 transition 是差不多的，比如 animation-duration 主要用来设置 CSS3 动画<strong>播放时间</strong><br>animation-timing-function 属性主要用来设置动画<strong>播放方式</strong>。主要让元素根据时间的推进来改变属性值的变换速率，就是上面表格中的那些函数</p>
<p>另有几个特有的属性：<br>控制<strong>播放次数</strong>，毕竟是动画嘛；<strong>animation-iteration-count</strong> 属性主要用来定义动画的播放次数。<br>这个值通常为整数，但是小数也是可以的，默认为一次，如果是 <strong>infinite</strong> 表示无限循环<br>设置<strong>动画播放方向</strong> ，就是使用 <strong>animation-direction</strong> 了 ，其主要有两个值：</p>
<ul>
<li>normal<br>默认值，动画的每次循环都是向前播放；</li>
<li>alternate<br>动画播放在<strong>第偶数次</strong>向前播放，<strong>第奇数次</strong>向反方向播放。</li>
</ul>
<p>控制元素动画的<strong>播放状态</strong>：使用的是 animation-play-state 属性；其主要有两个值：<strong>running</strong> 和 <strong>paused</strong>。从命名也能看出是这是什么作用了，只是如果暂停了动画的播放，元素的样式将回到最原始设置状态（应该是形状和颜色，像背景、位置都是会保留的）。<br>设置动画<strong>时间外属性</strong>：animation-fill-mode 属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：</p>
<table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>效果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时，动画会反转到初始帧处</td>
</tr>
<tr>
<td>forwards</td>
<td>表示动画在结束后继续应用最后的关键帧的位置</td>
</tr>
<tr>
<td>backwards</td>
<td>会在向元素应用动画样式时迅速应用动画的初始帧</td>
</tr>
<tr>
<td>both</td>
<td>元素动画同时具有forwards和backwards效果</td>
</tr>
</tbody>
</table>
<h2 id="布局样式"><a href="#布局样式" class="headerlink" title="布局样式"></a>布局样式</h2><h3 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h3><p>应用多列布局非常简单，通过 columns 属性，语法：<code>columns：&lt;column-width&gt; || &lt;column-count&gt;</code><br>第一个为列宽，第二个是分为多少列，直接应用在某个 div 上就行，div 里面可以使用 p 或者 span 等标签来写文字</p>
<p>当然也可以拆开来写，比如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">column-width</span><span class="selector-pseudo">:200px</span>;</span><br><span class="line"><span class="selector-tag">-webkit-column-count</span><span class="selector-pseudo">:3</span>;</span><br><span class="line"><span class="selector-tag">column-count</span><span class="selector-pseudo">:3</span>;</span><br></pre></td></tr></table></figure>
<p>column-width 的值还可以设置为 auto 或者不写，那么就会按照其他属性自动适应，比如参考列数，列数如果设置为 auto 那么默认就当作是    1 列<br>还可以使用 column-gap 来设置<strong>列间距</strong>，语法：<code>column-gap: normal || &lt;length&gt;</code> ；normal 为默认值，为 1em（如果你的字号是px，其默认值为你的 font-size 值）<br>如需<strong>跨列</strong>的情况，可以使用：<code>column-span: none | all</code> 除了这两种，可以指定跨多少列，一般用于第一段，设置位 all<br>column-rule 主要是用来定义列与列之间的<strong>边框宽度、边框样式</strong>和<strong>边框颜色</strong>。简单点说，就有点类似于常用的 border 属性。但 column-rule 是<strong>不占用任何空间位置</strong>的，在列与列之间改变其宽度不会改变任何列的位置。</p>
<blockquote>
<p>  style 包括：none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。<br>  如果不希望显示边框的颜色，也可以将其设置为 transparent (透明色)</p>
<p>  使用如：<code>column-rule: 2px dotted green;</code></p>
</blockquote>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>通过设置 box-sizing 可以指定其解析方式：<code>box-sizing: content-box | border-box | inherit</code><br>我的简单理解为，第一种为 W3C 标准的盒模型，也是默认值 （element width/height = border + padding + content width / height）<br>第二种是 IE6 以下的盒模型 （元素的宽度或高度等于元素内容的宽度或高度；这里的内容宽度或高度包含了元素的border、padding、内容的宽度或高度（盒子的宽度或高度 - 边框 - 内距））<br>第三种是继承父元素的盒模型</p>
<blockquote>
<p>  总之，最大的用处就是<br>  在自适应布局当中，在元素基础上添加内距 padding，按照标准盒模型解析，往往会将布局撑破，但使用 box-sizing 的 border-box 值，可以让你轻松完成</p>
</blockquote>
<h3 id="伸缩布局"><a href="#伸缩布局" class="headerlink" title="伸缩布局"></a>伸缩布局</h3><p>CSS3 引入了一种新的布局模式——<strong>Flexbox布局</strong>，即<strong>伸缩布局盒模型</strong>（Flexible Box），用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的<strong>大小是未知或者动态的。</strong></p>
<p>Flexbox 布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。<br>Flexbox 布局在定义伸缩项目大小时<strong>伸缩容器会预留一些可用空间</strong>，让你可以调节伸缩项目的相对大小和位置。例如，你可以确保伸缩容器中的多余空间平均分配多个伸缩项目，当然，如果你的伸缩容器没有足够大的空间放置伸缩项目时，浏览器会根据一定的比例减少伸缩项目的大小，使其不溢出伸缩容器</p>
<blockquote>
<p>  Flexbox 规范版本众多，浏览器对此语法支持度也各有不同</p>
</blockquote>
<h2 id="生成内容"><a href="#生成内容" class="headerlink" title="生成内容"></a>生成内容</h2><p>这个属性我感觉很重要，用的很频繁！</p>
<blockquote>
<p>  在 Web 中插入内容，在 CSS2.1 时代依靠的是 JavaScript 来实现。但进入 CSS3 进代之后我们可以通过 CSS3 的伪类 <code>:before</code>，<code>:after</code>和 CSS3 的伪元素 <code>::before</code>、<code>::after</code>来实现，其关键是依靠 CSS3 中的 <code>content</code> 属性来实现。<br>  不过这个属性对于 img 和 input 元素不起作用。<br>  他们两者的区别可以参见：<a href="https://www.qianduan.net/before-and-before-the-difference-between/" target="_blank" rel="noopener">https://www.qianduan.net/before-and-before-the-difference-between/</a></p>
</blockquote>
<p><code>content</code> 的属性一般有：</p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>不生成任何内容</td>
</tr>
<tr>
<td>attr</td>
<td>插入标签属性值</td>
</tr>
<tr>
<td>url</td>
<td>使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）</td>
</tr>
<tr>
<td>string</td>
<td>插入字符串</td>
</tr>
</tbody>
</table>
<p>在 CSS 中有一种清除浮动的方法叫“clearfix”。而这个“clearfix”方法就中就使用了“content”，只不过只是在这里插入了一个空格。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>:””;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">	<span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自由缩放"><a href="#自由缩放" class="headerlink" title="自由缩放"></a>自由缩放</h2><p>为了增强用户体验，CSS3 增加了很多新的属性，其中 resize 就是一个重要的属性，<strong>它允许用户通过拖动的方式来修改元素的尺寸来改变元素的大小。</strong>到目前为止，可以使用 overflow 属性的任何容器元素。<br>resize 的取值：</p>
<table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>取值说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>用户不能拖动元素修改尺寸大小。</td>
</tr>
<tr>
<td>both</td>
<td>用户可以拖动元素，同时修改元素的宽度和高度</td>
</tr>
<tr>
<td>horizontal</td>
<td>用户可以拖动元素，仅可以修改元素的宽度，但不能修改元素的高度。</td>
</tr>
<tr>
<td>vertical</td>
<td>用户可以拖动元素，仅可以修改元素的高度，但不能修改元素的宽度。</td>
</tr>
<tr>
<td>inherit</td>
<td>继承父元素的resize属性值。</td>
</tr>
</tbody>
</table>
<h2 id="外轮廓属性"><a href="#外轮廓属性" class="headerlink" title="外轮廓属性"></a>外轮廓属性</h2><p>外轮廓 outline 在页面中呈现的效果和边框 border 呈现的效果极其相似，但和元素边框 border 完全不同，外轮廓线不占用网页布局空间，不一定是矩形，外轮廓是属于一种动态样式，<strong>只有元素获取到焦点或者被激活时呈现</strong>。取值为：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>属性值</strong></th>
<th style="text-align:left"><strong>属性值说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">outline-color</td>
<td style="text-align:left">定义轮廓线的颜色，属性值为CSS中定义的颜色值。在实际应用中，可以将此参数省略，省略时此参数的默认值为黑色。</td>
</tr>
<tr>
<td style="text-align:center">outline-style</td>
<td style="text-align:left">定义轮廓线的样式，属性为CSS中定义线的样式。在实际应用中，可以将此参数省略，省略时此参数的默认值为none，省略后不对该轮廓线进行任何绘制。</td>
</tr>
<tr>
<td style="text-align:center">outline-width</td>
<td style="text-align:left">定义轮廓线的宽度，属性值可以为一个宽度值。在实际应用中，可以将此参数省略，省略时此参数的默认值为medium，表示绘制中等宽度的轮廓线。</td>
</tr>
<tr>
<td style="text-align:center">outline-offset</td>
<td style="text-align:left">定义轮廓边框的偏移位置的数值，此值可以取负数值。当此参数的值为正数值，表示轮廓边框向外偏离多少个像素；当此参数的值为负数值，表示轮廓边框向内偏移多少个像素。</td>
</tr>
<tr>
<td style="text-align:center">inherit</td>
<td style="text-align:left">元素继承父元素的 outline 效果。</td>
</tr>
</tbody>
</table>
<p>例如：<code>outline: red solid 2px;</code></p>
<h2 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h2><p>简单说就是为了适应不同的设备而弄出来的，在 CSS2 中也是有的，叫 CSS3 Media Queries，目前大多数浏览器已经支持，使用方法类似：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* media 是在 css3 中新增的 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width:<span class="number">600px</span>) and (max-width:<span class="number">900px</span>)&#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:<span class="number">#f5f5f5</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 其他方式还有 link 和 import 这些在 css2 中就可以使用 */</span></span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href="style.css" media="screen" /&gt;</span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href="print.css" media="print" /&gt;</span><br><span class="line">@<span class="keyword">import</span> url(reset.css) screen;   </span><br><span class="line">@<span class="keyword">import</span> url(print.css) print;</span><br></pre></td></tr></table></figure>
<p>意思就是宽度在 600-900px 之间，中间的样式才会生效，这部分没怎么仔细去看，突然感觉前端真的是不容易<br>Media Queries 在其他浏览器中不要像其他 CSS3 属性一样在不同的浏览器中添加前缀。</p>
<p>这一部分最热的应该就是 Responsive 了，也就是常说的响应式布局，不过…..我没足够的耐心看下去了<br>使用 Responsive 的话就必须要使用 meta 标签：<code>&lt;meta name=”viewport” content=”” /&gt;</code> ；它用来处理可视区域，content 的取值嘛….</p>
<p>最后附一张相关的表，W3C 总共列出了10种媒体类型：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>设备类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>All</td>
<td>所有设备</td>
</tr>
<tr>
<td>Braille</td>
<td>盲人用点字法触觉回馈设备</td>
</tr>
<tr>
<td>Embossed</td>
<td>盲文打印机</td>
</tr>
<tr>
<td>Handheld</td>
<td>便携设备</td>
</tr>
<tr>
<td>Print</td>
<td>打印用纸或打印预览视图</td>
</tr>
<tr>
<td>Projection</td>
<td>各种投影设备</td>
</tr>
<tr>
<td>Screen</td>
<td>电脑显示器</td>
</tr>
<tr>
<td>Speech</td>
<td>语音或音频合成器</td>
</tr>
<tr>
<td>Tv</td>
<td>电视机类型设备</td>
</tr>
<tr>
<td>Tty</td>
<td>使用固定密度字母栅格的媒介，比如电传打字机和终端</td>
</tr>
</tbody>
</table>
<p>其中<strong>Screen</strong>、<strong>All</strong>和<strong>Print</strong>为最常见的三种媒体类型。</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java知识补充]]></title>
      <url>http://bfchengnuo.com/2017/05/26/Java%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      <content type="html"><![CDATA[<p>回过头发现有些 Java 基础并没有学好，也许是忘了也许是学的时候就没仔细看，那就在这里补回来<br>本篇介绍的是：迭代器、可变参数、枚举、反射、注解、动态代理的简单使用<a id="more"></a></p>
<h2 id="迭代器与for"><a href="#迭代器与for" class="headerlink" title="迭代器与for"></a>迭代器与for</h2><h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>Java 提供一个专门的迭代器 Iterator，它是一个接口，我们可以对某个序列实现该 interface，来提供标准的 Java 迭代器。Iterator 接口实现后的功能是“使用”一个迭代器，比如定义了 next 等方法<br>也就是说，实现了这个接口就可以称为是一个迭代器了</p>
<h3 id="Iterable可迭代对象"><a href="#Iterable可迭代对象" class="headerlink" title="Iterable可迭代对象"></a>Iterable可迭代对象</h3><p>Java 中还提供了一个 Iterable 接口，Iterable 接口实现后的功能是<strong>“返回”一个迭代器</strong>,我们常用的实现了该接口的子接口有:  Collection、Deque、List、Queue、Set 等，该接口的 <strong>iterator()</strong> 方法返回一个标准的 Iterator 实现。实现这个接口允许对象成为 For each 语句的目标。就可以通过 For each 语法遍历你的底层序列。<br>也就是说：实现这个接口允许对象成为 “foreach” 语句的目标，实现接口就成为了可以被迭代的对象。<br><strong>Iterable 接口包含一个能够产生 Iterator 的 iterator() 方法</strong>，并且 Iterable 接口被 foreach 用来在序列中移动。因此如果创建了任何实现 Iterable 接口的类，都可以将它用于 foreach 语句中。</p>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h3><p>forEach 不是关键字，关键字还是 for，语句是由 iterator 实现的，他们最大的不同之处就在于 <strong>remove()</strong> 等方法上。<br>但是，如果在循环的过程中调用集合的 remove() 方法，就会导致循环出错，因为循环过程中 <code>list.size()</code> 的大小变化了，就导致了错误。 所以，如果想在循环语句中删除集合中的某个元素，就要用迭代器 iterator 的 remove() 方法，因为它的 remove() 方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的 remove() 方法，调用之前至少有一次 next() 方法的调用。</p>
<p><strong>forEach 就是为了让用 iterator 循环访问的形式简单，写起来更方便。</strong>当然功能不太全，所以但如有删除等操作，还是要用它原来的形式。</p>
<h3 id="Iterator与for特点"><a href="#Iterator与for特点" class="headerlink" title="Iterator与for特点"></a>Iterator与for特点</h3><p>采用 ArrayList 对<strong>随机访问</strong>比较快，而 for 循环中的 get() 方法，采用的即是随机访问的方法，<strong>因此在 ArrayList 里，for 循环较快</strong></p>
<p>采用 LinkedList 则是<strong>顺序访问</strong>比较快，iterator 中的 next() 方法，采用的即是顺序访问的方法，<strong>因此在LinkedList 里，使用 iterator 较快</strong></p>
<p>从数据结构角度分析, <strong>for 循环适合访问顺序结构，可以根据下标快速获取指定元素；而 Iterator 适合访问链式结构，因为迭代器是通过 next() 和 Pre() 来定位的，可以访问没有顺序的集合.</strong></p>
<p>而使用 Iterator 的好处在于可以使用相同方式去遍历集合中元素，而不用考虑集合类的内部实现（只要它实现了 <code>java.lang.Iterable</code> 接口），如果使用 Iterator 来遍历集合中元素，一旦不再使用 List 转而使用 Set 来组织数据，那<strong>遍历元素的代码不用做任何修改</strong>，如果使用 for 来遍历，那所有遍历此集合的算法都得做相应调整,因为List 有序, Set 无序,结构不同,他们的访问算法也不一样.<br>清空 List 的时候（单条删除），除了使用迭代器，用 for 条件倒序删除就不会出现越界问题，想出这个方法的真是人才…</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数完全可以当作数组来用，是在 Java5 加入的，如果有多个参数可变参数必须在最后<br>因为可变参数基本等同于数组，所以甚至可以直接传一个数组给他，关于可变参数在 API 文档中随处可见，比如我想到了 <code>Arrays.asList()</code> 这个方法，你可以传出多个参数也可以直接传入一个数组（这个方法接收的是对象参数，不要传基本类型的数组啊，要不然整个数组会被当作一个参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = testSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">	System.out.println(testSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testSum</span><span class="params">(<span class="keyword">int</span> ...nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">            nums) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举的情况不算少，就是那种需要传入一些固定的参数的方法，比如一个方法允许传入的参数值就两种字符 A 和 B 吧，但是如果定义为 char 类型的话调用者可以瞎鸡巴传的，传个 D 、E、F 都是合法的，枚举就是用来做这个的<br>当然也可以自定义一个类，然后把构造方法私有了，内部制造出指定的几个，这样就太麻烦了，看下面定义个简单的枚举，相当于是个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">    A, B, C, D, E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来非常简单，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        enumTest(TestEnum.A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumTest</span><span class="params">(TestEnum e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name ---&gt;"</span> + e.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是最最简单的使用，既然枚举相当于一个类，那么它也有构造函数，也有字段、方法，还可以定义抽象方法，不过要在声明枚举项的时候也就是上面的 A B C D 的时候给复写了，这样就可以直接通过 <code>TestEnum.A.methodName()</code> 的形式调用<br>具体的栗子代码放在了<a href="https://github.com/bfchengnuo/java_learn/blob/master/XC/JavaEE/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E6%9E%9A%E4%B8%BE/VarPar.java" target="_blank" rel="noopener">这里Github</a></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射技术非常的重要，一般用于来做框架，虽然做框架都是大牛，但是不懂反射也看不懂框架啊，那就没法用啊，所以还是很有必要的，可以不用精通嘛<br>反射就是加载类，并解剖出类的各个组成部分；别人扔给你一个编译后的类，你不知道里面是啥东西吧，然后别人可能会告诉你里面有个什么方法，这时候想要执行就得用反射，首先把类给搞进去，弄出个对象来，然后检测有没有这个方法，有就调用呗</p>
<p>获取类的字节码文件，也就是把类加载到内存中去，一般有三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = (Class&lt;Student&gt;) Class.forName(<span class="string">"com.bfchengnuo.reflect.Student"</span>); <span class="comment">// 完整路径</span></span><br><span class="line"><span class="comment">//Class clazz = new Student().getClass();</span></span><br><span class="line"><span class="comment">//Class clazz = Student.class;</span></span><br></pre></td></tr></table></figure>
<p>通过反射加载了类下一步就是创建对象了，也就是要获取构造函数了，另外还可以获得方法、字段等，反正啥都可以得到，这就反射的厉害之处<br>详细的反射不在这写了，在 <a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/JavaEE/%E5%8F%8D%E5%B0%84/reflect" target="_blank" rel="noopener">Github</a> 上有</p>
<h3 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h3><p>内省可以当作是反射技术中的一类特殊的情况，它是<strong>专门来处理 JavaBean 类的</strong>，Java 还提供了相关的 API<br>简单说就是：内省就是用来访问某个属性的 getter/setter 方法的</p>
<blockquote>
<p>  一般在 JavaBean 中会从 Object 中继承一个属性，Object 中有个 getClass 方法啦</p>
</blockquote>
<p>关于内省 Java 提供的 API 中，最重要的是 Introspector 类，它确定了到底“省”谁，被省了以后就会把 bean 的信息封装到一个 BeanInfo 中去；下面基本就是执行其 set 方法填充数据，或者 get 方法获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IntrospectionException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取javabean的所有属性</span></span><br><span class="line">    <span class="comment">//BeanInfo beanInfo = Introspector.getBeanInfo(Stu.class);</span></span><br><span class="line">    <span class="comment">// 除去从 obj 继承的属性</span></span><br><span class="line">    BeanInfo beanInfo = Introspector.getBeanInfo(Stu.class,Object.class);</span><br><span class="line">    PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();  <span class="comment">// 得到属性描述符</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">        <span class="comment">// 获得属性名</span></span><br><span class="line">        System.out.println(pd.getName());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 相当于是拿到set方法</span></span><br><span class="line">        Method writeMethod = pd.getWriteMethod();</span><br><span class="line">        <span class="comment">// 执行方法，填充数据</span></span><br><span class="line">        writeMethod.invoke(<span class="keyword">new</span> Stu(),<span class="string">"loli"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到get方法</span></span><br><span class="line">        Method readMethod = pd.getReadMethod();</span><br><span class="line">        readMethod.invoke(<span class="keyword">new</span> Stu(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解的出现，就是为了代替配置文件（比如 XML）的。注解是给程序看的，所以如果想要用自定义注解，那就要必须让程序（编译器）看明白才行，关键字 @interface 意思就是定义一个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元注解，给注解加注解，分别是：指定保留域、作用在那、可继承</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 可以定义八种基本数据类型、字符串、其他注解、类、枚举；当然也可以是数组</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以配置缺省值</span></span><br><span class="line">    <span class="function">Class <span class="title">clazz</span><span class="params">()</span> <span class="keyword">default</span> String.class</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value 是比较特殊的，只有一个属性 value 的话，赋值的时候可以省略属性名</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义后就可以使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射，获取注解的信息，首先获取到方法，这个是获取公共方法的....</span></span><br><span class="line">            Method method = Main.class.getMethod(<span class="string">"test"</span>);</span><br><span class="line">            <span class="comment">// 获取到注解信息</span></span><br><span class="line">            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            name = annotation.name();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(name = <span class="string">"loli"</span>, age = <span class="number">12</span>, value = &#123;<span class="string">"test"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 2017/5/24  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了注解虽然不需要再配置 XML 了，也非常的直观，但是，弊端也体现出来了，如果想要改动配置，必须要修改 java 文件….还得重新进行编译<br>高级的用法就是，有可能加了一个注解就拥有了一个对象，说到底还是通过反射技术来实现的，通过反射解析出创建那个类，以及相应的数据，然后再利用反射设置到这个变量上去就行了（注入对象）</p>
<p>完整代码参考：<a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/JavaEE/%E6%B3%A8%E8%A7%A3" target="_blank" rel="noopener">Github</a></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的意义在于：<strong>拦截对真实业务对象的访问</strong> ；拦截以后可以干嘛呢，这个就看需求了，比如可以对方法进行增强啥的，就不需要使用包装模式了</p>
<p>动态代理是利用 JavaAPI 在内存中动态的构建代理对象，套路一般是从被代理者上抽取一个接口，这个接口在后面有大用处，也是 Java 的规定，相关的 API 在反射包下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽取的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hug</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的被代理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(づ｡◕‿‿◕｡)づ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开吃...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"吃饱了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是代理者了，一般内部维护一个具体被代理的对象，然后通过 Java 自带的 API ( <code>Proxy.newProxyInstance()</code> ) 返回给调用者一个代理者，也就是一个接口，当调用这个接口的方法时，会自动携带相关参数到 invoke 方法，嗯？！就是回调，然后在这个方法中进行一些判断或者增强啥的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoliProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StandardLoli mLoli = <span class="keyword">new</span> StandardLoli();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Loli <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定写法</span></span><br><span class="line">        <span class="comment">// 1.第一个参数是类加载器，用当前的类获取就可以，或者 mLoli</span></span><br><span class="line">        <span class="comment">// 2.第二个为被代理者的接口，是接口</span></span><br><span class="line">        <span class="comment">// 3.第三个为核心，返回的代理调用时就是调用这个方法</span></span><br><span class="line">        <span class="comment">//      在这个方法里判断是调用的那个方法，然后执行相应的处理</span></span><br><span class="line">        <span class="keyword">return</span> (Loli) Proxy.newProxyInstance(StandardLoliProxy.class.getClassLoader(), mLoli.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equalsIgnoreCase(<span class="string">"hug"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"确认身份..."</span>);</span><br><span class="line">                    <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"bfchengnuo"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(mLoli, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equalsIgnoreCase(<span class="string">"eat"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"代理人..."</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(mLoli, args);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"其他方法不允许执行！"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把内部维护的对象设置为 Object（使用泛型可能会更好），当然返回值也要是 Object 了，那么就成为了一个通用的代理对象了；最后简单测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StandardLoliProxy proxy = <span class="keyword">new</span> StandardLoliProxy();</span><br><span class="line">        Loli loli = proxy.createProxy();</span><br><span class="line"></span><br><span class="line">        loli.hug(<span class="string">"bfchengnuo"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        String result = loli.eat();</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>+ result +<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="comment">// loli.hashCode();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实除了动态代理还有静态代理，静态代理需要实现和代理对象相同的接口，在内部维护一个代理对象的实例，然后最后调用的是代理的方法（也就是 proxy.xxx 的方式），在调用代理类的方法中会调用内部实例的方法，有点类似装饰模式了，不建议使用</p>
<h2 id="List家族"><a href="#List家族" class="headerlink" title="List家族"></a>List家族</h2><p>两大支柱当然就是 ArrayList 与 LinkedList 了，以往我们都是说 ArrayList 采用连续存储随机查找、读取快，增删慢；LinkedList 采用链表，增删快，随机访问慢。<br>这样说确实没问题，不过实际上还是有点差别，主要是我们忽略了“定位”的时间来说的，如果算上这个时间，直观上 ArrayList 可以完胜了，当然是在性能上。</p>
<p>拜读了这个系列的文章，对我的认知产生了不小的冲击，<a href="https://mp.weixin.qq.com/s/QQDJswjSyuTUntTBpEr06Q" target="_blank" rel="noopener">原文地址</a><br>另外也可以看看我的笔记本里<a href="https://bfchengnuo.com/MyRecord/#/%E7%AC%94%E8%AE%B0/Java/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92%28%E4%BA%8C%29?id=arraylist%E5%92%8Clinkedlist">对应地址</a></p>
<p>确实有点出乎意料，按照这样的观点，LinkedList <strong>性能上</strong>岂不是没有任何优势根据第二篇介绍， LinkedList 因为双向链表，添加元素可以两边查找，所以在中间插入最耗时，Array 当然是开头插入最耗时，因为越是靠前需要进行移动的元素越多；<br>然而，无论哪一种，作者测试都是 ArrayList 遥遥领先…..但是 LinkedList 的耗时其实全部都用在了定位元素上，真正的插入和删除只是修改几个链接，是不耗时的；<br>无奈 ArrayList 使用 native 提速后一般的增删和链表差不多了，甚至反超…..看来维护双向链表的成本确实很大啊~</p>
<p>PS：与上面的迭代器相关内容没有影响。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>所有的包装类都默认实现了 Serializable 接口<br>也就是说，如果你不确定传过来的值是 String 还是 Long 或者 Integer 等对象，就可以使用 Serializable 来接收了！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/redcoatjk/articles/4863340.html" target="_blank" rel="noopener">迭代器与for相关</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的事件处理]]></title>
      <url>http://bfchengnuo.com/2017/05/20/Java%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>紧接着上一篇说，学习观察者模式的时候看到了这个事件处理机制，大体浏览了一下就是用的观察者模式嘛，并且是惊人的相似，既然这样那就顺便写写啦</p>
<p>Java 的事件机制中一共设计到3个角色，分别是：<strong>事件源、事件对象、事件监听器</strong><a id="more"></a><br>事件源上发生某操作的时候，会调用事件监听器里的相应的监听方法，并在调用这个方法的时候把事件对象传递过去，事件监听器由开发人员编写<br>所以在事件监听器中可以通过事件对象拿到相应的事件源</p>
<p>举个栗子，比如把一个窗口当作是事件源，当点击这个窗口上的某个按钮的时候就相当于触发了一个事件，然后会被事件监听器捕获到，交给相应的方法去处理（会携带事件对象）</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p>首先定义/确定一个事件源，我呢，就继续厚颜无耻的改造下前面的代码用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoli</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"佳芷"</span>;</span><br><span class="line">    <span class="keyword">private</span> LoliListeners listeners;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当事件触发的时候通知相应的监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大哥哥"</span> + name + <span class="string">"快来呀！！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Event event = <span class="keyword">new</span> Event(<span class="keyword">this</span>);</span><br><span class="line">            listeners.speakListeners(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(づ｡◕‿‿◕｡)づ"</span>);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Event event = <span class="keyword">new</span> Event(<span class="keyword">this</span>);</span><br><span class="line">            listeners.hugListeners(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个注册监听器的方法，由事件源对象调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">(LoliListeners listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然是允许注册多个监听器的，那就要定义一个集合来存储了，和前面的观察者模式一样，我就简单起见，只写了一个的情况</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>我认为事件对象就是用于传递对象或者说是数据的，当事件触发的时候通知事件监听器的时候总是会带点东西过去吧….最起码也得把自己带过去啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StandardLoli mStandardLoli;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(StandardLoli standardLoli)</span> </span>&#123;</span><br><span class="line">        mStandardLoli = standardLoli;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StandardLoli <span class="title">getStandardLoli</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStandardLoli;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里还真的就只带了自己过去，或者可以加一个 status 的属性</p>
<h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>与其相关的有两个类，一个是接口，一个是它的实现类；接口的作用嘛，除了规范主要就是用来在事件源中调用未来的方法的！这个说法很好啊，因为事件源中触发事件后调用监听器的方法时确实不知道你是怎么实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoliListeners</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个监听方法对应一个事件源中的需要被监听方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speakListeners</span><span class="params">(Event event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hugListeners</span><span class="params">(Event event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>废话不说，接着是它的实现类，也就是真正的事件监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListeners</span> <span class="keyword">implements</span> <span class="title">LoliListeners</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speakListeners</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        StandardLoli loli = event.getStandardLoli();</span><br><span class="line">        System.out.println(loli.getName() + <span class="string">"我来了！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hugListeners</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抱抱.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我都感觉我的命名和方法有些丧心病狂…..</p>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>最后一步就是进行测试了，也就是实际用的时候应该怎么用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 事件源</span></span><br><span class="line">        StandardLoli loli = <span class="keyword">new</span> StandardLoli();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册监听器</span></span><br><span class="line">        loli.registerListeners(<span class="keyword">new</span> MyListeners());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test</span></span><br><span class="line">        loli.speak(<span class="string">"bfchengnuo"</span>);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        loli.hug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Java默认实现"><a href="#使用Java默认实现" class="headerlink" title="使用Java默认实现"></a>使用Java默认实现</h2><p>巧了，在 Java 中的 util 包中也提供了相关的类和接口，但是我感觉吧，比较鸡助啊，也许是我还没有领会到其中的精髓吧，那就再把上面的代码改把改把吧，先来看看 Java 给提供了那些东西：</p>
<ul>
<li><code>public interface EventListener</code><br>所有事件监听器接口必须扩展的<strong>标记接口</strong>。</li>
<li><code>public class EventObject extends Object implements Serializable</code><br>所有事件状态对象都将从其派生的根类。 所有 Event 在构造时都引用了对象 “source”，在逻辑上认为该对象是最初发生有关 Event 的对象。</li>
</ul>
<h3 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h3><p>这次从事件对象写起，必须继承 EventObject 类，这样就不用定义保存事件源的对象了，此外只是定义了一个 status 的属性而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a prototypical Event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source The object on which the Event initially occurred.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if source is null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(Object source, String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于继承的作用，应该也看出来了，就是那个构造方法</p>
<h3 id="监听接口"><a href="#监听接口" class="headerlink" title="监听接口"></a>监听接口</h3><p>是的，是定义一个接口，和上面的类似，只不过这个接口要<strong>继承 EventListener</strong> ，这是一个标记接口，就算打了标记，我目前认为没什么太大的作用，不过看看 API 手册又有另一番感慨…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoliListeners</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个监听方法对应一个事件源中的需要被监听方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Event event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doHug</span><span class="params">(Event event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监听接口的实现"><a href="#监听接口的实现" class="headerlink" title="监听接口的实现"></a>监听接口的实现</h3><p>和上面一样的套路，代码也基本一样，不多说，当然，可以定义多个实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListeners</span> <span class="keyword">implements</span> <span class="title">LoliListeners</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到事件源对象</span></span><br><span class="line">        StandardLoli loli = (StandardLoli) event.getSource();</span><br><span class="line">        System.out.println(loli.getName() + <span class="string">"我来了！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHug</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        String status = event.getStatus();</span><br><span class="line">        System.out.println(<span class="string">"抱抱，状态"</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了上面的类，还需要一个 事件源对象和测试的类，这个两个完全可以照搬前面的代码，都不用改的</p>
<p>所以，使用 Java 的默认实现我也没感觉有多大的好处，代码也没少些嘛，也许是我功底不够理解不到，等我理解到了再回来写上哈</p>
<p>完整测试代码在 <a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/%E5%85%B6%E4%BB%96/Java%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-%E7%9B%91%E5%90%AC%E5%99%A8" target="_blank" rel="noopener">Github</a></p>
<blockquote>
<p>  EventListener 接口，这是由几十个其他接口扩展的 Java API，你可以使用一个标记接口来建立一组接口的父接口。<br>  例如：当一个接口继承了 EventListener 接口，Java 虚拟机 (JVM) 就知道该接口将要被用于一个事件的代理方案。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-观察者模式]]></title>
      <url>http://bfchengnuo.com/2017/05/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>什么是观察者模式，Wiki 上的定义为：</p>
<blockquote>
<p>  观察者模式是软件设计模式的一种。在此种模式中，一个目标对象<strong>管理</strong>所有相依于它的观察者对象，并且在它本身的状态改变时<strong>主动发出通知</strong>。<br>  这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来<strong>实时事件处理系统</strong>。</p>
</blockquote>
<p>通过定义也可以看出，一个对象是可以对应多个观察者的，当这个对象发生变化时，会通知所有的观察者，让它们能够自动更新自己<a id="more"></a><br>观察者还是 JDK 中使用最多的模式之一，相当于定义了对象之间的一对多依赖</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>观察者模式涉及到了4个角色：</p>
<ul>
<li><strong>抽象目标(Subject)角色</strong>：<br>此抽象类提供一个界面让观察者进行添附与解附作业。通俗理解就是主要定义三个功能的方法，注册、删除、更新（通知）观察者</li>
<li><strong>具体目标(ConcreteSubject)角色</strong>：<br>将有关<strong>状态</strong>存入具体观察者对象；在具体目标的内部状态改变时，给所有登记过的观察者发出通知。</li>
<li><strong>抽象观察者(Observer)角色</strong>：<br>为所有的具体观察者定义一个接口，在得到目标（被观察者）的通知时更新自己，这个接口叫做更新接口。</li>
<li><strong>具体观察者(ConcreteObserver)角色</strong>：<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与目标（被观察者）的状态相协调。如果需要，具体观察者角色可以保持一个指向具体目标对象的引用。每个观察者类别都要实做它自己的更新函式，以应对状态更新的情形。</li>
</ul>
<p>可以看出，我们常说的“回调机制”就是它的一种体现形式嘛~~~回调的对象其实就是一个观察者嘛 （: 雾</p>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>下面就开始具体写这四个角色了，具体的写法不是固定的，我也看到了好多不同的写法，思路是差不多的<br>观察者模式的代表人物就是 MVC 了！！</p>
<h3 id="抽象目标角色"><a href="#抽象目标角色" class="headerlink" title="抽象目标角色"></a>抽象目标角色</h3><p>首先写<strong>抽象目标角色</strong>吧，正如上面所说，主要定义的是<strong>对观察者的一些列操作</strong>，我呢，继续偷懒尽可能复用前面的代码了 o(*≧▽≦)ツ<br>或者你可以按照 HeadFirst 中的叫法：主题（抽象）；想象成出版社？负责内容的更新以及通知相应的订阅者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StandardLoli</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Lolicon observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Lolicon observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(StandardLoliImpl data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到网上的一些其他实现是把这个类定义为抽象类，然后把上面的方法给实现了，因为所有的被观察者的实现基本都是一个套路</p>
<h3 id="具体目标角色"><a href="#具体目标角色" class="headerlink" title="具体目标角色"></a>具体目标角色</h3><p>也就是所说的 <strong>被观察者</strong> 了，我是在这里实现的抽象目标的方法，register 等方法是给 new 出的具体的对象调用的<br>就是上面所说的主题的具体的实现了。相当于具体的某家出版社<br>这个类通常会有一个属性表示状态….这里没写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoliImpl</span> <span class="keyword">implements</span> <span class="title">StandardLoli</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用来保存所有的已注册的观察者</span></span><br><span class="line">    <span class="comment">// 如果要频繁的增删那要使用 LinkedList</span></span><br><span class="line">    <span class="comment">// 如果要多线程同步操作，要把 list 转化为安全的 Collections.synchronizedList(list);</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Lolicon&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"佳芷"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法就当作是更新状态的方法吧</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大哥哥"</span> + name + <span class="string">"快来呀！！"</span>);</span><br><span class="line">        <span class="comment">// 更新完后通知所有观察者</span></span><br><span class="line">        notifyObservers(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Lolicon observer)</span> </span>&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Lolicon observer)</span> </span>&#123;</span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(StandardLoliImpl data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通知所有的已注册的观察者更新自己</span></span><br><span class="line">        <span class="comment">// 如果是用的 LinkedList 或者 Map 之类的要使用迭代器进行迭代</span></span><br><span class="line">        <span class="keyword">for</span> (Lolicon lolicon : list) &#123;</span><br><span class="line">            lolicon.update(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notifyObservers 的参数应该是接口的，我就是图方便直接写的实现类啦~<br>如果是使用的抽象类的方式，这里只要定义一个状态标志变量和 change 方法（相当于我的 speak 方法）就行了，具体的可以见参考里的第二个连接</p>
<h3 id="抽象观察者角色"><a href="#抽象观察者角色" class="headerlink" title="抽象观察者角色"></a>抽象观察者角色</h3><p>这个才是最简单的一个接口，就一个方法，用来更新观察者状态的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lolicon</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 更新的时候可以接受一个被观察者对象，用于获取相关信息</span></span><br><span class="line">    <span class="comment">// 这里直接传实现类了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(StandardLoliImpl loli)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观察者角色"><a href="#观察者角色" class="headerlink" title="观察者角色"></a>观察者角色</h3><p>被观察者状态变化后调用，用来通知观察者进行相应的更新自己</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoliconImpl</span> <span class="keyword">implements</span> <span class="title">Lolicon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String status = <span class="string">"我来了！！！"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被观察者更新时会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(StandardLoliImpl loli)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新自己.....</span></span><br><span class="line">        System.out.println(status + loli.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>好了，所有的角色都定义完毕，下面就开始操练起来了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被观察者</span></span><br><span class="line">        StandardLoliImpl standardLoli = <span class="keyword">new</span> StandardLoliImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建观察者</span></span><br><span class="line">        LoliconImpl lolicon = <span class="keyword">new</span> LoliconImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将观察者注册到被观察者上</span></span><br><span class="line">        standardLoli.register(lolicon);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新被观察者，观察者也会自动更新自己的状态</span></span><br><span class="line">        standardLoli.speak(<span class="string">"bfchengnuo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点，<del>很多人</del> （反正我是…..）都不会这样严格的定义，定义四个类太麻烦啦，我嘛，简单的功能就会省略掉抽象目标角色了…<br>果然是不是非常像我们常用的“回调机制”</p>
<h2 id="使用Java的默认实现"><a href="#使用Java的默认实现" class="headerlink" title="使用Java的默认实现"></a>使用Java的默认实现</h2><p>其实在 java 中实现观察者模式还有一种更简单的方式，它已经给我们提供好类使用了。<br>需要用到 <code>java.util</code> 包中提供的 <strong>Observable</strong> 类和 <strong>Observer</strong> 接口，分别对应 被观察者、观察者</p>
<p>被观察者需要<strong>继承 Observable</strong> ；它已经给你写好注册、取消等方法了，省事了不少，直接 super 调就行，不过需要注意的是 setChanged 方法，如果你不调用这个告诉它数据已经变化，notifyObservers 是不会执行的<br>这样其实有个好处就是避免了频繁的更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoli</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"佳芷"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法就当作是更新状态的方法吧</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大哥哥"</span> + name + <span class="string">"快来呀！！"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记此 Observable 对象为已改变的对象；现在 hasChanged 方法将返回 true</span></span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">        <span class="comment">// 更新完后通知所有观察者</span></span><br><span class="line">        <span class="comment">// 如果 hasChanged 方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来指示此对象不再改变。</span></span><br><span class="line">        <span class="comment">// 还可以携带一个对象传递</span></span><br><span class="line">        <span class="keyword">super</span>.notifyObservers();</span><br><span class="line">        <span class="comment">// super.notifyObservers("data");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Observable 内部保存多个观察者的是一个 AbstractList 集合，看一下源码应该已经保证了线程安全，但是因为它和 ArrayList 的存储结构是一样的，如果需要频繁操作还是要用链表<br>notifyObservers 方法可以传一个 data 数据，这相当于是“推”；如果不传就相当于“拉”；所以，Java 的实现是支持这两种方式的</p>
<p>然后就是观察者了，需要<strong>实现 Observer 接口，重写 update 方法</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lolicon</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String status = <span class="string">"我来了！！！"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lolicon</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lolicon</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会传递过来被观察者的对象实体，和数据（如果有的话）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新自己.....</span></span><br><span class="line">        StandardLoli loli = (StandardLoli) o;</span><br><span class="line">        System.out.println(status + loli.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在这里的构造函数中可以接收一个被观察者，直接将本对象注册，这好像才是比较正确的使用姿势……<br>然后写个测试类来测试下，看看效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被观察者</span></span><br><span class="line">        StandardLoli loli = <span class="keyword">new</span> StandardLoli();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建观察者</span></span><br><span class="line">        Lolicon lolicon1 = <span class="keyword">new</span> Lolicon();</span><br><span class="line">        Lolicon lolicon2 = <span class="keyword">new</span> Lolicon(<span class="string">"飞奔而来!!"</span>);</span><br><span class="line">        Lolicon lolicon3 = <span class="keyword">new</span> Lolicon(<span class="string">"从天而降!!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册观察者，顺序是先加入的后执行</span></span><br><span class="line">        loli.addObserver(lolicon1);</span><br><span class="line">        loli.addObserver(lolicon2);</span><br><span class="line">        loli.addObserver(lolicon3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新被观察者状态</span></span><br><span class="line">        loli.speak(<span class="string">"bfchengnuo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，这样看的话确实简单了不少，只需要两个类呢</p>
<blockquote>
<p>  使用 Java 的实现时；不要依赖于观察者被通知的次序<br>  因为 notifyObservers 是 Java 它实现的，具体的实现思路可能和我们自己的并不相同</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这里推荐一篇文章：<br><a href="https://www.zybuluo.com/pastqing/note/191632" target="_blank" rel="noopener">https://www.zybuluo.com/pastqing/note/191632</a><br><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构中的树]]></title>
      <url>http://bfchengnuo.com/2017/05/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>今天刚好有机会复习了下数据结构里的树，悲哀的发现基本快忘光啦！看来是需要做点记录什么的了！<br>正好前几天学 JDBC 的时候在数据库设计的时候还有点这方面的东西没说，这次一并补上！<a id="more"></a></p>
<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><ol>
<li>非空二叉树的第 n 层上至多有 <strong>2^(n-1)</strong> 个元素。</li>
<li>深度为 h 的二叉树至多有  <strong>2^h-1</strong> 个结点。</li>
</ol>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p><strong>在满二叉树中若其深度为h，则其所包含的结点数必为 2^h-1 。</strong><br>所有终端都在同一层次，且非终端结点的度数为2。<br>通俗讲就是： <strong>要么是叶子结点(结点的度为0)，要么结点同时具有左右子树 (结点的度为 2 )。</strong></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树是由满二叉树而引出来的。对于深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 K 的满二叉树中编号从 1 至 n 的结点一一对应时称之为完全二叉树。<br>就是说：每层结点都完全填满，在最后一层上如果不是满的，则只缺少右边的若干结点，就是不能出现只有右边没有左边的情况，你可以都没有或者只有左边，或者都有。<br><strong>对于完全二叉树，设一个结点为 i 则其父节点为 i/2 ，2i 为左子节点，2i+1 为右子节点。</strong></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>主要说的是深度优先的遍历方法，使用的均是递归的思想</p>
<ul>
<li>先序遍历<br>根-左-右</li>
<li>中序遍历<br>左-根-右</li>
<li>后序遍历<br>左-右-根</li>
</ul>
<p><img src="/image/dev/二叉树.jpg" alt="二叉树.jpg"><br>前序遍历：abdefgc<br>中序遍历：debgfac<br>后序遍历：edgfbca<br>层次遍历(广度优先了)：abcdfeg</p>
<h2 id="根据序列画二叉树"><a href="#根据序列画二叉树" class="headerlink" title="根据序列画二叉树"></a>根据序列画二叉树</h2><p>这应该是考试最喜欢的题目了，给两个遍历序列让你还原二叉树啥的<br>要还原出二叉树，必须要给一个 <strong>中序遍历</strong> 的序列才行，另外一个无所谓了</p>
<p>套路就是根据先序遍历或者后序遍历确定根的位置，然后根据中序遍历确定左右分支<br>来个栗子：<br>已知：先序遍历为： abdgcefh ；中序遍历为：dgbaechf；方便起见，先序遍历编号为1号，另一个为2号</p>
<p>下面开始画，首先根据先序遍历确定根是 a；然后再看2号，<code>dgb |a| echf</code> ；这样就分开了，左边的是左半枝，右边的是右半枝；先画左半枝吧，那要先确定左边的根是谁，也就是 a 的孩子是谁，拿着左半边的 dgb 去1号找，发现 b 在最前面，先序遍历最前面的就是根啦！所以就确定 a 的左孩子就是 b 了，然后再用 b 根据2号确定左半枝是 dg，右半枝是空，然后依次类推…最后得出：<br><img src="/image/dev/推算的二叉树.jpg" alt="推算的二叉树.jpg"></p>
<h2 id="树的转换"><a href="#树的转换" class="headerlink" title="树的转换"></a>树的转换</h2><p>树和二叉树之间可以转换，森林于二叉树之间也可以转换，二叉树就是吊</p>
<h3 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h3><p>一般的套路就是 画线、抹线、旋转（调整），这个方法就不说了，一搜一大把，利用规律可以不用画线快速写出来，比如下面的一颗简单的树：<br><img src="/image/dev/树.jpg" alt="树.jpg"><br><strong>遵循的套路是：如果此节点有孩子，把最左边（或者叫第一个）的孩子挂在左孩子的位置，如果有直接兄弟，就挂在右孩子的位置</strong><br>按照上面的图画的步骤是：首先 A 是根节点，最左边的孩子是 B ，就把 B 放在 A 的左孩子位置，A 没有兄弟所有右孩子的位置为空；<br>这样 A 就画完了，继续画 B ，B 的左孩子位置应该是第一个孩子 E , 右孩子应该是 B 的兄弟 C ，依次画下去….最后：<br><img src="/image/dev/转换后的二叉树.jpg" alt="转换后的二叉树.jpg"><br>如何把这个二叉树还原成树呢，也很简单，就是逆操作！<br><strong>套路是：此节点如果有左孩子，就变成其的孩子，它的所有的右分支就是其兄弟</strong><br>还是上图：A 有左孩子 B ，所以 B 是它（还原成树后的）的孩子，A 没有右孩子，所有没有兄弟，就是所谓的 根 了！然后再看 B，<br>B 有左孩子 E ，所以 E 是它的孩子，同时 B 的右分支有 C、D（就是顺着右边那条线下去）；所以 C 和 D 是它的兄弟节点，依次画下去….</p>
<div class="note warning"><p>由于树根没有兄弟，故树转化为二叉树后，二叉树的根结点的右子树必为空。</p>
</div>
<h3 id="森林与二叉树"><a href="#森林与二叉树" class="headerlink" title="森林与二叉树"></a>森林与二叉树</h3><p>森林就是由多棵树组成的，所以套路一样，首先把森林里的每棵树按照上面的套路弄成二叉树 ，树转化为二叉树有个特点就是根节点的右孩子是空的！<br>所以，找棵树的根作为主根，其他树往主根的右孩子节点上挂就是了，然后最后旋转调整下，其实相当于抓住主根向上拎一下，然后自然就是一个二叉树了！</p>
<p>顺着右孩子数，每一个节点就是一棵树，也能很容易看出这个森林由多少树组成的！<br>至于拆，也一个样，顺着右孩子的<strong>每一个节点</strong>拆下来就是一棵树，然后按照上面的套路再还原回去就行了</p>
<h2 id="数据库无限分类设计"><a href="#数据库无限分类设计" class="headerlink" title="数据库无限分类设计"></a>数据库无限分类设计</h2><p>在前面说数据库表的设计的时候，有个叫自连接的方案，是给关于分类这种场景用的，使用一张表存，用一个字段指向本表中的父节点的 id ，应该还记得…<br>这样有个很明显的问题是，当层次很深的时候查询非常慢，因为要递归！</p>
<p>于是，就有好事之人画了这这图：<br><img src="/image/dev/树结构.jpg" alt="树结构.jpg"><br>按照这样的结构在数据库存储，很明显这是二叉树，并且还是先序遍历，按照上图设计每一个节点也就是分类、对象的表结构，除了名称和 id 要加一个左值和右值了</p>
<p>通过上面的二叉树的图可以看出有几个特点：</p>
<ul>
<li>找某个分类下的条目就是左值和右值之间的条目<br>比如：找笔记本分类下的所有商品就是在 12-17 之间找</li>
<li>层次（深度）就是看属于几个根而决定的，或者说看有几个爸爸<br>比如：西门子有冰箱和商品两个爸爸，那深度就是3</li>
<li>区分父子节点<br>爸爸的左值小于孩子的左值；爸爸的右值大于孩子的右值</li>
<li>层次的顺序问题<br>顺序和左值相关，左值越小的应该排在最前面，当然是对某一分类而言</li>
<li>增加某个节点<br>只需要把后面的节点的左值右值全部统一加 2 就可以了，用 SQL 语句非常容易就能解决</li>
</ul>
<p>在设计对象的时候，对象除了表里的“属性”还应有一个层次或者叫深度的属性，这个属性的值可以根据上面的特点算出来，这个很关键，知道层次后才能用代码“画”出这样的树状层次结构</p>
<p>关键在于查询语句的写法了，首先要算出深度，因为父和子都在一张表里存着，哪就把这一张表想象成两张表，一张存父，一张存子，比如下面的 SQL 语句就能查到每个节点的爸爸：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">as</span> <span class="keyword">parent</span>,<span class="keyword">test</span> <span class="keyword">as</span> <span class="keyword">child</span> <span class="keyword">where</span> parent.lft &lt; child.lft <span class="keyword">and</span> parent.rgt &gt; child.rgt;</span><br><span class="line"></span><br><span class="line"># ThinkPad  笔记本</span><br><span class="line"># ThinkPad  商品</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p>也就是说根据某个节点的名称出现多少次就能确定有几个爸爸，也就能确定其的层次，层次就是父节点个数+1；为了方便可以直接把 <code>&gt;</code> 改成 <code>&gt;=</code> 这样就不需要再+1了<br>想要计算层次（深度），就是计算某个名称（分类）出现了多少次，可以使用 group 进行归组，然后用 count 函数统计下就可以了，完整语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> child.id, child.name,<span class="keyword">count</span>(child.name) <span class="keyword">as</span> <span class="keyword">depth</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">as</span> <span class="keyword">parent</span>,<span class="keyword">test</span> <span class="keyword">as</span> <span class="keyword">child</span> </span><br><span class="line">		<span class="keyword">where</span> parent.lft &lt; child.lft <span class="keyword">and</span> parent.rgt &gt; child.rgt <span class="keyword">group</span> <span class="keyword">by</span>(child.name) <span class="keyword">order</span> <span class="keyword">by</span> (child.lft);</span><br></pre></td></tr></table></figure>
<p>最后还对左值进行了排序，这样查询出来的数据就是按顺序的：id、名称、深度（层次） 了，也就是说每一类的父节点和子节点挨着，封装到对象中进行使用就可以了</p>
<p>用心去去体会！</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet技术之过滤器]]></title>
      <url>http://bfchengnuo.com/2017/05/13/Servlet%E6%8A%80%E6%9C%AF%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在 Servlet 规范 2.3 中定义了过滤器，它能够对 Servlet 容器的请求和响应对象进行检查和修改。Servlet 过滤器<strong>本身并不生成请求和响应对象</strong>，只是提供过滤功能。<br>Servlet 过滤器能够在 Servlet 被调用之前检查 Request 对象，并修改 Request Header 和 Request 内容；在 Servlet 被调用之后检查 Response 对象，修改 Response Header 和 Response 的内容。<a id="more"></a></p>
<p>常用的应用如：设置统一编码、设置静态资源的缓存时间、控制权限访问、敏感词拦截等</p>
<p>Servlet 过滤器可以过滤的 Web 组件包括 Servlet，JSP 和 HTML 等文件。Filter 类似于 IO 中的过滤流，实现也类似于 Servlet。</p>
<h2 id="了解Filter"><a href="#了解Filter" class="headerlink" title="了解Filter"></a>了解Filter</h2><p>使用过滤器非常的简单，新建一个类，实现 Filter 接口就可以了，也就是需要实现三个方法，从名字来看，有两个是和生命周期有关</p>
<ul>
<li>init(FilterConfig filterConfig)</li>
<li>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</li>
<li>destroy()</li>
</ul>
<p>说说其生命周期，随服务器（或者说随 web 应用）的启动而执行 init 方法，随服务器的关闭而 执行 destroy 方法，也就是生命周期和服务器保持一致，某些只需要执行一次的方法可以放在 init 里面啦！</p>
<p>拦截处理的操作一般都写在 doFilter 方法中，在这里可以对 request 和 response 进行一些处理，不过 ServletRequest 和 ServletResponse 一般需要转换成具体的 Servlet 实现对于的对象，如：HttpServletRequest 和 HttpServletResponse。</p>
<p>web 服务器在调用 doFilter 方法时，会传递一个 filterChain 对象进来，<strong>filterChain 对象是 filter 接口中最重要的一个对象</strong>，它也提供了一个 doFilter 方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则 web 服务器就会调用 web 资源的 service 方法，<strong>即 web 资源就会被访问，否则 web 资源不会被访问。</strong></p>
<p>在一个 web 应用中，可以开发编写多个 Filter，这些 Filter 组合起来称之为一个 Filter 链。不过需要注意下顺序的问题，<strong>web 服务器根据 Filter 在 web.xml 文件中的注册顺序，决定先调用哪个 Filter</strong><br>比如如果有两个过滤器，那么顺序类似：用户发起请求 –&gt; 请求被 Filter1 拦截 –&gt; 请求被 Filter2 拦截 –&gt; 响应被 Filter2 拦截 –&gt; 响应被 Filter1 拦截 –&gt; 响应返回给用户<br><strong>一般把 Filter 配置在所有的 Servlet 之前。</strong></p>
<div class="note warning"><p>通过注解配置 filter 时，没有专门的指令来配置 filter 执行顺序，确定 filter 执行的先后是根据 filter 类名的字母表顺序。<br>这非常不便于以后的维护，所以用不用，自己决定吧….</p>
</div>
<h2 id="设置全站编码的栗子"><a href="#设置全站编码的栗子" class="headerlink" title="设置全站编码的栗子"></a>设置全站编码的栗子</h2><p>这样是为了解决乱码的问题，我们的汉字太吊，乱码问题时常让我爆炸….<br>通过简单的栗子，应该是学习或者复习比较快速的一个方法<br>正好这个问题可以使用过滤器来解决，以后再也不用担心乱码的问题了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig mConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        mConfig = filterConfig;</span><br><span class="line">        System.out.println(<span class="string">"初始化成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取配置文件中设置的编码</span></span><br><span class="line">        String charset = mConfig.getInitParameter(<span class="string">"charset"</span>);</span><br><span class="line">        <span class="keyword">if</span> (charset.isEmpty())</span><br><span class="line">            charset = <span class="string">"utf-8"</span>;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">        req.setCharacterEncoding(charset);</span><br><span class="line">        <span class="comment">// 下面两句是设置输出的编码，不设置也可以，因为一般不会在 Servlet 中进行输出，而是跳到 JSP 进行输出</span></span><br><span class="line">        resp.setCharacterEncoding(charset);</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想生效，还需要在 <code>web.xml</code> 文件中进行响应的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MainFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.MainFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>charset<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 一个过滤器可以设置多个 mapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MainFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在 XML 中配置的初始化参数可以在 init 方法中拿到，就是 FilterConfig 这个对象；可以通过 getInitParameter 来获取设置的值</p>
<p>但是呢，这样只能解决 Post 方式提交的乱码问题，Get 方式的乱码还是会有，想要完全的解决需要进行增强 Request 的方式，在获取参数的时候进行判断，分别对 Get 和 Post 进行不同的处理，参考下面增强 Request 目录下的内容，关键代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    String value = mRequest.getParameter(name);</span><br><span class="line">    <span class="comment">// 非 Get 方式直接返回，不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!mRequest.getMethod().equalsIgnoreCase(<span class="string">"get"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value = <span class="keyword">new</span> String(value.getBytes(<span class="string">"iso-8859-1"</span>),mRequest.getCharacterEncoding());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制静态资源缓存"><a href="#控制静态资源缓存" class="headerlink" title="控制静态资源缓存"></a>控制静态资源缓存</h2><p>这次使用注解的方式来配置，如果配置多个过滤器的话，顺序方面会比较头疼，按名字的字母来排序，上面也提到过这个问题，但是使用注解确实方便了很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"CacheFilter"</span>,</span><br><span class="line">        urlPatterns = &#123;<span class="string">"*.jpg"</span>, <span class="string">"*.png"</span>, <span class="string">"*.css"</span>, <span class="string">"*.js"</span>&#125;,</span><br><span class="line">        initParams = &#123;</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"jpg"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"css"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">                <span class="meta">@WebInitParam</span>(name = <span class="string">"js"</span>, value = <span class="string">"10"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheFilter</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FilterConfig mConfig;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到用户访问的资源</span></span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        <span class="comment">// 获取配置的资源的缓存时间</span></span><br><span class="line">        <span class="keyword">int</span> expires = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (uri.endsWith(<span class="string">".jpg"</span>)) &#123;</span><br><span class="line">            expires = Integer.parseInt(<span class="keyword">this</span>.mConfig.getInitParameter(<span class="string">"jpg"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.endsWith(<span class="string">".js"</span>)) &#123;</span><br><span class="line">            expires = Integer.parseInt(<span class="keyword">this</span>.mConfig.getInitParameter(<span class="string">"js"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uri.endsWith(<span class="string">".css"</span>)) &#123;</span><br><span class="line">            expires = Integer.parseInt(<span class="keyword">this</span>.mConfig.getInitParameter(<span class="string">"css"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置缓存时间，注意格式</span></span><br><span class="line">        resp.setDateHeader(<span class="string">"expires"</span>, System.currentTimeMillis() + expires * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        mConfig = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就没有必要去设置 web.xml 文件了，上面的过滤器只会拦截设置的那些静态文件的请求，比如 JSP 中有个 img 标签，当加载 JSP 页面的时候，JSP 本身请求不会被拦截，但是发送的图片请求会被捕获到，然后设置个缓存时间<br>还有就是：<strong>刷新代表着重新执行上次操作，所以就算设置了缓存，刷新操作还是会重新进行获取</strong></p>
<h2 id="增强Request和Response"><a href="#增强Request和Response" class="headerlink" title="增强Request和Response"></a>增强Request和Response</h2><p>前面也说过，增强功能一般有三种方式：1、继承 2、装饰/包装 3、动态代理</p>
<p>第一种用的基本很少，因为在服务器相关的对象中往往都封装着很多的信息，如果使用继承的话这些信息就会丢失<br>第二种装饰模式确实可以，但是方法比较多的话会很复杂；即使 Apache 给提供了 <strong>HttpServletRequestWrapper</strong> 类来方便开发，这个类默认就是经过装饰了的，但是内部全部调用的是构造函数中传入的构件中的方法，<strong>我们用的时候直接继承自它，需要增强什么方法再单独覆盖</strong>，这样就能大大简化步骤了<br>第三种还没有看到，挖个坑，以后单独开一篇</p>
<p>关于 Request 的具体的应用可以是处理编码来解决乱码问题，敏感词过滤审核，进行数据转义防止 XXS 等<br>关于 Response 的具体应用最直接的就是用来搞压缩，大大节省流量啊，gzip 主要是压缩文本数据，还有就是缓存数据，在过滤器定义一个 Map 缓存那些不经常更新的数据（byte[]）</p>
<p>具体代码就不写了，有点长，可以参考我的笔记：<a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/JavaEE/Filter%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener">Github</a></p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>存下在过滤器中常用的一些对象使用的套路</p>
<h3 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h3><p>通过 request 或者 filterConfig 都可以得到 ServletContext 对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">ServletContext context = req.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">ServletContext context = filterConfig.getServletContext();</span><br></pre></td></tr></table></figure>
<h3 id="web-xml节点配置"><a href="#web-xml节点配置" class="headerlink" title="web.xml节点配置"></a>web.xml节点配置</h3><p>除了上面那几个，补充两个比较常用的</p>
<ul>
<li><code>&lt;servlet-name&gt;</code><br>指定过滤器所拦截的Servlet名称。</li>
<li><code>&lt;dispatcher&gt;</code><br>拦截方式，可以设定五个值（<strong>可以配置多个，默认 REQUEST</strong>）：<br><strong>REQUEST</strong>：当用户直接访问页面时，Web 容器将会调用过滤器。如果目标资源是通过 RequestDispatcher 的 <strong>include()</strong> 或 <strong>forward()</strong> 方法访问时，那么该过滤器就不会被调用。<br><strong>INCLUDE</strong>：如果目标资源是通过 RequestDispatcher 的 <strong>include()</strong> 方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。<br><strong>FORWARD</strong>：如果目标资源是通过 RequestDispatcher 的 <strong>forward()</strong> 方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。<br><strong>ERROR</strong>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。<br><strong>ASYNC</strong>：异步处理的请求</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>一些代码可以参考我的笔记：<a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/JavaEE/Filter%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener">Github</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-策略模式]]></title>
      <url>http://bfchengnuo.com/2017/05/10/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Wiki 上说，策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。<a id="more"></a></p>
<p>策略模式我感觉是非常简单的一种设计模式，应该也是一种比较基本的设计模式，在其它的设计模式中也能看到它的影子</p>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p>
<p><strong>策略模式是一种对象行为型模式。</strong></p>
<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，<strong>每一种方式称为一个策略</strong>，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。<br>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p>
<p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中；如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法<br>当然也可以将这些查找算法封装在一个统一的方法中，通过 <code>if…else…</code> 等条件判断语句来进行选择。<br>这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。该类代码将较复杂，维护较为困难。</p>
<p>可以得出<strong>策略模式的使用场景</strong></p>
<ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象多个子类，而又需要使用 <code>if-else</code> 或者 <code>switch-case</code> 来选择时。</li>
</ul>
<p>通俗来说就是：</p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li>
</ul>
<p>策略模式：</p>
<ul>
<li>定义了一族算法（业务规则）</li>
<li>封装了每个算法</li>
<li>这族的算法可互换代替（interchangeable）</li>
</ul>
<h2 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h2><p>其实策略模式我感觉在很多地方见过，说明应用还是很广泛的，貌似常用的回调技术也是这个模式的一种体现；这关键是依赖了一个设计原则：面向接口而不是面向实现</p>
<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
<p>下面的栗子继续使用上次的吧，就设置情景为我要交朋友，但是交什么朋友是不确定的吧，有好多种（实现），虽然不太恰当，无所谓啦~~~</p>
<p>首先是抽象策略类，就是定义一个接口了，<del>就是我要交的朋友的抽象</del>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的策略类，实现上面的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"要抱抱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LegitimateLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(づ｡◕‿‿◕｡)づ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是环境类，也就是使用场景，通常还可以在这个类中加入接口的一个 setter 方法，这样就可以动态的改变“策略对象”了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeFriends</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Loli mLoli;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MakeFriends</span><span class="params">(Loli loli)</span> </span>&#123;</span><br><span class="line">		mLoli = loli;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mLoli.hug();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是测试了，也就是应该如何去使用，应该越看越熟悉了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MakeFriends makeFriends;</span><br><span class="line"></span><br><span class="line">        makeFriends = <span class="keyword">new</span> MakeFriends(<span class="keyword">new</span> StandardLoli());</span><br><span class="line">        makeFriends.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        makeFriends = <span class="keyword">new</span> MakeFriends(<span class="keyword">new</span> LegitimateLoli());</span><br><span class="line">        makeFriends.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>策略模式主要用来分离算法，根据相同的行为抽象来做不同的具体策略实现。<br>优点：</p>
<ul>
<li>结构清晰明了、使用简单直观。</li>
<li>耦合度相对而言较低，扩展方便。</li>
<li>操作封装也更为彻底，数据更为安全。</li>
<li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li>
<li>策略模式提供了管理相关的算法族的办法。</li>
<li>策略模式提供了可以替换继承关系的办法。</li>
<li>使用策略模式可以避免使用多重条件转移语句。</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着策略的增加，子类也会变得繁多。<br>可以通过使用享元模式在一定程度上减少对象的数量。</li>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
</ul>
<h2 id="策略模式中的设计原则"><a href="#策略模式中的设计原则" class="headerlink" title="策略模式中的设计原则"></a>策略模式中的设计原则</h2><ul>
<li><strong>开闭原则（Open-Closed Principle，缩写为OCP）</strong><ul>
<li>一个软件实体应当对扩展(例如对抽象层的扩展)开放，对修改(例如对抽象层的修改)关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</li>
<li>开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。</li>
</ul>
</li>
<li><strong>里氏替换原则（Liskov Substitution Principle，缩写为LSP）</strong><ul>
<li>一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。比如，假设有两个类，一个是 Base 类，一个是 Derived 类，并且 Derived 类是 Base 类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有 method1(d)。反之，则不一定成立</li>
<li>里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。</li>
<li>策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/pastqing/note/198333" target="_blank" rel="noopener">https://www.zybuluo.com/pastqing/note/198333</a><br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/strategy/gkerison" target="_blank" rel="noopener">https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/strategy/gkerison</a><br><a href="http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3学习笔记(一)]]></title>
      <url>http://bfchengnuo.com/2017/05/08/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>CSS3 是 CSS2 的升级版本，3 只是版本号，它在 CSS2.1 的基础上增加了很多强大的新功能。<br>在编写 CSS3 样式时，由于现时不同浏览器支持程度不同，需要加上不同的浏览器前缀来区分。<br>它表示该 CSS 属性或规则尚未成为 W3C 标准的一部分，是浏览器的私有属性，虽然目前较新版本的浏览器都是不需要前缀的，但为了更好的向前兼容前缀还是少不了的。<a id="more"></a></p>
<table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>浏览器</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-webkit</td>
<td>chrome 和 safari</td>
</tr>
<tr>
<td>-moz</td>
<td>firefox</td>
</tr>
<tr>
<td>-ms</td>
<td>IE</td>
</tr>
<tr>
<td>-o</td>
<td>opera</td>
</tr>
</tbody>
</table>
<p>总是为兼容性操碎了心呐….<br>后来才知道，原先写的 CSS 都是 3-，真正 3 的魅力完全没体现出来</p>
<h2 id="CSS3的特性"><a href="#CSS3的特性" class="headerlink" title="CSS3的特性"></a>CSS3的特性</h2><p>简单的说就是带来的好处，CSS3 把很多以前需要使用图片和脚本来实现的效果、甚至动画效果，只需要短短几行代码就能搞定。比如圆角，图片边框，文字阴影和盒阴影，过渡、动画等。</p>
<p>CSS3 简化了前端开发工作人员的设计过程，加快页面载入速度。</p>
<p>先大体总结一下比较让人眼前一亮的特性：</p>
<ul>
<li>选择器<br>以前我们通常用 class、 ID 或 tagname 来选择 HTML 元素，CSS3 的选择器强大的难以置信。它们可以减少在标签中的 class 和 ID 的数量更方便的维护样式表、更好的实现结构与表现的分离。</li>
<li>圆角效果<br>以前做圆角通常使用背景图片，或繁琐的元素拼凑，现在很简单了 border-radius 帮你轻松搞定。</li>
<li>块阴影和文字阴影<br>可以对任意 DIV 和文字增加投影效果。</li>
<li>色彩<br>CSS3 支持更多的颜色和更广泛的颜色定义。新颜色 CSS3 支持 HSL ， CMYK ，HSLA and RGBA。</li>
<li>渐变效果<br>以前只能用 Photoshop 做出的图片渐变效果，现在可以用 CCS 写出来了。IE 中的滤镜也可以实现。</li>
<li>个性化字体<br>网页上的字体太单一？使用 <strong>@Font-Face</strong>  轻松实现定制字体。还可以“画”出一些图标来</li>
<li>多背景图<br>一个元素上添加多层背景图片。</li>
<li>边框背景图</li>
<li>变形处理<br>你可以对 HTML 元素进行旋转、缩放、倾斜、移动、甚至以前只能用 JavaScript 实现的强大动画。</li>
<li>多栏布局<br>可以让你不用使用多个 div 标签就能实现多栏布局。浏览器解释这个属性并生成多栏，让文本实现一个仿报纸的多栏结构。</li>
<li>媒体查询<br>针对不同屏幕分辨率，应用不同的样式。</li>
<li>……</li>
</ul>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>首先，就从边框开始吧！</p>
<h3 id="圆角效果"><a href="#圆角效果" class="headerlink" title="圆角效果"></a>圆角效果</h3><p>这个效果主要使用了 <strong>border-radius</strong> 属性：是向元素添加圆角边框。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.test</span>&#123;</span><br><span class="line">    <span class="comment">/* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */</span> </span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span> <span class="number">4px</span> <span class="number">3px</span> <span class="number">2px</span>; </span><br><span class="line">    <span class="comment">/* 所有角都使用半径为10px的圆角 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 实心圆 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.circle</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;<span class="comment">/*与width设置一致*/</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#9da</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">50px</span>;<span class="comment">/*四个圆角值都设置为宽度或高度值的一半*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*实心左半圆*/</span>   </span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.semi-circle</span>&#123; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#9da</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>它使用的单位不止是 px，也可以使用百分比之类的，但是效果不太理想</p>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>使用的是 <strong>box-shadow</strong> 属性：是向盒子添加阴影。支持添加一个或者多个。<br>语法：<code>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</code><br>前两个是必填的，其他的可以不写，阴影颜色默认是黑色，<strong>投影方式可以写在任何位置</strong>，当是 inset 时，是内部阴影；省略为外阴影</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*外阴影效果，比较有立体感啦*/</span></span><br><span class="line"><span class="selector-class">.box_shadow</span>&#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">4px</span> <span class="number">2px</span> <span class="number">6px</span> <span class="number">#333333</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*多阴影效果，用逗号分割*/</span></span><br><span class="line"><span class="selector-class">.box_shadow</span>&#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>:<span class="number">4px</span> <span class="number">2px</span> <span class="number">6px</span> <span class="number">#f00</span>,</span><br><span class="line">      -<span class="number">4px</span> -<span class="number">2px</span> <span class="number">6px</span> <span class="number">#000</span>, <span class="number">0px</span> <span class="number">0px</span> <span class="number">12px</span> <span class="number">5px</span> <span class="number">#33CC00</span> inset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面参数的介绍挺抽象的，反正我看不懂</p>
<blockquote>
<p>  <strong>阴影模糊半径</strong>：此参数可选，其值只能是为正值，如果其值为 0 时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；</p>
<p>  <strong>阴影扩展半径</strong>：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；</p>
<p>  至于<strong>X轴偏移量和Y轴偏移量值可以设置为负数</strong> ；可以理解为正负就是方向</p>
</blockquote>
<h3 id="边框背景图"><a href="#边框背景图" class="headerlink" title="边框背景图"></a>边框背景图</h3><p>顾名思义就是为边框应用背景图片，它和我们常用的 background 属性比较相似，使用的是 <strong>border-image</strong> 属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#border-image</span>&#123;</span><br><span class="line">   <span class="attribute">background</span>:<span class="number">#F4FFFA</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">210px</span>; <span class="attribute">height</span>:<span class="number">210px</span>; <span class="attribute">border</span>:<span class="number">70px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">   <span class="attribute">border-image</span>:<span class="built_in">url</span>(borderimg.png) <span class="number">70</span> repeat  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个矩形，有四个边框。如果应用了边框图片， 图片会自动被切割分成四等分。用于四个边框。所以要设置下切割高度，比如上面的 70px<br>图片的延伸方式有三种：round（平铺）、 repeat（重复）、 stretch（拉伸）<br>难度没多少，效果自己写下看看就知道了</p>
<h2 id="颜色相关"><a href="#颜色相关" class="headerlink" title="颜色相关"></a>颜色相关</h2><p>CSS3 支持 RGBA，是的，后面的 A 是透明度，用法：<br><code>background-color:rgba(100,120,60,0.5);</code></p>
<p>下面再来说说渐变色彩：<br>CSS3 Gradient 分为线性渐变(<strong>linear</strong>)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里只针对线性渐变的 W3C 标准语法来分析其用法，使用 <strong>linear-gradient</strong> 属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">linear-gradient</span>(to left, red, orange,yellow,green,blue,indigo,violet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出是支持多种颜色的，两个一组，对应开始和结束；那么第一个参数是啥呢？肯定和方向（角度）有关</p>
<table>
<thead>
<tr>
<th>角度</th>
<th>英文</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 deg</td>
<td>to top</td>
<td>从下向上</td>
</tr>
<tr>
<td>90 deg</td>
<td>to right</td>
<td>从左向右</td>
</tr>
<tr>
<td>180 deg</td>
<td>to bottom</td>
<td>从上向下</td>
</tr>
<tr>
<td>270 deg</td>
<td>to left</td>
<td>从右向左</td>
</tr>
<tr>
<td>-</td>
<td>to top left</td>
<td>右下角到左上角</td>
</tr>
<tr>
<td>-</td>
<td>to top right</td>
<td>左下角到右上角</td>
</tr>
</tbody>
</table>
<h2 id="文字与字体"><a href="#文字与字体" class="headerlink" title="文字与字体"></a>文字与字体</h2><p><strong>text-overflow</strong> 用来设置是否使用一个省略标记（…）标示对象内文本的溢出。<br>但是 <strong>text-overflow</strong> 只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（<strong>white-space:nowrap</strong>）及溢出内容为隐藏（<strong>overflow:hidden</strong>），只有这样才能实现溢出文本显示省略号的效果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ellipsis:显示省略标记；clip:表示剪切 */</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">text-overflow</span>: ellipsis; </span><br><span class="line">	<span class="attribute">overflow</span>: hidden; </span><br><span class="line">	<span class="attribute">white-space</span>: nowrap; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>word-wrap</strong> 也可以用来设置文本行为，当前行超过指定容器的边界时是否断开换行。<br>它有两个可以设置的属性：<br><em>normal</em> : 控制连续文本换行（测试应该遇到长单词是不换行）<br><em>break-word</em>: 表示内容将在边界内换行（就算是整个单词，太长也会换行）<br>normal 为浏览器默认值，break-word 设置在长单词或 URL 地址内部进行换行，此属性不常用，用浏览器默认值即可。</p>
<h3 id="嵌入字体-font-face"><a href="#嵌入字体-font-face" class="headerlink" title="嵌入字体@font-face"></a>嵌入字体@font-face</h3><p><strong>@font-face</strong> 能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family </span>: 字体名称;</span><br><span class="line">    <span class="attribute">src </span>: 字体文件在服务器上的相对或绝对路径;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size </span>:<span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">font-family </span>: <span class="string">"My Font"</span>;</span><br><span class="line">    <span class="comment">/*必须项，设置 @font-face 中 font-family 同样的值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实利用它可以完成 <strong>字体图标</strong> 的效果，这个我感觉还是非常实用的，不需要再用 PS 切图了，具体的实现打算专门写一篇，毕竟看了下比较复杂的….(其实是功力不够)</p>
<p>发现一篇写的很好的文章，很详细：<a href="https://www.w3cplus.com/content/css3-font-face" target="_blank" rel="noopener">https://www.w3cplus.com/content/css3-font-face</a></p>
<h3 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h3><p><strong>text-shadow</strong> 可以用来设置文本的阴影效果。语法为：<br><code>text-shadow: X-Offset Y-Offset blur color;</code><br><em>X-Offset</em>：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移<br><em>Y-Offset</em>：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移<br><em>Blur</em>：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将 Blur 值设置为 0<br><em>Color</em>：是指阴影的颜色，其可以使用 rgba 色。</p>
<h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><p>CSS3 支持设置元素背景图片的<strong>原始起始位置</strong>。<br>语法：<code>background-origin ： border-box | padding-box | content-box;</code><br>参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。<br>需要注意的是，<strong>如果背景不是 no-repeat，这个属性无效，它会从边框开始显示。</strong></p>
<p>裁剪可以使用属性 background-clip<br>语法：<code>background-clip ： border-box | padding-box | content-box | no-clip</code><br>参数分别表示从<strong>边框、</strong>或<strong>内填充</strong>，或者<strong>内容区域</strong>向外裁剪背景。<br><strong>no-clip</strong> 表示不裁切，和参数 <strong>border-box</strong> 显示同样的效果。<code>backgroud-clip</code> 默认值为 <strong>border-box</strong>。</p>
<p>还有可以设置背景图片的大小，以<strong>长度值</strong>或<strong>百分比</strong>显示，还可以通过 <strong>cover</strong> 和 <strong>contain</strong> 来对图片进行伸缩。<br>语法：<code>background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain</code><br>参数：<br><strong>auto</strong>：默认值，不改变背景图片的原始高度和宽度；<br><strong>&lt;长度值&gt;</strong>：成对出现如 200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；<br><strong>&lt;百分比&gt;</strong>：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；<br><strong>cover</strong>：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；<br><strong>contain</strong>：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。</p>
<p>然后就是多重背景，常见的写法一般有两种：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(http://img.mukewang.com/54cf2365000140e600740095.jpg),</span><br><span class="line">                      <span class="built_in">url</span>(http://img.mukewang.com/54cf238a0001728d00740095.jpg),</span><br><span class="line">                      <span class="built_in">url</span>(http://img.mukewang.com/54cf23b60001fd9700740096.jpg);</span><br><span class="line">    <span class="attribute">background-position</span>: left top, <span class="number">100px</span> <span class="number">0</span>, <span class="number">200px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat, no-repeat, no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.task</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(http://static.mukewang.com/static/img/logo_index.png) no-repeat, </span><br><span class="line">               <span class="built_in">url</span>(http://static.mukewang.com/static/img/logo_index.png) no-repeat;</span><br><span class="line">               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有 size 值，需要紧跟 position 并且用 “/“ 隔开 (<code>[/background-size]</code>)；<br>background-color 只能设置一个。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>在 CSS2 中引入了一些属性选择器，而 CSS3 在 CSS2 的基础上对属性选择器进行了扩展，新增了3个属性选择器，使得属性选择器有了通配符的概念，这三个属性选择器与 CSS2 的属性选择器共同构成了 CSS 功能强大的属性选择器</p>
<p>关于这个我曾经整理过一篇文章见：<a href="https://bfchengnuo.com/2016/10/04/css-jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93/">CSS/jQuery选择器总结</a></p>
<p>简单说这三种选择器是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择 a 标签中 class 以 column 开头的 */</span></span><br><span class="line">a[<span class="class"><span class="keyword">class</span>^</span>=column]&#123;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择 a 标签中 href 属性以 doc 结尾的 */</span></span><br><span class="line">a[href$=doc]&#123;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择 a 标签中 title 属性包含 box 的 */</span></span><br><span class="line">a[title*=box]&#123;</span><br><span class="line">    background:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CSS3 还增加了一些伪类选择器，下面列举一些，全套的参考上面那篇文章：</p>
<ul>
<li><p><code>:root</code> 选择器<br>从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在 HTML 文档中，根元素始终是 <code>&lt;html&gt;</code><br>可以用来设置页面的背景颜色</p>
</li>
<li><p><code>:not</code> 选择器<br>否定选择器，和 jQuery 中的 <code>:not</code> 选择器<strong>一模一样</strong>，可以选择除某个元素之外的所有元素。<br>就拿 form 元素来说，比如说你想给表单中除 submit 按钮之外的 input 元素添加红色边框，CSS 代码可以写成</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[type="submit"]</span>)&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>:empty</code> 选择器<br>表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，<strong>哪怕是一个空格也算不为空</strong>。</p>
</li>
<li><p><code>:target</code> 选择器<br>目标选择器，用来匹配文档(页面)的 url 的某个标志符的目标元素。比如经常用的锚链接，在段落设置相应的 id 属性；在连接使用 <code>#id</code> 来定位（使用 href）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 点击#id连接后id为brand元素的样式 */</span></span><br><span class="line"><span class="selector-id">#brand</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#jake</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#aron</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只定义一个 <code>:target{}</code>  默认对应的是全部的链接是 <code>#id</code> 元素，也就是说点击他们反映在各自 id 元素上的样式是一致的，但最多只能标记一个使用样式，好像描述的不太清楚，自己测试一下就知道了<br>测试地址：<a href="http://www.w3school.com.cn/tiy/t.asp?f=css_sel_target" target="_blank" rel="noopener">http://www.w3school.com.cn/tiy/t.asp?f=css_sel_target</a></p>
</li>
<li><p><code>:nth-child(n)</code> 选择器<br>用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数 n 的起始值始终是 1，而不是 0。也就是说，参数 n 的值为 0 时，选择器将选择不到任何匹配的元素。<br>类似的还有 <code>nth-last-child(n)</code> 就是倒着来的，以及类似的 <code>E:nth-of-type</code> 指定子元素的，比如匹配奇数行这样写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2n+1)</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选择倒数第五个 */</span></span><br><span class="line"><span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child(5)</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>:enabled</code> 选择器<br>在 Web 的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器 <strong>:enabled</strong> 对这些表单元素设置样式。</p>
</li>
<li><p><code>::selection</code> 伪元素<br>它是用来匹配突出显示的文本(<strong>用鼠标选择文本时的文本</strong>)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的<br>不过在 Firefox 浏览器还需要添加前缀：<code>::-moz-selection</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-moz-selection</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>::before</code> 和 <code>::after</code><br>这两个主要用来给元素的前面或后面插入内容，这两个常和 <strong>“content”</strong> 配合使用，使用的场景最多的就是清除浮动。<br>我也看到好多配合 @font-face 来使用字体图标的</p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用 input 定义 button 的时候，要想按钮处于禁用状态可以直接在标签上加 disabled 属性，类似 checked 这样的标识，如果使用 css 的方式实现可以试试下面两种方案：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-class">.disabled</span>, <span class="selector-class">.btn</span><span class="selector-attr">[disabled]</span>, <span class="selector-tag">fieldset</span><span class="selector-attr">[disabled]</span> <span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;</span><br><span class="line">    <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">    <span class="attribute">opacity</span>: .<span class="number">65</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优雅的JDBC写法]]></title>
      <url>http://bfchengnuo.com/2017/05/06/%E4%BC%98%E9%9B%85%E7%9A%84JDBC%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>介绍下在数据库的相关操作中什么是元数据，以及如果自己写工具类的时候应该如何写，或者可以使用别人写好的工具类，比如 Apache 的 dbutils 工具类，就是不知道现在是不是还在用，也当作是为以后学习框架做准备吧！<a id="more"></a></p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>首先，来了解下什么是元数据，当然主要说的是数据库相关的，简单说它就是：<strong>数据库、表、列的定义信息</strong><br>所以，指的基本就是数据库一些“对象”的信息，基本可以分为三类</p>
<ul>
<li>DatabaseMetaData<br>数据库的元数据，封装了数据库的相关信息，比如版本、名字、驱动、URL、用户名等等</li>
<li>ParameterMetaData<br>参数元数据，简单说就是：获得预编译 SQL 语句中  “?” 信息。比如：参数的个数、类型等，但是并不是所有的数据库(驱动)都支持</li>
<li>ResultSetMetaData<br>结果集的元数据，封装了结果集中的列数、列名称、列类型等信息</li>
</ul>
<h2 id="工具类写法"><a href="#工具类写法" class="headerlink" title="工具类写法"></a>工具类写法</h2><p>下面就来优雅的写 JDBC 的工具类，嗯….起码算比较优雅</p>
<p>以前我们在工具类就写了两个方法，一个是获取连接，一个是释放相关资源；下面就来扩展一下，让其变得更加通用一些<br>增加两个方法，一个用于增删改(update)，一个用于查询(query)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql, Object[] params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">        st = conn.prepareStatement(sql);  <span class="comment">// 预编译</span></span><br><span class="line">        <span class="comment">// 填充参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            st.setObject(i + <span class="number">1</span>, params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        st.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">query</span><span class="params">(String sql, Object[] params, ResultSetHandler handler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">        st = conn.prepareStatement(sql);  <span class="comment">// 预编译</span></span><br><span class="line">        <span class="comment">// 填充参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            st.setObject(i + <span class="number">1</span>, params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = st.executeQuery();</span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        <span class="keyword">return</span> handler.handler(rs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本思路应该看出来了，增删改的时候统一调用 update 方法，传入相应的 SQL 语句和参数数组就可以了；<br>然后查询的时候单独一个方法 query ，除了需要 SQL 和参数数组还要传入一个 ResultSetHandler 对象，这个是个接口，是自己定义的，主要用于回调来处理结果集，因为 SQL 语句不确定，结果集也不确定如何处理，最妥的方式就是交给用户处理，既然是你写的 SQL 所以你肯定知道怎么处理结果集嘛！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">handler</span><span class="params">(ResultSet rs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果让用户去实现接口多少还是有些麻烦的，为了更好的用户体验我们可以给用户准备几个常用的，比如把查询出来的数据封装到一个 Javabean 中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanHandler</span> <span class="keyword">implements</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;SimpleTab&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanHandler</span><span class="params">(Class&lt;SimpleTab&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handler</span><span class="params">(ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs == <span class="keyword">null</span> || !rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Object bean = clazz.newInstance();</span><br><span class="line">            <span class="comment">// 得到结果集的元数据</span></span><br><span class="line">            ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">            <span class="keyword">int</span> count = metaData.getColumnCount();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取每一列的名字</span></span><br><span class="line">                String name = metaData.getColumnName(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 获取每一列的值</span></span><br><span class="line">                Object value = rs.getObject(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 利用反射技术得到相应的属性，使数据拷贝到 javabean 里</span></span><br><span class="line">                Field field = bean.getClass().getDeclaredField(name);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(bean, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | SQLException | NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就用到了之前说的元数据，还使用到了反射技术，调用的时候直接 new 这个实现类就可以了，传入一个 class 用来指定 bean 的类型；<br>当然如果查询返回了多条记录，一般是封装到 List 集合中去，所以再写一个实现类吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanListHandler</span> <span class="keyword">implements</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanListHandler</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handler</span><span class="params">(ResultSet rs)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; mList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Object bean = clazz.newInstance();</span><br><span class="line">                ResultSetMetaData metaData = rs.getMetaData();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; metaData.getColumnCount(); i++) &#123;</span><br><span class="line">                    String name = metaData.getColumnName(i + <span class="number">1</span>);</span><br><span class="line">                    Object value = rs.getObject(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反射，使用 Declared 说明获取的是私有变量</span></span><br><span class="line">                    Field field = bean.getClass().getDeclaredField(name);</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(bean, value);</span><br><span class="line">                &#125;</span><br><span class="line">                mList.add(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用的时候就很简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extendedTest2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = <span class="string">"SELECT * FROM simpletab"</span>;</span><br><span class="line">    Object[] params = &#123;&#125;;</span><br><span class="line">    List list = (List) JdbcUtils.query(sql, params, <span class="keyword">new</span> BeanListHandler(SimpleTab.class));</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// String sql = "insert INTO simpletab VALUES (?,?)";</span></span><br><span class="line">    <span class="comment">// Object[] params = &#123;2, "测试"&#125;;</span></span><br><span class="line">    <span class="comment">// JdbcUtils.update(sql,params);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用DBUtils"><a href="#使用DBUtils" class="headerlink" title="使用DBUtils"></a>使用DBUtils</h2><p>上面的工具类是我们自己定义的，然后 Apache 其实也写了一个，就叫 dbutils 不过我看了下最新的也已经是几年前了，不知道在实际开发中还用不用，不过嘛，这种工具类应该一般也不需要更新<br>dbutils 的使用和自定义的工具类很类似，实现原理可能也差不多<br>它只是对 JDBC 进行简单封装，学习成本低，并且不会影响程序的性能。它不是一个框架</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>使用很简单，毕竟就是为了简化开发，导入相应的包后直接用就行了，主要用到的是 <strong>QueryRunner</strong> 对象，具体的方法可以去看 API，说点常用的，比如执行增删改操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner(JdbcUtilsC3P0.getDataSource());</span><br><span class="line">    String sql = <span class="string">"INSERT INTO simpletab(id,name) VALUES (?,?)"</span>;</span><br><span class="line">    Object[] param = &#123;<span class="number">3</span>, <span class="string">"hello"</span>&#125;;</span><br><span class="line">    qr.update(sql, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和我们自己写的非常相似，new 的时候接收一个 conn 对象，直接从连接池里取了<br>再说查询，也是支持封装到 bean 和 List 中去，就举个封装到 List 中的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner(JdbcUtilsC3P0.getDataSource());</span><br><span class="line">    String sql = <span class="string">"SELECT * FROM simpletab"</span>;</span><br><span class="line">    List&lt;SimpleTab&gt; list = qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(SimpleTab.class));</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dbutils 还给了一些实现了 ResultSetHandler  的类，这里不多说了 API 写的很明白，比如可以封装到数组中去。<br>如果返回的是单条数据可以使用 <strong>ScalarHandler</strong> 对象，用于获取结果集中第一行某列的数据并转换成 T （指定的泛型）表示的实际对象，更多的返回类型可以参考：<a href="http://www.cnblogs.com/myit/p/4272824.html" target="_blank" rel="noopener">http://www.cnblogs.com/myit/p/4272824.html</a></p>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>就是批量执行 SQL 了，当然是相同的 sql 类型，比如可以批量删除、添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner(JdbcUtilsC3P0.getDataSource());</span><br><span class="line">    String sql = <span class="string">"INSERT INTO simpletab(id,name) VALUES (?,?)"</span>;</span><br><span class="line">    Object[][] params = <span class="keyword">new</span> Object[<span class="number">5</span>][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        params[i] = <span class="keyword">new</span> Object[]&#123;i + <span class="number">4</span>, <span class="string">"test"</span> + i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    qr.batch(sql, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要区别就是参数的一维数组换成了二维数组，也就是说数组中的每一个数组中封装了批量操作中的一条数据，然后执行 batch 方法执行</p>
<h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>事务这是一个重要的操作，就当是操作吧，既然要使用事务，那么就不能让它执行完一条 SQL 就关闭连接了，所以只能我们自己传入 conn 了，并且是关闭了自动提交的 conn</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtilsC3P0.getConnection();</span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        String sql1 = <span class="string">"UPDATE simpletab SET name='loli' WHERE id=1"</span>;</span><br><span class="line">        qr.update(conn, sql1);</span><br><span class="line"></span><br><span class="line">        String sql2 = <span class="string">"UPDATE simpletab SET name='loli' WHERE id=2"</span>;</span><br><span class="line">        qr.update(conn, sql2);</span><br><span class="line"></span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这样的写法是有问题的，如果是按照三层架构开发的话，dao 层是不允许有业务逻辑的，只能有执行 sql 的相关代码，类似这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由构造方法获得</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">updateExample</span><span class="params">(SimpleTab bean)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    String sql = <span class="string">"UPDATE simpletab SET name=? WHERE id=?"</span>;</span><br><span class="line">    Object[] param = &#123;bean.getName(), bean.getId()&#125;;</span><br><span class="line">    <span class="keyword">return</span> qr.update(conn, sql, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SimpleTab <span class="title">findExample</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">        String sql = <span class="string">"SELECT * FROM simpletab WHERE id=?"</span>;</span><br><span class="line">        Object[] param = &#123;id&#125;;</span><br><span class="line">        <span class="keyword">return</span> qr.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;&gt;(SimpleTab.class), param);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写的话，如果使用到事务，在 Server 层的时候获取连接后关闭自动提交，然后再传进来，最后还要记得手动 commit 和 close</p>
<p>但是这样写还是不太好，更优雅的写法可以考虑使用 <strong>ThreadLocal</strong> ，将 conn 绑定到线程上，这样也不用考虑高并发的问题了</p>
<h3 id="使用ThreadLocal优化工具类"><a href="#使用ThreadLocal优化工具类" class="headerlink" title="使用ThreadLocal优化工具类"></a>使用ThreadLocal优化工具类</h3><p>ThreadLocal 可以简单理解为线程管理数据的类，他有两个经常用的方法，get、set 都是静态的，分别表示着往当前线程获取、保存数据<br>下面就来改造下工具类，主要是添加几个管理 conn 的方法，其他方法不变，就省略了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtilsC3P0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource ds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 设置为静态，随类加载而创建，内部其实是一个 Map 集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnectionThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 便于 Dao 层的获取，一般来说获取的到的是开启事务的连接，获取不到就从连接池拿一个普通的</span></span><br><span class="line">            <span class="comment">// 得到当前线程上绑定的连接</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="comment">// 判断是否为空，如果为空就从连接池获取一个，绑定到当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 便于 Server 层获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到当前线程上绑定的连接</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="comment">// 判断是否为空，如果为空就从连接池获取一个，绑定到当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commintTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 千万记得释放资源，否则 Map 集合会越来越大；只会移除当前线程的</span></span><br><span class="line">            tl.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改造后基本就比较优雅了，效率也比较好了</p>
<h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><p>这个也不是太难，大体思路是：接受一个 bean 根据里面的具体数据来构造相应的 sql ，比如如果传入的 bean 包含有多个子 bean ；其实对应的就是一对多的关系，先把主 bean 中的基本数据存进去，再把子 bean 拆出来一个个的存，最后加上外键连接起来就 OK 了<br>当然每一个 bean 都应该对应一个具体的 dao 层操作的方法</p>
<p>PS：set 集合的 <strong>addAll()</strong> 方法可以把传入的集合拆了，然后再存进自己的 set</p>
<p>代码就不写了….</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-装饰模式]]></title>
      <url>http://bfchengnuo.com/2017/05/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>来继续之前的设计模式之旅~~这次介绍的是装饰（包装）模式，还是使用 Java 来进行说明，首先来简单了解下装饰模式：</p>
<blockquote>
<p>  装饰模式又名包装( Wrapper )模式。装饰模式以对客户端透明的方式扩展对象的功能，<strong>是继承关系的一个替代方案。</strong></p>
</blockquote>
<p>Wiki 上的解释为：<a id="more"></a></p>
<blockquote>
<p>  是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，<strong>装饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</strong></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过使用装饰模式，可以在<strong>运行时</strong>扩充一个类的功能。<br>原理是：增加一个装饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。<strong>装饰类必须和原来的类有相同的接口。</strong></p>
<p>装饰模式是类继承的另外一种选择。<strong>类继承在编译时候增加行为，而装饰模式是在运行时增加行为。</strong></p>
<p>当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些面向对象的编程语言中，类不能在运行时被创建，通常在设计的时候也不能预测到有哪几种功能组合。这就意味着要为每一种组合创建一个新类。<br>相反，装饰模式是面向运行时候的对象实例的,这样就可以在运行时根据需要进行组合。一个装饰模式的示例是 JAVA 里的 Java I/O Streams 的实现。</p>
<p>然而大多数的装饰模式实际上是半透明的装饰模式（介于装饰模式和适配器模式之间的），这样的装饰模式也称做半装饰、半适配器模式。</p>
<h2 id="使用前"><a href="#使用前" class="headerlink" title="使用前"></a>使用前</h2><p>使用场景一般是：</p>
<ul>
<li>在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责。</li>
<li>处理那些可以撤销的职责。</li>
<li>当不能采用生成子类的方法进行扩充时。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。<br>装饰模式允许系统<strong>动态决定</strong>“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。<br>继承关系则不同，<strong>继承关系是静态的</strong>，它在系统运行前就决定了。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使用装饰模式会产生比使用继承关系<strong>更多的对象</strong>。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。<br>额，所以说命名很关键</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>在装饰模式中的角色有：</p>
<ul>
<li><strong>抽象构件(Component)角色：</strong><br>给出一个抽象接口，以规范准备接收附加责任的对象。<br>所有的装饰者和被装饰对象都要继承它（如果是接口就是实现）</li>
<li><strong>具体构件(ConcreteComponent)角色：</strong><br>定义一个将要接收附加责任的类（将要被装饰的类）。<br>继承上面的抽象构建</li>
<li><strong>装饰(Decorator)角色：</strong><br>持有一个构件( Component )对象的实例，并定义一个与抽象构件接口一致的接口。<br>也可以是一个实现 interface 的抽象类，也就是说要继承（广义上的）抽象构件</li>
<li><strong>具体装饰(ConcreteDecorator)角色：</strong><br>负责给构件对象“贴上”附加的责任。<br>继承自装饰角色（抽象）；在内部维护一个被装饰对象</li>
</ul>
<p>下面用代码来说明，先来 抽象构件角色，所有的装饰者、被装饰对象都要实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">speak</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是具体构件角色，也就是将要被装饰的<strong>具体对象</strong>，这解释的是啥玩意，说白了就是被装饰对象呗<br>这里我就写一个了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LegitimateLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(￣^￣)"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(づ｡◕‿‿◕｡)づ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰角色（引入构件类， 给具体构件类增加职责，但是具体职责在其子类中实现），一般是写成抽象的，当然也可以下面的这样写法吧，大概….：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有的构件实例</span></span><br><span class="line">    <span class="keyword">private</span> Loli mLoli;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Loli loli)</span> </span>&#123;</span><br><span class="line">        mLoli = loli;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里具体实现直接委派给构件实例了...</span></span><br><span class="line">        <span class="keyword">return</span> mLoli.speak(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        mLoli.hug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体装饰角色（主要就是对功能进行扩展），嗯，就是装饰者了，大部分会在这里维护被装饰对象，不过也看到过在装饰角色中直接就弄好的，比如说现在的这个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LovelyLoli</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LovelyLoli</span><span class="params">(Loli loli)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(loli);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.speak(name) + <span class="string">" +++装饰+++ 我很可爱~~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行原来的构件的功能</span></span><br><span class="line">        <span class="keyword">super</span>.hug();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行扩展功能</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        System.out.println(<span class="string">"+++装饰+++ 我很可爱~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是来调用测试啦，怎么感觉好羞耻(:捂脸..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择了标准 Loli</span></span><br><span class="line">        Loli loli = <span class="keyword">new</span> LegitimateLoli();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对标准 Loli 进行了装饰（增加功能）</span></span><br><span class="line">        loli = <span class="keyword">new</span> LovelyLoli(loli);</span><br><span class="line"></span><br><span class="line">        loli.hug();</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">        System.out.println(loli.speak(<span class="string">"bfchengnuo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，大体思想就是这样啦~~<br>当然也不一定都是这样的写法，比如可以把构件实例放在具体装饰角色里面，怎么喜欢怎么来吧~~<br>还是要看实际情况嘛~~</p>
<h2 id="小小总结"><a href="#小小总结" class="headerlink" title="小小总结"></a>小小总结</h2><ul>
<li>装饰者和被装饰对象有相同的超类</li>
<li>你可以用一个或者多个装饰者包装一个对象</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合可以用装饰过的对象代替他</li>
<li><strong>装饰者可以在所委托的被装饰者的行为之前或者之后，加上自己的行为，已达到特定的目的</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态的、不限量的用你喜欢的装饰者来装饰对象</li>
</ul>
<p>在 Java 的 I/O 实现中就使用了这个模式，最原始的 InputStream 是抽象的，相当于是抽象组件；FileInputStream 继承自它，相当于是具体构件，也就是被装饰对象的角色；<br>我们在使用的时候大多使用 BufferedInputStream 进行装饰，它继承自 FilterInputStream ，它是一个抽象装饰者，或者在外面再套一层…..</p>
<h2 id="透明与半透明"><a href="#透明与半透明" class="headerlink" title="透明与半透明"></a>透明与半透明</h2><p>装饰模式对客户端的透明性要求程序不要声明一个 ConcreteComponent 类型的变量，而应当声明一个 Component 类型的变量。<br>上面这句标准解释反正我看不懂，按照上面的栗子就是，这是透明的，是正确的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loli loli = <span class="keyword">new</span> LegitimateLoli();</span><br><span class="line">loli = <span class="keyword">new</span> LovelyLoli(loli);</span><br></pre></td></tr></table></figure>
<p>这样干是不对的，不透明的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loli loli = <span class="keyword">new</span> LegitimateLoli();</span><br><span class="line">LovelyLoli loli2 = <span class="keyword">new</span> LovelyLoli(loli);</span><br></pre></td></tr></table></figure>
<p>前面也说过，纯粹的装饰模式是很难找到的，按照透明模式来，我如果在 LovelyLoli 里面进行扩展了方法是调用不到的，这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。</p>
<p>换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明 ConcreteDecorator 类型的变量，从而可以调用 ConcreteDecorator 类中才有的方法，说白了就是类似上面说的错误做法。</p>
<p>半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。</p>
<p>为什么是半透明？<br>也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的</p>
<h2 id="扩充资料"><a href="#扩充资料" class="headerlink" title="扩充资料"></a>扩充资料</h2><p>如果不是很明白可以看：<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html</a><br><a href="http://blog.csdn.net/zhshulin/article/details/38665187" target="_blank" rel="noopener">http://blog.csdn.net/zhshulin/article/details/38665187</a><br><a href="http://blog.csdn.net/lovelion/article/details/7425873" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7425873</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC学习之事务和连接池]]></title>
      <url>http://bfchengnuo.com/2017/05/04/JDBC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>上一篇写了一些基本数据库操作，以及批处理、调用存储过程等内容，这一次主要是使用事务以及使用连接池来提高效率，当然最好还是选用比较成熟的连接池，这些在框架中应该都已经集成了，但是现在不是没学嘛~多了解一点也是有好处的<br>到这里 JDBC 基本就差不多了，如果还看到什么知识点的话就再补充一篇<a id="more"></a></p>
<h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><p>关于什么是事务，以及有什么特点，我在<a href="https://bfchengnuo.com/2016/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/">这篇文章</a>中更新过了，下面就主要说说在 JDBC 中如何使用事务，还是以 MySQL 为例，其他的也都一致，就是注意下隔离级别的问题，像 Oracle 就只支持 2 种；首先来看下最基本的使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        <span class="comment">// 关闭自动提交</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        String sql1 = <span class="string">"update users set rmb = rmb-100 where name='lolicon'"</span>;</span><br><span class="line">        String sql2 = <span class="string">"update users set rmb = rmb+100 where name='loli'"</span>;</span><br><span class="line"></span><br><span class="line">        st = conn.prepareStatement(sql1);</span><br><span class="line">        st.executeUpdate();</span><br><span class="line"></span><br><span class="line">        st = conn.prepareStatement(sql2);</span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要操作的是 conn 对象，首先我们要关闭它的自动提交，否则每发送一条 SQL 会立即完成，关闭后相当于开启了一个事务，无论执行多少次 SQL 只要不进行 commit ，数据库就会进行回滚操作</p>
<p>下面再说下手动设置事务的回滚点，并且手动回滚操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">custPoint</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    Savepoint sp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        String sql1 = <span class="string">"update users set rmb = rmb-100 where name='lolicon'"</span>;</span><br><span class="line">        String sql2 = <span class="string">"update users set rmb = rmb+100 where name='loli'"</span>;</span><br><span class="line"></span><br><span class="line">        st = conn.prepareStatement(sql1);</span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        <span class="comment">// 设置回滚点</span></span><br><span class="line">        sp = conn.setSavepoint();</span><br><span class="line">        st = conn.prepareStatement(sql2);</span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 手动进行回滚，记得进行 commit</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn.rollback(sp);</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用的方式是设置一个回滚点 Savepoint ，当然应该还有其他方式的….先说这一种</p>
<p>然后是手动设置隔离级别，就是一句话的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Connection conn = JdbcUtils.getConnection();</span><br><span class="line">    <span class="comment">// 设置隔离级别</span></span><br><span class="line">    conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    JdbcUtils.release(conn,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note default"><p>补充一点，产生 conn 的方法还可以使用工厂模式来生产 Dao<br>它能使各层之间能达到完全解耦的目的，但是相应的代码的复杂度会增加<br>如果项目确定不会更换 Dao 层，那么其实不使用工厂模式比较好<br>代码参考： <a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/Dao" target="_blank" rel="noopener">Github</a></p>
</div>
<h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>首先，要明确数据库能创建的连接数（也就是 conn）是非常有限的，并且创建出来也很不容易，所以，每次操作数据库的时候就让数据库给创建连接效率是非常低的，于是就有了连接池的概念<br>就是说，事先先创建好一批连接，存到一个“池”里，当需要的时候就从这个池里取，用完后不要释放而是再放回这个池里，这样会极大的提高效率<br>思路大概就是这样了….</p>
<p>下面来手写个连接池，当然是最基本的；简单说就是实现 DataSource 接口，这个接口只有两个方法，其他都是继承过来的，可以简单的认为实现了DataSource 接口的就是一个连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcPool</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设计到频繁删改 使用链表结构效率好一点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; mList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">"db.properties"</span>));</span><br><span class="line">            Class.forName(prop.getProperty(<span class="string">"driver"</span>));</span><br><span class="line">            <span class="comment">// 获取 10 个连接</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                mList.add(DriverManager.getConnection(prop.getProperty(<span class="string">"url"</span>), prop.getProperty(<span class="string">"username"</span>), prop.getProperty(<span class="string">"password"</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库正忙....请稍后再获取"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Connection conn = mList.removeFirst();</span><br><span class="line">        <span class="comment">// 进行装饰，使其 close 的时候再放回池里</span></span><br><span class="line">        MyConn myConn = <span class="keyword">new</span> MyConn(conn);</span><br><span class="line">        <span class="keyword">return</span> myConn;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用装饰模式增强 close，使其关闭的时候添加回连接池中</span></span><br><span class="line"><span class="comment">     * 有点繁琐，最好还是使用 动态代理（aop 面向切面，拦截技术）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 装饰步骤</span></span><br><span class="line"><span class="comment">     *   1.定义一个类，实现被增强类相同的接口</span></span><br><span class="line"><span class="comment">     *   2.定义一个变量，记住被增强对象</span></span><br><span class="line"><span class="comment">     *   3.定义一个构造函数，接收被增强对象</span></span><br><span class="line"><span class="comment">     *   4.覆盖想增强的方法</span></span><br><span class="line"><span class="comment">     *   5.对于不想增强的方法，直接调用目标对象的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyConn</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Connection conn;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyConn</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.conn = conn;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="comment">// 进行自定义</span></span><br><span class="line">            mList.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.conn.createStatement();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.conn.prepareStatement(sql);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有很多方法，没用到省略了</span></span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>
<h2 id="DBCP连接池"><a href="#DBCP连接池" class="headerlink" title="DBCP连接池"></a>DBCP连接池</h2><p>对于新手，自己写的连接池是很不放心啊，所以还是用比较成熟的开源的比较好，比如 BDCP 和 C3P0<br>哦，对了 DBCP 是 Apache 的，下面是使用的参考代码，记得导入相关的包，没记错的话应该是需要三个包，一个是 DBCP 的还需要 logging 和 pool2 的包，有点麻烦，不过都是 Apache 家的，在 Apache 的官网都可以找到<br>主包地址：<a href="https://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbcp/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtilsDBCP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 使用静态代码块保证只加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(JdbcUtilsDBCP.class.getClassLoader().getResourceAsStream(<span class="string">"dbcp.properties"</span>));</span><br><span class="line">            ds = BasicDataSourceFactory.createDataSource(prop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement st, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便贴下 DBCP 的配置文件：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########DBCP配置文件##########</span></span><br><span class="line"><span class="comment">#驱动名</span></span><br><span class="line"><span class="attr">driverClassName</span>=com.mysql.jdbc.Driver</span><br><span class="line"><span class="comment">#url</span></span><br><span class="line"><span class="attr">url</span>=jdbc:mysql://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span>/test</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line"><span class="attr">username</span>=Loli</span><br><span class="line"><span class="comment">#密码</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123456</span></span><br><span class="line"><span class="comment">#初试连接数</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">#最大活跃数</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="number">30</span></span><br><span class="line"><span class="comment">#最大idle数</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">#最小idle数</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="number">5</span></span><br><span class="line"><span class="comment">#最长等待时间(毫秒)</span></span><br><span class="line"><span class="attr">maxWaitMillis</span>=<span class="number">1000</span></span><br><span class="line"><span class="comment">#程序中的连接不使用后是否被连接池回收(该版本要使用removeAbandonedOnMaintenance和removeAbandonedOnBorrow)</span></span><br><span class="line"><span class="comment">#removeAbandoned=true</span></span><br><span class="line"><span class="attr">removeAbandonedOnMaintenance</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">removeAbandonedOnBorrow</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment">#连接在所指定的秒数内未使用才会被删除(秒)(为配合测试程序才配置为1秒)</span></span><br><span class="line"><span class="attr">removeAbandonedTimeout</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="C3P0连接池"><a href="#C3P0连接池" class="headerlink" title="C3P0连接池"></a>C3P0连接池</h2><p>使用步骤和 DBCP 类似，不过貌似效率更高一些<br>官网地址：<a href="http://www.mchange.com/projects/c3p0/" target="_blank" rel="noopener">http://www.mchange.com/projects/c3p0/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtilsC3P0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ComboPooledDataSource ds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 使用静态代码块保证只加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 如果采用的是配置文件，注释的内容可以不写</span></span><br><span class="line"><span class="comment">            ds.setDriverClass("com.mysql.jdbc.Driver");</span></span><br><span class="line"><span class="comment">            ds.setJdbcUrl("jdbc:mysql://115.152.254.541:3306/test");</span></span><br><span class="line"><span class="comment">            ds.setUser("Loli");</span></span><br><span class="line"><span class="comment">            ds.setPassword("123456");</span></span><br><span class="line"><span class="comment">            // 设置初始连接池的大小！</span></span><br><span class="line"><span class="comment">            ds.setInitialPoolSize(2);</span></span><br><span class="line"><span class="comment">            // 设置连接池的最小值！</span></span><br><span class="line"><span class="comment">            ds.setMinPoolSize(1);</span></span><br><span class="line"><span class="comment">            // 设置连接池的最大值！</span></span><br><span class="line"><span class="comment">            ds.setMaxPoolSize(10);</span></span><br><span class="line"><span class="comment">            // 设置连接池中的最大 Statements 数量！</span></span><br><span class="line"><span class="comment">            ds.setMaxStatements(50);</span></span><br><span class="line"><span class="comment">            // 设置连接池的最大空闲时间！</span></span><br><span class="line"><span class="comment">            ds.setMaxIdleTime(60);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement st, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 src 下有配置文件直接 new 就可以了，如果没有那就只能手动指定了，配置文件统一命名为 <code>c3p0-config.xml</code> ，示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://115.159.234.122:3306/test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>Loli<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　     <span class="comment">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　     <span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- This app is massive! --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"intergalactoApp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>default 对应空构造函数，如果你还配置了其他的，比如上面的就是叫 named ，在 new ComboPooledDataSource 的时候把名字作为参数传入就好了，这样更加灵活</p>
<h2 id="Tomcat自带连接池"><a href="#Tomcat自带连接池" class="headerlink" title="Tomcat自带连接池"></a>Tomcat自带连接池</h2><p>其实就是用的 DBCP，因为 DBCP 是 Apache 的，Tomcat 也是 Apache 的，都是一家子嘛~~<br>使用自带的连接池的步骤在 Tomcat 的文档中写的也算是很清楚了，见：<strong>JNDI Resources</strong> 目录下<br><div class="note info"><p>因为使用自带的连接池需要配 Context ，Context 的配置方式一共有 5 种 (:应该是<br>见：<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Defining a context" target="_blank" rel="noopener">官方在线文档</a><br>除去前面介绍 Tomcat 时说的几种，还有一种是在工程的 Web 目录下新建 <strong>META-INF</strong> 目录，然后再新建 <strong>context.xml</strong> 文件，在这个文件中进行配置<br>其实这种方式最终会复制一份到 <code>conf\Catalina\localhost</code> 下，一般以应用名开头，所以清理项目的时候记得手动删除</p>
</div></p>
<p>好了，继续说，首先按照文档先要把驱动拷到服务器的 lib 文件夹，然后进行配置 Context 就可以了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc/EmployeeDB"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">username</span>=<span class="string">"dbusername"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">"dbpassword"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">driverClassName</span>=<span class="string">"org.hsql.jdbcDriver"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">url</span>=<span class="string">"jdbc:HypersonicSQL:database"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxActive</span>=<span class="string">"8"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxIdle</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>获取链接的示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 JNDI</span></span><br><span class="line">Context initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line"><span class="comment">// 获取 JNDI</span></span><br><span class="line">Context envCtx = (Context) initCtx.lookup(<span class="string">"java:comp/env"</span>);</span><br><span class="line"><span class="comment">// 获取连接池</span></span><br><span class="line">DataSource ds = (DataSource) envCtx.lookup(<span class="string">"jdbc/EmployeeDB"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<p>文档为啥会在 JNDI 目录下呢，因为数据库池（DataSource）保存在 web 服务器的 JNDI 容器中（当然也是可以存其他东西的）</p>
<p>所以说，服务器传对象给 Servlet 其实又多了一种方式，那就放在 JNDI 容器中，需要的时候向 JNDI 中获取就行了</p>
<h2 id="JNDI科普"><a href="#JNDI科普" class="headerlink" title="JNDI科普"></a>JNDI科普</h2><p>什么是 JNDI ？</p>
<blockquote>
<p>  JNDI是 <strong>Java 命名与目录接口</strong>（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一.</p>
<p>   JNDI 是 Java 平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。如同其它很多 Java 技术一样，JDNI 是 provider-based 的技术，暴露了一个  API 和一个服务供应接口（SPI）。<br>  这意味着任何基于名字的技术都能通过 JNDI 而提供服务，只要 JNDI 支持这项技术。<br>  JNDI 目前所支持的技术包括 LDAP、CORBA Common Object Service（COS）名字服务、RMI、NDS、DNS、Windows 注册表等等。<br>  很多 J2EE 技术，包括 EJB 都依靠 JNDI 来组织和定位实体。可以把它理解为一种将对象和名字捆绑的技术，对象工厂负责生产出对象，这些对象都和唯一的名字绑在一起，外部资源可以通过名字获得某对象的引用。</p>
</blockquote>
<p>简单来说就是，原来我们写代码需要在代码中指定数据库的连接、用户名、密码等信息，现在只需要在 XML 配置文件中指定就可以了，达到了解耦的目的；现在这些问题都<strong>由 J2EE 容器来配置和管理</strong>，程序员只需要对这些配置和管理进行引用即可。<br><strong>J2EE 规范要求所有 J2EE 容器都要提供 JNDI 规范的实现。</strong>JNDI 是通过资源的名字来查找的，资源的名字在整个j2ee应用中（j2ee 容器中）是唯一的</p>
<h2 id="JTA与EJB科普"><a href="#JTA与EJB科普" class="headerlink" title="JTA与EJB科普"></a>JTA与EJB科普</h2><p>java Transaction API（Java事务 API）完整的名称应该是：Java Transaction API(Application Programming Interface)</p>
<blockquote>
<p>  JTA Transaction 是指由 J2EE Transaction manager 去管理的事务。其最大的特点是调用 UserTransaction 接口的 begin，commit 和 rollback 方法来完成事务范围的界定，事务的提交和回滚。<br>  JTATransaction 可以实现同一事务对应不同的数据库，但是它仍然无法实现事务的嵌套。</p>
</blockquote>
<p>就是我们所说的全局事务</p>
<hr>
<p>顺便再补充下什么是 EJB 吧：</p>
<blockquote>
<p>  企业级JavaBean（Enterprise JavaBean, <strong>EJB</strong>）是一个用来构筑企业级应用的服务器端可被管理组件。</p>
<p>  用通俗话说，EJB 就是：”把你编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了”。<br>  是的，没错！EJB 就是将那些”类”放到一个服务器上，用 C/S 形式的软件客户端对服务器上的”类”进行调用。</p>
</blockquote>
<p>EJB 包含的 3 种 bean 是：session bean（会话 bean）, entity bean（实体 bean）, message bean（消息 bean）</p>
<p>更详细的内容可参考：<a href="http://blog.csdn.net/cuiran/article/details/40950487" target="_blank" rel="noopener">http://blog.csdn.net/cuiran/article/details/40950487</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC入门]]></title>
      <url>http://bfchengnuo.com/2017/04/27/JDBC%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>学习之前先要弄明白的是：什么是 JDBC？</p>
<blockquote>
<p>  SUN 公司为了简化、统一对数据库的操作，定义了一套 Java 操作数据库的规范，称之为 JDBC</p>
</blockquote>
<p>我们要操作数据库，需要有数据库厂商提供的驱动，但是它们的规范很可能是不同的，难道我们要把所有的数据库规范都看一遍？学习成本太高，不利于推广啊，于是 sun 公司就搞了个 JDBC (接口)，所有的驱动按照它的规范来，这样我们用的时候只要导入相应的驱动，代码统一使用 JDBC 的规范就可以了，降低了学习成本<a id="more"></a></p>
<p><img src="/image/dev/JDBC.jpg" alt="JDBC.jpg"></p>
<p>其实 Servlet 也是一样的思想，也是接口，是一种规范；比如我使用的是 Tomcat ，那么具体实现就是 Tomcat 来完成的，这就是我们为什么要导入 Tomcat 中的相关 jar</p>
<p>我的机器只有 MySQL 的，所以我就只是用的它做的测试，驱动下载的官方地址：<br><a href="https://www.mysql.com/products/connector/" target="_blank" rel="noopener">https://www.mysql.com/products/connector/</a><br>使用 IDEA 的同学可以直接在 DATABASE的侧边栏 设置里自动下载哦</p>
<h2 id="基本套路"><a href="#基本套路" class="headerlink" title="基本套路"></a>基本套路</h2><p>使用 JDBC 的基本套路可以用下面的代码来表示，一共六点<br>需要注意的是：<code>java.sql.*</code> 和 <code>javax.sql.*</code>  都属于 JavaSE 了，所以建个普通工程就可以用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// URL 后面建议加 ?useUnicode=true&amp;characterEncoding=UTF-8 属性来确保编码</span></span><br><span class="line">    <span class="comment">// 如果是连本机可以省略：jdbc:mysql:///test</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://115.159.200.212:3306/test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">"Loli"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"xxxxx"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 加载驱动，推荐第二种</span></span><br><span class="line">        <span class="comment">// DriverManager.registerDriver(new Driver());</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取链接</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(url, userName, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取向数据库发sql语句的 statament 对象</span></span><br><span class="line">        Statement statement = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 向数据库发送 SQL，获取结果集</span></span><br><span class="line">        ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM users;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 从结果集获取数据</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">"name"</span>));</span><br><span class="line">            System.out.println(resultSet.getObject(<span class="string">"sex"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放链接，顺序是反着的</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一步的加载驱动的时候，有两种方法：<br>第一种不推荐，因为首先它会被加载两次（可以看源代码中的静态代码块），其次会有强依赖性，必须要 import 相关 jar 包；<br>而第二种只需要一个字符串而已，在更换数据库的时候更方便。</p>
<p>不得不再感慨，IDEA 的代码提示救了我这英语白痴+健忘，连 SQL 语句和配置文件的内容都可以提示…..</p>
<div class="note warning"><p>防止在读取/存储时中文出现乱码，记得设置 url 的时候，结尾加上 <code>?useUnicode=true&amp;characterEncoding=UTF-8</code> ，如果报错了，反正就是提示 url 有问题，那么可以尝试转义一下试试，转义后的 url 为：<code>?useUnicode=true&amp;amp;characterEncoding=UTF-8</code><br>学过 html 的都懂哈….</p>
</div>
<h2 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h2><p>从上面的代码也可以看出，这个是用来<strong>向数据库发送 SQL 语句</strong>的；常见的几个方法有：</p>
<ul>
<li>executeQuery()<br>执行查询语句，返回一个结果集</li>
<li>executeUpdate()<br>执行增删改语句，返回影响的行数；判断是否大于 0 来判断是否执行成功</li>
<li>execute()<br>执行所有的 SQL 语句，但是一般不太用，因为它返回的是一个  boolean ，代表是否执行成功<br>比如查询，我们还需要判断、再用 getResultSet 来获取结果集，太麻烦</li>
</ul>
<h2 id="preparedStatement对象"><a href="#preparedStatement对象" class="headerlink" title="preparedStatement对象"></a>preparedStatement对象</h2><p>在实际中，其实使用 preparedStatement 的情况比较多，从名字上就可以猜出它与 Statement 一定关系不一般<br>statement 和 preparedStatement 的区别：</p>
<ol>
<li>preparedStatement 是 statement 的孩子，也就是 preparedStatement  继承自 statement</li>
<li>preparedStatement 可以防止 SQL 注入问题，设置的参数会被转义</li>
<li>preparedStatement 可以对 SQL 语句进行预编译，提高效率</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        String sql = <span class="string">"SELECT * FROM users WHERE id = ?"</span>;</span><br><span class="line">        st = conn.prepareStatement(sql);  <span class="comment">// 预编译 sql</span></span><br><span class="line">        st.setInt(<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 补全设置的占位符</span></span><br><span class="line"></span><br><span class="line">        rs = st.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JdbcUtils 的写法可以参考：<a href="https://github.com/bfchengnuo/java_learn/blob/master/XC/JavaEE/JDBC/src/JdbcUtils.java" target="_blank" rel="noopener">Github</a></p>
<h2 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h2><p>查询返回的结果集，可以简单理解为一个表格，有一个游标，和 Android 一样默认是<strong>指向第一行之前</strong> ；所以一般是先进行 next 获取<br>它提供了一堆的 get 方法，获取各种类型的数据，当然无论那种数据都可以使用万能的 getObject<br>所有的 get 方法都提供了两种重载，可以<strong>使用索引号或者列名获取一行的数据</strong>，<strong>注意索引从 1 开始</strong> ，为了更直观，一般不会使用索引来获取；如果结果集只有一列，那么用索引就比较方便了</p>
<p>如果结果集只有一行数据，可以使用 <code>if(resultSet.next()){}</code> ，有多行就要用 <code>while(resultSet.next()){}</code> 来循环取出</p>
<p>其他的常用方法：</p>
<ul>
<li>下一行：<code>rs.next();</code></li>
<li>上一行：<code>rs.previous();</code></li>
<li>移动到指定行：<br>可以是负数！如果传入1，相当于 <code>first();</code> ；如果传入 -1 ，相当于 <code>last();</code><br>滚动后是可以直接取数据<br><code>rs.absolute(indexNum);</code></li>
<li>移动到最前，<strong>第一行之前</strong><br><code>rs.beforeFirst();</code></li>
<li>移动到最后，<strong>最后一行之后</strong><br><code>rs.afterLast();</code></li>
</ul>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>如果想要同时执行多条 SQL 语句，那么一条一条的去执行看起来比较弱鸡，资源开销太大，效率太低，所以肯定有批量的法子啊！就是这么自信<br>既然执行 SQL 语句有两种方式，那么类似的批量操作应该也有两种方式 : 使用 statement 和使用 preparedStatement</p>
<h3 id="使用statement"><a href="#使用statement" class="headerlink" title="使用statement"></a>使用statement</h3><p>非常非常简单，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以同时执行不同类别的语句，但是效率低</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statementTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        st.addBatch(<span class="string">"insert into temp(id,value) VALUES (100,'lolicon')"</span>);</span><br><span class="line">        st.addBatch(<span class="string">"UPDATE temp SET id=101 WHERE id=1"</span>);</span><br><span class="line">        st.executeBatch();</span><br><span class="line">        st.clearBatch();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是通过 addBatch 方法添加进 List 集合，然后 executeBatch 一起执行，再用 clearBatch 清空 List<br>就当作 createStatement 方法返回的 st 内部维护了一个 List 集合嘛~我也没看源码实现，应该是差不多的 (:雾</p>
<h3 id="使用preparedStatement"><a href="#使用preparedStatement" class="headerlink" title="使用preparedStatement"></a>使用preparedStatement</h3><p>其实它们是比较类似的，事实上这一种用的比较多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能执行相同的语句，用于批量插入、更新等；效率高</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preparedStatementTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        st = conn.prepareStatement(<span class="string">"insert into temp (id, value) values (?,?);"</span>);</span><br><span class="line">        <span class="comment">// 插入 30 条数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            st.setInt(<span class="number">1</span>, i);</span><br><span class="line">            st.setString(<span class="number">2</span>, <span class="string">"test"</span> + i);</span><br><span class="line">            <span class="comment">// 添加到 List 集合</span></span><br><span class="line">            st.addBatch();</span><br><span class="line">            <span class="comment">// 每满 10 条发送一次</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                st.executeBatch();</span><br><span class="line">                st.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn, st, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面一种基本一致，只能预编译一条 SQL ，所以……<br><div class="note info"><p>因为 List 存在内存中，JVM 的内存也是有限的，所以如果要执行很多条 SQL 的话建议分段<br>就向上面一样，每满多少条就执行一下，然后清空 List<br>当然我这里设的 10 太小了，只为测试，设个 1000 应该也不多，具体多大凭感觉…</p>
</div></p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><p>至于什么是存储过程我在 MySQL 的文章中说过了，简单说就是一个函数；所以也就是说如何调用函数了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    CallableStatement st = <span class="keyword">null</span>; <span class="comment">// 注意</span></span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        st = conn.prepareCall(<span class="string">"&#123;call demo(?,?)&#125;"</span>);</span><br><span class="line">        st.setString(<span class="number">1</span>,<span class="string">"lolicon"</span>);</span><br><span class="line">        <span class="comment">// 设置输出的类型</span></span><br><span class="line">        st.registerOutParameter(<span class="number">2</span>,Types.VARCHAR);</span><br><span class="line">        st.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取存储过程的输出值</span></span><br><span class="line">        String str = st.getString(<span class="number">2</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键在于使用 prepareCall 来调用函数，在 MySQL 中，函数的返回值也写在参数，这是不太一样的地方，总之还是比较简单的</p>
<h2 id="获取自动生成的键"><a href="#获取自动生成的键" class="headerlink" title="获取自动生成的键"></a>获取自动生成的键</h2><p>在插入数据的时候，如果某一列我们设置为自动增长，通常也设置为主键，这样在插入的时候就不需要管这列了，但是如果后续操作需要用到这一列，那就得再查询一次，这样肯定不爽，所以要自信的认为有个插入数据的时候会返回这列的值的方法；也就是说这东西可以返回它自动生成的值<br>当然， <strong>仅对于 insert 有效，因为只有插入的时候才会生成 ID</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement st = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line">        <span class="comment">// 第二个参数是是否返回主键，mysql 是默认返回可以不写，写上最好</span></span><br><span class="line">        st = conn.prepareStatement(<span class="string">"insert into keytemp (val) VALUES ('abcd')"</span>, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        <span class="comment">// 获取返回的主键，如果没有就返回空的 ResultSet 对象</span></span><br><span class="line">        rs = st.getGeneratedKeys();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(conn,st,rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方 API 上说：</p>
<blockquote>
<p>  获取由于执行此 Statement 对象而创建的所有自动生成的键。如果此 Statement 对象没有生成任何键，则返回空的 ResultSet 对象。<br>  注：如果未指定表示自动生成键的列，则 JDBC 驱动程序实现将确定最能表示自动生成键的列。</p>
</blockquote>
<h2 id="关于表设计"><a href="#关于表设计" class="headerlink" title="关于表设计"></a>关于表设计</h2><p>一般来说一个对象（javabean）对应一个表，大部分也就是下面的几种情况</p>
<p>当两个表有关联的时候，比如一对多，对应到 bean 中就是主 bean （相当于主表）中有个 set 集合保存子 bean ，子 bean 包含一个主 bean 类型</p>
<h3 id="一对多-多对一"><a href="#一对多-多对一" class="headerlink" title="一对多/多对一"></a>一对多/多对一</h3><ol>
<li>先不要管映射关系，先设计出基本的属性</li>
<li>在多的一方加外键描述</li>
</ol>
<p>但是呢，尽量不要使用一对多，能不用就不用，因为有时候做查询，返回有太多的数据会导致内存溢出，具体可以考虑显示的需求，如果“一”中不需要显示“多”，那么就不需要查询多的一方了</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ol>
<li>先不要管映射关系，先设计出基本的属性</li>
<li>设计一个中间表，一般两列；命名为：两个表名中间用 <code>_</code> 连接</li>
<li>中间表要加约束，对应各自的 id , 当然也可以使用联合主键保证不重复</li>
</ol>
<h3 id="一对一（主从关系）"><a href="#一对一（主从关系）" class="headerlink" title="一对一（主从关系）"></a>一对一（主从关系）</h3><ol>
<li>先不要管映射关系，先设计出基本的属性</li>
<li>从表要加外键约束、非空、不能重复、来自主表</li>
</ol>
<p>某些情况可以把主键设置成外键所在列</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><ol>
<li>先设计基本属性</li>
<li>设计一列，增加外键约束，<strong>约束来自本表</strong>，不要加非空</li>
</ol>
<p>名字参考：parent_id<br>主要是用来做无限分级（比如分类表），但是如果层次太深查询使用递归的时候就很容易导致内存溢出，有一种解决方案是使用树结构（树状节点），其实就是二叉树的先序遍历，这个以后再说吧</p>
<h2 id="其他注意"><a href="#其他注意" class="headerlink" title="其他注意"></a>其他注意</h2><p>Connection 连接非常的宝贵，因为数据库支持的连接数是非常有限的，所以要遵循 <strong>尽量晚创建，尽量早释放</strong>  的原则；提示，释放连接的代码要写在 finally 里，<strong>来确保一定会释放</strong>，一般的套路是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 加载驱动</span></span><br><span class="line">            <span class="comment">// 2. 获取链接</span></span><br><span class="line">            <span class="comment">// 3. 获取向数据库发sql语句的 statament 对象</span></span><br><span class="line">            <span class="comment">// 4. 向数据库发送 SQL，获取结果集</span></span><br><span class="line">            <span class="comment">// 5. 从结果集获取数据</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 释放链接，顺序是反着的；保证绝对释放</span></span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于 JDBC 中 Java 和 MySQL 对应的数据类型到这里查看：<br><a href="http://wiki.jikexueyuan.com/project/jdbc/data-types.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/jdbc/data-types.html</a></p>
<p>JDBC 的使用其实有很多重复代码，最好使用抽出来形成一个工具类，比如获取 conn 和 释放连接的方法，就像上面给的地址中的那样</p>
<p>更多的内容，比如事务等下次再写吧…</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSP之自定义标签]]></title>
      <url>http://bfchengnuo.com/2017/04/20/JSP%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<p>接上次说，在 JSP 中一般是不允许出现 Java 代码的，但有的时候必须要用 Java 代码来做一些输出，这时候可以使用自定义标签来实现，自定义标签对应一个 Java 类，JSP 引擎解析到标签的时候会执行对应类中相应的方法<a id="more"></a></p>
<h2 id="传统标签"><a href="#传统标签" class="headerlink" title="传统标签"></a>传统标签</h2><p>先来说说在 JSP2.0 之前的做法，虽然可能已经没人用了，但是了解一点没坏处啊，又不是很难，看框架的时候也许会用到呢</p>
<p>自定义标签需要实现 Tag 接口，这个接口非常简单，当然一般都是继承它的实现类 TagSupport 然后复写需要的方法<br>API 参考：<a href="https://tomcat.apache.org/tomcat-5.5-doc/jspapi/" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-5.5-doc/jspapi/</a><br>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> web.tag;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewIPTag</span> <span class="keyword">extends</span> <span class="title">TagSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般写在 Start 方法里</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doStartTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 pageContext 对象,也就得到了所有的隐式对象</span></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) <span class="keyword">this</span>.pageContext.getRequest();</span><br><span class="line">        JspWriter out = <span class="keyword">this</span>.pageContext.getOut();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 IP 并输出</span></span><br><span class="line">        String remoteAddr = request.getRemoteAddr();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out.write(remoteAddr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.doStartTag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就简单写了个输出 IP 的例子，剩下的就是让这个类和标签关联起来，一般我们在 <strong>WEB-INF</strong> 目录下新建一个 <strong>tld</strong> 文件来指定，可以是多级目录下，但必须在 WEB-INF 下，如果用的是 IDEA 的话直接有现成的模板，实在不行可去抄 Tomcat 里的例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"2.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>bfchengnuo<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://bfchengnuo.com<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>ViewIP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>web.tag.ViewIPTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主要是配置 uri 和 tag 标签，下面在 JSP 中会用到 <strong>body-content</strong> 属性可以认为标签是否含有标签体，单标签双标签的区别，然后下面就是在 JSP 中进行引用了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://bfchengnuo.com"</span> <span class="attr">prefix</span>=<span class="string">"custTag"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义标签测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    您的 IP 是：<span class="tag">&lt;<span class="name">custTag:ViewIP</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>prefix 一般写我们定义的那个 tld 的文件名，有利于查找</strong></p>
<div class="note warning"><p>还有一点需要注意，自定义标签处理完后一般不会立即释放资源，也就是一般不会执行 <strong>release()</strong> 方法，和 Servlet 类似，也会被缓存，等待下一次访问，等 Web 服务器关闭的时候会释放资源</p>
</div>
<h3 id="自定义标签扩展"><a href="#自定义标签扩展" class="headerlink" title="自定义标签扩展"></a>自定义标签扩展</h3><p>自定义标签除了上面的用法，还有几种比较常用的方式，比如控制 JSP 的 <strong>某一部分/全部内容</strong> 是否执行，重复输出某些内容、修改某些内容等，从 JSP 的用法上看它们都是一样的，就是把要控制的内容放进自定义标签体里。</p>
<h4 id="控制是否执行"><a href="#控制是否执行" class="headerlink" title="控制是否执行"></a>控制是否执行</h4><p>JSP 文件就不多说了，把要控制的内容包进去就可以了，然后我们在 Java 代码中进行控制，至于怎么控制，那就是用 Start/End 方法的返回值了！在 API 文档中说的也比较详细了，Tag 接口中定义了几个常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doStartTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有权限</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    	<span class="keyword">return</span> Tag.EVAL_BODY_INCLUDE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Tag.SKIP_BODY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是控制整个 JSP 的内容，可以在 JSP 开始处加一个结束标签，然后...</span></span><br><span class="line"><span class="comment">// 这样就不需要把所有的内容包进去，只是在头部加个结束标签</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doEndTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有权限</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    	<span class="keyword">return</span> Tag.EVAL_PAGE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Tag.SKIP_PAGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对了，还有，不要忘记在 WEB-INF 文件夹下的 tld 文件里修改 <strong>body-content</strong> 为 JSP</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ViewIP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>web.tag.ViewIPTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>JSP<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="重复执行"><a href="#重复执行" class="headerlink" title="重复执行"></a>重复执行</h4><p>重复执行某段内容，Tag 接口就无能为力了，所以就有了 IterationTag 接口，是的，它是专门为了重复执行而设计的，在 Tag 的基础上加了一个常量和方法<br>TagSupport 类已经实现了这个接口，所以说，用到直接复写 <strong>doAfterBody()</strong> 方法就可以了<br>它的调用时机是在<strong>标签体执行完，doEndTag 方法执行前</strong><br>如果返回 EVAL_BODY_AGAIN 继续重复执行( doAfterBody 方法也会重复执行)；<br>返回的是 SKIP_BODY 继续向下执行，但是 doStartTag 方法只会执行一次，毕竟配对的 doEndTag 不会执行嘛</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 循环输出 6 次，是在标签体执行完后才执行 doAfterBody</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doAfterBody</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> IterationTag.EVAL_BODY_AGAIN;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> IterationTag.SKIP_BODY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h4><p>如果想要修改内容的话，上面的两个接口都无能为力，只能靠 BodyTag 接口了，类似的我们一般是<strong>继承 BodyTagSupport 类</strong>然后复写需要的方法其实还是是 <strong>doStartTag()</strong>  只不过返回值不同了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateTag</span> <span class="keyword">extends</span> <span class="title">BodyTagSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doStartTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回值为 EVAL_BODY_BUFFERED 会自动调用 setBodyContent(BodyContent b)</span></span><br><span class="line">        <span class="comment">// 然后就可以在 End 标签里获取到内容了</span></span><br><span class="line">        <span class="keyword">return</span> BodyTag.EVAL_BODY_BUFFERED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doEndTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException </span>&#123;</span><br><span class="line">        BodyContent bodyContent = <span class="keyword">this</span>.getBodyContent();</span><br><span class="line">        String content = bodyContent.getString();</span><br><span class="line">        <span class="comment">// TODO...</span></span><br><span class="line">        <span class="keyword">return</span> Tag.EVAL_PAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单标签"><a href="#简单标签" class="headerlink" title="简单标签"></a>简单标签</h2><p>正是因为传统标签做不同的操作需要实现不同的接口太麻烦，所以在 JSP2.0+ 加入了<strong>SimpleTag</strong> 接口来统一，所有的功能实现这一个就可以了，不过我们还是习惯继承 SimpleTagSupport 类啦~</p>
<p>在简单标签中，解析时会先执行 setJspBody 方法把标签体的内容存起来 (当然还会自动调用 setParent [没有就会传 null ]、setJspContext 方法)，然后执行 doTag() 方法<br>要注意的是：在简单标签中没有 Start/End 方法了，<strong>开始结束全都是执行 doTag</strong>；从 API 文档中可以知道，如果不想执行后面的内容，抛一个 <strong>SkipPageException</strong> 异常即可，相当于是传统标签的 SKIP_PAGE </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取标签体</span></span><br><span class="line">        JspFragment jf = <span class="keyword">this</span>.getJspBody();</span><br><span class="line">        <span class="comment">// 执行标签体的内容，如果不手动调用就不会执行</span></span><br><span class="line">        jf.invoke(<span class="keyword">this</span>.getJspContext().getOut());</span><br><span class="line">        <span class="comment">// 上面那句等价于 jf.invoke(null);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取标签体内容. 将内容写入到事先准备的缓冲区内，然后获取</span></span><br><span class="line">        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        jf.invoke(sw);</span><br><span class="line">        String content = sw.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不执行后面的内容，抛一个 SkipPageException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SkipPageException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要记得修改 <strong>body-content</strong> ，在 2.0+ 后要使用 scriptless，从名字也可以看得出，是不建议再在 JSP 中嵌入java 代码的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SimpleTag<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>web.tag.SimpleTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本上就是这样了..</p>
<h3 id="自定义标签的属性"><a href="#自定义标签的属性" class="headerlink" title="自定义标签的属性"></a>自定义标签的属性</h3><p>都知道 HTML 标签都有属性，自定义的应该也有嘛~，想要设置自定义属性一般需要两步</p>
<ul>
<li>在对应的 Java 文件中编写对应的 Set 方法，程序会自动调用的，注意名称一致</li>
<li>配置 TLD 文件</li>
</ul>
<p>下面就举个简单栗子，循环输出指定次数的标签体:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAttributes</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cont;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以自动转换八大基本数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCont</span><span class="params">(<span class="keyword">int</span> cont)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cont = cont;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">        JspFragment jf = <span class="keyword">this</span>.getJspBody();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cont; i++) &#123;</span><br><span class="line">            jf.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只设置一个 Set 方法就行了，Get 没什么必要，下面就是配置 tld 文件了:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>custAttributes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>web.tag.SimpleAttributes<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>cont<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;type&gt;&lt;/type&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>required ：表示是否是必须的<br>rtexprvalue：表示是否允许使用表达式（比如 ${name} ）<br>type：指定类型，一般没必要设置</p>
<p>然后就可以在 JSP 中进行使用了，可以实现 防盗链、if判断、迭代、处理转义等功能，就如 EL 表达式一样，迭代功能写起来可能复杂点，不过利用反射技术挺方便的<br>PS：转义的实现在 <code>\webapps\examples\WEB-INF\classes\util</code> 下有现成的</p>
<p>最后，可以把这些自定义标签打成 jar 包，以后用到了直接丢进 lib 就行了，打包的时候建一个普通的 Java 工程就行，只要保证在 web 项目中没问题，拷贝到 Java 项目中后出现的错误不用管，是 J2EE 依赖的问题，然后把 tld 文件放在根目录下的 META-INF 目录就行，参考 Tomcat 中自带的 Jar 包结构。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编写简单的爬虫]]></title>
      <url>http://bfchengnuo.com/2017/04/13/%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<p><center>我用的 Python 版本是 3.X 的，现在大部分的库应该也都过渡到 3 了吧<br>顺便说说比较实用的一个功能，虚拟化环境，使用的是 Virtualenv </center> <a id="more"></a></p>
<h2 id="爬虫的简单架构"><a href="#爬虫的简单架构" class="headerlink" title="爬虫的简单架构"></a>爬虫的简单架构</h2><p>首先分为几个模块，首先还要有一个调度端，来负责启动爬虫、停止爬虫、监视爬虫的状态<br>在爬虫模块中主要有：URL 管理器、网页下载器、网页解析器<br>具体架构和运行流程见下图，说的非常清楚了<br><img src="/image/dev/爬虫架构.png" alt="爬虫架构.png"></p>
<p><img src="/image/dev/爬虫运行流程.png" alt="爬虫运行流程.png"></p>
<h2 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h2><p><strong>在 Python 3.x 里，urllib2 改名为 urllib</strong>，被分成一些子模块： urllib.request、urllib.parse 和 urllib.error。尽管函数名称大多和原来一样，但是在用新的 urllib 库时需要注意哪些函数被移动到子模块里了。 </p>
<p><strong>urllib 是 Python 的标准库</strong>（就是说你不用额外安装就可以运行这个例子），包含了从网络请求数据，处理 cookie，甚至改变像请求头和用户代理这些元数据的函数。这个库的说明文档在：<a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="noopener">https://docs.python.org/3/library/urllib.html</a></p>
<p>首先来看一下最基本也是最简单的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="comment"># urlopen 用来打开并读取一个从网络获取的远程对象</span></span><br><span class="line"><span class="comment"># 它可以读取 HTML 文件、图像文件、其他任何文件流</span></span><br><span class="line">html = urlopen(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">print(html.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展一下</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = request.urlopen(url, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> response.getcode() != <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> response.read()</span><br><span class="line">	<span class="comment">#  Py3 中默认是 u8，在出现乱码时手动设定下</span></span><br><span class="line">    <span class="comment"># return response.read().decode('UTF-8')</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'下载异常'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>当然有些网站可能会对爬虫进行屏蔽处理，这时候我们一般进行浏览器伪装，必要的时候要使用 Cookie，我目前遇到的加个请求头就可以了，这里使用到了 Request 这个类，比较简单，等后面再扩展</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加请求头，伪装浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 设置存放路径以及根 url</span></span><br><span class="line">    self.homeUrl = <span class="string">"http://huaban.com/boards/3191393"</span></span><br><span class="line">    self.h = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 '</span></span><br><span class="line">    &#125;</span><br><span class="line">req = request.Request(self.homeUrl, headers=self.h)</span><br><span class="line">request.urlopen(req).read().decode(<span class="string">'UTF-8'</span>)</span><br></pre></td></tr></table></figure>
<p>Request 官方中文文档：<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#</a></p>
<h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p>简单说，这个库就是来解析 HTML 的，通过标签将 HTML 进行结构化处理、展示，一切都是为了便于从杂乱的 HTML 获得有用的信息</p>
<p>由于 BeautifulSoup 库不是 Python 标准库，因此需要单独安装，最新的版本为 BeautifulSoup 4 版本（也叫 BS4 ）我们可以通过 Python 的包管理 pip 命令进行安装：<code>$pip install beautifulsoup4</code><br>像我，如果用的 PyCharm 可以直接在项目设置里搜索安装，或者直接先写上导入代码(<code>from bs4 import BeautifulSoup</code>)，然后利用错误修正快速安装</p>
<p>好了，下面就来看看它的基本用法吧，也是官方提供的一段代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.文档字符串 2.HTML解析器 3.文档编码</span></span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">'html.parser'</span>,from_encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找所有指定节点的名称、属性、内容</span></span><br><span class="line">print(<span class="string">'获取所有连接'</span>)</span><br><span class="line">links = soup.find_all(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    print(link.name,link[<span class="string">'href'</span>],link.get_text())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'查找指定属性'</span>)</span><br><span class="line">link_node = soup.find(<span class="string">'a'</span>, href=<span class="string">"http://example.com/lacie"</span>)</span><br><span class="line">print(link_node.name, link_node[<span class="string">'href'</span>], link_node.get_text())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'使用正则'</span>)</span><br><span class="line">link_node = soup.find(<span class="string">'a'</span>, href=re.compile(<span class="string">r"ill"</span>))</span><br><span class="line">print(link_node.name, link_node[<span class="string">'href'</span>], link_node.get_text())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'指定class名'</span>)</span><br><span class="line">p_node = soup.find(<span class="string">'p'</span>, class_=<span class="string">"title"</span>)</span><br><span class="line">print(p_node.name, p_node.get_text())</span><br></pre></td></tr></table></figure>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>在爬取网页的时候，常见的有两种错误，比如我们使用 urlopen 函数来打开一个网页，那么可能</p>
<ul>
<li>这个网页不存在，就是说在服务器上找不到<br>程序可能会返回 HTTP 错误，比如 404 或者 500 之类的，这是 urlopen 都会都会抛出 <strong>HTTPError</strong> 异常，我们可以使用 <code>try...except</code> 语句来进行捕捉</li>
<li>服务器不存在<br>urlopen 会返回一个 None 对象，我们可以使用 <code>if html is None</code> 来进行判断下</li>
</ul>
<p>除了上面最基本的两个，还有其他很多情况，比如获取到的网页内容并不是和我们预想的一样，这样的话，我们使用 BeautifulSoup 的时候就会出现问题</p>
<p>如果你想要调用的标签不存在，BeautifulSoup 就会返回 None 对象，如果再调用这个 None 对象下面的子标签，就会发生 AttributeError 错误，解决方案嘛，可以按照下面的代码来写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> HTTPError</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        html = urlopen(url)</span><br><span class="line">    <span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bsObj = BeautifulSoup(html.read())</span><br><span class="line">        title = bsObj.body.h1</span><br><span class="line">    <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line">title = getTitle(<span class="string">"http://www.pythonscraping.com/pages/page1.html"</span>)</span><br><span class="line"><span class="keyword">if</span> title == <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">"Title could not be found"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(title)</span><br></pre></td></tr></table></figure>
<p>如果服务器不存在，上面代码中 html 就是一个 None 对象，<code>html.read()</code> 就会抛出 AttributeError</p>
<h2 id="Virtualenv"><a href="#Virtualenv" class="headerlink" title="Virtualenv"></a>Virtualenv</h2><p>我们知道所有第三方的包都会被 <code>pip</code> 安装到 Python3 的 <code>site-packages</code> 目录下。</p>
<p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个 Python，就是安装在系统的 Python 3。如果应用 A 需要jinja 2.7，而应用 B 需要 jinja 2.6 怎么办？</p>
<p>这种情况下，每个应用可能需要各自拥有一套“独立”的 Python 运行环境。virtualenv 就是用来为一个应用创建一套“隔离”的 Python 运行环境。也可以说是一个虚拟化环境</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先，我们用 pip 进行安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>然后创建一个目录，在这个目录进行初始化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd Test</span><br><span class="line"><span class="meta">$</span> virtualenv venv</span><br><span class="line"><span class="meta">#</span> $ virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure>
<p><strong>virtualenv venv</strong>  将会在当前的目录中创建一个文件夹(此例中是 venv)，包含了 Python 可执行文件，以及 pip 库的一份拷贝，这样就能安装其他包了。虚拟环境的名字（此例中是 venv ）可以是任意的；若省略名字将会把文件均放在当前目录。</p>
<p>有时也会加上 <code>--no-site-packages</code> 参数，这样已经安装到系统 Python 环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的 Python 运行环境。</p>
<p>还可以使用 <code>-p</code> 参数指定 Python 解释器，我这里只有 Py3</p>
<p>在 venv 环境下，用 pip 安装的包都被安装到 venv 这个环境下，系统 Python 环境不受任何影响。也就是说，venv 环境是专门针对 Test 这个应用创建的。</p>
<p>环境差不多已经配置完毕，下面就可以进入这个环境进行操作了，进入后当前虚拟环境的名字会显示在提示符左侧，然后就可以使用 pip 安装库，或者使用 Python 进入Py 的环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> source venv/bin/activate</span><br><span class="line"><span class="meta">#</span> 如果是 Windows 系统，使用：</span><br><span class="line"><span class="meta">#</span> venv\Scripts\activate</span><br><span class="line"><span class="meta">$</span> pip list</span><br></pre></td></tr></table></figure>
<p>完成工作后，可以使用下面的命令来停用、退出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> deactivate</span><br></pre></td></tr></table></figure>
<p>这将会回到系统默认的 Python 解释器，包括已安装的库也会回到默认的。<br>要删除一个虚拟环境，只需删除它的文件夹。（要这么做请执行 <code>rm -rf venv</code> ）</p>
<div class="note info"><p>virtualenv 是如何创建“独立”的 Python 运行环境的呢？<br>原理很简单，就是把系统 Python 复制一份到 virtualenv 的环境，用命令 <code>source venv/bin/activate</code> 进入一个 virtualenv 环境时，virtualenv 会修改相关环境变量，让命令 python 和 pip 均指向当前的 virtualenv 环境。</p>
</div>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>某些特殊需求下,可能没有网络, 我们期望直接打包一个 ENV, 可以解压后直接使用, 这时候可以使用 <code>virtualenv --relocatable ./</code> 指令将 ENV 修改为可更改位置的 ENV</p>
<blockquote>
<p>  一般情况下，隔离环境都绑定在某个特定路径下。这也就意味着不能通过仅仅是移动或拷贝目录到另一台计算机上而迁移隔离环境。 这时可以使用 <code>–relocatable</code>  来重定位隔离环境<br>  $ virtualenv –relocatable ENV</p>
</blockquote>
<p>不过这个命令在 Windows 下不能使用….也是实验性的一个命令</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>可以看看我学习时写的花瓣网和百科的简单爬虫：<a href="https://github.com/bfchengnuo/Python_learn" target="_blank" rel="noopener">Github</a><br>关于 BeautifulSoup 这里有份不错的中文文档：<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/" target="_blank" rel="noopener">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Servlet基础知识(HTTP相关)]]></title>
      <url>http://bfchengnuo.com/2017/04/11/Servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p><center>这篇主要讲的是 Request 和 Response 的一些基本使用<br>还有就是 Cookie 和 Session 的使用</center><a id="more"></a><br>关于 Servlet API 的介绍，可移步到这里：<a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Web/JavaEE%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92.md" target="_blank" rel="noopener">JavaEE 复习计划</a></p>
<h2 id="Request和Response"><a href="#Request和Response" class="headerlink" title="Request和Response"></a>Request和Response</h2><p>请求和响应，使用频率应该是非常高的，我目前也是初学者，对这两大对象了解的也不多，当然会尽量让内容丰满起来滴</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>它就是请求，带着用户的一些请求信息而来，常用的方法有：</p>
<ul>
<li><p>getParamenterNames(key)<br>  获取用户提交过来的参数的名字，返回一个枚举，GET 和 POST 都可以使用，然后可以根据名字来获得值</p>
</li>
<li><p>getParameter()<br>  很显然，这是获取指定提交参数名字(key)的值</p>
</li>
<li><p>getParameterMap()<br>  获取一个 Map 集合类型的参数集合，可以用一些库通过反射技术直接拷贝到 javabean 里面去<br>  返回值是 <code>Map&lt;String, String[]&gt;</code></p>
</li>
<li><p>getHeader(key)<br>  可能会用到，请求头也有些有用的信息，返回的是全部的请求头信息</p>
</li>
<li><p>setAttribute( key,val )<br>  设置自定义参数，除了获取值还可以设置值，可以通过转发等方式继续向下传递</p>
</li>
<li><p>setCharacterEncoding()<br>  设置 request 的编码，解决中文乱码问题，提交中文数据的时候是按当前网页的码表进行提交，但是 request 的默认码表未必是你设置的码表，所以就会有乱码，所以要先设置一下<br>  当然改服务器的配置也是可以的，但是不推荐<br>  <strong>但是这个方法只对 POST 请求方式有效</strong>，GET 方式出现中文要进行URL编码，内容都在 URL 中，还有其实各个浏览器默认编码也不统一，对于 GET 方式的处理方式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setCharacterEncoding 方法和 getCharacterEncoding 方法只对请求体起作用</span></span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 第一个参数是 Tomcat 编码，第二个是浏览器编码</span></span><br><span class="line">name = <span class="keyword">new</span> String(name.getBytes(<span class="string">"iso8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>
<p>  至于为什么要使用 <code>getBytes(&quot;iso-8859-1&quot;)</code>，是因为在你浏览器用某种编码后，Servlet 容器自作多情给你用 <code>iso-8859-1</code> 解码了一下，所以….只能原路返回<br>  在 Tomcat8 + 的版本，官方已使用 UTF-8 编码，不存在这个问题了</p>
</li>
<li><p>getRequestDispatcher(“path”).forward(request,response)<br>这就是我们经常写的请求转发<br><strong>一个请求只能往客户机写出一次，当 clos 以后就不能再写了，所以转发后别关呀</strong><br>同样转发也是写数据，所以只能转发一次，为了避免报错，<strong>所以转发后最好写个 return</strong><br>转发时会把以前写的数据（Response中）清空</p>
</li>
<li><p>getRequestDispatcher(“path”).include(request,response);<br>包含界面，也很常用，需要注意的是，被包含页面不要写全部的 html 标签，因为是整个文件包含进来，所以只写主体部分就可以了</p>
</li>
<li><p>getInputStream()<br>获取流，一般上传文件的时候会用到</p>
</li>
</ul>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>相比 Request 来说 Response 的使用就比较简单了，当然说的是常规使用<br>通常我们会设置：<code>setContentType(&quot;text/html;charset=utf-8&quot;);</code><br>它其实相当于两句，设置响应头和 response 对象的默认编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置resp使用什么码表，往里写字符流的时候，建议还是写上，清晰点</span></span><br><span class="line">resp.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">resp.setHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure>
<p>然后就是使用 <strong>sendRedirect()</strong> 进行重定向<br>至于 getOutputStream 和 getWriter 方法我就不多说了，就是一个字节流一个字符流，使用字符流要注意编码，他们两个不能同时使用</p>
<p>如果是下载文件的需求或者存在中文记得要进行 URL编码 后再设置到 header。<br>再说缓存问题，通过设置头信息可以禁止浏览器缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不允许浏览器端或缓存服务器缓存当前页面信息。</span></span><br><span class="line">response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"No-cache"</span>);</span><br><span class="line"><span class="comment">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>但是需history要注意的是浏览器的后退按钮直接走的  history 缓存，默认是不刷新页面的。</p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>至于它们是什么，什么用，在以前的文章 <a href="https://bfchengnuo.com/2017/03/13/HTTP%E7%AC%94%E8%AE%B0/#Session与Cookie">HTTP笔记中</a> 已经说的很清楚了，不多说，一句话概况就是用来管理会话的</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>一段代码说明问题，简单的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户的cookie</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cookies != <span class="keyword">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cookies[i].getName().equals(<span class="string">"time"</span>))&#123;</span><br><span class="line">        <span class="keyword">long</span> time = Long.parseLong(cookies[i].getValue());</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">        writer.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新的 cookie</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"time"</span>,System.currentTimeMillis()+<span class="string">""</span>);</span><br><span class="line"><span class="comment">// 设置有效期 单位：秒  如果设为 0 表示清除，负数表示关闭浏览器失效，path一定要一致</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">3600</span>);</span><br><span class="line"><span class="comment">// 如果不设置，默认是当前页面有效</span></span><br><span class="line">cookie.setPath(<span class="string">"/webapp"</span>);</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p>重点是 path 的默认值，通过看源码就很明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...............其他代码................</span></span><br><span class="line"><span class="keyword">for</span> (String headerValue : responseHeaders.get(headerKey)) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;HttpCookie&gt; cookies = HttpCookie.parse(headerValue);</span><br><span class="line">    <span class="keyword">for</span> (HttpCookie cookie : cookies) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cookie.getPath() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If no path is specified, then by default</span></span><br><span class="line">        <span class="comment">// the path is the directory of the page/doc</span></span><br><span class="line">        String path = uri.getPath();</span><br><span class="line">        <span class="keyword">if</span> (!path.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">          <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">"/"</span>);</span><br><span class="line">          <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path = path.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path = <span class="string">"/"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cookie.setPath(path);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...............其他代码................</span></span><br></pre></td></tr></table></figure>
<p>可以总结为：</p>
<ul>
<li>当 cookie 的 path 设置了值不为 null 的时候，以设置的值为准。</li>
<li>当 cookie 的 path 为 null 时候，获取请求的 URI 的 path 值。<ul>
<li>当 URI 的 path 值是以 <code>/</code> 结尾的时候，直接设置为 cookie 的 path 值</li>
<li>当 URI 的 path 值不是以 <code>/</code> 结尾的时候，查看 path 里面是否有“/”<br>如果有“/”的话，直接截取到最后一个“/”，然后设置为 cookie 的 path 值。<br>如果没有“/”的话，将 cookie 的 path 设置为 /</li>
</ul>
</li>
</ul>
<p>然后就是不要忘记父域可以访问子域的 cookie。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>同样是一段代码就可以说明问题，简单使用，Session 还是会用到 Cookie的，默认情况下它会以一个固定的名字（Jsessionid）将ID存储到 Cookie，然后，以后的请求就会带有这个 Cookie，也就 SessionID，SessionID 也可以理解为是 Cookie 中特殊的一个值，<strong>它默认不设置有效期，也就是浏览器关闭就会失效</strong><br>如果需要自定义有效期有手动进行覆盖(其实就是设置此 Cookie 的有效期)，记得设 path<br>一般情况下都要对这个 ID 进行加密处理的，同时，一个浏览器独占一个 Session</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="comment">// 还可以接受一个参数，用来控制如果没有的话是否创建</span></span><br><span class="line"><span class="comment">// request.getSession(false);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session 域传递参数，数据存在服务器</span></span><br><span class="line">session.setAttribute(<span class="string">"key"</span>,<span class="string">"data"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"token"</span>,<span class="string">"base64-md5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  当浏览器禁用 Cookie 的时候，使用 URL 进行传输 Session ID</span></span><br><span class="line"><span class="comment">  第一次请求会返回一个带 SessionID 的URL，</span></span><br><span class="line"><span class="comment">  当检测到下一次请求带有Cookie的时候，表示Cookie没有被禁用，以后就不再更改 URL</span></span><br><span class="line"><span class="comment">  然后把此 url 设置给 a 标签之类的就可以了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String strURL = response.encodeURL(<span class="string">"/JavaWeb/xx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// session.invalidate();  手动销毁</span></span><br></pre></td></tr></table></figure>
<p>如果仅仅是简单使用的话，其实只用第一行代码就足够了<br>想要手动设置 Session 的期限的话，需要造一个 Cookie 然后把那个 SessionID 写进去，相当于覆盖了原先的，然后设个时间；这样是为了用户关闭浏览器后再打开的时候还可以保持以前的状态，当然这个时间一般最多也就是半小时，因为默认半小时后 SessionID 就被服务器给回收了，带过去也没用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">String id = session.getId();</span><br><span class="line"><span class="comment">// 设置 Cookie 相同的 key 进行覆盖</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>, id);</span><br><span class="line">cookie.setPath(<span class="string">"/JavaWeb"</span>);  <span class="comment">// 不要忘记</span></span><br><span class="line">cookie.setMaxAge(<span class="number">30</span> * <span class="number">60</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure>
<p>不过有些浏览器的版本（IE）是按进程来区分的，就是说你同时打开两个浏览器的窗口 Session 是共享的<br>选项卡直接是共享的，这个任何浏览器都没问题</p>
<p>在 web.xml 中可以控制 Session 的回收时间、默认名称等，在  <code>&lt;session-config&gt;</code> 标签设置<br>如果启用了 HTTPS 那么 SessionID 完全可以使用 SSLSessionID ，毕竟在握手的时候就创建了一个密钥了</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Cookie 可以用来实现 记住密码 的功能，当然要进行加密处理，也可以保存一下其他的不是很重要的信息，因为毕竟它保存在客户端，其实就是一个文本文件，可以人为的进行修改，不安全</p>
<p>Session 一般用来记录用户的登陆状态，这个放在服务器端比较好，不管是从安全方面还是设计方面<br>还可以用来防止表单的重复提交，给表单加一个隐藏域来保存 id 参数，同时也存一份在 Session 中，然后提交的时候先判断带过来的 id 是否合法，就是与 Session 中的进行比较，如果合法就删除掉，然后处理请求，如果不合法直接 return 哼</p>
<p>关于生成的唯一 id，或者叫令牌  Token，一般最后要进行摘要算法进行处理（比如用 MD5），变成固定长度的数据，但是这个数据是二进制的，不能直接搞成字符串，所以再进行 Base64 进行编码，这样一般就没问题了<br>PS：了解 Base64 是什么看左边菜单的科普</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对于四大域（ServletContext 、Request 、Session、PageContext）的使用：<br><div class="note info"><p>数据显示后就没用了，使用 Request 域，比如 Servlet 传给 JSP 进行显示<br>数据显示后还要用，使用 Session 域<br>数据显示后还要用，并且还要给别人用，那就使用 context 域</p>
</div></p>
<p>关于地址的写法，遵循：<br>如果地址是给服务器用的 <code>/</code>代表 Web 应用<br>如果是给浏览器用的 <code>/</code> 代表网站（就是 webapps），网站下有多个应用</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSP技术]]></title>
      <url>http://bfchengnuo.com/2017/04/03/JSP%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><strong>JSP</strong>（全称JavaServer Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同建立的一种使软件开发者可以响应客户端请求，而动态生成HTML、XML或其他格式文档的Web网页的技术标准。<br>最终还是要由 JSP 编译器翻译成 Servlet 执行</p>
</blockquote><a id="more"></a>
<h2 id="JSP运行原理"><a href="#JSP运行原理" class="headerlink" title="JSP运行原理"></a>JSP运行原理</h2><p>服务器会先将 JSP 翻译为 Servlet ，最后会生成在 Tomcat 的 Work 文件夹，可以去扒一下源码，其实就是 Servlet</p>
<p>访问一个网站的流程一般是：浏览器访问 –&gt; Servlet —(通过转发)–&gt; JSP<br>注意，转发使用的是一个请求<br>如果有参数，使用 request 域将参数带过去</p>
<p>通过看 JSP 翻译后的 Servlet 文件，就可以发现 JSP 中的内容被翻译到了方法中，在这个方法中默认就定义了九大对象，我们称为是九大隐式对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">    javax.servlet.http.HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">    javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">    javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">      			<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      out.write(<span class="string">'\r'</span>);</span><br><span class="line">      out.write(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">	String path = request.getContextPath();</span><br><span class="line">	String basePath = request.getScheme() + <span class="string">"://"</span></span><br><span class="line">			+ request.getServerName() + <span class="string">":"</span> + request.getServerPort()</span><br><span class="line">			+ path + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">      out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;head&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;base href=\""</span>);</span><br><span class="line">      out.print(basePath);</span><br><span class="line">      ........</span><br></pre></td></tr></table></figure>
<p>我们看到，jsp 页面的内容其实就是用 out 进行了输出，如果嵌入了 java 代码（<code>&lt;% code %&gt;</code>），就会原封不动的翻译到这个方法里，需要注意一点是，可以看到上面翻译后的 JSP 默认调用了 <code>getSession()</code> 方法，也就是默认会给每一个会话产生一个 Session ，这个对于传值来说还是很方便的（比如常用的： <code>request.getSession().setAttribute()</code>），但是相应的也会耗费一些资源，毕竟每开一个窗口就会创建一个 Session，并且还是存在内存里<br>在 JSP 页面可以通过 session 属性来控制是否默认产生 Session</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">session</span>=<span class="string">"false"</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结一下，这九大对象是<!--访问服务器的时候会自动创建八大对象，一共有九大对象，异常这个对象不会被自动创建（详细看下面）-->：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Request</span><br><span class="line">Response</span><br><span class="line">Session</span><br><span class="line">Application</span><br><span class="line">Config</span><br><span class="line">Out  * （有缓冲）</span><br><span class="line">Exception</span><br><span class="line"><span class="comment">// 当前 JSP 的实例, object类型</span></span><br><span class="line"><span class="comment">// 它代表JSP被编译成Servlet,可以使用它来调用Servlet类中所定义的方法</span></span><br><span class="line"><span class="comment">// 注意 Page 和 pageContext 的区别</span></span><br><span class="line">Page</span><br><span class="line">pageContext  *</span><br></pre></td></tr></table></figure>
<p>其中有两个比较特殊的对象，已经使用 <code>*</code> 标出了<br><div class="note warning"><p>通过上面的代码我们知道 jsp 中的 html，默认也是用 out 输出，它是有缓冲区，当缓冲区满了或者页面关闭时才会刷到Response 去<br>所以，如果 代码中有 getWrite 的输出，那么html的内容会在它的后面，<strong>所以最好只使用 out 进行输出</strong></p>
<p>当第一次访问 JSP 的时候会被翻译成 Servlet，而不是启动服务器的时候翻译，所以第一次访问 JSP 页面的时候比第二次慢得多，只要翻译过了，以后就会直接用</p>
</div></p>
<hr>
<p>然后我们再来看看：pageContext<br>可以认为它是 JSP 的运行环境，<strong>它在内部封装了其他八大隐式对象的引用</strong>（多用于自定义标签）<br>所以，当需要传数据的时候可以直接传一个 pageContext 有了它，就等于啥也有了</p>
<p>同时它自身是一个域对象，可以用来保存数据，使用它的 setAttribute 方法</p>
<p>然后再来看看它的生命周期：就是 JSP 这个页面 打开/关闭，所以还是蛮短的</p>
<p>来看个非常好用的方法：<strong>findAttribute()</strong> 查找所有域中的数据，顺序为：<br><strong>pageContext —&gt; request —&gt; session —&gt; application</strong> 在 JSP 中，使用的 <code>${data}</code> 其实就是调用的它<br>在 Jsp 中我们写链接的时候，当然不能把链接的路径给写死，一般都是使用 <code>${pageContext.request.contextPath}</code> 获得当前 web 应用的路径，然后再补全具体的地址<br>还有两个也比较使用，省了不少事：forward（转发）  和 include 方法，不再多说</p>
<hr>
<p>JSP页面中有一个内置的 <strong>exception</strong> 对象，这个 <strong>exception</strong> 对象是 Throwable 的实例。<strong>当在 JSP 中发生错误或异常时</strong>，就会将捕获的 <code>java.lang.Throwable t</code> 赋值给内置对象 exception 异常对象。<br><strong>由此可见，exception 对象仅在异常处理页面中才有效</strong>，是异常处理页面！<br>整个 <code>_jspService</code> 方法会被 try 起来，当异常被捕获到后会交给 <code>_jspx_page_context</code> 处理，首先判断抛出异常的当前 JSP 页面 page 指令是否指定了 errorPage 属性，如果指定了，则将请求 forward 到 errorPage 属性指定的页面；否则就使用系统页面来输出异常信息。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page1 --&gt;</span><br><span class="line">&lt;%@ page errorPage=<span class="string">"/page2.jsp"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的是 page2 --&gt;</span><br><span class="line">&lt;!-- page2 中输出异常信息，因为都是 JSP 自带 exception 对象 --&gt;</span><br><span class="line">&lt;%=exception.toString() %&gt;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://www.jellythink.com/archives/1353" target="_blank" rel="noopener">http://www.jellythink.com/archives/1353</a></p>
<h2 id="JSP指令-标签"><a href="#JSP指令-标签" class="headerlink" title="JSP指令/标签"></a>JSP指令/标签</h2><p><strong>首先要明确的是：JSP 是用于输出的，格式良好的JSP 不允许出现(尽量少的出现) Java 代码</strong></p>
<p>专用的脚本表达式输出某个变量/属性：<code>&lt;%=name %&gt;</code> ；还看到有这样用的 <code>&lt;%=request.getContextPath()%&gt;</code> ，感觉还是用 <strong>$</strong> 比较好</p>
<p>JSP 的声明一般有两种：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 这是注释，不会输出到 html 中 --%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 下面标签中如果写java代码，会被翻译到 _jspService 方法中 --%&gt;</span><br><span class="line">&lt;% code %&gt;</span><br><span class="line">&lt;%-- 下面标签中如果写java代码，会被翻译到 _jspService 方法外中，所以可以定义方法 --%&gt;</span><br><span class="line">&lt;%! code  %&gt;</span><br></pre></td></tr></table></figure>
<p>JSP 指令是给解析引擎看的，这里也就是 Tomcat：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 比如导包、设定是否创建 session 对象、错误页面，但是不要太大，&lt;<span class="number">1</span>K --%&gt;</span><br><span class="line">&lt;%@ page %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 包含页面，是静态包含 --%&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">""</span> %&gt;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>关于 include ：<br>包含就是把整个页面搞进来，所以要 include 的页面最好不要写头标签 head 之类的，直接写重点即可<br><strong>静态包含就是把这些页面拼合在一个 Servlet 中</strong><br><strong>而动态包含就是：翻译成多个 Servlet ，等访问时再合成，所以还是尽量使用静态的吧</strong><br>例子：<code>request.getRequestDispatcher(&quot;path&quot;).include(request,response);</code></p>
</div>
<p>下面来说说 JSP 的标签，主要的就是这三类：</p>
<ul>
<li><code>&lt;jsp:forward page=&quot;&quot;&gt;</code><br>就是转发啦，直接写地址就可以了</li>
<li><code>&lt;jsp:param name=&quot;xx&quot; value=&quot;dd&quot;&gt;</code><br> 传递参数用的，常套在 forward 标签里使用</li>
<li><code>&lt;jsp:include page=&quot;&quot;&gt;</code><br>就是动态包含了，不过不推荐</li>
</ul>
<p>更多的标签可以去 Wiki 看下：<a href="https://zh.wikipedia.org/wiki/JSP" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/JSP</a> 还是很详细的</p>
<h2 id="EL表达式与JSTL"><a href="#EL表达式与JSTL" class="headerlink" title="EL表达式与JSTL"></a>EL表达式与JSTL</h2><p>更新于：2017-4-21</p>
<h3 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h3><p>关于 EL 现简单说一个，以后再补充：<br><code>${data}</code>  —–&gt;  <code>pageContext.findAttribute(&quot;data&quot;)</code><br>其实就是简化了代码，最大的一个好处是：<strong>如果没有找到就返回空字符串</strong>，不会影响显示</p>
<hr>
<p>EL 表达式的作用嘛，基本上可以概况为四点：</p>
<ol>
<li>获取数据</li>
<li>执行运算</li>
<li>获取 web 开发常用对象</li>
<li>调用 java 方法</li>
</ol>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>这个在之前写的就是了，就是分割线之前的内容，就是来获取数据的，其他的还有获取 Javabean 的，很简单，其实是获取的<strong>属性</strong>，只要有对应的 get/set 方法就行，写 EL 的时候省略 get；以及还有一些常用的：<br><code>${name}</code> JSP 引擎会自动拿着 name 当key，去四个域查找，上面我们也说过了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 List 中的数据</span></span><br><span class="line"><span class="comment">// 和 JS 类似，data.key == data['key']</span></span><br><span class="line">$&#123;data[<span class="string">'1'</span>].name&#125;</span><br><span class="line"><span class="comment">// 获取 Map 中的数据</span></span><br><span class="line">$&#123;data.key.name&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行运算"><a href="#执行运算" class="headerlink" title="执行运算"></a>执行运算</h4><p>语法：<code>${运算表达式}</code><br>其实就是在 <strong>{}</strong> 内做一些逻辑判断之类的，用的比较多的是下面几个，注意是花括号不是小括号</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 检测是否为 <span class="keyword">null</span> 或者 空 --%&gt;</span><br><span class="line">$&#123;empty(data)&#125;</span><br><span class="line">&lt;%-- 二元表达式的支持 --%&gt;</span><br><span class="line">&lt;input type=<span class="string">"radio"</span> name=<span class="string">"sex"</span> $&#123;user == <span class="string">'nv'</span>?<span class="string">'checked'</span>:<span class="string">''</span>&#125;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="获取-web-开发常用对象"><a href="#获取-web-开发常用对象" class="headerlink" title="获取 web 开发常用对象"></a>获取 web 开发常用对象</h4><p>这个用的比较频繁，前面其实也用到了，就是获取当前应用名的时候<br>EL 表达式定义了 11 种隐式对象<br>解析的时候先要判断传入的是否是隐式对象，语法 <code>${隐式对象名}</code></p>
<ol>
<li>pageContext</li>
<li>pageScope<br>返回的是 page 域中的 Map 集合；也就是从指定域 (page) 找</li>
<li>requestScope<br>返回的是 request 域中找 ，下同</li>
<li>sessionScope</li>
<li>applicationScope</li>
<li>param<br>返回请求参数的 Map 集合</li>
<li>paramValues<br>返回的是数组，对应多个请求参数的情况</li>
<li>header<br>返回的是请求头的 Map 集合</li>
<li>headerValues</li>
<li>cookie<br>返回的是保存了 Cookie 的 Map 集合,<br>注意：每一个 key 获取到的是一个 Cookie 对象<br>比如这样用：<code>${cookie.JSESSIONID.value/name}</code></li>
<li>initParam<br>返回的是web 应用的初始化参数的 Map 集合，<br>就是 web.xml 文件中的 <code>&lt;content-param&gt;</code> 中的内容</li>
</ol>
<h4 id="执行-Java-代码"><a href="#执行-Java-代码" class="headerlink" title="执行 Java 代码"></a>执行 Java 代码</h4><p><strong>只能是 静态方法！</strong><br>并且相应的方法需要在 tld 文件中进行描述<br>只能执行与 web 开发无关的代码，一些工具类啊，也能想得通，毕竟静态；所以它不能取代<a href="https://bfchengnuo.com/2017/04/20/JSP%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/">自定义标签</a><br>在 JSP 中的使用和自定义标签一样，tld 文件的定义名称、含包名的路径、方法的定义，类似：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>utils.WebUtils<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>java.lang.String test(java.lang.String)<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 JSP 中这样用：<code>${c:test(&quot;str&quot;)}</code>  ；c 是你导入时候定义的名称<br>不得不说 IDEA 的代码提示真是爽！</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>其实还可以看出，EL 表达式是不支持字符串的连接的，还有一些其他需求的话自带的是满足不了我们的，所以就会有自定义 EL 函数了<br>一般习惯于命名为 MyEL<br><code>${}</code> 中是可以套 el 函数的，比如下面的写法是完全可行的<br><code>${user == null?my:test(str):&#39;&#39;}</code></p>
<p>还有一点需要注意的是：<strong><code>$</code> 中不能再嵌套 <code>$</code>，</strong> 写法上写一个就行了，效果还是有的</p>
<p>EL 表达式取出的类型会自动推断，不需要为类型（转换）而操心。</p>
<h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p>至于 JSTL ，说白了就是用来做一些逻辑判断的，其实感觉就是一些<a href="https://bfchengnuo.com/2017/04/20/JSP%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/">自定义标签</a> ，毕竟它就叫 JSP 标准标签库嘛。<br>需要导入相应的 jar 包，<code>jstl.jar 、 standerd.jar</code>，放在 lib 目录下即可；<br>导入标签库：在 JSP 的开始声明：<code>&lt;%@ taglib url=&quot;http://java.sun.com/jsp/jstl/core&quot; prifix=&quot;c&quot; %&gt;</code><br>url 可以在导入的 jar 的 <strong>c.tld</strong> 文件中找到，然后给定义个名称，一般使用 c ，和文件名统一（文件名就叫 c）。<br>类似这样的使用，temp 可以是个 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:foreach</span> <span class="attr">var</span>=<span class="string">"temp"</span> <span class="attr">items</span>=<span class="string">"$&#123;list&#125;"</span>&gt;</span></span><br><span class="line">	$&#123;temp.name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">c:foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;name == null&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 字符串等比较除了 == 可以使用 eq --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;name eq 'abc'&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h4><ul>
<li><p>out<br><code>&lt;c:out value=&#39;${data}&#39; default=&#39;addd&#39; escapeXml=&#39;true&#39;&gt;&lt;/c:out&gt;</code><br>用来显示一个表达式的结果，与 <code>&lt;%= %&gt;</code> 作用相似<br>escapeXml 控制是否进行转义，如果值为空就输出 default 的值</p>
</li>
<li><p>set<br><code>&lt;c:set var=&#39;key&#39; value=&#39;data&#39; scope=&#39;page&#39;&gt;&lt;/c:set&gt;</code><br>可以设置 域、bean、map( key 为 property) 的数据; 比如上面的例子是存到 page 域</p>
</li>
<li><p>remove<br>用来删除域中的数据，使用参考上面的 set</p>
</li>
<li><p>catch<br><code>&lt;c:catch var=&#39;key&#39;&gt;&lt;/c:catch&gt;</code><br>用来处理产生错误的异常状况，并且将错误信息储存起来<br>默认将异常存到 page 域，需要指定一个 key</p>
</li>
<li><p>if<br><code>&lt;c:if test=&#39;逻辑&#39;/&gt;</code></p>
</li>
<li><p>choose<br>相当于 if…else，或者说 switch 分支语句，就是只选择一个，第一个通过后就不会向下执行了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:choose</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c:when</span> <span class="attr">test</span>=<span class="string">''</span>&gt;</span>if true<span class="tag">&lt;/<span class="name">c:when</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c:otherwise</span>&gt;</span>else<span class="tag">&lt;/<span class="name">c:otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:choose</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach<br>  迭代，varStatus 对象表示当前选择的是那个; 还可以做分页，step 是步长</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">'key'</span> <span class="attr">varStatus</span>=<span class="string">'status'</span> <span class="attr">items</span>=<span class="string">"$&#123;list&#125;"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"$&#123;status.conut%2==0?'even':'odd'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 输出 1-7</span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">var</span>=<span class="string">'key'</span> <span class="attr">begin</span>=<span class="string">'1'</span> <span class="attr">end</span>=<span class="string">'7'</span> <span class="attr">step</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">  $&#123;key&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>url<br>  主要用于 url 的重写！ 会自动构建 url 的 Session 地址，自动加入当前应用的名字，不需要手动获取了，如果不写 var 属性就会默认输出到页面上，否则就存到 var 指定的变量中</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c:url</span> <span class="attr">var</span>=<span class="string">'key'</span> <span class="attr">value</span>=<span class="string">'url'</span>&gt;</span></span><br><span class="line">	// 设置 url 的 get 参数，如果是中文会自动进行编码</span><br><span class="line">	<span class="tag">&lt;<span class="name">c:param</span> <span class="attr">name</span>=<span class="string">'key'</span> <span class="attr">value</span>=<span class="string">'测试'</span>&gt;</span><span class="tag">&lt;/<span class="name">c:param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:url</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>redirect<br>  实现重定向</p>
</li>
<li><p>forTokens<br>  用 delims 定义的值来分割 items 里的数据，然后迭代<br>  <code>&lt;c:forTokens var=&#39;key&#39; items=&#39;${data}&#39; delims=&#39;,&#39;&gt;&lt;/c:forTokens&gt;</code><br>  例如，items 中存的是字符串 “a,b,c,d” ；那么第一次迭代 key 就是 a，第二次是 b …..</p>
</li>
</ul>
<p>JSTL 除了核心标签库还有其他的几个库，更详细的说明可参考：<a href="http://www.runoob.com/jsp/jsp-jstl.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-jstl.html</a><br>其中有个格式化标签需要特别注意下：<code>&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</code> , 非常的好用</p>
<h4 id="JSTL-中的-EL-函数库"><a href="#JSTL-中的-EL-函数库" class="headerlink" title="JSTL 中的 EL 函数库"></a>JSTL 中的 EL 函数库</h4><p>JSTL 也就是官方给的一个库，里面还包含了些 EL 的函数库，<strong>一般是用来操作字符串的</strong> ，如果没有，就只能去自定义了<br>使用之前记得导入：<code>&lt;%@ taglib url=&quot;http://java.sun.com/jsp/jstl/functions&quot; prifix=&quot;fn&quot; %&gt;</code> ；可以看出是在 <strong>fn.tld</strong> 的文件中描述的<br>通过名字基本上也能看出是什么作用来，常见的有：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:toLowerCase(str)&#125;</span><br><span class="line">$&#123;fn:trim(str)&#125;</span><br><span class="line"></span><br><span class="line">$&#123;fn:length(str)&#125;</span><br><span class="line"><span class="comment">// 利用 length 的迭代方式</span></span><br><span class="line">&lt;c:forEach var=<span class="string">'i'</span> begin=<span class="string">'0'</span> end=<span class="string">'$&#123;fn:length(list)&#125;'</span> &gt;</span><br><span class="line">	$&#123;list[i]&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">$&#123;fn:split(str,<span class="string">','</span>)&#125;</span><br><span class="line"><span class="comment">// 连接；1.要连接的字符串数组 2.链接符</span></span><br><span class="line">$&#123;fn:join(str,<span class="string">'.'</span>)&#125;</span><br><span class="line"><span class="comment">// 查找；返回的是 int 索引值</span></span><br><span class="line">$&#123;fn:indexOf(str,<span class="string">'key'</span>)&#125;</span><br><span class="line"><span class="comment">// 包含；str 中是否包含 key，返回布尔类型，大小写敏感</span></span><br><span class="line">$&#123;fn:contains(str,<span class="string">'key'</span>)&#125;</span><br><span class="line"><span class="comment">// 是否以指定的 key 开头</span></span><br><span class="line">$&#123;fn:startsWith(str,<span class="string">'key'</span>)&#125;</span><br><span class="line"><span class="comment">// 替换；1.源字符 2.替换那个字符 3.替换成什么</span></span><br><span class="line">$&#123;fn:startsWith(str,<span class="string">'key'</span>,<span class="string">''</span>)&#125;</span><br><span class="line"><span class="comment">// 截取；从 1 截取到 3，在 java 中最后一个表示的是截取长度</span></span><br><span class="line">$&#123;fn:substring(str,<span class="number">1</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="comment">// 截取之前、之后</span></span><br><span class="line">$&#123;fn:substringAfter(str,<span class="number">1</span>)&#125;</span><br><span class="line">$&#123;fn:substringBefore(str,<span class="number">1</span>)&#125;</span><br><span class="line"><span class="comment">// 转义 HTML</span></span><br><span class="line">$&#123;fn:escapeXml(str)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于乱码"><a href="#关于乱码" class="headerlink" title="关于乱码"></a>关于乱码</h2><p>中文的一大特色就是乱码咯，乱码产生的原因：</p>
<blockquote>
<p>Java 的内核和 <strong>class</strong> 文件是基于 unicode 的，这使 Java 程序具有良好的跨平台性，但也带来了一些中文乱码问题的麻烦。<br>首先 Java（包括 JSP）源文件中很可能包含有中文，而 Java 和 JSP 源文件的保存方式是基于字节流的，如果 Java 和 JSP 编译成 class 文件过程中，使用的编码方式与源文件的编码不一致，就会出现乱码。</p>
</blockquote>
<p>对于 JSP，在文件头加上 <code>&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt;</code> ，不设置默认会解析为 iso8859-1，这样基本上就能解决这类乱码问题.<br>注意，配置的 <code>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;</code> 意思为设置 jsp 文件的存储格式。<br>保险起见，还可以对请求进行软编码：<code>&lt;%request.seCharacterEncoding(&quot;utf-8&quot;);%&gt;</code></p>
<hr>
<p>对于 Servlet 的乱码，可以直接修改 Tomcat 服务器，<code>conf/server.xml</code> 中的 Connector 节点加入属性：<br><code>useBodyEncodingForURL=&quot;true&quot;</code> 。<br>如果不能修改服务器，那么就只能使用硬编码转换了，因为事先知道默认编码，所以：<code>new String(str.getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;);</code><br>无论那种，都不要忘了设置软编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p>最好还是用过滤器处理，这样基本就不会出现乱码了。</p>
<blockquote>
<p>注意！！！<br>从 Tomcat8 开始，默认编码已更换为 UTF-8，get 请求含有中文也不会乱码了（需要软编码）！<br>如果再进行硬编码处理，反而会乱码</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果需要在 web.xml 里面配置相关的映射，因为 JSP 本质还是一个 Servlet，所以按 Servlet 配置就好，只是路径换成 jsp 页面所在的位置即可</p>
<h3 id="javaBean相关"><a href="#javaBean相关" class="headerlink" title="javaBean相关"></a>javaBean相关</h3><p>首先，一个良好的 JavaBean 一般都是要有一个空构造函数的</p>
<ul>
<li><code>&lt;jsp:useBean id=&quot;loli&quot; class=&quot;com.bf.dd&quot; scope=&quot;page&quot;/&gt;</code><br>从 page 域寻找 id 为 loli 的 bean，如果找到就返回，找不到就创建<br>如果是个双标签，并且里面如果有内容，只有在创建的时候才执行里面的代码</li>
<li><code>&lt;jsp:setProperty name=&quot;id&quot; property=&quot;name&quot; value=&quot;xxxx&quot;/&gt;</code><br>设置 bean 里面的属性，id 指定那个 bean</li>
<li><code>&lt;jsp:setProperty name=&quot;id&quot; property=&quot;name&quot; param=&quot;xxxx&quot;/&gt;</code><br>将属性设置为URL请求的参数，?name=xxx</li>
<li><code>&lt;jsp:setProperty name=&quot;id&quot; property=&quot;*&quot;/&gt;</code><br>一次性设置所有的属性，从 url 参数获取，名字要对应</li>
<li><code>&lt;jsp:getProperty name=&quot;id&quot; property=&quot;name&quot; /&gt;</code><br>获取属性</li>
</ul>
<h3 id="MVC与三层架构"><a href="#MVC与三层架构" class="headerlink" title="MVC与三层架构"></a>MVC与三层架构</h3><p>关于这个我在我的公众号确实发过，当然说的也不是太深，简单理解还是够的，这里就只简单说下在 Java 中的体现<br>它们基本可以应用于任何语言的开发，不过思想都是一样的<br>有人说 三层架构是属于架构设计，MVC 是属于设计模式，当然也有人说 MVC 也是一种架构，这个不表，我现在还没整明白架构、框架是啥</p>
<ul>
<li>MVC<br>M ( Mode )  —-&gt;  其实就是 javabean ；负责数据相关<br>V ( View ) —- &gt; 指的就是 jsp；主要是来负责显示<br>C ( Controller ) —-&gt; 这个指的就是 servlet 了；用来处理请求，然后转发给 jsp 显示给用户看</li>
<li>三层架构<br>Web层 —-&gt; 基本指的就是 Servlet、jsp<br>业务逻辑层( Service ) —-&gt; 指的是 service、javabean，用来处理请求、数据的<br>数据访问层 ( Dao ) —-&gt; 指的是 dao、javabean，和数据库打交道 JDBC<br>各层之间使用接口相联系，上层调用接口，下层实现接口，这样以后如果下层的实现换了以后，上层一行代码都不需要改</li>
</ul>
<div class="note primary"><p>在 MVC 或者三层架构下，通常 jsp 的数据是 servlet 带过来的，所以用户不能直接访问 JSP，一般放在 web-inf 文件夹中保护起来<br>当然，首页的 JSP 肯定是放在外面的</p>
</div>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>关于分包，有个模板，不知道现在还用不用了….前面的包名省略了</p>
<blockquote>
<p>  domain  —-&gt; 一般放和数据库相关的 javabean 实体<br>  dao —-&gt; 放数据库相关的接口<br>  dao.impl —-&gt; 与上面的接口对应，是接口的实现<br>  service<br>  service.impl<br>  web.controller<br>  web.ui<br>  web.listener<br>  web.filter<br>  utils<br>  ……</p>
</blockquote>
<p>开发顺序一般是从下往上，也就是说一般先设计 javabean，然后编写 dao 层，然后是 service 层<br>先写 impl 层，然后使用 IDE 的抽取接口功能就好了</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AJAX入门]]></title>
      <url>http://bfchengnuo.com/2017/03/29/AJAX%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。<br>AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。<a id="more"></a><br>其实简单点说，AJAX 就是 JS 中的一个对象而已，就是 XMLHttpRequest对象</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>AJAX 是一种异步加载的技术多使用在表单提交、（滚动）加载更多、输入提示等方面</p>
<p>先来了解下同步请求是什么，比如提交一个表单，流程可以是：<br>点击提交后，客户端向服务器发起请求，服务器进行处理，然后返回结果给客户机，然后客户端刷新页面显示结果；<br>在客户端发起请求后，是一直处于等待服务器响应的状态的，没法做别的事，这是同步的一种体现</p>
<p>还是上面的例子，如果是异步请求，那就是在你输入某一个信息后，就会携带某个信息立即向服务器发起请求，服务器返回结果，从而调用 js/css 来显示给用户输入是否正确(比如用户名是否重复)<br>在这个过程用户完全可以继续填其他的内容，也不会刷新页面，这就是异步的一种体现</p>
<h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>前面我们说过，AJAX 的核心就是 XMLHttpRequest 对象，所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p>
<p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 参数为：请求方式、请求地址、是否异步(默认为异步)</span></span><br><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.action"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"ajax_test.action"</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置 HTTP 头，表明这是个表单数据</span></span><br><span class="line"><span class="comment">// 使用post方式必须设置，在open和send之间</span></span><br><span class="line">xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xmlhttp.send(<span class="string">"fname=Bill&amp;lname=Gates"</span>);</span><br></pre></td></tr></table></figure>
<p>注意 send 方法，如果是 GET 请求，因为参数都在 URL 中，所以不需要填（填了也没用），如果是 POST 请求，那么就必须把参数传入 send 方法了</p>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>对于对象来说，响应就很简单了，ajax 支持三种类型的数据：</p>
<ul>
<li>String</li>
<li>XML</li>
<li>JSON</li>
</ul>
<p>其中 String 和 JSON 的 MIME 类型都是 <code>text/plain</code> 都是使用 responseText 来接收；而 XML 类型的数据使用 responseXML 来接收，MIME 是 <code>text/xml</code> 在服务端设置的时候需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得字符串形式的响应数据。</span></span><br><span class="line">xmlhttp.responseText</span><br><span class="line"><span class="comment">// 获得 XML 形式的响应数据。</span></span><br><span class="line">xmlhttp.responseXML</span><br><span class="line"><span class="comment">// 可以直接这样获取，和html类似，但是不能用 innerHTML 方法</span></span><br><span class="line"><span class="comment">// ajax.responseXML.getElementsByTagName('root').firstChild.nodeValue;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数字或文本形式的 HTTP 状态码</span></span><br><span class="line">xmlhttp.status</span><br><span class="line">xmlhttp.statusText</span><br><span class="line"><span class="comment">// 获取所有的响应报头</span></span><br><span class="line">xmlhttp.getAllResponseHeader()</span><br><span class="line"><span class="comment">// 查询响应中的某个字段的值</span></span><br><span class="line">xmlhttp.getResponseHeader()</span><br></pre></td></tr></table></figure>
<p>我们可以通过监听 readyState 属性来实现：</p>
<blockquote>
<p>  readyState 属性的变化<strong>代表服务器响应的变化</strong><br>  0：请求未初始化，open还没有调用<br>  1：服务器连接已建立，open已经调用了<br>  2：请求已接收，也就是接收到头信息了<br>  3：请求处理中，也就是接收到了响应主体<br>  4：请求已完成，且响应已就绪，也就是响应完成了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">"GET"</span>,<span class="string">"get.php"</span>,<span class="literal">true</span>);</span><br><span class="line">request.send();</span><br><span class="line"><span class="comment">// 设置监听，每当 readyState 改变时，就会触发 onreadystatechange 事件</span></span><br><span class="line">request.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(request.readState===<span class="number">4</span> &amp;&amp; request.status===<span class="number">200</span>)&#123;</span><br><span class="line">  	<span class="comment">//做一些事情 request.responseText;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，不同的浏览器对这几种状态码的支持是不一样的，也就是说有的浏览器没有 0，有的没有 1；但是肯定都支持 4；<br>并且只有在状态码发生变化后才会触发这个函数，所以说如果状态码一直是 4 也不会触发这个函数</p>
<h3 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h3><p>如果是 XML 的数据，那么解析的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ajax.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ajax.status == <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>);</span><br><span class="line">      <span class="keyword">var</span> ruslt = ajax.responseXML;</span><br><span class="line">      <span class="keyword">var</span> str = [<span class="string">"&lt;table style='width: 600px;margin:0 auto;' border='1px'&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;邮箱&lt;/th&gt;&lt;th&gt;手机&lt;/th&gt;&lt;/tr&gt;"</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> stus = ruslt.getElementsByTagName(<span class="string">'student'</span>);</span><br><span class="line">			<span class="keyword">var</span> len = stus.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str.push(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + stus[i].getAttribute(<span class="string">'id'</span>) + <span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">        str.push(<span class="string">"&lt;td&gt;"</span> + stus[i].getAttribute(<span class="string">'name'</span>) + <span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">        <span class="comment">// stus[i].getElementsByTagName('email')[0].firstChild.nodeValue</span></span><br><span class="line">        str.push(<span class="string">"&lt;td&gt;"</span> + stus[i].childNodes[<span class="number">0</span>].textContent + <span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">        str.push(<span class="string">"&lt;td&gt;"</span> + stus[i].childNodes[<span class="number">1</span>].textContent + <span class="string">"&lt;/td&gt;&lt;/tr&gt;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      str.push(<span class="string">"&lt;/table&gt;"</span>);</span><br><span class="line"></span><br><span class="line">      div.innerHTML = str.join(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中，for 循环为了避免每次都判断 length 属性浪费性能，所以单独提出来，如果对顺序没要求，可以直接采用倒序遍历的方式，就没有这个问题了。<br>为了避免字符串拼接的效率问题，使用数组来代替字符串的拼接，主要是 push 方法增加，最后使用 <code>join(&quot;&quot;)</code> 转成字符串，如果直接使用 toString 方法那会输出 <code>abc,def,aa,xx</code> ，所以使用 join 来处理。</p>
<h3 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h3><p>JSON 类型的数据应该是最常见的，同时解析也非常的简单，因为 JSON 的语法和 JS 的对象定义基本完全一致的。<br>一般原生 JS 解析 JSON 可以使用两种方式：</p>
<ul>
<li><code>JSON.parse(str)</code></li>
<li><code>eval(&#39;(&#39; + str + &#39;)&#39;)</code></li>
</ul>
<p>后面的遍历就简单了，完全按照 JS 中的对象处理来。</p>
<h2 id="用jQuery实现"><a href="#用jQuery实现" class="headerlink" title="用jQuery实现"></a>用jQuery实现</h2><p>jQuery 已经帮我们封装好了，使用起来也非常的方便</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"#save"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      type: <span class="string">"post"</span>,</span><br><span class="line">      url: <span class="string">"service.php"</span>,</span><br><span class="line">      dataType: <span class="string">"json"</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: $(<span class="string">"#staffName"</span>).val(),</span><br><span class="line">        number: $(<span class="string">"#staffNumber"</span>).val(),</span><br><span class="line">        sex: $(<span class="string">"#staffSex"</span>).val(),</span><br><span class="line">        job: $(<span class="string">"#staffJob"</span>).val()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 必须是一个方法，成功后回调</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.success) &#123;</span><br><span class="line">          $(<span class="string">"#createResult"</span>).html(data.msg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          $(<span class="string">"#createResult"</span>).html(<span class="string">"error: "</span> + data.msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"error: "</span></span><br><span class="line">              jqXHR.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">"GET"</span>,</span><br><span class="line">  url: <span class="string">"service.php?number="</span> + $(<span class="string">'#keyword'</span>).val,</span><br><span class="line">  dataType: <span class="string">"json"</span>,</span><br><span class="line">  <span class="comment">// 必须是一个方法，成功后回调，data 是 Obj 类型</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.success) &#123;</span><br><span class="line">      $(<span class="string">"#createResult"</span>).html(data.msg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">"#createResult"</span>).html(<span class="string">"error: "</span> + data.msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"error: "</span></span><br><span class="line">          jqXHR.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data ：是一个对象，连同请求发送到服务器的数据<br>dataType：预期服务器返回的数据类型，如果不指定将根据 HTTP 包中的 MIME 信息智能判断，一般我们都用 JSON 格式</p>
<p>如果是 Json 类型的数据还可以使用 JavaScript 原生的 <code>JSON.parse</code> 方法进行转换成对象，jQuery 中使用 ajax 请求的方式除了上面的栗子有下面几种：</p>
<ul>
<li>jQuery.load( url, [data], [callback] )<br>默认使用 GET 方式来传递的，如果 [data] 参数有传递数据进去，就会自动转换为 POST 方式的。</li>
<li>jQuery.get( url, [data], [callback] )<br>相似的还有一个 <code>$.getJSON()</code> 方法，只是被限定为 JSON 类型</li>
<li>jQuery.post( url, [data], [callback], [type] )</li>
<li>jQuery.getScript( url, [callback] )<br>通过 GET 方式请求载入并执行一个 JavaScript 文件</li>
</ul>
<p><code>$.ajax()</code> 是所有 ajax 方法中最底层的方法，所有其他方法都是基于 <code>$.ajax()</code> 方法的封装，jQuery 真的是博大精深啊<br>callback 函数可以有三个参数，第一个就是服务器返回是数据了（对象形式，和服务器端的实体对象对应），第二个是状态码，第三个是 ajax 对象。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>在浏览器的规则中 JavaScript 是不被允许访问其他域下的内容的，只有在子域名和主域名都相同的情况下才不算跨域，端口号也必须相同<br>http 与 https 之间也算是跨域</p>
<p>解决这个问题，一般的几种方式为：</p>
<h3 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h3><p>属于后端技术，比如写个 PHP 页面专门用来转发请求，后端访问是没有问题的</p>
<h3 id="JSONP-（只支持GET请求）"><a href="#JSONP-（只支持GET请求）" class="headerlink" title="JSONP （只支持GET请求）"></a>JSONP （只支持GET请求）</h3><p>出于安全考虑，浏览器都有同源策略。即相同 domain(域) 的页面运行在一个沙箱（sandbox）中，与其他 domain 的沙箱隔离，不能跨越 domain <strong>直接访问</strong>其他 domain 下的资源。</p>
<p>但HTML中有几个标签可以忽略同源限制去请求其他 domain 下的资源，比如<code>&lt;img&gt;</code>和<code>&lt;script&gt;</code>等。比如当浏览器解析到<code>&lt;script&gt;</code>标签，就会发起一个get请求，请求的 URL 即为 scr 所指定的 url。这就相当于跨域访问了一个资源。</p>
<p>JSONP 就是这样的原理，我们可以利用 Src 来跨域得到我们想要的数据，但这这样就会变成下面的样子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	&#123;[<span class="string">'some string 1'</span>, <span class="string">'some data'</span>, <span class="string">'whatever data'</span>]&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但这样的数据解析很麻烦，所以 JSONP 做了下处理，返回的结果是：<br><code>my_callback({[&#39;some string 1&#39;, &#39;some data&#39;, &#39;whatever data&#39;]});</code><br>可以看到，这里的返回结果是直接执行了一个函数 <code>my_callback(...)</code>, 实参就是我们需要的数据；那么只要在代码里实现 <strong>my_callback</strong> 函数，就可以做任何想做的事了</p>
<p>当然也可以使用 jQuery 来做，type 选择 jsonp，然后增加一个属性 jsonp，值可以任意，其实就是上面的那个函数名</p>
<p>然后在跨域的服务端要获取到这个名字，可以看出是在 url 传递了一个参数，所以也就只支持GET请求了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">type:<span class="string">"GET"</span>,</span><br><span class="line">url:<span class="string">"http://127.0.0.1:8080/ajaxdemo/service.php?number"</span>+$(<span class="string">"#keyword"</span>).val(),</span><br><span class="line">dataType:<span class="string">"jsonp"</span>, <span class="comment">//由"json"改为"jsonp"</span></span><br><span class="line">jsonp:<span class="string">"callback"</span>, <span class="comment">//增加此项，用于后台代码编写</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>后端代码以 PHP 为例</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$jsonp = $_GET[<span class="string">"callback"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值我们说过应该是一个函数，函数名就是上面的jsonp变量了</span></span><br><span class="line"><span class="comment">// 所以要改在一下，外面套一层函数</span></span><br><span class="line">$result = $jsonp.<span class="string">'(data..)'</span></span><br></pre></td></tr></table></figure>
<p>简单说就是在 script 标签里我们请求 ：<code>&lt;script src=‘http://b.com?callback=fun’ /&gt;</code> ，为了方便后端返回把函数名当做参数传回去了，后端拿到这个参数就相当于拿到了回调函数的名称，然后拼一个函数把数据当做参数传入就行了（<code>fun(&#39;datadatadata&#39;)</code>），这样前台就能直接调用了，方法的定义在前台<br>并且后端处理更灵活，如果发现没带 callback 参数那就返回正常的 JSON 数据，如果带了就返回 JSONP 的格式，一个接口适应了两种情况</p>
<h3 id="XHR2"><a href="#XHR2" class="headerlink" title="XHR2"></a>XHR2</h3><p><strong>HTML5</strong> 提供的 XMLHttpRequest Level2 已经实现了跨域访问以及其他的一些新功能</p>
<p>在<strong>服务器端</strong>加入下面两句</p>
<blockquote>
<p>  那个域可以访问，* 表示所有<br>  header(‘Access-Control-Allow-Origin:*‘);<br>  支持什么方法<br>  header(‘Access-Control-Allow-Methods:POST,GET’);</p>
</blockquote>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>异步请求使用一个 XMLHttpRequest  对象就足够了，发起的异步请求都会交给它来处理，它内部必然有个类似数组结构的变量来存，然后<strong>依次</strong>请求服务器（将原始请求进行包装，然后以 http 协议发送），当响应完成后（通过流的形式）再由 XMLHttpRequest 通知调用方（返回给调用方）进行处理；<br>Ajax 其实就是起到了一个中转的作用</p>
<hr>
<p>利用 js 将 select 元素的 options 的长度设为 1，会只保留第一项其他的全部清空，比如： <code>selectElement.options.length = 1</code></p>
<hr>
<p>ajax 技术还经常用在验证码的时候，判断输入的个数以及按键弹起事件（onkeyup）通过后，通过 ajax 从后台获取输入的是否正确，及时给予用户提示</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Servlet]]></title>
      <url>http://bfchengnuo.com/2017/03/27/%E5%88%9D%E8%AF%86Servlet/</url>
      <content type="html"><![CDATA[<p>Servlet 是sun提供的一门专门用于开发动态web资源的技术，传统的步骤分为两步：</p>
<ol>
<li>编写一个java类，实现servlet接口<br>不过一般是继承自 HttpServlet ，因为大多都是用于http，它默认已经实现了所有未实现的方法，需要那个覆盖那个即可</li>
<li>把开发好的java类部署到web服务器</li>
</ol>
<p>听起来蛮简单的，其中的道道不少呢<a id="more"></a><br>Servlet已经是属于J2EE的其中之一，在java SE 的API中是没有的，不过Tomcat中是自带的，因为他要解析啊</p>
<h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>引用自Wiki上的一句：<br><div class="note info"><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。<br>狭义的Servlet是指Java语言<strong>实现的一个接口</strong>，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
</div></p>
<p>Servlet运行于支持 Java 的应用服务器中。从实现上讲，<strong>Servlet 可以响应任何类型的请求</strong>，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<h3 id="与JSP的关系"><a href="#与JSP的关系" class="headerlink" title="与JSP的关系"></a>与JSP的关系</h3><p>Java服务器页面（JSP）是 HttpServlet 的扩展。由于 HttpServlet 大多是用来响应HTTP请求，并返回Web页面（例如HTML、XML），所以不可避免地，在编写 servlet 时会涉及大量的HTML内容，这给 servlet 的书写效率和可读性带来很大障碍，JSP便是在这个基础上产生的。</p>
<p>其功能是使用HTML的书写格式，在适当的地方加入 Java 代码片段，将程序员从复杂的 HTML 中解放出来，更专注于 servlet 本身的内容。</p>
<p>JSP在首次被访问的时候被应用服务器转换为servlet ，在以后的运行中，容器直接调用这个 servlet，而不再访问 JSP 页面。<strong>JSP的实质仍然是 servlet。</strong></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在 Servlet 中有了生命周期的概念，也就有了相应的方法，比如 <code>init()</code> 和<code>destroy()</code></p>
<p>当用户第一次访问的时候创建，执行 init 方法完成初始化，此后会一直存在于容器等待客户机的第二次访问<br>web服务器关闭的时候 Servlet 才会销毁，也就是说 <strong>一个Class文件只会存在一个Servlet对象</strong></p>
<p>但是每一次请求，服务器都会创建一个新的 request 和 response 对象（同时也会创建一个新线程），注意是每一次请求，一个用户就可以发起多次请求，好在它们的生命周期很短，随请求的结束就销毁了，因为一次请求的时间本来就很短<br>每一次请求调用 Servlet 一次，但是对象只有一个</p>
<p>因为<strong>每一次请求都会有各自的线程进行处理</strong>，虽然解决了一个对象可以同时被访问（也就是说不同的请求可以同时<del>cao</del>执行一个对象[servlet]里的方法），但是存在线程安全问题，当然如果变量是在类里定义的，那对象只有一个，变量也就只有一个</p>
<h2 id="编写Servlet"><a href="#编写Servlet" class="headerlink" title="编写Servlet"></a>编写Servlet</h2><p>我们写一个最简单的 Servlet ，国际惯例使用 Hello World 测试，本质就是一个Java类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloWorld"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        msg = <span class="string">"is Hello World java"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.print(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就会输入 msg 的消息，我是用 IDEA 写的，在类名的上面加上标注(注解) <code>@WebServlet(&quot;/HelloWorld&quot;)</code> 意思是设置 servlet 对应的url地址</p>
<blockquote>
<p>  Servlet3.0 之后提供了注解(annotation)，使得不再需要在 web.xml 文件中进行 Servlet 的部署描述，简化开发流程<br>  JDK1. 5版本之后， JAVA提供了一种叫做 Annotation 的新数据类型，中文译为注解或标注，它的出现为铺天盖地的XML配置文件提供了一个完美的解决方案，让  JAVA EE 开发更加方便快速，也更加干净了</p>
</blockquote>
<p>如果不想使用注解，还有另一种方式，就是在 <strong>web.xml</strong> 文件中进行手动配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bfchengnuo.test.HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hw<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>servlet 标签配置名字以及具体的 class，<strong>servlet-mapping</strong> 是设置映射关系，将那个名字的 Servlet 映射到什么虚拟目录(浏览器访问时输入)<br>上面的一段其实和 <code>@WebServlet(name=&quot;HelloWorld&quot;,value=&quot;/hw&quot;)</code> 是完全相同的<br><div class="note warning"><p><strong>当标注(注解)与 web.xml 同时配置时，标注无效。</strong><br>使用标注：由于是在对应的类中配置的信息，因而则可以不用在标注中配置class了。<br>对于 web.xml 中的配置，在标注中通通都有配置<br>在 web.xml 中一个 servlet 可以配置多个 servlet-mapping, 只要在其中指定相同的 servlet-name 即可。标注也可以指定多个的，但不再用 value，而是用urlPatterns 数组。<br><code>@WebServlet(name=&quot;HelloWorld&quot;,urlPatterns={&quot;/HelloWroldServlet&quot;,&quot;/HelloWorld&quot;})</code></p>
</div></p>
<p>同时如果需要随服务器加载，可以在 servlet 标签下设置 <code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code> 数字越小越优先</p>
<h2 id="关于映射"><a href="#关于映射" class="headerlink" title="关于映射"></a>关于映射</h2><p>映射如果写的是类似 <code>/1.html</code> 这种就是伪静态，因为实际访问的是动态的web资源</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hw.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然你在浏览器输入的确实html，但是其实请求的是一个 Servlet<br>映射当然也是支持通配符的，比如 <code>/*</code> 就是映射到任何页面<br><strong>但是只能有两种固定的格式：</strong></p>
<ol>
<li><code>*.</code> 开头 + 扩展名  [ 固定扩展名(*.jsp) ]</li>
<li><code>/</code> 开头并且以 <code>/*</code> 结尾  [固定路径]</li>
</ol>
<p>像 <code>/abc/*.html</code> 是错误的,有歧义嘛~ ; 服务器不知道它是路径映射还是扩展映射</p>
<p>这样也就不可避免的会有存在匹配冲突的情况下，谁匹配更多(也就是更精确)就是那个，和正则类似，<code>*</code>的匹配优先级最低，所以<code>*</code>开头的都很低，一般是最后匹配<br><div class="note primary"><p>缺省的 Servlet 的映射为： / ，当找不到 Servlet 的时候找它<br>其实任何请求都是由 Servlet 进行处理的，当访问静态资源的时候其实就是因为找不到相关的 Servlet 映射，就交给系统缺省的 Servlet 映射负责处理，来找到那些静态的资源，如果静态资源也没用，那就只能映射到 404 页面了<br>如果覆盖了缺省的 Servlet ，那静态资源就访问不到了，只会访问自定义的缺省的 Servlet ，所以不要把 url-pattern 设置为 /</p>
</div></p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>Web容器在启动的时候，会为每一个 web 应用都创建一个 ServletContext 对象，它代表<strong>当前的 web 应用</strong>，注意是当前的web应用不是 Servlet<br>ServletContext 在服务器启动时创建，关闭时销毁，既然它代表web应用，那么就有很多相应的方法，比如获取各种配置等，面向对象思想嘛~<br>上一篇 了解Tomcat 中已经说的很详细了<br>ServletConfig 对象中维护了 ServletContext 对象的引用，所以可以在 Servlet 中通过 <code>this.ServletConfig.getServletContext()</code> 获得 ServletContext 对象<br>当然其实也是直接可以通过 getServletContext 方法获取到的，因为继承的是 HttpServlet 在爷爷辈的 init 方法中已经进行了保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getServletConfig().getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ServletContext 对象通常称为 context 域</strong></p>
<h2 id="转发-amp-重定向"><a href="#转发-amp-重定向" class="headerlink" title="转发&amp;重定向"></a>转发&amp;重定向</h2><p>这个用的次数是非常之频繁的，先说明下它和重定向的主要区别：</p>
<ul>
<li>重定向：我没有，我给你个地址，让你去找别人要</li>
<li>转发：我没有，我帮你找别人获取，然后再把你需要的资源给你</li>
</ul>
<p>转发对于客户端来说只发一次请求，网址也不变，客户端甚至不会察觉，也不知道这个资源到底是谁的( 嗯，有点像反向代理呢 ，在我的公众号已经写过正向代理和反向代理是什么了)<br>用代码来表达就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher rd = getServletContext().getRequestDispatcher(<span class="string">"/index.jsp"</span>)</span><br><span class="line">rd.forward(request,response);</span><br><span class="line"><span class="comment">// 一般的写法为</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"path"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>
<p>至于这两者的区别，最大的区别就是 ServletContext 转发时路径必须绝对路径，也就是 <code>/</code> 开头<br>使用 request 进行转发既可以使用绝对路径也可以使用相对路径（相对于 web 应用也就是比起上面可以不写 <code>/</code>），一般这种方式用的比较多，大多数是使用绝对路径的</p>
<p><strong>当然如果需要携带参数需要 Request 域来实现，使用 setAttribute 设置自定义参数，下次再说，当然也可以使用 getParameter 方法来获得 URL 携带的数据</strong></p>
<p>重定向就是用 sendRedirect 方法设置下路径就可以了，路径就是浏览器中的地址了，所以如果 <code>/</code> 开头就是指的此网站，后面多半需要加 web 应用的名，或者通过 <code>request.getContextPath()</code> 来获取此 web 应用的地址，然后再加 “/xxx.jsp”这样。</p>
<blockquote>
<p> 重定向（redirect）后：确认了要跳转的页面的 url，<strong>继续执行 redirect 下面的代码</strong>；执行完后，断开当前的与用户所发出的请求连接，即断开 request 的引用指向，因此 request 里存放的信息也会丢失。<br>转发（forward）后：确认了要转发的页面的地址，现在<strong>停止继续执行后面的代码</strong>，而是先执行转发后的那个 servlet 里的代码，<strong>执行完后再回来继续执行后面的代码</strong>；在这期间 check 和 success 共享一个 request 和 response 对象。</p>
</blockquote>
<h2 id="读取-存储问题"><a href="#读取-存储问题" class="headerlink" title="读取/存储问题"></a>读取/存储问题</h2><p>我们可以把一些信息存在 web.xml 文件中，方便修改和获取，在 web.xml 中也有两种形式，一种是属于 Servlet 的，一种是整个web应用的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>conData<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Lolicon<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bfchengnuo.test.HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>data<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>is test data<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>获取方式基本也相同，当然也可以进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Servlet 中的配置的数据</span></span><br><span class="line">String str = <span class="keyword">this</span>.getServletConfig().getInitParameter(<span class="string">"data"</span>);</span><br><span class="line"><span class="comment">// 获取 web 应用的配置的数据</span></span><br><span class="line">String str2 = <span class="keyword">this</span>.getServletContext().getInitParameter(<span class="string">"conData"</span>);</span><br></pre></td></tr></table></figure>
<div class="note info"><p>设置初始化参数使用注解也是可以的，类似这样<br><code>@WebServlet(name=&quot;HelloWorld&quot;,urlPatterns={&quot;/HelloWorld&quot;},initParams={@WebInitParam(name=&quot;id&quot;,value=&quot;1&quot;),@WebInitParam(name=&quot;name&quot;,value=&quot;Loli&quot;)})</code></p>
</div>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>对于无逻辑性的数据，一般使用：<code>.properties</code> 来进行存储，内容格式非常简单一般就是一行一个 key=val 的形式，详细的介绍见 <a href="https://zh.wikipedia.org/wiki/.properties" target="_blank" rel="noopener">维基百科</a><br>Java中提供了专门的类来处理这种文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream resourceAsStream = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/a.properties"</span>);</span><br><span class="line">Properties prope = <span class="keyword">new</span> Properties();</span><br><span class="line">prope.load(resourceAsStream);</span><br><span class="line"></span><br><span class="line">String str = prope.getProperty(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure>
<p>如果读取资源文件的程序不是 Servlet 类，就只能通过类装载器去读，文件不能太大，因为会被加载进内容，太大会内存溢出<br><code>ParamTest.class.getClassLoader().getResourceAsStream(path)</code><br>类装载器的 path 相对于的是 src 目录，也就是包名的开始目录<br><div class="note warning"><p>由于类装载器只装载一次，在 JVM 没有重启的情况下，修改文件无效<br>解决方案是用传统方式读取，首先通过类装载器获取到文件的绝对路径，再 FileInputStream 读取<br><strong>FileInputStream 的相对路径是相对的 JVM 的启动目录</strong>，所以最好传绝对路径，如果用 ServletContext 去读，相应的 / 就是 web 应用的目录，用类装载器的话相对的目录就是 src 下开始<br>获取路径的方法为：<br><code>HelloWorld.class.getClassLoader().getResourceAsStream(&quot;com/bfchengnuo/xx&quot;).getPath()</code></p>
</div></p>
<h2 id="关于-WebServlet的补充"><a href="#关于-WebServlet的补充" class="headerlink" title="关于@WebServlet的补充"></a>关于@WebServlet的补充</h2><p>@WebServlet 主要属性列表：</p>
<table>
<thead>
<tr>
<th><strong>属性名</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>String</td>
<td>指定 Servlet 的 name 属性，等价于 <code>&lt;servlet-name&gt;</code>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。</td>
</tr>
<tr>
<td>value</td>
<td>String[]</td>
<td>该属性等价于 urlPatterns 属性。<strong>两个属性不能同时使用。</strong></td>
</tr>
<tr>
<td>urlPatterns</td>
<td>String[]</td>
<td>指定一组 Servlet 的 URL 匹配模式。等价于 <code>&lt;url-pattern&gt;</code>标签。</td>
</tr>
<tr>
<td>loadOnStartup</td>
<td>int</td>
<td>指定 Servlet 的加载顺序，等价于 <code>&lt;load-on-startup&gt;</code> 标签。</td>
</tr>
<tr>
<td>initParams</td>
<td>WebInitParam[]</td>
<td>指定一组 Servlet 初始化参数，等价于 <code>&lt;init-param&gt;</code>标签。</td>
</tr>
<tr>
<td>asyncSupported</td>
<td>boolean</td>
<td>声明 Servlet 是否支持异步操作模式，等价于 <code>&lt;async-supported&gt;</code>标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>该 Servlet 的描述信息，等价于 <code>&lt;description&gt;</code> 标签。</td>
</tr>
<tr>
<td>displayName</td>
<td>String</td>
<td>该 Servlet 的显示名，通常配合工具使用，等价于 <code>&lt;display-name&gt;</code>标签。</td>
</tr>
</tbody>
</table>
<p>例如初始化参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"HelloWorld"</span>,urlPatterns=&#123;<span class="string">"/HelloWroldServlet"</span>,<span class="string">"/HelloWorld"</span>&#125;,initParams=&#123;<span class="meta">@WebInitParam</span>(name=<span class="string">"id"</span>,value=<span class="string">"yeh"</span>),<span class="meta">@WebInitParam</span>(name=<span class="string">"name"</span>,value=<span class="string">"Loli"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分开配置</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="meta">@WebInitParam</span>(name=<span class="string">"id"</span>,value=<span class="string">"yeh"</span>)</span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意格式就好，第二种低版本的 Tomcat 好像不识别</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/zw_2011/article/details/7432839" target="_blank" rel="noopener">http://blog.csdn.net/zw_2011/article/details/7432839</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[了解Tomcat]]></title>
      <url>http://bfchengnuo.com/2017/03/26/%E4%BA%86%E8%A7%A3Tomcat/</url>
      <content type="html"><![CDATA[<p>Tomcat的大名就不用多说了，要学习 java web 肯定会接触到它，可以说是学习 Java web 的前提，所以为了弄明白 Tomcat 的目录结构层次以及它的体系结构，就有了这篇文章，以便让我能更好的理解整个 java web 网站的处理流程，能更快的理解学习吧，当然还有一些配置相关的东西。<a id="more"></a><br>在使用Tomcat之前，首先要认识两个环境变量：</p>
<ul>
<li>JAVA_HOME：<strong>必须先配置 JAVA_HOME</strong>，因为 Tomcat 启动需要使用 JDK</li>
<li>CATALANA_HOME：<strong>如果是安装版，那么还需要配置这个变量</strong>，这个变量用来指定 Tomcat 的安装路径<br>如果是绿色版，并且配置了这个环境变量，无论你从那个文件夹执行的启动脚本，最终执行的就是这个环境变量下的 Tomcat，所以最好不要配</li>
</ul>
<h2 id="目录结构层次"><a href="#目录结构层次" class="headerlink" title="目录结构层次"></a>目录结构层次</h2><ul>
<li><p>bin<br>二进制文件以及执行脚本文件(比如启动和关闭)的存放目录。<br>常见的几个重要文件：</p>
<blockquote>
<p>  <code>catalina.sh</code> ：用于启动和关闭 tomcat 服务器<br>  <code>configtest.sh</code> ：用于检查配置文件<br>  <code>startup.sh</code> ：启动 Tomcat 脚本<br>  <code>shutdown.sh</code> ：关闭 Tomcat 脚本</p>
</blockquote>
</li>
<li><p><strong>conf</strong><br>  <strong>配置文件存放目录。</strong></p>
</li>
<li><p>lib<br>  Tomcat 的库文件夹，用于存放 <strong>Tomcat 所依赖的</strong>以及第三方扩展的 jar 文件。</p>
</li>
<li><p>logs<br>  日志文件存放目录</p>
<blockquote>
<p>  <code>localhost_access_log</code> ：访问日志<br>  <code>localhost.log</code> ：错误和其它日志<br>  <code>manager.log</code> ：管理日志<br>  <code>catalina.log</code>： Tomcat 启动或关闭日志文件</p>
</blockquote>
</li>
<li>temp<br>  临时文件存放目录</li>
<li><strong>webapps</strong><br>  <strong>主要 Web 发布目录（存放我们自己的 JSP, SERVLET,类）</strong></li>
<li>work<br>  存放 Tomcat 编译 JSP 对应的 Java 字节码类文件。</li>
</ul>
<h3 id="conf目录"><a href="#conf目录" class="headerlink" title="conf目录"></a>conf目录</h3><p><code>server.xml</code> ：Tomcat 的全局配置文件<br><code>web.xml</code> ：为不同的 Tomcat 配置的 web 应用设置缺省值的文件<br><code>tomcat-users.xml</code> ：Tomcat 用户认证的配置文件</p>
<hr>
<p>把 Web 应用交给服务器管理的过程称为：虚拟目录映射，比如在 <strong>server</strong> 配置文件中，我们可以配置一个 web 应用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/home"</span> <span class="attr">docBase</span>=<span class="string">"c:\news"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Context 标签类似于代表一个 web 应用，path 就是对外路径(虚拟路径)，如果把 path 设置为空那就成为默认的 web 应用了，说白了虚拟路径就是在输入网址时候的路径，是虚拟的，本地并不存在，后面的 docBase 指定的是本地硬盘的 web 应用的路径，这就是一个映射过程<br><div class="note warning"><p>注：这样搞重启才能生效，所以官方是不建议这样用的，上面只是为演示<br>通常可以在<code>conf\Catalina\localhost</code>目录下建一个 XML 文件，文件名为虚拟路径(多级目录可以用 <code>#</code> 区分)，如果文件名是 ROOT 那就是默认的 web 应用了(并非是默认网页)，然后可以在文件内配置 Context，自然 path 就不需要写了，这样会被自动加载，不需要重启</p>
</div><br>当然最简单的方法是直接往 <strong>webapps</strong> 目录一扔就 OK 了，文件名就是虚拟目录名</p>
<hr>
<p><code>web.xml</code>文件是部署描述符文件，这个文件中注册了很多 MIME 类型，即文档类型。<br>这些 MIME 类型是客户端与服务器之间说明文档类型的，如用户请求一个 html 网页，那么服务器还会告诉客户端浏览器响应的文档是 text/html 类型的，这就是一个 MIME 类型。<br>客户端浏览器通过这个 MIME 类型就知道如何处理它了。当然是在浏览器中显示这个 html 文件了。但如果服务器响应的是一个 exe 文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。<strong>MIME 就是用来说明文档的内容是什么类型的！</strong></p>
<hr>
<p><code>tomcat-users</code> 文件，就是存储 tomcat 用户的文件，这里保存的是 tomcat 的用户名及密码，以及用户的角色信息。<br>可以按着该文件中的注释信息添加 tomcat 用户，然后就可以在 Tomcat 主页中进入 Tomcat Manager 页面了</p>
<h3 id="Webapp目录"><a href="#Webapp目录" class="headerlink" title="Webapp目录"></a>Webapp目录</h3><p>这个目录就是用来放 web 应用的，也就是网站的一个个的功能，将开发好的 web 应用(文件夹)仍在这里面就好，然后就是对于一个个的 web 应用也是有一定的目录结构的，如果是静态资源 ( HTML/CSS/JS等 ) 就放在根目录即可，JSP 文件同样也是<br>如果存在 ROOT 目录那就是默认的应用目录<br>web 应用程序下还要有一个 <code>WEB-INF</code> 文件夹，注意要大写，里面主要就是放一些 java 相关的东西了：</p>
<ul>
<li><code>WEB-INF/web.xml</code> <strong>这是一个 Web 应用程序的描述文件。</strong><br>这个文件是一个 XML 文件，描述了 Servlet 和这个 Web 应用程序的其他组件信息，此外还包括一些初始化信息和安全约束等等。<br>例如，web 应用的默认网页就是在这里配置的</li>
<li><code>WEB-INF/classes/</code> 这个目录及其下的子目录应该包括这个 Web 应用程序的所有 JavaBean 及 Servlet 等编译好的 Java 类文件（<code>*.class</code>）文件，以及没有被压缩打入 JAR 包的其他 class 文件和相关资源。<br>注意：在这个目录下的Java类应该按照其所属的包层次组织目录</li>
<li><code>WEB-INF/lib/</code> 这个目录是来存放各种 jar 包的<br>除了各种依赖 jar，通常 <strong>Web-INF/classes/</strong>  这个目录下的类文件也可以打包成  JAR  文件，放在该目录下。如将 classes 目录下的各个<code>*.class</code>文件打包成 <strong>WebMis.jar</strong> 文件</li>
</ul>
<div class="note info"><p>注意：<br>WEB-INF 目录中包含应用软件所使用的资源，但是 WEB-INF 却不在公共文档根目录之中。<strong>在这个目录中所包含的文件都不能被客户机所访问。</strong><br>如果一个类出现在 JAR 文件中同时也出现在类的目录中，类加载器会加载位于类目录中的那一个。</p>
</div>
<p>如果我们不知道<code>web.xml</code> 应该怎么写，最简单的就是去其他项目或者自带的例子中拷(抄)一份过来，然后改一下就行了，一般就是要它的头和尾</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>一个 Tomcat 只会启动一个 JVM，所有 webapps 公用一个 JVM 进程<br><img src="/image/dev/151836131.png" alt=""><br>Tomcat 体系结构中的六个主要概念：</p>
<ul>
<li>Server<br>Server 代表整个容器(container)。它可以包含一个或多个 Service，还可以包含一个 GlobalNamingResources。<br>A Server element represents the entire Catalina servlet container. (Singleton)</li>
<li>Service<br>它由一个或者多个 Connector (连接器)组成，以及一个 Engine (引擎)，负责处理所有 Connector 所获得的客户请求。</li>
<li>Engine<ul>
<li>Engine 下可以配置多个虚拟主机 Virtual Host，每个虚拟主机都有一个域名 </li>
<li>当 Engine 获得一个请求时，它把该请求匹配到某个Host上，然后把该请求交给该 Host 来处理 </li>
<li>Engine 有一个默认虚拟主机，当请求无法匹配到任何一个 Host 上的时候，将交给该默认 Host 来处理</li>
</ul>
</li>
<li>Host<ul>
<li>代表一个 Virtual Host，虚拟主机，每个虚拟主机和某个网络域名 (Domain Name) 相匹配</li>
<li>每个虚拟主机下都可以部署 (deploy)一个或者多个 Web App，每个 Web App 对应于一个 Context，有一个 Context path</li>
<li>当 Host 获得一个请求时，将把该请求匹配到某个 Context 上，然后把该请求交给该 Context 来处理</li>
<li>匹配的方法是“最长匹配”，所以一个 <code>path==&quot;&quot;</code> 的 Context 将成为该 Host 的默认 Context</li>
<li>所有无法和其它 Context 的路径名匹配的请求都将最终和该默认 Context 匹配</li>
</ul>
</li>
<li>Connector<br>Tomcat 有两个典型的 Connector，一个直接侦听来自浏览器的 http 请求，一个侦听来自其它 WebServer 的请求<br>当然现在 https 也越来越普遍了</li>
<li>Context<ul>
<li>一个 Context 对应于一个 Web Application，一个 Web Application 由一个或者多个 Servlet 组成 </li>
<li>Context 在创建的时候将根据配置文件 <code>$CATALINA_HOME$/conf/web.xml</code>和<code>$WEBAPP_HOME$/WEB-INF/web.xml</code> 载入 Servlet 类 </li>
<li>当 Context 获得请求时，将在自己的映射表 (mapping table) 中寻找相匹配的 Servlet 类 </li>
<li>如果找到，则执行该类，获得请求的回应，并返回</li>
</ul>
</li>
</ul>
<blockquote>
<p>  <code>CATALINA_HOME</code> 是 Tomcat 的安装目录，<code>CATALINA_BASE</code> 是 Tomcat 的工作目录。<br>  当我们想要运行多个 Tomcat 实例，但是不想拷贝多个 Tomcat 副本时，那么我们可以配置多个不同工作目录 (修改 catalina.sh 文件)</p>
</blockquote>
<h3 id="如何处理一个请求"><a href="#如何处理一个请求" class="headerlink" title="如何处理一个请求"></a>如何处理一个请求</h3><p>假设来自客户的请求为：<code>http://localhost:8080/test/index.jsp</code> 对照上面的图更好理解</p>
<ol>
<li>请求被发送到本机端口 8080，被在那里侦听 http 的连接器 ( Coyote HTTP/1.1 Connector ) 获得</li>
<li>Connector 把该请求交给它所在的 Service 的 Engine 来处理，并等待来自 Engine 的回应</li>
<li>Engine 获得请求 <code>localhost/test/index.jsp</code>，匹配它所拥有的所有虚拟主机 ( Virtual Host )</li>
<li>Engine 匹配到名为 localhost 的 Host（即使匹配不到也把请求交给该 Host 处理，因为该 Host 被定义为该 Engine 的默认主机）</li>
<li>localhost Host 获得请求<code>/test/index.jsp</code>，匹配它所拥有的所有 Context</li>
<li>Host 匹配到路径为 <strong>/test</strong> 的 Context（如果匹配不到就把该请求交给路径名为<code>&quot;&quot;</code>的默认 Context 去处理）</li>
<li><code>path=&quot;/test&quot;</code> 的 Context 获得请求 <strong>/index.jsp</strong>，在它的 mapping table 中寻找对应的 servlet</li>
<li>Context 匹配到 URL PATTERN 为 <code>*.jsp</code> 的 servlet，对应于 JspServlet 类</li>
<li>构造 <strong>HttpServletRequest</strong> 对象和 <strong>HttpServletResponse</strong> 对象，作为参数调用 JspServlet 的 doGet 或 doPost 方法</li>
<li>Context 把执行完了之后的 <strong>HttpServletResponse</strong> 对象返回给 Host</li>
<li>Host 把 HttpServletResponse 对象返回给 Engine</li>
<li>Engine 把 HttpServletResponse 对象返回给 Connector</li>
<li>Connector把 HttpServletResponse 对象返回给客户浏览器</li>
</ol>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><p>用到了就来补充，现在应该很乱，等数量够了再集中整理一下</p>
<h3 id="context相关"><a href="#context相关" class="headerlink" title="context相关"></a>context相关</h3><p>前面提到过：Context 标签类似于代表一个 web 应用<br>path 属性就是对外路径(虚拟路径)，如果设为<code>path=&quot;&quot;</code> 就代表默认应用<br>docBase 属性为映射的物理路径<br>reloadable：是否自动加载，如果设置为 true 就是自动加载，开发调试时小的应用可以开，大的应用就不要开了，可能会内存溢出</p>
<h3 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h3><p>用户相关的配置在 <code>tomcat-users</code> 文件下，默认也有几个，但是被注释了，如果想进入管理页面还需要手动加一个管理员的权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"tomcat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"role1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"tomcat,manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"both"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"tomcat,role1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"role1"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"role1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以在 Tomcat 主页中进入Tomcat Manager 页面了，就是 <code>http://localhost:8080/manager/html</code></p>
<h3 id="单向加密连接器"><a href="#单向加密连接器" class="headerlink" title="单向加密连接器"></a>单向加密连接器</h3><p>当然在实际的环境下，都是双向加密，这里只是稍微提一下，以后再补充<br>我们可以用java自带的 keytool 工具生成一个密钥库:<br><code>keytool -genkey -alias mytest -keyalg RSA</code><br>上面的命令在生成密钥库的时候指定了一个别名叫 mytest，以及指定了算法是 RSA，当然还可以指定有效期，还有很多参数如加 <code>-keystore</code> 后面跟指定保存的路径，其他的就不多说了，只说下常用的，然后输入域名和密码即可，其他的可忽略<br>弄好以后会生成一个 <code>.keystore</code> 文件，然后可以把它放到 Tomcat 的目录里去，比如放到 conf 下，并且配置它的全局配置文件 <code>server.xml</code> 打开 HTTPS 的连接器，设置密钥库的路径( keystoreFile )和密码( keystorePass )属性。<br>当然，要想让浏览器信任，需要 CA 的签名的证书<br>上面只是给服务器生成了证书，要做到双向加密还需要给客户端（浏览器）也生成证书，并且要让服务器信任客户端的证书，客户端也需要信任服务器的证书，这个过程比较复杂，但是也不难，可以自行Google资料</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>当我们的web应用开发好以后要部署在服务器上，通常当然要先打一个包，然后再上传到服务器，这样既能保证数据的完整，还能节省点流量，java有打包工具，包就是我们常说的jar包，但是一般会命名为 <code>.war</code> 后缀，因为这种后缀Tomcat会自动进行解压</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://qiita.com/CoffeeDog/items/7082c1db5ab84c8df60b" target="_blank" rel="noopener">http://qiita.com/CoffeeDog/items/7082c1db5ab84c8df60b</a><br><a href="http://blog.csdn.net/clementad/article/details/46842309" target="_blank" rel="noopener">http://blog.csdn.net/clementad/article/details/46842309</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java基础知识复习]]></title>
      <url>http://bfchengnuo.com/2017/03/25/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h2><p>每种编程语言都有自己的操作内存中元素的方式，Java中，我们认为一切皆对象，我们通过引用来操纵对象，引用可以比作遥控器，对象就是电视机，就算没有电视机，遥控器也可以独立存在。<br>例如：<code>String s</code>这里我们只是创建了一个引用，并不是对象，如果我们现在向s发送一个信息(调用)就会报一个错误，因为它并没有和任何事物关联<a id="more"></a><br>为了简化对象的生命周期，在创建对象时把它放进堆里，通过引用来进行访问，需要注意的是，基本类型是个特例，它一般很小、很简单，还放在堆里不是很有效，所以对于这种类型一般就直接放在堆桟中，同时为了跨平台，大小一般是固定的<br>Java中数组也是对象，当创建一个数组对象时，就创建了一个引用数组，每个引用会自动进行初始化为某个特定值，该值拥有自己的关键字null，一旦Java看到null就知道这个引用还没有指向一个对象。</p>
<h2 id="关于默认值"><a href="#关于默认值" class="headerlink" title="关于默认值"></a>关于默认值</h2><p>当变量作为类的成员使用时，Java才确保给定其默认值，以确保那些<strong>基本类型的</strong>成员变量得到初始化，防止出现错误。<br>然而<strong>初始化并不适用于局部变量</strong>(即<strong>并非某个类中</strong>的字段)，比如某个方法中的变量是不会被默认初始化的。<br>如果变量没有被初始化，编译器会报一个错误而不像C报一个警告</p>
<h2 id="关于Static静态"><a href="#关于Static静态" class="headerlink" title="关于Static静态"></a>关于Static静态</h2><p>静态最大的特点就是：单独分配存储空间，并且在内存中只有一份，多用于数据共享；不依赖于对象，也就是不与任何对象实例关联(不持有引用)。<br><strong>使用类名是引用static变量的首选方式</strong>，如：<code>ClassName.varName</code>它不仅强调了变量的static结构，还在某些情况下为编译器的优化提供了更好的机会。对于静态方法也是如此，可以直接调用而不需要创建实例</p>
<p>静态变量存储于内存中的方法区(也有的叫共享区/数据区)的静态区<br>什么时候用static呢？</p>
<ul>
<li>需要访问对象中的特有数据</li>
<li>如果对象中没有成员变量，只有方法，那么就定义成静态</li>
</ul>
<p>静态代码块中如果有异常不能直接抛，只能先抓，然后在catch里可以new一个异常再抛</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>我们先看一段经典代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">		changeData(n);</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">		data = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果当然还是3.<br>可以理解为传入方法处理的时候将n拷贝了一份赋给变量data，data存在于changeData方法中，生命周期也就伴随着这个方法，当方法执行完毕这个变量也就销毁了。<br><strong>基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的</strong></p>
<p>特别的，如果传入的是引用类型(对象)，那么就是传递的引用，如果改变了这个对象，那就是真的改变了，比如下面的例子，数组也是个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] ls = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		updateData(ls);</span><br><span class="line">		System.out.println(ls[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">		data[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h3><p>开始我测试的其实是字符串，毕竟String也是对象嘛~~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String ls = <span class="string">"abc"</span>;</span><br><span class="line">		updateData(ls);</span><br><span class="line">		System.out.println(ls[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateData</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">		data += <span class="string">"d"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，结果还是<code>abc</code>，不变，让我懵逼….<br>随后才想到，忘记了一个知识点，String其实可以说一旦声明后就是是不可变的(学Py的话应该也会了解到)，<code>data += &quot;d&quot;;</code>这一句意思就是将data这个对象赋值一份然后追加上<code>d</code>拼成一个新的对象，再把这个对象的引用赋给data，于是最后data随updateData方法的生命周期销毁了….</p>
<p>所以字符串操作应该是尽量少用的，它会在堆中产生大量垃圾，会引起频繁的GC进行回收，卡顿，尽量使用 StringBuffer 和StringBuilder 吧</p>
<div class="note info"><p>字符串拼接的效率问题：<br>使用 <code>+</code> 、使用  StringBuilder 、使用 StringBuffer<br>在 1.5+ 的 JDK 版本：StringBuilder  = <code>+</code> &gt;  StringBuffer<br>在 1.5- 的 JDK 版本：StringBuilder  &gt;  StringBuffer  &gt;  <code>+</code><br>原因就是 Java 也意识到了使用 + 的问题，所以在编译的时候会自动转换成 StringBuilder  ，所以在 1.5+ 的版本它们的效率是一样的，因为要保证多线程同步所以势必会慢一些，但是还是建议使用 StringBuilder </p>
</div>
<p>需要说明的是，这里的转换是在 str1 + str2 这种情况下的，当使用 <code>str += &quot;asjdkla&quot;;</code> 这种形式的时候实际上是转换为：<code>str = new StringBuilder().append(str).append(&quot;asjdkla&quot;).toString();</code><br>一眼就能看出<strong>创建了太多的 StringBuilder 对象</strong>，而且在每次循环过后 str 越来越大，导致每次申请的内存空间越来越大，很多人喜欢把它放到 for 里循环做对比测试。<br>还有一点就是使用 stringbuilder 的时候，默认它会创建一个长度 16 的容器，当不够了的时候就再 +16，然后把内容拷过去，所以，当大量拼接时，可以根据估计长度来设置这个值：<code>new StringBuilder(24)</code><br>PS：此方案不适用于 List ，反而会增加损耗。<br>使用 <code>String.valueOf（）</code> 方法转换字符串能避免 toString 空指针问题；两个字符串拼接直接调用 <code>String.concat()</code> 性能最好<br>格式化输出可以使用 <code>String.format()</code> 【使用  <code>%1$2s</code> 等占位】或者 <code>Message.format()</code> 【使用 <code>{}</code> 占位】</p>
<p>如果了解字符串在堆中的存储结构应该会很好的理解<br>推荐这篇文章：<a href="https://segmentfault.com/a/1190000007099818" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007099818</a></p>
<h2 id="自增运算问题"><a href="#自增运算问题" class="headerlink" title="自增运算问题"></a>自增运算问题</h2><p>Java简化了运算，用++可以实现自增，但是如果这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">3</span>,b = <span class="number">3</span>;</span><br><span class="line">  a = ++a;</span><br><span class="line">  b = b++;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">  System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说结果a为4，b为3；对于a没什么好说的，主要是b，刚开始我所想的是b赋给b，然后b再自增应该是4，但是呢，这里确实不太好理解，我感觉正确的理解应该是这样的：<br>我们都知道<code>=</code>运算先执行右边，但是<code>b++</code>要等到整句执行完才自增才对，程序是不能回头的，咋办？于是java就搞出了个临时变量，先把b(就是等号右边的b)存到临时变量中，执行自增运算，然后进行了<code>=</code>运算把这个临时变量赋给了b，所以，最后b是3，在C中也是如此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=b; <span class="comment">//存到临时变量</span></span><br><span class="line">b=b+<span class="number">1</span>; <span class="comment">//执行自增，右边运算结束</span></span><br><span class="line">b=t; <span class="comment">//用临时变量t开始左边的“=”运算</span></span><br></pre></td></tr></table></figure>
<h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><p>我们使用“直接常量”的时候，有时候是模棱两可的，如果出现这样的情况要对编译器进行适当的“指导”，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">0X2f</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">0X2F</span>;</span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">0177</span>;</span><br><span class="line"><span class="keyword">long</span> n1 = <span class="number">200L</span>;</span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12F</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">2</span>D;</span><br></pre></td></tr></table></figure>
<p>十六进制数适用于所有的整数数据类型，前缀0x或0X，是数字0，再有，如果是long的类型，在后面最好用大写的L，小写的l和数字1很像</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>关于创建的问题，<strong>静态内部类</strong>可以直接被创建<code>new A.B();</code>，如果<strong>内部类不是静态</strong>那就只能这样创建:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">A.B b = a.new B();</span><br></pre></td></tr></table></figure>
<p>静态内部类的创建并不依赖于外围类，也就是不含外围类的引用，毕竟不能用外围类的方法嘛~<br>广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。关于这个以前的某篇文章貌似也是说过的，哎~写的太乱，分类也乱，我也很无奈啊，先这样吧</p>
<h2 id="重写问题"><a href="#重写问题" class="headerlink" title="重写问题"></a>重写问题</h2><p>父类的静态方法不能被子类重写<br>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现<br><div class="note default"><p>隐藏和覆盖的主要区别是：<br>如果是覆盖，当子类转换成父类时不能调用父类原本的方法，因为以及被覆盖了<br>如果是隐藏，当子类变为父类对象时，是可以执行原本父类的方法，而不会去调用子类的</p>
</div></p>
<h2 id="关于权限"><a href="#关于权限" class="headerlink" title="关于权限"></a>关于权限</h2><p>Java中有4种权限，至于各个的作用，通过一张表就能明白了，很有规律</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">公共(public)</th>
<th style="text-align:center">保护(protected)</th>
<th style="text-align:center">默认(default)</th>
<th style="text-align:center">私有(private)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同一类中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">同一包中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">子类中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">不同的包中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h2><p>一个类里定义的变量叫做字段，当提供了get/set方法，就称为属性，比如常见的javabean里面的变量都称为属性<br>属性的多少与变量无关，只与get/set方法的数量有关<br>这应该是比较正规的叫法</p>
<p>注意，在定义属性的时候命名不要用 <code>mXxx</code> 的这种形式，规范是一方面，还有就是当你生成 get/set 方法时就变成了 getMXxxx ，是不是很恶心，IDE 基本会自动帮你出去开头的 M，所以就变成了 getXxxx，但是返回的还是 mXxxx，这样就更恶心了，所以…..要规范！不要在 java bean 里乱定义名字</p>
<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>instanceof是Java的一个二元操作符，和==，&gt;，&lt;是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。<strong>它的作用是测试它左边的对象是否是它右边的类的实例</strong>，返回boolean类型的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"I AM an Object!"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isObject = s <span class="keyword">instanceof</span> Object;</span><br></pre></td></tr></table></figure>
<p>String类当然是继承自Object，所以当然返回是True了<br>instanceof运算符 只被用于对象引用变量，检查左边的被测试对象 是不是 右边类或接口的 实例化。如果被测对象是null值，则测试结果总是false<br>判断实例和类的方法常用的就是下面的三种，第一种就是上面我们所说：</p>
<ol>
<li>instanceOf<strong>关键字</strong>，用来判断对象是否是类的实例 </li>
<li>isAssignableFrom，用来判断类型间是否存在派生关系</li>
<li>isInstance方法，用来判断对象是否属于某个类型的实例 </li>
</ol>
<p>注意，后两个方法是class类中的，一般是这样用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.class.isAssignableFrom(Object.class);  <span class="comment">//false </span></span><br><span class="line">Object.class.isAssignableFrom(ArrayList.class);  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"javaisland"</span>); </span><br><span class="line">System.out.println(String.class.isInstance(s)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>遇到精度问题，例如经典的 1.0 - 0.9 ，原因就不说了，都知道，就算使用 BigDecimal 依然有精度问题，需要说明的是使用 BigDecimal 的时候不要使用 new 来构造，使用 <code>BigDecimal.valueOf()</code> 来初始化值，运算一律使用方法进行（除法运算除不尽时可能会抛异常）</p>
<hr>
<p>遇到 if 连续嵌套太深（无 else ，也推荐不要写 else），为了可读性可以考虑反向条件分解成多个独立的 if，这样会比较好阅读</p>
<h2 id="存档系列"><a href="#存档系列" class="headerlink" title="存档系列"></a>存档系列</h2><p>把那些复习 Java 时做的笔记大部分转移到了 Github，不占博客的空间了，随着熟练程度的增加那些也没啥用了。。。。</p>
<p>这里提供下索引，集中到这篇笔记中。</p>
<ul>
<li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/BlogBackup/java%E5%BF%AB%E9%80%9F%E6%8D%A1%E8%B5%B7.md" target="_blank" rel="noopener">Java快速捡起</a><br>基础知识概念，包含：重载、构造函数、继承、多态、封装<br>现在看着写的还算不错</li>
<li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/BlogBackup/Java%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98.md" target="_blank" rel="noopener">Java复习之内存</a><br>JVM 内存规划的基础基础，后面看了 <a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM.md" target="_blank" rel="noopener">深入理解 JVM</a> 表示实写的实在是太简单了</li>
<li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/BlogBackup/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.md" target="_blank" rel="noopener">java中的集合框架</a><br>同样是早期学习的产物，现在看看写的太浅了，深入一点的可以参考:<br><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92(%E4%BA%8C" target="_blank" rel="noopener">Java基础复习计划二</a>.md)</li>
<li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/BlogBackup/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3java.md" target="_blank" rel="noopener">抽象类和接口</a><br>早期学习产物，基本的对比而已，当时竟然还单独写了一篇，看来当时这是个难点</li>
<li><a href="https://github.com/bfchengnuo/MyRecord/blob/master/%E7%AC%94%E8%AE%B0/Java/BlogBackup/%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E5%92%8C%E5%A4%9A%E6%80%81.md" target="_blank" rel="noopener">继承，覆盖，抽象类，和多态</a><br>早期学习产物，概念的对比，当时自学时被这些概念困扰了好久啊 o(￣▽￣<em>)ゞ))￣▽￣</em>)o</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Centos搭建自己的邮件服务器]]></title>
      <url>http://bfchengnuo.com/2017/03/21/%E7%94%A8Centos%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>今天主要是闲的无聊，买的VPS不能白白的浪费掉啊，就搭个邮件服务来玩，使用的是Postfix和Dovecot来搭建，用Foxmail客户端登陆测试收信、发信均没问题<a id="more"></a><br>先了解几个email有关的名词：</p>
<ul>
<li>MUA：用户代理端，即用户使用的写信、收信客户端软件</li>
<li>MTA：邮件传送端，即常说的邮件服务器，用于转发、收取用户邮件。</li>
<li>MDA：邮件代理端，相当于MUA和MTA的中间人，可用于过滤垃圾邮件。</li>
<li>POP：邮局协议，用于MUA连接服务器收取用户邮件，通信端口110。</li>
<li>IMOP：互联网应用协议，功能较POP多，通信端口143。</li>
<li>SMTP：简单邮件传送协议，MUA连接MTA或MTA连接MTA发送邮件使用此协议，通信端口25。</li>
</ul>
<p>postfix正是提供MTA功能的开源软件，是用来收发邮件的，它没有web页面，所以要配合本地的MUA（类似于foxmail，outlook之类的软件）来进行可视化的邮件管理操作。<br>Dovecot 是一个开源的IMAP 和POP3 邮件服务器，支持Linux/Unix 系统。作为IMAP和POP3服务器，Dovecot为邮件用户代理(MUA)提供了一种访问服务器上存储的邮件的方法(简单理解为检测用户的合法性)。但是，<strong>Dovecot并不负责从其他邮件服务器接收邮件。Dovecot只是将已经存储在邮件服务器上的邮件通过MUA显示出来。</strong></p>
<p>好了下面就开始干吧</p>
<h2 id="安装Postfix和Dovecot"><a href="#安装Postfix和Dovecot" class="headerlink" title="安装Postfix和Dovecot"></a>安装Postfix和Dovecot</h2><p>在安装之前，首先我们先卸载默认的sendmail（如果有的话），因为它是系统默认的MTA程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove sendmail</span><br></pre></td></tr></table></figure>
<p>然后就可以安装了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install postfix</span><br><span class="line">yum install cyrus*</span><br></pre></td></tr></table></figure>
<p>cyrus函数库为postfix的stmp提供安全的验证支持<br>修改MTA（默认邮件传输代理）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alternatives --config mta</span><br></pre></td></tr></table></figure>
<p>检查一下是不是已经设置成功了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alternatives --display mta</span><br></pre></td></tr></table></figure>
<p>第一行可以看到mta的状态。 例如：<code>mat - status is manual.</code><br>安装Dovecot：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dovecot</span><br></pre></td></tr></table></figure>
<h2 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h2><p>需要添加两条记录，如果要设置过滤垃圾邮件的规则的话，还要再加一条，关键字：SPF和TXT记录类型<br>设置后一段时间后才会生效，10几分钟吧</p>
<table>
<thead>
<tr>
<th style="text-align:center">主机记录</th>
<th style="text-align:center">记录类型</th>
<th style="text-align:center">记录值</th>
<th style="text-align:center">MX优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@(不填即可，默认会给这个)</td>
<td style="text-align:center">MX</td>
<td style="text-align:center">mail.bfchengnuo.com</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">mail</td>
<td style="text-align:center">A</td>
<td style="text-align:center">服务器的公网IP</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>下面再说说这两条记录的作用</p>
<ul>
<li>MX 记录<br>这是为邮件服务器专门设计的，用于指定负责处理发往收件人域名的邮件服务器，简单邮件传输协议（SMTP）会根据 MX 记录的值来决定邮件的路由过程。<br>比如用 Gmail 往 163 发邮件，因为不是一个域的，在“转发”的过程中需要根据收信人地址(@163.com)查找 DNS 以确定对方域的 IP ，这样才能正确的投递</li>
<li>A 记录<br>这个是为了免登陆的，正常情况下，我们发邮件需要登陆自己的账户，那么 Gmail 往 163 进行“转发”也是在发邮件，这个过程显然不可能也要进行登陆，这就用到了 A 记录<br>Gmail 转发邮件时通过 ehlo 打招呼的时候表明自己的邮件服务器域，也就是类似 <code>mail.gmail.com</code> 这样的，就是指向发邮件的服务器；<br>对方(163)收到后进行确认，拿着这个地址查 DNS，找出对应的 IP，然后核对发送人是不是这个 IP，这样就可以确认发送人是服务器而不是个人用户，就不需要登陆了</li>
</ul>
<p>大型的邮件系统收信服务器和发信服务器不会是在一台物理服务器上，比如基本都是 <code>imap.gmail.com</code> 收信服务器；<code>smtp.gmail.com</code> 发信服务器；对应着协议，以及现在用的比较少的 POP3</p>
<blockquote>
<p>  POP3 协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。<br>  而 IMAP 提供 webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。<br>  <a href="http://help.163.com/10/0203/13/5UJONJ4I00753VB8.html" target="_blank" rel="noopener">http://help.163.com/10/0203/13/5UJONJ4I00753VB8.html</a></p>
</blockquote>
<h2 id="配置Postfix"><a href="#配置Postfix" class="headerlink" title="配置Postfix"></a>配置Postfix</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/postfix/main.cf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在75行，postfix主机名，修改成你的域名 此项需要添加A记录并指向postfix所在主机公网IP</span><br><span class="line">myhostname = mail.bfchengnuo.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在83行，后面为主机域名</span><br><span class="line">mydomain = bfchengnuo.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在100行，设置postfix邮箱的域名后缀为$mydomain</span><br><span class="line">myorigin = $mydomain</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在117行</span><br><span class="line"><span class="meta">#</span>指定postfix系统监听的网络接口</span><br><span class="line"><span class="meta">#</span>若注释或填入公网ip  服务器的25端口将对公网开放</span><br><span class="line"><span class="meta">#</span>默认值为all 即监听所有网络接口</span><br><span class="line"><span class="meta">#</span>此项指定localhost后 本机postfix就只能发邮件不能接收邮件</span><br><span class="line">inet_interfaces = all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在120行,指定网络协议</span><br><span class="line">inet_protocols = ipv4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在165行</span><br><span class="line"><span class="meta">#</span>指定postfix接收邮件时收件人的域名，换句话说，也就是你的postfix系统要接收什么样的邮件。</span><br><span class="line"><span class="meta">#</span>此项配置中$myhostname表示postfix接受@$myhostname为后缀的邮箱的邮件 逗号分割支持指多项</span><br><span class="line"><span class="meta">#</span>此项默认值使用myhostname</span><br><span class="line">mydestination = $myhostname, localhost.$mydomain, localhost</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在266行</span><br><span class="line"><span class="meta">#</span>指定你所在的网络的网络地址</span><br><span class="line"><span class="meta">#</span>这里我填的依次是公网IP、内网IP、本地IP</span><br><span class="line"><span class="meta">#</span>请依据实际情况修改</span><br><span class="line">mynetworks = 40.120.xxx.xxx, 10.200.xx.xxx, 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>大约在571行</span><br><span class="line"><span class="meta">#</span>指定MUA通过smtp连接postfix时返回的header头信息</span><br><span class="line"><span class="meta">#</span>原始配置附带有postfix版本号 去掉即可，此项酌情处理</span><br><span class="line">smtpd_banner = $myhostname ESMTP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>SMTP Config  ,将下面的内容添加到文件尾部即可</span><br><span class="line"><span class="meta">#</span> 规定邮件最大尺寸为10M</span><br><span class="line">message_size_limit = 10485760</span><br><span class="line"><span class="meta">#</span> 规定收件箱最大容量为1G</span><br><span class="line">mailbox_size_limit = 1073741824</span><br><span class="line"><span class="meta">#</span> SMTP认证</span><br><span class="line">smtpd_sasl_type = dovecot</span><br><span class="line">smtpd_sasl_path = private/auth</span><br><span class="line">smtpd_sasl_auth_enable = yes</span><br><span class="line">smtpd_sasl_security_options = noanonymous</span><br><span class="line">smtpd_sasl_local_domain = $myhostname</span><br><span class="line">smtpd_recipient_restrictions = permit_mynetworks,permit_auth_destination,permit_sasl_authenticated,reject</span><br></pre></td></tr></table></figure>
<p>修改好了之后使用<code>/etc/rc.d/init.d/postfix start</code>开启postfix<br>使用<code>chkconfig postfix on</code>将postfix开机启动。</p>
<p><del>其中，myhostname 还有说是运行 hostname 命令返回的结果，如果不成功，可尝试</del></p>
<h2 id="配置Dovecot"><a href="#配置Dovecot" class="headerlink" title="配置Dovecot"></a>配置Dovecot</h2><p>还是修改配置文件，注意要修改的文件比较多，跟着改即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/dovecot/dovecot.conf</span><br><span class="line"><span class="meta">#</span> 26行: 如果不使用IPv6，请修改为*</span><br><span class="line">listen = *</span><br><span class="line"></span><br><span class="line">vi /etc/dovecot/conf.d/10-auth.conf</span><br><span class="line"><span class="meta">#</span> 9行: 取消注释并修改</span><br><span class="line"><span class="meta">#</span> 是否允许在沒有 SSL/TLS 下以明码登录</span><br><span class="line">disable_plaintext_auth = no</span><br><span class="line"><span class="meta">#</span> 97行: 添加</span><br><span class="line">auth_mechanisms = plain login</span><br><span class="line"></span><br><span class="line">vi /etc/dovecot/conf.d/10-mail.conf</span><br><span class="line"><span class="meta">#</span> 30行: 取消注释并添加</span><br><span class="line">mail_location = maildir:~/Maildir</span><br><span class="line"></span><br><span class="line">vi /etc/dovecot/conf.d/10-master.conf</span><br><span class="line"><span class="meta">#</span> 88-90行: 取消注释并添加 Postfix smtp 验证</span><br><span class="line">unix_listener /var/spool/postfix/private/auth &#123;</span><br><span class="line">    mode = 0666</span><br><span class="line">    user = postfix</span><br><span class="line">    group = postfix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开启服务和加入开机启动</span><br><span class="line">/etc/rc.d/init.d/dovecot start</span><br><span class="line">chkconfig dovecot on</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一切都弄好以后，就可以使用Foxmail等第三方软件来收发邮件了。<br>在这里需要说一下，<strong>系统用户就是邮件的用户</strong>，例如root，就是一个邮箱用户，邮箱是root@bfchengnuo.com，密码就是root的密码，所以需要创建用户，只要使用<code>useradd</code>创建用户，再使用passwd设置密码。<br>不建议使用root用户来测试，还是useradd一个admin用户比较好</p>
<p>如果使用的是Foxmail，输入E-mail地址和密码后，选择接收服务器类型是IMAP，邮件账号是你的用户名（不是邮箱地址）<br>下面的IMAP和SMTP服务器保持默认的mail.bfchengnuo.com即可</p>
<p>还有就是：一定别忘了开启服务器的相应的端口！比如基本的143和25端口，对应上面的两个服务<br>就酱！</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><ul>
<li>启动 postfix 服务提示找不到？<br>试试 <code>service postfix start</code> 或者 <code>systemctl start postfix</code> ；<br>顺便可使用 <code>service postfix reload</code> 刷一下配置</li>
<li>出现意外情况？查看日志<br>查看 <code>/var/log/maillog</code> 下的日志或许会有些帮助，然后放到 Google 上</li>
</ul>
<p>PS：后来换阿里云的测试….谁能想阿里云防垃圾邮件默认封杀 25 端口，需要申请解封，心累…</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sina.com.cn/s/blog_5ce87d560100fvoa.html" target="_blank" rel="noopener">Dovecot是什么</a><br><a href="http://lomu.me/post/linux-email-server" target="_blank" rel="noopener">http://lomu.me/post/linux-email-server</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 邮件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你所应该知道的JS特性]]></title>
      <url>http://bfchengnuo.com/2017/03/17/%E4%BD%A0%E6%89%80%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84JS%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>这算是我知道的唯一一种既能写前端又能写后端的语言，这么腻害的语言不会太简单，并且还是脚本语言更是有各种不可描述的用法，这只是一小部分…..<a id="more"></a></p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p>当<strong>基本类型</strong>以对象的方式去使用时，JavaScript会自动转换成对应的<strong>包装类型</strong>，相当于new了一个对象，内容和基本类型的内容一样，但是如果执行完毕后，这个临时对象会被销毁，所以如果再访问时候就是undefined<br>比如string类型是基本数据类型，但它可以调用length属性，也可以赋予属性，但是如果访问之前赋予的属性就会提示undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"lalala"</span>;</span><br><span class="line">str.length;  <span class="comment">// 6</span></span><br><span class="line">str.t=<span class="number">3</span>;  <span class="comment">//成功</span></span><br><span class="line">str.t;  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>js中是没有块级(<code>{}</code>)作用域的，但是函数作用域是有的，如果单独定义代码块(<code>{}</code>)，定义在里面的变量在代码块外照样可以使用，定义在里面和外面并无区别，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和下面的写法是完全一样的</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是啊，在ES6面试之后有了let，即开始有了块级作用域…..<br>还有，当我们在函数内定义局部变量的时候，有时会用<code>var a=b=1</code>这样来建立2个变量，如果这样写，a确实是局部变量，但b是全局变量，在函数外也是可以拿到的，所以，一定要分开写</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>创建函数我们一般使用两种形式，直接定义fun或者赋给一个变量，直接定义的会被预处理，在定义之前调用也是可以的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lalala'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>for...in</code>的时候要注意，它遍历的顺序是不确定的，具体与引擎的实现有关<br>使用with会使引擎的优化变得困难，所以不建议使用，可以用变量来代替，甚至在严格模式下，禁用了with<br>如果想要在严格模式下执行，只需要在函数第一句或者js文件的第一句写上<code>&quot;use strict&quot;</code>，如果老版本浏览器会被当成字符串忽略，做到了很好的向下兼容</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象中定义的属性是<strong>无序</strong>的，并且每一个属性都有一个<strong>字符串</strong>key和对应的value，就算你输入的不是字符串类型，js也会帮你转换成字符串类型，这也就能解释的通为什么等价于<code>a.s</code>的<code>a[&#39;s&#39;]</code>里面是字符串了<br>我们也稍微了解到过，对象一般都是有原型的，就是prototype，当我们通过new创建一个对象的时候，prototype就指向了函数定义的原型，当然函数原型中也有它的原型就是Object，一层一层Object的原型就是null了，就好比很多属性都有toString方法，这个就是从Object继承而来的，感觉有点说白明白，举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 在原型上定义一个属性</span></span><br><span class="line">foo.prototype.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo();</span><br><span class="line">obj.a = <span class="number">1</span>;</span><br><span class="line">obj.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.x);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这就叫原型链，我怎么感觉和继承重写似得…..需要注意的一点是使用<code>in</code>来判断某属性是否存在时，是会顺着原型链查找的<br>创建对象还可以使用<code>var a = Object.create(null);</code>这样的意思其实就是a的原型指向null，不过一般是传入的一个对象，也就是指定原型的指向吧(继承 :雾)</p>
<h2 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h2><p>说来也比较奇怪，js中竟然有两个表示“无”的值，一切都是历史遗留问题<br>undefined和null在if语句中，都会被<strong>自动转为false</strong>，相等运算符（==）甚至直接报告两者相等。<br>平常的使用中，它们基本没啥区别，也没啥问题</p>
<blockquote>
<p>  1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。<br>  根据C语言的传统，null被设计成可以自动转为0。</p>
</blockquote>
<p>null像Java里的一样，被当成一个<strong>对象</strong>，是的，null是一个对象，如果你用<code>typeof(null)</code>来查看返回的是Object<br>所以嘛，有人(Brendan Eich)就认为这样是不合理的，所以又设计出了undefined<br>JavaScript的最初版本是这样区分的：<strong>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</strong><br>但是呢，在实践中证明这样是不可行的，所以后来也就…..<br>目前普遍认为的是：<br><strong>null表示”没有对象”，即该处不应该有值。</strong>典型用法是：</p>
<blockquote>
<p>  作为函数的参数，表示该函数的参数不是对象。<br>  作为对象原型链的终点。</p>
</blockquote>
<p><strong>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</strong>典型用法是：</p>
<blockquote>
<p>  变量被声明了，但没有赋值时，就等于undefined。<br>  调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>  对象没有赋值的属性，该属性的值为undefined。<br>  函数没有返回值时，默认返回undefined。</p>
</blockquote>
<p>undefined ：表示未知的事物，啥也没有，无法想象。<br>null ：有这么个概念，但是没东西   ，但是 null并非object，虽然 <code>typeof null</code> 的结果是 object</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>一般来说，定义全局变量有三种方式<br>第一种就是直接var一个，不过不要在函数内，否则就是局部变量了(哦，对JS中是没有class概念的)<br>另一种是直接给标识符赋值，这样会<strong>隐式的声明</strong>了全局变量test。<strong>即使该语句是在一个function内，当该function被执行后test变成了全局变量。</strong>有人说这才是最正统的定义全局变量的方式<br>最后一种就是不使用var使用window，类似：<code>window.x = 4</code><br>查看定义的全局变量可以使用<strong>for in window</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断有没有a1 a2 a3变量</span></span><br><span class="line"><span class="keyword">for</span>(a <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'a1'</span>||a==<span class="string">'a2'</span>||a==<span class="string">'a3'</span>)&#123;</span><br><span class="line">        alert(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意一点的是：通过var声明的变量无法删除(<code>delete a1</code>)，所有浏览器表现一致。这在犀牛书上也有提到。</p>
<h2 id="NaN类型"><a href="#NaN类型" class="headerlink" title="NaN类型"></a>NaN类型</h2><p>全局属性NaN表示 Not-A-Number 的值，所以说它是一个全局对象的属性，NaN属性的初始值就是NaN，和<code>Number.NaN</code> 的值一样。也就是说 <code>NaN</code> 是一种特殊的 <code>Number</code> 类型值</p>
<blockquote>
<p>  无穷大除以无穷大、给任意负数做开方运算 或者 算数运算符与不是数字或无法转换为数字的操作数一起使用时都将返回 <code>NaN</code>。<br>  如果 JavaScript 期望使用一个数字，它把给定的值将转换为数字（如果转换结果无意义的话将返回 NaN）。<br>  举个栗子就是：<code>Number(&#39;a&#39;);</code></p>
</blockquote>
<p>首先全局的 <code>isNaN()</code> 函数不能严格判断输入值是否为 <code>NaN</code>。严格判断使用<code>typeof value === &#39;number&#39; &amp;&amp; isNaN(value);</code><br>NaN 和<strong>任何</strong>对象做运算都会返回NaN，好玩的是 <code>NaN != NaN</code> 确实是这样，它谁都不等，包括自己</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>JavaScript由三部分组成：EMCAScript、DOM、BOM。<br>DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口。,而BOM定义了JavaScript可以进行操作的浏览器的各个功能部件的接口。<br>首先应该清楚的是两者皆为接口定义。</p>
<ul>
<li>DOM是W3C的标准（所有浏览器公共遵守的标准）</li>
<li>BOM是各个浏览器厂商根据DOM在各自浏览器上的实现</li>
<li>window是BOM对象，而非JavaScript对象，不过恰好为EMCAScript中所定义的Global对象</li>
</ul>
<p><strong>window是BOM对象</strong>，而非JavaScript对象，不过恰好为EMCAScript中所定义的Global对象<br>由于window包含了document，因此JavaScript可以直接通过使用window的document对象来访问、检索、修改文档内容与结构。因为document对象又是DOM的根节点，所以可以理解为BOM包含了DOM。即浏览器提供出来给予访问的是BOM对象，而BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</p>
<p>原文：<a href="https://www.zhihu.com/question/29917511" target="_blank" rel="noopener">https://www.zhihu.com/question/29917511</a> </p>
<h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p>在很多高级语言中，加号(+)在字符串的操作中被赋予了更多的意义：作为字符串拼接的操作符。不过在Java和C#中，我们也知道如何频繁进行字符串拼接的操作，使用加号(+)就会产生效率问题，因此在这种情况下就会推荐使用StringBuilder。<br>我们知道 java 中 String 是引用类型，使用 += 进行字符串拼接将会频繁地分配新地址，指向新的地址块，这无疑白白地消耗了系统的性能。javascript中的字符串类型同java的String类似，如果我们大量使用+=进行字符串拼接的话，将会使界面失去响应(卡死状态)<br>解决方案可以使用数组来代替 StringBuilder：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">strArr.push(<span class="string">"aaaa"</span>);</span><br><span class="line">strArr.push(<span class="string">"bbbb"</span>);</span><br><span class="line">strArr.push(<span class="string">"ccccc"</span>);</span><br><span class="line">alert(strArr.join(<span class="string">' '</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> sb = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;=<span class="number">21</span>; i++) &#123;</span><br><span class="line">  sb.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(sb.join(<span class="string">''</span>));</span><br></pre></td></tr></table></figure>
<p>在其他语言中也是类似，所以频繁拼接的尽量避免 += 方式，比如 python 中可以使用 <code>&#39;&#39;.join</code> 来进行拼接<br>涉及到中文的字符记得使用 js 中的 encodeURL 方法进行编码.</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数），它相当于是匿名函数，简化了函数的定义，有点 lambda 的味道~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含多条语句的</span></span><br><span class="line">x =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> - x * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数:</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数:</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">    sum += rest[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象，为了避免冲突使用括号</span></span><br><span class="line">x =&gt; (&#123; <span class="attr">foo</span>: x &#125;)</span><br></pre></td></tr></table></figure>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的<code>this</code>是词法作用域，由上下文确定。<br>回顾前面的例子，由于JavaScript函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数方式</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>定义正则用 <code>/str/</code>  ,如果是全文匹配就是 <code>/str/g</code> ，全文匹配表示匹配到一个后并不会停下来，它不需要转义，但是使用 <code>new RegExp(&quot;\\d+&quot;)</code> 这样的原始形式是需要转义的。</p>
<p>isNaN() 函数通常用于检测 parseFloat() 和 parseInt() 的结果，以判断它们表示的是否是合法的数字。</p>
<p>禁止事件冒泡： <code>e.preventDefault()</code>，IE 则是使用 <code>e.returnValue = false;</code> ，e 为事件 event，一般在函数中传递。<br>javascript 的 <code>return false</code> 只会阻止默认行为，而是用 jQuery 的话则既阻止默认行为又防止对象冒泡。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP笔记]]></title>
      <url>http://bfchengnuo.com/2017/03/13/HTTP%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>发现写的好乱，内容基本是图解HTTP里的，但感觉讲的确实比较浅，以前我确实也是特意搜过这些，抓包的时候会用到吧~啊哈哈，真的是又乱又杂….<br><a id="more"></a><br>就先这样吧，比如SSL/TLS这种我在公众号写过了，这里就直接不多解释了，解释起来内容也挺多了…..</p>
<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><p>如果查看数据包，前两行应该是类似这样的：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">*</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host:bfchengnuo.com</span></span><br></pre></td></tr></table></figure>
<p>OPTIONS方法主要用来查询针对请求URL指定资源<strong>支持</strong>的方法，*代表的就是不是对特定资源，而是对服务器发起的请求</p>
<p>CONNECT方法要求在与代理服务器通讯时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL/TLS协议把通信内容进行加密然后经过网络隧道传输：<code>CONNECT 代理服务器名:端口号 HTTP版本</code>，后面也就一样了跟Host之类，如果响应为200，那么之后就进入网络隧道了<br>其实我们常用的也就是GET和POST方法，GET常用于获取，POST用于发送，明显的区别就是GET会把参数放在URL中传送，所以不安全内容大小也有限，但是速度快，POST相反，内容放在请求头中，相对安全</p>
<p>我们知道HTTP是无连接的协议，也就是每进行一次HTTP请求就要断开一次TCP连接，如果访问一个很多图片的网站，除了本身的获取HTML文件需要建立连接、发送请求/响应、断开连接，每一个图片的获取也要都来一遍，这就非常的浪费流量，并且还增加了服务器负载<br>所以在HTTP/1.1中有了<strong>持久连接</strong>，就是说，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在1.1中默认都是持久连接，当然是需要客户端(比如浏览器)支持的<br>支持<strong>管线化</strong>后可以同时发送多个HTTP请求，使网页加载更快<br>但毕竟是无连接的协议，在网页跳转之后服务器就不认识你了，在需要记录登陆状态的网站，一般都需要使用Cookie来实现，当发送HTTP请求的时候携带Cookie，服务器再进行对比分析(通过Session)，从而确认是谁发起的请求<br>具体的步骤是：<br>客户端请求—-&gt;服务器生成Cookie，并且通过响应返回给客户端—-客户端在请求中添加Cookie—-&gt;服务器知道是这家伙发送的请求<br>Cookie最大也只能是4KB~存在于请求头中</p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP报文有两部分组成，报文首部和报文主体，中间用空行(CR+LF)分割，以访问百度为例<br>请求报文：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.baidu.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">DNT</span>: 1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, sdch, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8,zh-TW;q=0.6</span><br><span class="line"><span class="attribute">Cookie</span>: BAIDUID=241D3FBE4A65352E2607D08762736012:FG=1;省略....太长了</span><br><span class="line">空行</span><br></pre></td></tr></table></figure>
<p>响应报文：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span>: bfe/1.0.8.18</span><br><span class="line"><span class="attribute">Date</span>: Sat, 11 Mar 2017 07:30:01 GMT</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html;charset=utf-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: private</span><br><span class="line"><span class="attribute">Expires</span>: Sat, 11 Mar 2017 07:30:01 GMT</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">X-UA-Compatible</span>: IE=Edge,chrome=1</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span>: max-age=172800</span><br><span class="line"><span class="attribute">BDPAGETYPE</span>: 2</span><br><span class="line"><span class="attribute">BDQID</span>: 0x8bb8b8d40000c99a</span><br><span class="line"><span class="attribute">BDUSERID</span>: 273454118</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BDSVRTM=111; path=/</span><br><span class="line">空行</span><br><span class="line"><span class="attribute">html网页内容（报文主体）</span></span><br></pre></td></tr></table></figure>
<p>为了节省流量，服务器返回的主体可能会进行压缩，比如gzip, deflate方式等，还有一个是<strong>identity</strong>是不进行编码</p>
<ul>
<li>分割发送<br>因为浏览器必须等到主体后才能加载，当一个网页很大时，那么加载就需要一定时间，页面一片空白，这时可以把主体部分进行分割发送，让浏览器先加载一部分<br>分块时每一块都会用16进制来标记块的大小，主体的最后一块使用<code>0(CR+LF)</code>来标记</li>
<li>范围请求<br>也就是所说的断点续传，就是可以获取部分内容的请求，比如要获取5001-10000字节内的资源<br>在请求头中有：<code>Range:bytes=5001-10000</code><br>与之对应的响应：<code>Content-Range:bytes 5001-10000/10000</code><br>如果是获取从5000以后的全部可以直接<code>5000-</code>这样写，以及可以多重范围：从开始到200以及300以后的就是：<code>-200,300-</code><br>如果服务器支持会返回<code>206 Partial Content</code>的状态码，不支持就返回200 OK并且会返回全部的内容</li>
<li>内容协商<br>就是根据你的环境返回最适合的内容，比如使用Accept-Language指明语言为中文，返回的就是中文网页</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><ul>
<li>1XX: 信息</li>
<li>2XX: 成功</li>
<li>3XX:重定向<br>301：永久重定向<br>302：临时重定向<br>301、302、303返回时，几乎所有浏览器都会把POST改为GET，并删除报文中的主体部分，然后再次发送<br>虽然301、302的标准是进制改为GET的</li>
<li>4XX客户端错误<br>400：请求是不是写错了？服务器不理解<br>401：需要认证并且认证失败<br>403：不允许访问<br>404：没找到</li>
<li>5XX服务器错误<br>503：服务器正忙</li>
</ul>
<p>详细参考：<u><a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_httpmessages.asp</a></u></p>
<h2 id="Web服务器的协作"><a href="#Web服务器的协作" class="headerlink" title="Web服务器的协作"></a>Web服务器的协作</h2><p>一台Web服务器是运行部署多个域名的，虽然会被解析到同一台服务器，但是因为Host首部指定了唯一的域名地址，所以是可以正常解析的</p>
<ul>
<li>代理<br>其实就相当于在服务器与客户端之间的中间人，负责转发数据包</li>
<li>网关<br>网关是转发其他服务器通信数据的服务器，接收到客户端发来的请求时，像自己拥有资源一样进行处理，客户端甚至感觉不到通信目标是个网关<br>网关顾名思义就是连接两个网络的设备，能在网络间转递数据包，主机则不能<br>利用网关也可以把HTTP请求转换为其他通信协议</li>
<li>隧道<br>简单说就是：相隔较远的服务器和客户端之间进行中转，并保持双方通信连接的程序，隧道本身是透明的<br>使用SSL等加密手段确保客户端和服务器进行安全的通信，隧道本身不会去解析HTTP请求，保持原样转发<br>隧道协议：将另一个<strong>不同的网络协议</strong>，封装在负载部分。使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。<br>比如SSH隧道提供一个绕过防火墙，从而连到某些被禁止的互联网服务的的方法。<br><strong>被封装的数据包在互联网上传递时所经过的逻辑路径被称为”隧道”。</strong><br>隧道可在网络的任一层实现，最常用的是两层：数据链路层和网络层。</li>
<li>缓存<br>缓存都会有一个期限，以浏览器为例：当超过后浏览器会向服务器确认是否过期，如果确实失效，然后再重新获取</li>
</ul>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><p>主要是HTTP/1.1版本，每隔字段下面其实还细分很多参数，太多了就不贴了，用到的时候去找文档<br>贴下各首部主要是干什么的</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为(no-cache可以缓存，但需要向服务器确认)</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部，连接的管理(Keep-Alive持久连接，close关闭连接)</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragna</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>需要说明的是，除了下面的这些 HTTP 头是可以自定义的，在做 RESTful 的时候可能会用到；<br>在 HTTP 协议本身是没有限制 HTTP 头的大小。尽管如此，很多Web服务器、客户端和代理软件都对HTTP头的大小进行限制。如 Apache2.3 中，每个头的大小最多是8160个字节，一个请求里面最多包含100个头。</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型（xx;q=0.6, xxx表示权重）</td>
</tr>
<tr>
<td>Accept—Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td style="text-align:center">优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td style="text-align:center">Web认证信息(证书信息，会返回401)</td>
</tr>
<tr>
<td>Expect</td>
<td style="text-align:center">期待服务器的指定行为</td>
</tr>
<tr>
<td>From</td>
<td style="text-align:center">用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td>if-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td>if-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td>if-None-Match</td>
<td style="text-align:center">比较实体标记（与if-Match相反）</td>
</tr>
<tr>
<td>if-Range</td>
<td style="text-align:center">资源为更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>if-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与if-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td style="text-align:center">实体字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td style="text-align:center">对请求中的URL的原始获取方法（防盗链）</td>
</tr>
<tr>
<td>TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td style="text-align:center">HTTP客户端程序的信息</td>
</tr>
</tbody>
</table>
<p>更多可参考：<a href="http://dafeizizhu.github.io/2013/07/12/http-header/" target="_blank" rel="noopener">http://dafeizizhu.github.io/2013/07/12/http-header/</a></p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td style="text-align:center">令客户端重定向至指定的URL</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Rety-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td style="text-align:center">HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td style="text-align:center">资源科支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td style="text-align:center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td style="text-align:center">替代对资源的URL</td>
</tr>
<tr>
<td>Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h3 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所有的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<h3 id="Set—Cookie字段的属性"><a href="#Set—Cookie字段的属性" class="headerlink" title="Set—Cookie字段的属性"></a>Set—Cookie字段的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td style="text-align:center">赋予Cookie的名称和其值</td>
</tr>
<tr>
<td>expires=DATE</td>
<td style="text-align:center">Cookie的有效期（若不mingque指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td style="text-align:center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td style="text-align:center">作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名，更安全）</td>
</tr>
<tr>
<td>Scure</td>
<td style="text-align:center">仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td style="text-align:center">加以限制，使Cookie不能被JavaScript脚本访问</td>
</tr>
</tbody>
</table>
<p>参考：<u><a href="https://ttop5.gitbooks.io/illustration-http/content/chapter6.html" target="_blank" rel="noopener">https://ttop5.gitbooks.io/illustration-http/content/chapter6.html</a></u></p>
<h2 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h2><p>关于这个在PHP(二)中提到过，这里再补充下<br><strong>cookie保存在客户端，session保存在服务器端</strong>，session 可以放在 文件(默认)、数据库、或内存中都可以。<br>它们大多用来保持会话状态，流程类似：<br>客户端发送认证信息—-&gt;服务器认证后生成一个Session然后把ID存到Cookie里返回给客户端<br>客户端再次请求时携带Cookie—–&gt;服务器验证后确认是真实用户<br>用户的多数信息可以放在Session中，一方面是因为安全问题，Cookie在客户端可以随意更改；另一方面Cookie只能保存4KB大小，Session随意了，因为一般不会放在内存中</p>
<blockquote>
<p>  我们知道HTTP是无连接的，当我们从A页面跳到B页面时，HTTP请求肯定是不同的，不同的HTTP请求之间肯定是无法共享数据的，但是Cookie在整个网站的域是可以随意访问的，所以可以利用Cookie来进行保持会话</p>
</blockquote>
<h3 id="Session生命周期"><a href="#Session生命周期" class="headerlink" title="Session生命周期"></a>Session生命周期</h3><p>Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet、PHP等后端程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。<br>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“<strong>活跃（active）</strong>”了一次。<br>服务器会把长时间内没有活跃的Session从内存/硬盘删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。<br>不过有人说当浏览器关闭后(非标签)，Session就会销毁，这种是通过什么实现的我没找到….不过我知道服务器为保存SessionID而设置的Cookie是没有有效期的：</p>
<blockquote>
<p>  Cookie如果没有设置有效期，它的maxAge属性一般为–1，表示仅<strong>当前浏览器内有效</strong>，关闭浏览器就会失效。<br>  服务器回写的 Cookie 名默认叫 JSESSIONID，注意是有path的，默认为当前应用</p>
</blockquote>
<p>所以，当关掉浏览器这个Cookie就失效了，ID也就丢失了，服务器判断一段时间 Session 没有活跃，所以就删除了</p>
<p>更多内容参考：<u><a href="http://www.admin10000.com/document/7097.html" target="_blank" rel="noopener">http://www.admin10000.com/document/7097.html</a></u></p>
<h2 id="追加协议"><a href="#追加协议" class="headerlink" title="追加协议"></a>追加协议</h2><p>HTTP/1.1也有很多的缺点：</p>
<ul>
<li>一条连接只能发送一个请求</li>
<li>请求只能从客户端开始，客户端不能接收响应外的指令</li>
<li>发送冗长的首部，每次发相同的首部也是浪费流量</li>
<li>非强制压缩，有可能未经压缩就发送</li>
</ul>
<p>如果是一个对实时更新要求比较高的网站，服务器端更新了在没有请求的情况下不能发送给客户端，只能客户端不断的去请求，<strong>发送大量重复的首部</strong>，每次返回的都是全部的内容</p>
<ul>
<li>Ajax<br>核心技术是XMLHttpRequest的API，通过JS脚本就可以和服务器进行HTTP通信，从而实现在加载完的页面上发送请求，并且进行局部更新</li>
<li>Comet<br>通常，服务器收到请求，处理完毕后会立即返回响应，但是Comet会将响应置于挂起状态，一旦服务器更新了再返回响应，这样也就是说，一次连接的时间边长了</li>
</ul>
<p>但是以上两种并没有解决HTTP本身的问题，还是会发送大量的重复首部，后来有了Google的SPDY<br>SPDY工作在会话层，也就是TCP(SSL)和HTTP之间，还是采用HTTP建立连接，考虑到安全性规定使用SSL，它做到了：</p>
<ul>
<li>单路复用<br>在单一的TCP连接上可以处理多个HTTP请求</li>
<li>赋予请求优先级</li>
<li>压缩HTTP首部</li>
<li>推送功能<br>服务器可以直接发送数据给客户端，不用等待客户端的请求</li>
<li>服务器提示<br>主体提示客户端请求的所需资源，在客户端请求资源前就知道了资源的存在，减少了请求</li>
</ul>
<h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><p>也是为了解决HTTP协议的瓶颈，它支持发送任意类型的数据，推送功能，会一直保持连接状态所以也就可以进行全双工通信，可以直接向客户端发送数据</p>
<p>建立WebSocket还是用的HTPP，在首部加入<code>Upgrade:websocket;Connection:Upgrade</code>，服务器收到后返回<code>101 Switching Protocols</code>然后双方就开始使用WebSocket进行通信了</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git基本操作]]></title>
      <url>http://bfchengnuo.com/2017/03/12/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>知道及接触Git也有一段时间了，但是很惭愧的只会5条左右的命令….(:捂脸)，就是添加、提交、推送等，还有一些功能比如回退这是很常用的，这次搞个总结，以后忘记了来巴拉巴拉<br><a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下载就不说了，然后是要配置Git，Git的全局配置一般会写到用户目录下的<code>.gitconfig</code>文件中，所以之间修改这个文件也是可以的，当然用命令也是可以的，首先就是配置用户名和邮箱啦</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.name "John Doe"</span><br><span class="line"><span class="meta">$</span> git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<p>加上global就是全局的意思，如果想单独设置可以去掉global，会保存在<code>.git/config</code>下<br>修改差异比较工具：<code>$ git config --global merge.tool vimdiff</code><br>查看配置：<code>git config --list</code></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>首先我们要得到一个仓库才行啊，有两种方式，1.本地创建一个  2.从别处克隆(下载)一个</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git init</span><br><span class="line"><span class="meta">#</span> or</span><br><span class="line"><span class="meta">#</span> 默认克隆到当前目录，也可以后面跟个指定的目录名</span><br><span class="line"><span class="meta">$</span> git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>
<p>然后就可以操作这可库了，比如通过add跟踪一个文件，commit提交，status查看文件状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看文件状态</span><br><span class="line"><span class="meta">$</span> git status</span><br><span class="line"><span class="meta">#</span> 开始跟踪一个新文件</span><br><span class="line"><span class="meta">$</span> git add README</span><br></pre></td></tr></table></figure>
<p>文件被跟踪后会进入暂存区，文件一单有改动使用status就可以看到基本变动信息，并且需要重新把这个变更的文件重新添加到暂存区，也就是说，你的改动并不会影响暂存区的文件，暂存区的文件相当于一份拷贝，你必须重新add后暂存区的文件才会更新成现在你最新更新的文件，所以说add方法是个多功能的命令<br>至于意义，因为当你commit提交的时候只会提交暂存区的文件，无论你本地修改了多少内容，只要不add，就是无效</p>
<p>Git还可以自动忽略某些文件，在仓库目录新建一个<code>.gitignore</code>的文件，在这里面规定就可，可以使用通配符，比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 忽略所有以 .o 或 .a 结尾的文件。</span><br><span class="line">*.[oa]</span><br><span class="line"><span class="meta">#</span> 忽略所有以~结尾的文件</span><br><span class="line">*~</span><br><span class="line"><span class="meta">#</span> 此为注释 – 将被 Git 忽略</span><br><span class="line"><span class="meta">#</span> 忽略所有 .a 结尾的文件</span><br><span class="line">*.a</span><br><span class="line"><span class="meta">#</span> 但 lib.a 除外</span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta">#</span> 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"><span class="meta">#</span> 忽略 build/ 目录下的所有文件</span><br><span class="line">build/</span><br><span class="line"><span class="meta">#</span> 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta">#</span> ignore all .txt files in the doc/ directory</span><br><span class="line">doc/**/*.txt</span><br></pre></td></tr></table></figure>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>要查看<strong>尚未暂存的文件更新了哪些部分</strong>，不加参数直接输入 <code>git diff</code><br>若要看<strong>已经暂存起来的文件和上次提交时的快照之间</strong>的差异，可以用 <code>git diff --cached</code> 或者<code>git diff --staged</code>命令</p>
<p>好了，最后就是提交了，一般使用类似<code>$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;</code>的命令，后面跟提交说明<br>如果给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交：<code>$ git commit --amend</code>，就是说这条命令有两个作用：</p>
<ol>
<li>提交当前<code>暂存区</code>，并合并到上一次commit。常用于提交后发现漏了几个文件，又不想再提交一次的情况；</li>
<li>可以修改上一次commit的描述。</li>
</ol>
<p>如果我们不小心add了某个文件，怎么将这个文件<strong>从暂存区删除</strong>呢，可以使用<code>git reset HEAD &lt;file&gt;...</code>，注意的是文件的修改并不会被抹掉，只是从暂存区删除<br>如果我们感觉某个文件完全没修改的必要，想要<strong>回退到未修改的状态</strong>，也就是与版本库一致，那么可以使用：<code>$ git checkout -- benchmarks.rb</code><br>强制<strong>回退到某个版本</strong>，可以使用<code>git reset --hard 02c4b5b31</code>后面的是ID，保证唯一即可，注意加了hard所有的修改会被抹掉，还有一些常用的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git reset HEAD^ #将当前分支往回退一步,不会抹掉修改，出现很多未暂存文件</span><br><span class="line"></span><br><span class="line">HEAD^ # HEAD之前的commit</span><br><span class="line">HEAD^^ # HEAD回退两步的commit</span><br><span class="line">master~5 # master指针回退5步的commit</span><br></pre></td></tr></table></figure>
<p>你已经执行了 <code>git push</code>, 把你的修改发送到了 GitHub，现在你意识到这些 commit 的其中一个是有问题的，你需要撤销那一个 commit ，这时可以使用 <code>git revert &lt;SHA&gt;</code> :<br>git revert <strong>会产生一个新的 commit</strong>，它和指定 SHA 对应的 commit 是相反的（或者说是反转的），也就是说这次反转也会被记录在 commit 历史里，这样更安全，但是由于一些原因不希望记录回退的记录那么可以……<br>还有一个大杀招：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 取消当前版本之前的两次提交</span><br><span class="line">git reset --hard HEAD~2</span><br><span class="line"><span class="meta">#</span> 强制提交到远程版本库，从而删除之前的两次提交数据</span><br><span class="line">git push origin HEAD --force</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>在推送之前首先得和远程仓库建立联系，如果使用的clone命令创建的仓库，那么就会自动关联了，如果是init创建的，就需要手动的关联：<br><code>git remote add origin &lt;server&gt;</code><br>然后就可以使用<code>git push origin master</code>推送了，master可以换成你想要推送的任何分支<br>当然也可以添加多个远程仓库，名字不用重即可，比如上面那个就是叫origin的，通过克隆的会自动归于origin下<br>删除远程库：<code>$ git remote rm paul</code><br>查看所关联的仓库：<code>$ git remote -v</code><br>获取远程仓库的最新内容可以使用：<code>git pull</code>，他会拉取并自动合并<br>只是拉取的话也可以使用：<code>git fetch origin</code></p>
<h2 id="分支-标签管理"><a href="#分支-标签管理" class="headerlink" title="分支/标签管理"></a>分支/标签管理</h2><p>查看本地所有分支（如果至查看远程就加 <code>-r</code> ，查看全部 <code>-a</code>）：<br><code>git branch</code><br>创建一个叫做“feature_x”的分支，并切换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉：<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是 <em>不为他人所见的</em>：<br><code>git push origin &lt;branch&gt;</code><br>要合并其他分支到你的<strong>当前分支</strong>（例如 master），执行：<br><code>git merge &lt;branch&gt;</code><br>删除远程分支：<br><code>git push origin --delete [branch-name]</code></p>
<hr>
<p>查看所有 tag：<br><code>git tag</code><br>删除本地分支：<br><code>git tag -d [tag]</code><br>删除远程分支：<br><code>git push origin :refs/tags/[tagName]</code><br>查看 tag 信息：<br><code>git show [tag]</code><br>提交指定/全部 tag：<br><code>git push [remote] [tag]</code><br><code>git push [remote] --tags</code><br>新建一个分支，指向某个 tag：<br><code>git checkout -b [branch] [tag]</code><br>可以执行如下命令创建一个叫做 <em>1.0.0</em> 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。当然不一定是10位，只要保证唯一性就可以，可以使用log命令获得，默认是当前最近的一次 commit</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Git默认是忽略文件夹的大小写的，如果想要它对大小写敏感使用：<br><code>git config core.ignorecase false</code><br>在需要的仓库下执行即可，如果想全局生效加<code>--global</code>参数</p>
<p>待补充…</p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery-动画]]></title>
      <url>http://bfchengnuo.com/2017/03/11/jQuery-%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<h2 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h2><p>让页面上的元素不可见，一般可以通过设置css的display为none属性。jQuery中可以直接调用<code>.hide()</code>来隐藏，这个方法可以接受一个参数，用来实现动画化，并且有两个快捷参数<code>fast</code> 和<code>slow</code> 分别代表200和600毫秒的延时，就是元素会执行200/600毫秒的动画后再隐藏<br><a id="more"></a></p>
<blockquote>
<p>  jQuery在做hide操作的时候，是<strong>会保存本身的元素的原始属性值，再之后通过对应的方法还原的时候还是初始值</strong>。<br>  比如一个元素的display属性值为inline，那么隐藏再显示时，这个元素将再次显示inline。一旦透明度达到0，display样式属性将被设置为none，这个元素将不再在页面中影响布局</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#a2"</span>).hide(&#123;</span><br><span class="line">    duration: <span class="number">3000</span>,</span><br><span class="line">    complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'执行3000ms动画完毕'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>既然有隐藏，当然也就有显示，使用方法类似，举个栗子：<br><code>$(&#39;elem&#39;).hide(3000).show(3000)</code><br>但是需要注意的是：如果让show与hide成为一个动画，那么默认执行动画会改变元素的高度，高度，透明度</p>
<p>show与hide是一对互斥的方法。需要对元素进行显示隐藏的互斥切换，通常情况是需要先判断元素的display状态，然后调用其对应的处理方法。<br>对于这样的操作行为，jQuery提供了一个便捷方法<strong>toggle</strong>用于切换显示或隐藏匹配元素，其实调用的就是上面两个方法，所以使用方法都是一样的</p>
<h2 id="上卷下拉效果"><a href="#上卷下拉效果" class="headerlink" title="上卷下拉效果"></a>上卷下拉效果</h2><p>上面的显示和隐藏方法会将元素的宽度，高度，以及不透明度，同时进行动画操作。这样看起来不是很爽<br>下拉动画：<strong>.slideDown()：用滑动动画显示一个匹配元素</strong><br><strong>.slideDown()</strong>方法将给匹配元素的高度的动画，这会导致页面的下面部分滑下去，弥补了显示的方式<br>常见的操作，提供一个动画是时间，然后传递一个回调，用于知道动画是什么时候结束：<code>.slideDown( [duration ][, complete ] )</code><br>持续时间（duration）是以毫秒为单位的，数值越大，动画越慢，不是越快。<br>字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时。<br>如果提供任何其他字符串，或者这个duration参数被省略，那么默认使用400 毫秒的延时。<br>具体使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ele"</span>).slideDown(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//等待动画执行1秒后(也就是动画完成后),执行别的动作....</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么上卷函数就是<strong>slideUp</strong>了，使用方法一样</p>
<blockquote>
<p>  因为动画是异步的，所以要在动画之后执行某些操作就必须要写到回调函数里面，这里要特别注意</p>
</blockquote>
<p>和隐藏方法类似，也有上卷下拉切换的方法<strong>slideToggle</strong></p>
<h2 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h2><p><code>fadeOut()</code>函数用于隐藏所有匹配的元素，并带有淡出的过渡动画效果，使用方法和上面的几个函数是一样的<br>有out当然就有in，所以有相应的<code>fadeIn()</code>方法<br>相应的也有一个切换的方法：<code>fadeToggle()</code>如果隐藏就显示，如果显示就隐藏<br>既然是透明度，那么就不止0和1，还有0.5这样的半透明状态，所以jQ还提供了一个方法：<code>fadeTo()</code>来过渡到指定的透明度，用法都是类似，不多说</p>
<h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><p>自定义主要使用的是<strong>animate</strong>方法</p>
<blockquote>
<p>  <code>.animate()</code>方法允许我们在任意的数值的CSS属性上创建动画。2种语法使用，几乎差不多了，唯一必要的属性就是一组CSS属性键值对。这组属性和用于设置<code>.css()</code>方法的属性键值对类似，除了属性范围做了更多限制。第二个参数开始可以单独传递多个实参也可以合并成一个对象传递了</p>
</blockquote>
<p>使用方法可以参考下面的栗子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $aaron = $(<span class="string">"#aaron"</span>);</span><br><span class="line"><span class="keyword">if</span> (v == <span class="string">"1"</span>) &#123;</span><br><span class="line">    <span class="comment">// 数值的单位默认是px</span></span><br><span class="line">    $aaron.animate(&#123;</span><br><span class="line">        width  :<span class="number">300</span>,</span><br><span class="line">        height :<span class="number">300</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="string">"2"</span>) &#123;</span><br><span class="line">    <span class="comment">// 在现有高度的基础上增加100px</span></span><br><span class="line">    $aaron.animate(&#123;</span><br><span class="line">         width  : <span class="string">"+=100px"</span>,</span><br><span class="line">         height : <span class="string">"+=100px"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="string">"3"</span>) &#123;</span><br><span class="line">    $aaron.animate(&#123;</span><br><span class="line">        fontSize: <span class="string">"5em"</span></span><br><span class="line">    &#125;, <span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"动画 fontSize执行完毕!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == <span class="string">"4"</span>) &#123;</span><br><span class="line">    <span class="comment">//通过toggle参数切换高度</span></span><br><span class="line">    $aaron.animate(&#123;</span><br><span class="line">        width: <span class="string">"toggle"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于动画的时间也是提供’fast’ 和 ‘slow’字符串，分别表示持续时间为200 和 600毫秒。<br><strong>如果多个元素执行动画，回调将在每个匹配的元素上执行一次，不是作为整个动画执行一次</strong><br>除了上面的创建方式，其实还有一种：<code>.animate( properties, options )</code><br><strong>options参数</strong></p>
<ul>
<li>duration - 设置动画执行的时间</li>
<li>easing - 规定要使用的 easing 函数，过渡使用哪种缓动函数</li>
<li>step：规定每个动画的每一步完成之后要执行的函数</li>
<li>progress：每一次动画调用的时候会执行这个回调，就是一个进度的概念</li>
<li>complete：动画完成回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v == <span class="string">"1"</span>) &#123;</span><br><span class="line">    $aaron.animate(&#123;</span><br><span class="line">        height: <span class="string">'50'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        duration :<span class="number">2000</span>,</span><br><span class="line">        <span class="comment">//每一个动画都会调用</span></span><br><span class="line">        step: <span class="function"><span class="keyword">function</span>(<span class="params">now, fx</span>) </span>&#123;</span><br><span class="line">           $aaron.text(<span class="string">'高度的改变值:'</span>+now)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有就是可以手动停止动画，方法就是stop了，它最多可以接受2个参数，具体怎么用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#aaron"</span>).animate(&#123;</span><br><span class="line">    height: <span class="number">300</span></span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line">$(<span class="string">"#aaron"</span>).animate(&#123;</span><br><span class="line">    width: <span class="number">300</span></span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line">$(<span class="string">"#aaron"</span>).animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.6</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<p><code>stop()</code>：只会停止第一个动画，第二个第三个继续<br><code>stop(true)</code>：停止第一个、第二个和第三个动画<br><code>stop(true ture)</code>：停止动画，直接跳到第一个动画的最终状态 </p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><p>jQuery中有个很重要的核心方法each，大部分jQuery方法在内部都会调用each，其主要的原因的就是jQuery的实例是一个元素合集<br>jQuery的大部分方法都是针元素合集的操作，所以jQuery会提供<code>$(selector).each()</code>来遍历jQuery对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="string">"Aaron"</span>, <span class="string">"慕课网"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//index是索引,也就是数组的索引</span></span><br><span class="line">   <span class="comment">//value就是数组中的值了</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//停止迭代</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>each就是for循环方法的一个包装，内部就是通过for遍历数组与对象，通过回调函数返回内部迭代的一些参数</p>
<p><code>jQuery.inArray()</code>函数用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。<br><code>$.inArray(5,[1,2,3,4,5,6,7])</code>  返回对应的索引：4，在ECMAScript5已经有数据的indexOf方法支持了</p>
<p>JQ同样也支持trim方法去除字符串两段的空格</p>
<p>如果想要获得指定的DOM对象，比如：第二个a元素的查找： <code>$(a).get(1)</code>，索引从0开始嘛~但是它是支持从后往前找的，比如找最后一个<code>get(-1)</code>，<strong>index</strong>方法就是相反了，根据DOM元素来获取索引</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中使用正则]]></title>
      <url>http://bfchengnuo.com/2017/03/06/Java%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99/</url>
      <content type="html"><![CDATA[<p>这应该是比较常用的吧….可惜我忘了，还有字符串相关的方法使用频率也很高<br>Java 提供了 java.util.regex 包来与正则表达式进行模式匹配。注意使用的就是两个类，<strong>Pattern </strong>和<strong>Matcher </strong>其他语言也挺类似的，使用方法也比较一致<br><a id="more"></a><br>对了字符串这个对象吧….其实是“固定的”（不可变），每次改变都会重新开辟内存，所以还是尽量少频繁的使用String+=…</p>
<p><code>java.util.regex</code>包主要包含了下面的三个类：</p>
<ul>
<li><strong>Pattern 类</strong>:一个 Pattern 对象是正则表达式<strong>编译表示</strong>。 Pattern 类没有提供公共的构造函数。要创建一个 Pattern 对象，你必须首先调用他的公用静态编译方法来获得 Pattern 对象。<strong>这些方法的第一个参数是正则表达式。</strong></li>
<li><strong>Matcher 类</strong>:一个 Matcher 对象是用来<strong>解释模式和执行与输入字符串相匹配的操作</strong>。和 Pattern 类一样 Matcher 类也是没有构造方法的，你需要<strong>通过调用 Pattern 对象的 matcher 方法来获得 Matcher 对象。</strong></li>
<li><strong>PatternSyntaxException</strong>: 一个 PatternSyntaxException 对象是一个不被检查的异常，来指示正则表达式中的语法错误。</li>
</ul>
<h2 id="捕获组的概念"><a href="#捕获组的概念" class="headerlink" title="捕获组的概念"></a>捕获组的概念</h2><p>捕获组可以通过从左到右计算其开括号来编号，编号是从<code>1</code> 开始的。例如，在<strong>正则表达式</strong> <code>( (A)  (B (C) ) )</code>中，存在四个这样的组:</p>
<blockquote>
<p>  1—–((A)(B(C)))<br>  2—–(A)<br>  3—–( B (C) )<br>  4—–(C)</p>
</blockquote>
<p>其实还有一个0组，<strong>始终代表整个表达式。</strong><br>至于为什么要说这个捕获组呢，因为很快就会用到了</p>
<h2 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h2><p>既然有捕获组那就有非捕获组</p>
<blockquote>
<p>  建议看完其他内容后最后再看这个</p>
</blockquote>
<p>非捕获组(non-capturing)： <strong>(?:X) 、(?=X)、 (?&lt;=X)、 (?!X)、 (?&lt;!X)</strong><br>这里就只是简单的说下吧<br><strong>(?:X)</strong>:我们知道了分组用group(index)可以获得指定组的匹配结果，那么(?:X)的作用就是只分组不捕获，就是说匹配的时候还是管用的，但是如果它是在第二组，使用group(2)的时候并不会获得它，会跳过，获得的是第三组的结果<br><strong>(?=X)</strong>：举个例子<code>[0-9a-z]{2}(?=aa)</code>意思就是是两位字符（数字，或字母），且<strong>后面</strong>紧跟着两个a。但是使用while循环匹配<code>group()</code>获取的时候虽然匹配aa但是不会显示在匹配结果中。这里需要注意的是当第二次搜索的时候是从第一次匹配的aa<br><strong>(?&lt;=)</strong>：和上面差不多，不一样的是它是匹配<strong>前面</strong>的，也就是要放在前面<br><strong>(?!)和(?&lt;!)</strong>：不多说了举两个栗子吧：<br><code>[0-9a-z]{2}(?!aa)</code> 意思是：匹配两个字符，且<strong>后面</strong>紧跟着的不是aa<br><code>(?&lt;=aa)[0-9a-z]{2}</code> 意思是：匹配两个字符，且<strong>前面</strong>紧跟着的不是aa</p>
<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>前面说过这个类可以认为是负责编译正则的，如果书写的正则表达式有错误那么它就会报错<br>然后就说下常用的几个方法</p>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">String[] str=p.split(<span class="string">"我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com"</span>); </span><br><span class="line"><span class="comment">// 结果:str[0]="我的QQ是:" str[1]="我的电话是:" str[2]="我的邮箱是:aaa@aaa.com"</span></span><br></pre></td></tr></table></figure>
<p>说白了就是用p去分割字符串</p>
<h3 id="快速匹配"><a href="#快速匹配" class="headerlink" title="快速匹配"></a>快速匹配</h3><p>有一个静态方法是：<code>Pattern.matcher(String regex,CharSequence input)</code> 可以快速让我们知道某个字符串是否符合某个规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223"</span>);<span class="comment">//返回true</span></span><br><span class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223aa"</span>);<span class="comment">//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到</span></span><br></pre></td></tr></table></figure>
<h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><p>好了，重头戏来了，前面说过获取Mather必须由Pattern来，也就是<code>Pattern.matcher</code>方法<br>Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持.<br>下面是官方API里的例子，典型调用顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>); <span class="comment">//编译</span></span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaaab"</span>); <span class="comment">//获取结果</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches(); <span class="comment">//使用结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面三句可以写成一句</span></span><br><span class="line"><span class="comment">//但是对于重复的匹配而言它效率不高，因为它不允许重用已编译的模式。</span></span><br><span class="line"><span class="keyword">boolean</span> b = Pattern.matches(<span class="string">"a*b"</span>, <span class="string">"aaaaab"</span>);</span><br></pre></td></tr></table></figure>
<p>如果写成一句，那就是编译加匹配，编译还是蛮耗时的，所以上面一行代码的适合不频繁使用的情况</p>
<h3 id="匹配操作的三个方法"><a href="#匹配操作的三个方法" class="headerlink" title="匹配操作的三个方法"></a>匹配操作的三个方法</h3><p>首先说明三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false </p>
<ul>
<li><p>Matcher.matches()<br>对整个字符串进行匹配,只有整个字符串都匹配了才返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </span><br><span class="line">m.matches();<span class="comment">//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. </span></span><br><span class="line">Matcher m2=p.matcher(<span class="string">"2223"</span>); </span><br><span class="line">m2.matches();<span class="comment">//返回true,因为\d+匹配到了整个字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Matcher.lookingAt()<br>  lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </span><br><span class="line">m.lookingAt();<span class="comment">//返回true,因为\d+匹配到了前面的22 </span></span><br><span class="line">Matcher m2=p.matcher(<span class="string">"aa2223"</span>); </span><br><span class="line">m2.lookingAt();<span class="comment">//返回false,因为\d+不能匹配前面的aa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Matcher.find()<br>  find()对字符串进行匹配,匹配到的字符串可以在任何位置，不再多说<br>  此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则<strong>从以前匹配操作没有匹配的第一个字符开始</strong>。</p>
</li>
</ul>
<h3 id="获得信息"><a href="#获得信息" class="headerlink" title="获得信息"></a>获得信息</h3><p>这里同样也有常用的三个方法</p>
<ul>
<li>start() 返回匹配到的子字符串在字符串中的索引位置. </li>
<li>end() 返回匹配到的子字符串的最后一个字符在字符串中的索引位置. </li>
<li>group() 返回匹配到的子字符串<br>准确的说是：返回由以前匹配操作所匹配的输入子序列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">Matcher m=p.matcher(<span class="string">"aaa2223bb"</span>); </span><br><span class="line">m.find();<span class="comment">//匹配2223</span></span><br><span class="line"></span><br><span class="line">m.start();<span class="comment">//返回3 </span></span><br><span class="line">m.end();<span class="comment">//返回7,返回的是2223后的索引号 </span></span><br><span class="line">m.group();<span class="comment">//返回2223</span></span><br></pre></td></tr></table></figure>
<p>如果没有匹配到的话返回的就是0、字符串长度、原字符串</p>
<h3 id="分组的使用"><a href="#分组的使用" class="headerlink" title="分组的使用"></a>分组的使用</h3><p>利用上面find的特性可以使用while循环全匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">Matcher m=p.matcher(<span class="string">"我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com"</span>); </span><br><span class="line"><span class="keyword">while</span>(m.find()) &#123; </span><br><span class="line">     System.out.println(m.group()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//456456</span></span><br><span class="line"><span class="comment">//0532214</span></span><br><span class="line"><span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>使用分组的话，类似这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pattern r = Pattern.compile(<span class="string">"(\\d+)(test.*)"</span>);</span><br><span class="line">Matcher m = r.matcher(<span class="string">"abc23333test123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.find()) &#123;</span><br><span class="line">    <span class="comment">// 第一个是原字符串哦</span></span><br><span class="line">    System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">2</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"NO MATCH"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//Found value: 23333test123</span></span><br><span class="line"><span class="comment">//Found value: 23333</span></span><br><span class="line"><span class="comment">//Found value: test123</span></span><br></pre></td></tr></table></figure>
<h2 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h2><p>这里还是再说下吧，贪婪就是尽可能多的匹配，默认就是这种模式，这种也很好理解，不多说<br>重要的是非贪婪匹配，一般带有量词以及<code>?</code>的都是非贪婪吧….就是尽可能少的匹配<br>下面是常见的几种非贪婪匹配模式：</p>
<blockquote>
<p>  <code>*?</code>重复任意次，但尽可能少重复<br>  <code>+?</code> 重复1次或更多次，但尽可能少重复<br>  <code>??</code> 重复0次或1次，但尽可能少重复<br>  <code>{n,m}?</code> 重复n到m次，但尽可能少重复<br>  <code>{n,}?</code> 重复n次以上，但尽可能少重复</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/ggjucheng/p/3423731.html" target="_blank" rel="noopener">http://www.cnblogs.com/ggjucheng/p/3423731.html</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware的三种网络模式]]></title>
      <url>http://bfchengnuo.com/2017/03/06/VMware%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>一般都是默认不动，能上网就行了嘛，不过特殊情况要手动配置网络的时候就完全不知道怎么搞了<br>VM给了三种网络模式，名字都挺高大上的，也看不懂，从网上找了些资料，了解这几种模式的区别<br><a id="more"></a><br>VM给的三种模式分别为：</p>
<ul>
<li>bridged (桥接模式) //对应网卡vment0</li>
<li>NAT (网络地址转换模式) //对应网卡vment8</li>
<li>host-only (主机模式) //对应网卡vment1</li>
</ul>
<p>就网络环境来说，我们常见的家庭网络拓扑结构有下面两种：</p>
<ul>
<li>主机通过拨号直接连接Internet</li>
<li>主机处于局域网环境中，通过路由器拨号连接Internet</li>
</ul>
<p>如果你是属于第一种网络环境，由于是ISP分配你的公网IP（假设只有一个地址），则<strong>不能使用桥接模式</strong>，因为桥接模式需要你拥有属于你机器相同网段内的另一个IP地址。这种情况下可以使用<code>NAT</code>和<code>Host-only</code>。而如果是属于第二种网络环境，则三种模式可以任意选用。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式是三种模式中最简单的一种，VMware安装的时候默认就使用这种配置方式。在这种模式下，<strong>虚拟机相当于<em>局域网中的</em>一台独立机器，和主机处于同一个网段，公用同一个网关。</strong>桥接模式使用的是虚拟机的<strong>VMnet0</strong>网卡，一般情况下，在虚拟机中将网络设置成自动获取IP就能直接联网。<br><img src="/image/dev/bridge.png" alt=""></p>
<p>在桥接模式下，<strong>虚拟机和主机可以互相ping通，虚拟机可以访问Internet</strong>，虚拟机上的服务也可以通过虚拟机IP地址在本机直接访问，如果ping不通，那就要检测下本机连接属性里面是否勾选了<code>VMware Bridge Protocol</code>和防火墙设置</p>
<h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><p>上面也说了，如果你不在局域网内，只有一个IP，那么NAT模式正适合你。当然如果你在局域网内，NAT模式也未尝不可，不过使用NAT模式后，主机就变成了双网卡：本身的网卡连接Internet或连接拨号的路由器，另一个<strong>虚拟网卡VMnet8连接由虚拟机组成的一个虚拟网络</strong>。<em>从外部网络来看，无法直接访问这个虚拟网络</em>。虚拟网络则通过本机上的NAT虚拟服务器进行转发访问Internet。<br><strong>主机和虚拟机直接是可以进行互相访问的</strong>，如果局域网的其他机器想访问虚拟机的资源，可以配置下VM的NAT端口转发<br><img src="/image/dev/nat.png" alt=""></p>
<p>NAT模式是让虚拟机实现访问Internet最快的方式，几乎不用任何配置，只要主机能上网，那么虚拟机也就肯定能上网。如果又问题，那就检查下VM的服务是否已开启</p>
<h2 id="Host-only模式"><a href="#Host-only模式" class="headerlink" title="Host-only模式"></a>Host-only模式</h2><p>Host-only模式和NAT一样，也相当于主机双网卡，网络拓扑和NAT也是一样，只是<strong>主机不提供NAT功能了，所以虚拟网络只能和主机访问，不能访问Internet。</strong>如果需要一个<em>完全隔离</em>的网络环境，则Host-only最合适不过。Host-only相当于使用双绞线直接连接虚拟机和主机，这是最原始的网络结构，当然也是最灵活的。<br>这种情况下虚拟机就不能访问Internet了吗？局域网下的其他机器就不能访问虚拟机上的服务了吗？当然不是。如果我们自己在主机上搭建起我们自己的NAT服务和DHCP服务，那么Host-only其实和NAT是一样的。从下面的示意图也可以看出，Host-only和NAT的唯一区别就在于，主机上少了NAT这个部分。<br><img src="/image/dev/host-only.png" alt=""></p>
<p>类似于NAT，具体的配置这里略过。下面通过Windows上的ICS服务（Internet Connection Sharing，就是Internet连接共享）来实现Host-only模式的虚拟机访问Internet。ICS是Windows上的一种共享网络访问的服务，类似于mini版NAT，提供了NAT地址转换和DHCP的功能，但不支持端口转发（Port Forwarding）。<br>首先在网络连接里找到当前<strong>正在使用的连接</strong>，选择属性 -&gt; 共享，选中“允许其他网络用户通过此计算机的Internet连接来连接”，然后在网络连接下拉框中选择Host-only对应的虚拟网卡（这里是VMnet1），如下图<br><img src="/image/dev/ics.png" alt=""></p>
<p>在确定的时候，可能会弹出对话框提示错误：<em>“Internet连接共享访问被启用时，出现了一个错误（null）”</em>，这时去服务中找到<strong>Windows Firewall</strong>，启动即可。 ICS配置好之后，Host-only就和NAT一样了，在虚拟机中设置自动获取IP或手工设置IP，保证和VMnet1处于同一个网段内，如果一切顺利，就可以在虚拟机中访问Internet了。</p>
<h2 id="关于桥接的vment0"><a href="#关于桥接的vment0" class="headerlink" title="关于桥接的vment0"></a>关于桥接的vment0</h2><p>VM0网卡是桥接到本地网卡的，所以在网络适配器里面是看不到的，在VM的网络配置中可以看到，但若本地有多个网卡，问题就出现了。<br>现在笔记本一般有三块网卡，一块无线、一块有线、一块蓝牙，你看的没错，蓝牙也算一块网卡，另外，还可能有微软虚拟的路由器。VMnet0默认是自动桥接到物理网卡（4个都被桥接），所以用以太网通讯时，就找不见真正的有线网卡，若要正常使用，还需要手动指定VMnet0桥接到电脑的有线网卡上。<br>在VM虚拟机的<strong>编辑(E)</strong>下拉菜单中点击<strong>“虚拟网络编辑器”</strong>然后选择下面的<strong>更改设置</strong>可以知道桥接到那块网卡</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.aneasystone.com/archives/2015/04/three-network-modes-of-vmware-in-action.html#comment-613" target="_blank" rel="noopener">http://www.aneasystone.com/archives/2015/04/three-network-modes-of-vmware-in-action.html#comment-613</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android中SQLite的使用]]></title>
      <url>http://bfchengnuo.com/2017/03/05/Android%E4%B8%ADSQLite%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎，这是在普及方面的增长，与它的尺寸大小无关。SQLite 源代码不受版权限制。<br><a id="more"></a></p>
<h2 id="SQLite是什么"><a href="#SQLite是什么" class="headerlink" title="SQLite是什么"></a>SQLite是什么</h2><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、<strong>事务性</strong>的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。<br>就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。<br>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB（但它竟然可以支持高达2TB大小的数据库）<br>与许多其它数据库管理系统不同，SQLite不是一个客户端/服务器结构的数据库引擎，而是被集成在用户程序中。</p>
<p>SQLite采用动态数据类型，当某个值插入到数据库时，SQLite将会检查它的类型，如果该类型与关联的列不匹配，SQLite则会尝试将该值转换成该列的类型，如果不能转换，<strong>则该值将作为本身的类型存储</strong>，SQLite称这为“弱类型”。但有一个特例，如果是<strong>INTEGER PRIMARY KEY</strong>，则其他类型不会被转换，会报一个“datatype missmatch”的错误。<br>所以，还是尽量按规定的类型来存</p>
<p>在Android中主要涉及的就是<strong>SQLiteDatabase</strong>和<strong>SQLiteOpenHelper</strong>这两个类</p>
<h2 id="SQLiteDatabase"><a href="#SQLiteDatabase" class="headerlink" title="SQLiteDatabase"></a>SQLiteDatabase</h2><p>这个类提供了一些管理SQLite数据库的方法，比如创建、删除、执行SQL命令，和执行其他常见的数据库管理任务的方法。所以说这个类是比较核心的<br>常用的方法有：</p>
<blockquote>
<p>  db.execSQL(String sql) //<strong>执行任何的SQL语句</strong></p>
<p>  db.insert(String table,String nullColumnHack,ContentValues values) //插入记录</p>
<p>  db.delete(String table,String whereClause,String[] whereArgs)//删除记录</p>
<p>  db.update(String table,ContentValues values,String whereClause,String[] whereArgs)//更新记录</p>
<p>  db.query(String table,String[] columns,String selection,String[] selectionArgs,String groupBy,String having,String orderBy)//查询记录</p>
<p>  db.rawQuery(String sql,String[] selectionArgs)//通过sql语句查询记录</p>
</blockquote>
<p>然后看一段在Activity具体使用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="comment">//通过openOrCreateDatabase来打开或创建一个数据库,返回SQLiteDatabase对象</span></span><br><span class="line">    <span class="comment">//  第二个参数是权限，关于更详细见 Android安全开发</span></span><br><span class="line">    SQLiteDatabase db = openOrCreateDatabase(<span class="string">"user.db"</span>,MODE_PRIVATE,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//创建一个表</span></span><br><span class="line">    db.execSQL(<span class="string">"create table if not exists userTb ("</span> +</span><br><span class="line">               <span class="string">"_id integer primary key,"</span> +</span><br><span class="line">               <span class="string">"name text not null,age integer not null,"</span> +</span><br><span class="line">               <span class="string">"sex text not null)"</span>);</span><br><span class="line">    <span class="comment">//向表中插入记录</span></span><br><span class="line">    db.execSQL(<span class="string">"insert into userTb (name,age,sex) values ('张三',18,'女')"</span>);</span><br><span class="line">    <span class="comment">//Cursor为查询结果对象，类似于JDBC中的ResultSet，rawQuery是使用sql语句自己封装</span></span><br><span class="line">    Cursor queryResult = db.rawQuery(<span class="string">"select * from userTb"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 可以使用占位符：db.rawQuery("select * from ?", new String[]&#123;"userTb"&#125;);</span></span><br><span class="line">    <span class="keyword">if</span> (queryResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (queryResult.moveToNext()) &#123;</span><br><span class="line">        Log.i(<span class="string">"info"</span>, <span class="string">"id: "</span> + queryResult.getInt(queryResult.getColumnIndex(<span class="string">"_id"</span>))</span><br><span class="line">              + <span class="string">" 姓名: "</span> + queryResult.getString(queryResult.getColumnIndex(<span class="string">"name"</span>))</span><br><span class="line">              + <span class="string">" 年龄: "</span> + queryResult.getInt(queryResult.getColumnIndex(<span class="string">"age"</span>))</span><br><span class="line">              + <span class="string">" 性别: "</span> + queryResult.getString(queryResult.getColumnIndex(<span class="string">"sex"</span>)));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭游标对象</span></span><br><span class="line">      queryResult.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据库</span></span><br><span class="line">    db.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p>db 查询方法得到的 cursor 是指向第一条记录<strong>之前</strong>的<br>因此查询得到 cursor 后第一次调用 moveToFirst（实际要向后移一个位置）或 moveToNext（从指向第一条记录之前向后移动一个位置变为刚好指向第一条记录位置）都可以将 cursor 移动到第一条记录上。</p>
</div>
<h2 id="SQLiteOpenHelper"><a href="#SQLiteOpenHelper" class="headerlink" title="SQLiteOpenHelper"></a>SQLiteOpenHelper</h2><p>这个类为SQLiteDatabase的帮助类，主要用于管理数据库的创建与版本更新。SQLiteHelper是一个抽象类，一般通过创建一个继承自它的子类并重写<code>onCreat()</code>和<code>onUpgrade()</code>这两个<strong>回调</strong>方法进行使用。</p>
<blockquote>
<p>  onCreat(SQLiteDatabase db)<br>  首次创建数据库时调用，一般用于建表等操作。当检测到数据库已经存在后就不再执行了，只能用升级的方法更新</p>
<p>  onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion)<br>  当升级数据库版本时调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLiteHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  这里以2个参数的构造函数为例，所有构造函数都要调用super的4个参数的构造</span></span><br><span class="line"><span class="comment">     *  context:上下文对象</span></span><br><span class="line"><span class="comment">     *  name:数据库名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SQLiteHelper</span><span class="params">(Context context, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, name, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//首次创建数据库的时候调用，一般进行建表或某些初始化的操作</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建表</span></span><br><span class="line">    db.execSQL(<span class="string">"create table if not exists userTb ("</span> +</span><br><span class="line">               <span class="string">"_id integer primary key,"</span> +</span><br><span class="line">               <span class="string">"name text not null,age integer not null,"</span> +</span><br><span class="line">               <span class="string">"sex text not null)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当数据库版本升级时自动调用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候还会用到一个回调函数：onOpen，就是数据库打开的时候会回调<br>创建好了辅助类就可以在Activity中进行使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main2);</span><br><span class="line">    <span class="comment">//创建一个SQLiteHelper对象</span></span><br><span class="line">    SQLiteHelper helper = <span class="keyword">new</span> SQLiteHelper(MainActivity2.<span class="keyword">this</span>,<span class="string">"stu.db"</span>);</span><br><span class="line">    <span class="comment">//使用getWritableDatabase()或getReadableDatabase()方法获得SQLiteDatabase对象</span></span><br><span class="line">    <span class="comment">//它们默认都是打开的可读写的数据库，如果没有就新建再打开</span></span><br><span class="line">    <span class="comment">//区别就是：当磁盘已满的时候，getReadableDatabase会打开只读的数据库</span></span><br><span class="line">    SQLiteDatabase db = helper.getWritableDatabase();</span><br><span class="line">    <span class="comment">//插入记录</span></span><br><span class="line">    db.execSQL(<span class="string">"insert into userTb (name,age,sex) values ('张三',18,'女')"</span>);</span><br><span class="line">    db.execSQL(<span class="string">"insert into userTb (name,age,sex) values ('李四',19,'男')"</span>);</span><br><span class="line">    <span class="comment">//获取游标对象</span></span><br><span class="line">    Cursor queryResult = db.rawQuery(<span class="string">"select * from userTb"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//打印所有记录</span></span><br><span class="line">      <span class="keyword">while</span> (queryResult.moveToNext()) &#123;</span><br><span class="line">        Log.i(<span class="string">"info"</span>, <span class="string">"id: "</span> + queryResult.getInt(queryResult.getColumnIndex(<span class="string">"_id"</span>))</span><br><span class="line">              + <span class="string">" 姓名: "</span> + queryResult.getString(queryResult.getColumnIndex(<span class="string">"name"</span>))</span><br><span class="line">              + <span class="string">" 年龄: "</span> + queryResult.getInt(queryResult.getColumnIndex(<span class="string">"age"</span>))</span><br><span class="line">              + <span class="string">" 性别: "</span> + queryResult.getString(queryResult.getColumnIndex(<span class="string">"sex"</span>)));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭游标对象</span></span><br><span class="line">      queryResult.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据库</span></span><br><span class="line">    db.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多内容待补充…</p>
<h2 id="关于事务"><a href="#关于事务" class="headerlink" title="关于事务"></a>关于事务</h2><p>写数据库的时候也许会用到事务，SQLite是支持事务操作的，很简单的几句代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务开始</span></span><br><span class="line">db.beginTransaction();</span><br><span class="line"><span class="comment">//....一顿写之类的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置事务处理成功，不设置会自动回滚不提交。</span></span><br><span class="line">db.setTransactionSuccessful();</span><br><span class="line"><span class="comment">//在setTransactionSuccessful和endTransaction之间不进行任何数据库操作</span></span><br><span class="line">db.endTransaction(); <span class="comment">//处理完成</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/caobotao/p/5118463.html" target="_blank" rel="noopener">http://www.cnblogs.com/caobotao/p/5118463.html</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLite </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery-事件]]></title>
      <url>http://bfchengnuo.com/2017/03/04/jQuery-%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>越到后面才越看出jQuery的强大，这些封装确实方便了不少，纯js实现的话真是太可怕啦…<br>虽然有人说jQuery已经跟不上潮流了，但是依然很多很多在用<br>前端更新真是……py2与py3<br><a id="more"></a><br>2333333<br>理论知识够了，动手能力还很弱鸡</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>用交互操作中，最简单直接的操作就是<strong><em>点击操作</em></strong>。jQuery提供了两个方法一个是click方法用于监听用户单击操作，另一个方法是dbclick方法用于监听用户双击操作。这两个方法的用法是类似的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"test"</span>&gt;点击触发&lt;div&gt;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向 div元素</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test"</span>).click(<span class="number">11111</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向 div元素</span></span><br><span class="line">    <span class="comment">//e.date  =&gt; 11111 传递数据,可选参数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在dblclick之前接受两个 click 事件 ，而一些浏览器只接受一个 click 事件</p>
<p>判断鼠标点击其实就是判断鼠标按下、抬起的这个过程，都有相应的方法<strong>mousedown</strong>和<strong>mouseup</strong>，他们的用法和click基本一致，其中注意的是：用event 对象的which区别按键，敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3<br>PS:键盘也一样有keydown和keyup，还可以用KeyPress来获取输入，不过不能获取特殊按键，会有1个字符的延迟</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.target1'</span>).keypress(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	$(<span class="string">"em"</span>).text(e.target.value)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有一个使用率比较高的就是<strong><em>鼠标移动事件</em></strong>，也就是<strong>mousemove</strong>方法，用法和上面也是一致的，这个不要做太复杂的运算，因为像素点只要变化就会触发</p>
<p>在学JS的时候，有两个方法叫移入移出事件，就是<strong>onmouseover()</strong>与<strong>onmouseout()</strong>事件~jQuery当中同样提供了这样的事件来监听用户的移入移出操作，<code>mouseover()</code>与<code>mouseout()</code>事件，两者用法类似，使用方法还是同上</p>
<p>用交互操作中，经常需要知道用户操作鼠标是否有移到元素内部或是元素外部，因此jQuery提供了一个<strong>mouseenter</strong>和<strong>mouseleave</strong>的快捷方法可以监听用户移动到内部的操作，感觉和mouseover没啥区别啊，但是不可能同一个事件蛋疼的写出两种调用，<strong>区别它们的关键点就是：冒泡的方式处理问题</strong>，就是说：mouseenter事件只会在绑定它的元素上被调用，而<strong>不会在后代节点上被触发</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aaron2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标离开此区域触发mouseleave事件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果p、div元素它们都设置了mouseover事件，p触发后会传递给div，也就是它们的mouseover事件都被触发了，而如果是mouseenter就不会<br>所以为了避免冒泡问题，一般会用mouseenter处理，并且一般我们使用都是成对出现的，所以jQuery还给了一个简便的方法：<code>$(selector).hover(handlerIn, handlerOut)</code></p>
<p>还有一个事件就是<strong><em>聚焦事件</em></strong>，使用<strong>focusin</strong>方法，失去焦点就是<strong>focusout</strong>了，用法和上面一致</p>
<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><p>鼠标事件说过focusin事件与focusout事件，同样用于<strong><em>处理表单焦点</em></strong>的事件还有blur与focus事件，它们的本质区别就是：<strong>是否支持冒泡</strong>，blur与focus是不会冒泡的<br>既然是表单那就应该有输入（改变），也就有相应的事件，就是change了，用法都懂，一般就是传个函数就可以了<br>选择事件<strong>select</strong>，这个可以传数据进去，和上面鼠标事件是一样的，只是浏览器的默认行为也会调用它</p>
<p>表单提交是个很重要的事件，常常在这进行校验，错误则返回false就是不提交，减轻服务器压力，使用的是<strong>submit</strong>方法，使用上也差不多，需要注意的只有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#target"</span>).submit(<span class="number">11111</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//绑定提交表单触发</span></span><br><span class="line">    <span class="comment">//data =&gt; 1111 //传递的data数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>具体能触发submit事件的行为：</p>
<ul>
<li><code>&lt;input type=&quot;submit&quot;&gt;</code></li>
<li><code>&lt;input type=&quot;image&quot;&gt;</code></li>
<li><code>&lt;button type=&quot;submit&quot;&gt;</code></li>
<li>当某些表单元素获取焦点时，敲击Enter（回车键）</li>
</ul>
<blockquote>
<p>  form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为<br>  传统的方式是调用事件对象  e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可</p>
</blockquote>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>jQuery <code>on()</code>方法是官方推荐的绑定事件的一个方法。翻开源码其实可以看到，所有的快捷事件在底层的处理都是通过一个”on”方法来实现的。<br><strong>基本用法：<code>.on( events ,[ selector ] ,[ data ] )</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#elem"</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">//on方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个事件绑定同一个函数</span></span><br><span class="line">$(<span class="string">"#elem"</span>).on(<span class="string">"mouseover mouseout"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个事件绑定不同函数</span></span><br><span class="line">$(<span class="string">"#elem"</span>).on(&#123;</span><br><span class="line">    mouseover:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,  </span><br><span class="line">    mouseout:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据传递到处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  alert( <span class="string">"Hello "</span> + event.data.name ); <span class="comment">//Hello 慕课网</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用三个参数</span></span><br><span class="line">$( <span class="string">"button"</span> ).on( <span class="string">"click"</span>, &#123;</span><br><span class="line">  name: <span class="string">"慕课网"</span></span><br><span class="line">&#125;, greet );</span><br></pre></td></tr></table></figure>
<p><strong>on的高级用法-委托机制：<code>.on( events ,[ selector ] ,[ data ], handler(eventObject) )</code></strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"aaron"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span>&gt;</span>目标节点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $(<span class="string">"div"</span>).on(<span class="string">"click"</span>,<span class="string">"p"</span>,fn)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件绑定在最上层div元素上，当用户<strong>触发在a元素上</strong>，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，<strong>将会触发事件回调函数</strong></p>
<p>既然有绑定也就有卸载，绑定用on卸载就是off</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定2个事件</span></span><br><span class="line">$(<span class="string">"elem"</span>).on(<span class="string">"mousedown mouseup"</span>,fn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个事件</span></span><br><span class="line">$(<span class="string">"elem"</span>).off(<span class="string">"mousedown"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有事件</span></span><br><span class="line">$(<span class="string">"elem"</span>).off(<span class="string">"mousedown mouseup"</span>)</span><br><span class="line">$(<span class="string">"elem"</span>).off()  <span class="comment">//或者</span></span><br></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件中会涉及到很多方法，有的方法参数中出现了Event这个词，它就是事件对象了</p>
<blockquote>
<p>  事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁</p>
</blockquote>
<p><code>event.target</code>代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素，通常用于比较 <strong>event.target</strong> 和 <strong>this</strong> 来确定事件是不是由于冒泡而触发的。<br><code>event.type</code>：获取事件的类型<br><code>event.pageX</code> 和<code>event.pageY</code>：获取鼠标当前相对于页面的坐标，通过这2个属性，可以确定元素在当前页面的坐标值，坐标系从左上角开始的，不受滚动条的影响<br><code>event.preventDefault()</code>方法：阻止默认行为，可以用 <code>event.isDefaultPrevented()</code> 来确定这个方法是否(在那个事件对象上)被调用过了<br><code>event.stopPropagation()</code> 方法：阻止事件冒泡<br><code>event.which</code>：获取在鼠标单击时，单击的是鼠标的哪个键<br><code>event.currentTarget</code> : 在事件冒泡过程中的<strong>当前DOM元素</strong>，相当于this</p>
<blockquote>
<p>  js中事件是会冒泡的，所以this是可以变化的，<strong>但event.target不会变化</strong>，它永远是直接接受事件的目标DOM元素；<br>  .this 和 event.target都是dom对象<br>  如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用；</p>
</blockquote>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>原生事件比如click都是浏览器提供，并且需要和用户交互的，如果使用jQuery可以进行人为的干预，比如调用<code>$(&#39;#elem&#39;).trigger(&#39;click&#39;);</code> 就可以触发绑定在该元素的click事件<br>此外还可以进行自定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#elem'</span>).trigger(<span class="string">'Aaron'</span>,[<span class="string">'参数1'</span>,<span class="string">'参数2'</span>])</span><br><span class="line">$(<span class="string">'#elem'</span>).on(<span class="string">'Aaron'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event,arg1,arg2</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"自触自定义事件"</span>)</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>自定义事件对象，是jQuery模拟原生实现的，并且可以传递参数<br>trigger事件还有一个特性：会在DOM树上冒泡，所以如果要阻止冒泡就需要在事件处理程序中返回false或调用事件对象中的<code>.stopPropagation()</code> 方法可以使事件停止冒泡<br>如果是自定义的事件对象，那么就有一个不可避免的问题：<strong>event无法完美的实现</strong>，毕竟不是原生的<br>自定义事件也是通过改造现有的实现的，所以使用时由于冒泡机制，可能会触发其他事件，若要触发通过 jQuery 绑定的事件处理函数，而<strong>不触发原生的事件</strong>，使用<code>.triggerHandler()</code> 来代替<br>triggerHandler与trigger的用法是一样的，重点看不同之处：</p>
<ul>
<li>triggerHandler不会触发浏览器的默认行为，.triggerHandler( “submit” )将不会调用表单上的.submit()</li>
<li>.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素</li>
<li>使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理</li>
<li>与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler() 返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中使用screen命令]]></title>
      <url>http://bfchengnuo.com/2017/03/03/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8screen%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>Linux下经常使用putty或者secureCRT等通过ssh远程登录服务器，但如果在执行程序的过程中关闭远程终端窗口，则原先运行的程序会被立即杀死。这对于一些花费时间较长的程序非常不利，这时就要用screen了<br>相当于是后台执行吧<br><a id="more"></a><br>这个命令其实挺实用的，对于用shell连接服务器来说<br>原文：<a href="http://noalgo.info/1000.html" target="_blank" rel="noopener">http://noalgo.info/1000.html</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>screen是一款由GNU计划开发的<strong>用于命令行终端切换</strong>的自由软件，实现全屏窗口管理的功能，能够混合多个工作到一个终端上。一般linux系统中自带有screen命令，如果没有那就要手动安装下</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>通过putty等远程服务器后，直接在命令行下运行以下命令新建一个screen会话：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>
<p>也可以指定会话的名称，以下即创建以noalgo为名称的会话：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S loli</span><br></pre></td></tr></table></figure>
<p>也可以在新建会话时指定要运行的程序，以下运行了vi编辑器，注意此时退出vi编辑器即表示退出了screen会话。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S loli vi helloworld.c</span><br></pre></td></tr></table></figure>
<p>新建会话后即进入了screen的世界，在这里做的事情和在普通的shell中的事情没有什么区别，只是此时的会话是可以进行恢复的，即使发生网络中断，也可以通过再次运行screen命令回到刚才的会话中，而且，再次回来时屏幕上显示的是刚才的画面，而如果程序动态运行时，此时显示最新的结果。<br>如果有事需要离开，而服务器上的程序需要同时在运行，此时可以通过命令d分离会话。<strong>在screen会话中进行的操作都是以ctrl+a开始</strong>，所以分离时需要先按下ctrl+a，然后再按d</p>
<p>此时会回到原先的putty窗口，就可以随意关掉putty去干其他事情了。<br>当要回去的时候可以先通过putty进行登录，然后运行以下命令查看系统中已有的screen会话：<code>sscreen -list(ls)</code><br>得到的结果类似为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Loli@LoliconServer ~]$ screen -list</span><br><span class="line">There is a screen on:</span><br><span class="line">	8530.loli	(Detached)</span><br><span class="line">1 Socket in /var/run/screen/S-Loli.</span><br></pre></td></tr></table></figure>
<p>然后可以通过<code>screen -r 8530</code>回到会话中，也可以输入名字：<code>screen -r loli</code><br>另外，通过<code>screen -x</code>命令可以实现会话共享，此时多个用户登录到同一个会话中，如果他们同时处于同一个窗口下时，彼此的操作会同步给每一个用户，即达到共享桌面的效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个名称为“BENET”的共享屏幕会话</span><br><span class="line">screen –S BENET</span><br><span class="line"><span class="meta">#</span> 连接到共享屏幕，在另一个终端上</span><br><span class="line">screen -x BENET</span><br></pre></td></tr></table></figure>
<h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><p>在普通的shell环境中，如果要同时执行多个程序，可以通过ctrl+z，以及fg和bg等命令交替执行，但screen提供了多窗口的功能同样可以达到这个目的。<br>通过screen命令进入了screen会话默认的一个窗口，通过<code>Ctrl + a + c</code>命令可以新建一个窗口并进入新的窗口，在不同的窗口间切换可以通过下面两个命令进行，分别是进入下一个和前一个窗口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + n</span><br><span class="line">Ctrl + a + p</span><br></pre></td></tr></table></figure>
<p>使用以下命令可以查看当前共有几个窗口，标注*号的为当前所在的窗口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + w</span><br></pre></td></tr></table></figure>
<p>使用以下命令强行关闭一个窗口，如果当前只剩下最后一个窗口，则终止当前的会话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + k</span><br></pre></td></tr></table></figure>
<p>使用<code>exit</code>命令也可以达到同样的效果，当使用多个窗口时，可以通过将屏幕分割成几个区域来提高效率。使用以下命令进行分屏，分别是水平分割和垂直分割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + S</span><br><span class="line">Ctrl + a + |</span><br></pre></td></tr></table></figure>
<p>拥有多个屏幕时，使用以下命令进行切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + Tab</span><br></pre></td></tr></table></figure>
<p>使用以下命令关闭某个分屏，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + X</span><br></pre></td></tr></table></figure>
<p>或者关闭处当前区域的所有其他区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + a + Q</span><br></pre></td></tr></table></figure>
<h2 id="Screen详细参数"><a href="#Screen详细参数" class="headerlink" title="Screen详细参数"></a>Screen详细参数</h2><p>以上是通过简单的例子介绍screen的常见用法，下面对其参数进行详细介绍。screen的命令语法为：</p>
<p><code>screen [-AmRvx -ls -wipe][-d ][-h &lt;line&gt;][-r ][-s ][-S ]</code></p>
<p>其中的参数意义如下：</p>
<ul>
<li>-A：将所有的视窗都调整为目前终端机的大小。</li>
<li>-d：分离指定的screen会话。</li>
<li>-h：指定视窗的缓冲区行数。</li>
<li>-m：即使目前已在会话中的screen会话，仍强制建立新的screen会话。</li>
<li>-r：恢复分离的screen会话。</li>
<li>-R：先试图恢复离线的会话。若找不到离线的会话，即建立新的screen会话。</li>
<li>-s：指定建立新视窗时，所要执行的shell。</li>
<li>-S：指定screen会话的名称。</li>
<li>-v：显示版本信息。</li>
<li>-x：恢复之前离线的screen会话。</li>
<li>-ls：显示目前所有的screen会话。</li>
<li>-list：显示目前所有的screen会话。</li>
<li>-wipe：检查目前所有的screen会话，并删除已经无法使用的screen会话。</li>
</ul>
<p>在每个screen会话中，可以使用的命令如下。注意，screen的命令都是以ctrl+a(C-a)开始的，<strong>以下省略C-a而直接以后面的按键替代</strong>：</p>
<ul>
<li>?：Help，显示按键绑定情况。</li>
<li>c：Create，创建新的窗口。</li>
<li>n：Next，切换到下个窗口。</li>
<li>p：Previous，切换到前一个窗口。</li>
<li>M：查看活动状态。</li>
<li>x：锁住当前的窗口，需用用户密码解锁。</li>
<li>d：Detach，暂时离开当前会话，此后可以恢复。</li>
<li>z：把当前会话放到后台执行，可以使用shell的fg命令回去。</li>
<li>w：Windows，列出已创建的窗口。</li>
<li>t：Time，显示当前时间。</li>
<li>K：Kill，强行关闭当前的窗口。</li>
<li>[0..9]：切换到第 0..9个窗口。</li>
<li>[Space]：由窗口0顺序切换到窗口9。</li>
<li>C-a：在两个最近使用的窗口间切换。</li>
<li>S：水平分屏。</li>
<li>|：垂直分屏。</li>
<li>X：关闭当前分屏。</li>
<li>Q：关闭除当前分屏的所有分屏。</li>
<li>[Tab]：在分屏中切换。</li>
<li>[：Copy,进入拷贝模式，此时可以回滚、搜索、复制，就像用使用vi一样。</li>
<li>]：Paste，粘贴刚刚在拷贝模式选定的内容。</li>
</ul>
<p>其中在拷贝模式下可以使用的命令包括</p>
<ul>
<li>C-b：Backward，PageUp。</li>
<li>C-f：Forward，PageDown。</li>
<li>H：High，将光标移至左上角。</li>
<li>L：Low，将光标移至左下角。</li>
<li>0：移到行首。</li>
<li>$：移到行末。</li>
<li>w：forward one word，前移一个字。</li>
<li>b：backward one word，后移一个字。</li>
<li>Space：第一次按标记起点，第二次按标记终点。</li>
<li>Esc：结束copy mode。</li>
</ul>
<p>这里列的也不是全部的参数，需要更详细的内容，可以直接通过以下命令进行获取：<code>man screen</code></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux解压缩、VIM、Bash快捷键]]></title>
      <url>http://bfchengnuo.com/2017/03/02/Linux%E8%A7%A3%E5%8E%8B%E7%BC%A9%E3%80%81VIM%E3%80%81Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p>好丢人，完了这么久连个解压命令都记不住，只知道个unzip….（捂脸<br>还有一些bash shell的快捷键也是很好用的，VIM成神之路…..<br><a id="more"></a></p>
<h2 id="压缩相关命令"><a href="#压缩相关命令" class="headerlink" title="压缩相关命令"></a>压缩相关命令</h2><p>原文：<a href="http://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html" target="_blank" rel="noopener">http://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html</a></p>
<h3 id="tar-打包"><a href="#tar-打包" class="headerlink" title=".tar 打包"></a>.tar 打包</h3><p>解包：<code>tar -xvf FileName.tar</code><br>打包：<code>tar -cvf FileName.tar DirName</code><br>（注：tar是打包，不是压缩！）</p>
<h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><p>解压1：<code>gunzip FileName.gz</code><br>解压2：<code>gzip -d FileName.gz</code><br>压缩：<code>gzip FileName</code></p>
<h3 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h3><p>解压：<code>tar -zxvf FileName.tar.gz</code><br>压缩：<code>tar -zcvf FileName.tar.gz DirName</code></p>
<h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><p>解压1：<code>bzip2 -d FileName.bz2</code><br>解压2：<code>bunzip2 FileName.bz2</code><br>压缩： <code>bzip2 -z FileName</code></p>
<h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><p>解压：<code>tar -jxvf FileName.tar.bz2</code><br>压缩：<code>tar -jcvf FileName.tar.bz2 DirName</code></p>
<h3 id="bz"><a href="#bz" class="headerlink" title=".bz"></a>.bz</h3><p>解压1：<code>bzip2 -d FileName.bz</code><br>解压2：<code>bunzip2 FileName.bz</code><br>压缩：未知</p>
<h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title=".tar.bz"></a>.tar.bz</h3><p>解压：<code>tar -jxvf FileName.tar.bz</code><br>压缩：未知</p>
<h3 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h3><p>解压：<code>uncompress FileName.Z</code><br>压缩：<code>compress FileName</code></p>
<h3 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h3><p>解压：<code>tar -Zxvf FileName.tar.Z</code><br>压缩：<code>tar -Zcvf FileName.tar.Z DirName</code></p>
<h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><p>解压：<code>unzip FileName.zip</code><br>压缩：<code>zip FileName.zip DirName</code></p>
<h3 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h3><p>解压：<code>rar x FileName.rar</code><br>压缩：<code>rar a FileName.rar DirName</code></p>
<h3 id="rpm和-deb"><a href="#rpm和-deb" class="headerlink" title=".rpm和.deb"></a>.rpm和.deb</h3><p>解包：<code>rpm2cpio FileName.rpm | cpio -div</code><br>解包：<code>ar p FileName.deb data.tar.gz | tar zxf -</code></p>
<h2 id="Bash-Shell常用快捷键"><a href="#Bash-Shell常用快捷键" class="headerlink" title="Bash Shell常用快捷键"></a>Bash Shell常用快捷键</h2><p><a href="https://github.com/hokein/Wiki/wiki/Bash-Shell%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" target="_blank" rel="noopener">原文在Github ，点击我跳转</a></p>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul>
<li><code>ctrl+b</code>: 前移一个字符(backward)</li>
<li><code>ctrl+f</code>: 后移一个字符(forward)</li>
<li><code>alt+b</code>: 前移一个单词</li>
<li><code>alt+f</code>: 后移一个单词</li>
<li><code>ctrl+a</code>: 移到行首（a是首字母）</li>
<li><code>ctrl+e</code>: 移到行尾（end）</li>
<li><code>ctrl+x</code>: 行首到当前光标替换</li>
</ul>
<h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><ul>
<li><code>alt+.</code>: 粘帖最后一次命令最后的参数（通常用于<code>mkdir long-long-dir</code>后, <code>cd</code>配合着<code>alt+.</code>）</li>
<li><code>alt+d</code>: 删除当前光标到临近右边单词开始(delete)</li>
<li><code>ctrl+w</code>: 删除当前光标到临近左边单词结束(word)</li>
<li><code>ctrl+h</code>: 删除光标前一个字符（相当于backspace）</li>
<li><code>ctrl+d</code>: 删除光标后一个字符（相当于delete）</li>
<li><code>ctrl+u</code>: 删除光标左边所有</li>
<li><code>ctrl+k</code>: 删除光标右边所有</li>
<li><code>ctrl+l</code>: 清屏</li>
<li><code>ctrl+shift+c</code>: 复制（相当于鼠标左键拖拽）</li>
<li><code>ctrl+shift+v</code>: 粘贴（相当于鼠标中键）</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><code>ctrl+n</code>: 下一条命令</li>
<li><code>ctrl+p</code>: 上一条命令</li>
<li><code>alt+n</code>: 下一条命令（例如输入<code>ls</code>, 然后按’alt+n’, 就会找到历史记录下的<code>ls</code>命令）</li>
<li><code>alt+p</code>: 上一条命令（跟<code>alt+n</code>相似）</li>
<li><code>shift+PageUp</code>: 向上翻页</li>
<li><code>shift+PageDown</code>: 向下翻页</li>
<li><code>ctrl+r</code>: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项</li>
</ul>
<h2 id="VIM快捷键"><a href="#VIM快捷键" class="headerlink" title="VIM快捷键"></a>VIM快捷键</h2><p>VIM太神，这远远不够展示它的强大，但这是基础，成神之路<br>原文地址：<a href="http://blog.csdn.net/leexide/article/details/17269013" target="_blank" rel="noopener">http://blog.csdn.net/leexide/article/details/17269013</a></p>
<h3 id="进入输入模式"><a href="#进入输入模式" class="headerlink" title="进入输入模式"></a>进入输入模式</h3><ol>
<li><strong>i：在当前光标所在处前插入文本；</strong></li>
<li>I：将光标移动到当前行的行首，并在行首前插入文本；</li>
<li><strong>a：在当前光标所在处之后插入文本；</strong></li>
<li>A：将光标移动到当前行的行末，并在行末之后插入文本；</li>
<li><strong>o：在光标所在行的下面新插入一行，并将光标移动到新行的行首插入文本；</strong></li>
<li>O：在光标所在行的上面新插入一行，并将光标移动到新行的行首插入文本；</li>
</ol>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ol>
<li>h或者左方向键:将光标向左移动一格；</li>
<li>j或者下方向键：将光标向下移动一格；</li>
<li>k或者上方向键：将光标向上移动一格；</li>
<li>l或者右方向键：将光标向右移动一格；</li>
<li><strong>$：移动光标到当前行的行末；</strong><br><strong>数字0：移动光标到当前行的行首；</strong></li>
<li>w:移动光标到下个字的开头；</li>
<li>e：移动光标到下个字的字尾；</li>
<li>b：移动光标回上个字的开头；</li>
<li>nl：在当前行中往右移动n个字符，如：2l、34l；</li>
<li>crtl+b:屏幕往上翻一页；</li>
<li>crtl+f:屏幕往下翻一页；</li>
<li>crtl+u:屏幕往上翻半页；</li>
<li>crtl+d:屏幕往下翻半页；</li>
<li><strong>lG：移动光标到文件的第一行；</strong></li>
<li><strong>G：移动光标到文件的最后一行。</strong></li>
<li><strong>gg：移动光标到第一行</strong></li>
</ol>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><ol>
<li><strong>r：替换光标所在处的字符；</strong></li>
<li>R：替换光标所到之处的字符，直到按ESC键为止；</li>
<li>J：把光标所在行的下一行内容接到当前行的行末；</li>
<li><strong>x：删除光标所在位置的字符；</strong></li>
<li><strong>nx：删除光标所在位置开始的n个字符，如3x删除3个字符；</strong></li>
<li>X：删除光标所在位置的前一个字符；</li>
<li>nX：删除光标所在位置的前n个字符；</li>
<li><strong>dw：删除光标所处位置的单词；</strong></li>
<li>ndw：删除由光标所处位置之前的n个单词；</li>
<li>db：删除光标所处位置之前的一个单词；</li>
<li>ndb：删除光标所处位置之前的n个单词；</li>
<li><strong>dd：删除光标所在的行；</strong></li>
<li><strong>ndd：删除光标所在行开始的n行；</strong></li>
<li>d0：删除由光标所在行的第一个字符到光标所在位置的前一个字符之间的内容；</li>
<li><strong>d$：删除由光标所在位置到光标所在行的最后一个字符之间的内容；</strong></li>
<li><strong>dlG：删除由文件第一行到光标所在行之间的内容；</strong></li>
<li><strong>dG：删除由光标所在行到文件最后一行之间的内容；</strong></li>
<li><strong>u：撤销更改的内容；</strong></li>
<li>ctrl+u：撤销在输入模式下输入的内容。</li>
</ol>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><ol>
<li>yw：复制光标所在位置到单词末尾之间的字符；</li>
<li>nyw：复制光标所在位置之后的n个单词；</li>
<li><strong>yy：复制光标所在行；</strong></li>
<li>nyy：复制由光标所在行开始的n行；</li>
<li><strong>p：将复制的内容粘贴到光标所在位置。</strong></li>
</ol>
<h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><ol>
<li><strong>/str：从光标位置开始往文件末尾查找str，按n查找下一个，按N返回上一个；</strong></li>
<li><strong>?str：从光标位置开始往文件开头查找str，按n查找下一个，按N返回上一个；</strong></li>
<li><strong>:s/p1/p2/g：将光标所处行中所有p1均用p2替代；</strong></li>
<li><strong>:n1,n2s/p1/p2/g：将第n1到n2行中所有p1均用p2替代；</strong></li>
<li><strong>:g/p1/s//p2/g：将文件中所有p1均用p2替换</strong></li>
</ol>
<h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><ol>
<li><strong>w：保存当前文件；</strong></li>
<li><strong>w!：强制保存；</strong></li>
<li><strong>w file：将当前编辑的内容写到文件file中；</strong></li>
<li><strong>q：退出vi；</strong></li>
<li><strong>q！：不保存文件退出vi；</strong></li>
<li>e file：打开并编辑文件file，如果文件不存在则创建一个新文件；</li>
<li>r file：把文件file的内容添加到当前编辑的文件中；</li>
<li>n：移动光标到第n行；</li>
<li><strong>！command：执行Shell命令command</strong></li>
<li><strong>r！command：将命令command的输出结果添加到当前行。</strong></li>
<li>ZZ：保存修改并退出vi</li>
</ol>
<h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><ol>
<li><strong>：set nu指设置行号；</strong></li>
<li><strong>：set nonu指取消行号；</strong></li>
<li><strong>：n指移动光标到第n行；</strong></li>
<li>：n1，n2d指删除指定范围的行；</li>
</ol>
<h3 id="VI的配置文件"><a href="#VI的配置文件" class="headerlink" title="VI的配置文件"></a>VI的配置文件</h3><p>VI配置文件的位置：<code>~/.vimrc</code>（默认为空）<br>在编辑VI时我们常常需要打开行号的功能，如果要打开VI文件就<strong>显示行号</strong>，可以在<code>~/.vimrc</code>中加入<code>set nu</code>这句话就可以了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VIM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Centos5/6安装GCC4.8+]]></title>
      <url>http://bfchengnuo.com/2017/03/02/Centos5-6%E5%AE%89%E8%A3%85GCC4-8/</url>
      <content type="html"><![CDATA[<p>一般来说Centos5/6自带的GCC已经很低了，一般是4.1/4.4左右，但如果安装一些软件需求高版本的gcc就比较麻烦了。<br>除了下源码编译安装外，一直想找一种YUM源来直接安装的方法，源码编译太慢了…..<br><a id="more"></a><br>腾讯云cenos7版本没有32位的只好选个6版本的玩啦…果然Linux中的编译是一件很麻烦的事啊<br>而且还可能出现各种错误</p>
<h2 id="最简单的方案"><a href="#最简单的方案" class="headerlink" title="最简单的方案"></a>最简单的方案</h2><p>看到的时候说是centos5的方案，但是测试了下对6版本同样适用，几条命令执行一下即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载源</span><br><span class="line">wget https://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo</span><br><span class="line"></span><br><span class="line">yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++</span><br><span class="line">ln -s /opt/rh/devtoolset-2/root/usr/bin/* /usr/local/bin/</span><br><span class="line">hash -r</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure>
<p>可以顺便装下libxml2，编译PHP会用到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install libxml2</span><br><span class="line">yum install libxml2-devel</span><br></pre></td></tr></table></figure>
<h2 id="yum安装全方案"><a href="#yum安装全方案" class="headerlink" title="yum安装全方案"></a>yum安装全方案</h2><p><strong>GCC 4.8</strong><br>和上面的其实基本一样啦~~</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo</span><br><span class="line"></span><br><span class="line">yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++ -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 临时编译前使用</span><br><span class="line"></span><br><span class="line">export CC=/opt/rh/devtoolset-2/root/usr/bin/gcc</span><br><span class="line">export CPP=/opt/rh/devtoolset-2/root/usr/bin/cpp</span><br><span class="line">export CXX=/opt/rh/devtoolset-2/root/usr/bin/c++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以下为替换系统GCC，不建议这样操作</span><br><span class="line"></span><br><span class="line">ln -s /opt/rh/devtoolset-2/root/usr/bin/* /usr/local/bin/</span><br><span class="line">hash -r</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>GCC 4.9</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://copr.fedoraproject.org/coprs/rhscl/devtoolset-3/repo/epel-6/rhscl-devtoolset-3-epel-6.repo -O /etc/yum.repos.d/devtools-3.repo</span><br><span class="line"></span><br><span class="line">yum install devtoolset-3-gcc devtoolset-3-binutils devtoolset-3-gcc-c++ -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 临时编译前使用</span><br><span class="line"></span><br><span class="line">export CC=/opt/rh/devtoolset-3/root/usr/bin/gcc</span><br><span class="line">export CPP=/opt/rh/devtoolset-3/root/usr/bin/cpp</span><br><span class="line">export CXX=/opt/rh/devtoolset-3/root/usr/bin/c++</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>GCC 5.2</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://copr.fedoraproject.org/coprs/hhorak/devtoolset-4-rebuild-bootstrap/repo/epel-6/hhorak-devtoolset-4-rebuild-bootstrap-epel-6.repo -O /etc/yum.repos.d/devtools-4.repo</span><br><span class="line"></span><br><span class="line">yum install devtoolset-4-gcc devtoolset-4-binutils devtoolset-4-gcc-c++ -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 临时编译前使用</span><br><span class="line"></span><br><span class="line">export CC=/opt/rh/devtoolset-4/root/usr/bin/gcc</span><br><span class="line">export CPP=/opt/rh/devtoolset-4/root/usr/bin/cpp</span><br><span class="line">export CXX=/opt/rh/devtoolset-4/root/usr/bin/c++</span><br></pre></td></tr></table></figure>
<h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>试过一次，编译很慢，最后还失败了…..可能是我的姿势不对…先存档，以后有机会再试<br>在编译安装 GCC 之前，系统里必须先要通过 yum 安装老版本的 GCC 和依赖库。<br>如果是在 x86_64 系统下编译的话，还需要安装 libgcc.i686、glibc-devel.i686 才行。<br><strong>编译安装 GCC 内存不小于 1GB，Swap 不小于 1GB，硬盘最低不小于 10GB，否则极有可能会中途报错退出。</strong><br><strong>编译安装完后，目录 gcc-4.8.5 将会有 5GB 之多。</strong><br>最前面的下载解压就不说了，去官网下就行了，然后就是解压后，下载编译所依赖的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装前提条件</span><br><span class="line">yum install -y gcc texinfo-tex flex zip libgcc.i686 glibc-devel.i686</span><br><span class="line"></span><br><span class="line">cd gcc-4.8.1</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建目录用于存放编译结果：</span><br><span class="line">mkdir gcc-build-4.8.1</span><br><span class="line"><span class="meta">#</span> 进入新目录，并执行configure命令，产生makefile：</span><br><span class="line">cd gcc-build-4.8.1</span><br><span class="line">../gcc-4.8.1/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译，j4是四个线程，如果你是四核的话，如果配置低直接make吧...就像我</span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="补充-换yum源"><a href="#补充-换yum源" class="headerlink" title="补充-换yum源"></a>补充-换yum源</h2><p>我尝试换了阿里的yum源，但是还是4.4的版本，听说163的是4.8+的，这个没测试<br>不过换成国内的源应该还是比较好的，可以选择阿里的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>
<p>下载对应版本repo文件, 放入<code>/etc/yum.repos.d/</code>(操作前请做好相应备份)，以下为下载链接:<br><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></p>
<p>然后就是生成缓存、安装了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum -y install gcc gcc-g++</span><br></pre></td></tr></table></figure>
<p>CentOS 5：<br><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</code><br>CentOS 6：<br><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://lok.me/a/2045.html" target="_blank" rel="noopener">http://lok.me/a/2045.html</a><br><a href="https://www.zhangfangzhou.cn/centos6-devtoolset-gcc.html" target="_blank" rel="noopener">https://www.zhangfangzhou.cn/centos6-devtoolset-gcc.html</a><br><a href="https://my.oschina.net/vaero/blog/210485" target="_blank" rel="noopener">https://my.oschina.net/vaero/blog/210485</a><br><a href="https://teddysun.com/432.html" target="_blank" rel="noopener">https://teddysun.com/432.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GCC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery-DOM节点操作]]></title>
      <url>http://bfchengnuo.com/2017/03/01/jQuery-DOM%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>我为什么要看jQuery呢！我也不知道…..强迫症吧，看着学习进度不是100%就难受<br><del>也许是想放松下，看点简单的</del><br><a id="more"></a><br>jQuery还是很强大的！</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>使用Jquery创建节点变的非常容易，直接书写HTML就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">"&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;"</span>)</span><br><span class="line">$body.append(div)</span><br></pre></td></tr></table></figure>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p><strong>内部插入常用的几种方法：</strong><br>append：这个操作与对指定的元素执行<strong>原生的appendChild</strong>方法，将它们添加到文档中的情况类似。<br>appendTo：实际上，使用这个方法是颠倒了常规的<code>$(A).append(B)</code>的操作，即不是把B追加到A中，<strong>而是把A追加到B中</strong>。</p>
<blockquote>
<p>  <code>append()</code> ：前面是被插入的对象，后面是要在对象内插入的元素内容<br>  <code>appendTo()</code> ：前面是要插入的元素内容，而后面是被插入的对象</p>
</blockquote>
<p>在元素内部进行操作的方法，除了在被选元素的结尾（仍然在内部）通过append与appendTo插入指定内容外，相应的还可以在<strong>被选元素之前</strong>插入，jQuery提供的方法是<strong>prepend</strong>与<strong>prependTo</strong>，和上面的两个其实类似，只是是插入到前面</p>
<blockquote>
<p>  <code>append()</code> ：向每个匹配的元素内部追加内容<br>  <code>prepend()</code> ：向每个匹配的元素内部前置内容<br>  <code>appendTo()</code> ：把所有匹配的元素追加到另一个指定元素的集合中<br>  <code>prependTo()</code> ：把所有匹配的元素前置到另一个指定的元素集合中</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数是将要插入的内容。在内部后面追加</span></span><br><span class="line">$(<span class="string">".content"</span>).append(<span class="string">'&lt;div class="append"&gt;通过append方法添加的元素&lt;/div&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//.appendTo()刚好相反，内容在方法前面，</span></span><br><span class="line"><span class="comment">//无论是一个选择器表达式 或创建作为标记上的标记</span></span><br><span class="line"><span class="comment">//它都将被插入到目标容器的末尾。</span></span><br><span class="line">$(<span class="string">'&lt;div class="appendTo"&gt;通过appendTo方法添加的元素&lt;/div&gt;'</span>).appendTo($(<span class="string">".content"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到class="aaron1"的div节点</span></span><br><span class="line"><span class="comment">//然后通过prepend在内部的首位置添加一个新的p节点</span></span><br><span class="line">$(<span class="string">'.aaron1'</span>).prepend(<span class="string">'&lt;p&gt;prepend增加的p元素&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到class="aaron2"的div节点</span></span><br><span class="line"><span class="comment">//然后通过prependTo内部的首位置添加一个新的p节点</span></span><br><span class="line">$(<span class="string">'&lt;p&gt;prependTo增加的p元素&lt;/p&gt;'</span>).prependTo($(<span class="string">'.aaron2'</span>))</span><br></pre></td></tr></table></figure>
<p><strong>外部插入的几种方法：</strong><br>before(向前面)与after(向后面)都是用来对相对选中元素外部增加相邻的兄弟节点<br>两个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面，都支持多个参数传递<code>after(div1,div2,....)</code><br>jQuery由于内容目标的位置不同，然增加了2个新的方法insertAfter与insertBefore<br><code>.before()</code>和<code>.insertBefore()</code>实现同样的功能。主要的区别是语法——内容和目标的位置。 对于<strong>before()</strong>选择表达式在函数前面，内容作为参数，而<strong>insertBefore()</strong>刚好相反，内容在方法前面，它将被放在参数里元素的前面<br><code>.after()</code>和<code>.insertAfter()</code> 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于<strong>after()</strong>选择表达式在函数的前面，参数是将要插入的内容。对于 <strong>insertAfter()</strong>, 刚好相反，内容在方法前面，它将被放在参数里元素的后面<br>before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在匹配test1元素集合中的每个元素前面插入p元素</span></span><br><span class="line">$(<span class="string">".test1"</span>).before(<span class="string">'&lt;p style="color:red"&gt;before,在匹配元素之前增加&lt;/p&gt;'</span>, <span class="string">'&lt;p style="color:red"&gt;多参数&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匹配test1元素集合中的每个元素后面插入p元素</span></span><br><span class="line">$(<span class="string">".test2"</span>).after(<span class="string">'&lt;p style="color:blue"&gt;after,在匹配元素之后增加&lt;/p&gt;'</span>, <span class="string">'&lt;p style="color:blue"&gt;多参数&lt;/p&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在test1元素前后插入集合中每个匹配的元素</span></span><br><span class="line"><span class="comment">//不支持多参数，“多参数” 内容无效</span></span><br><span class="line">$(<span class="string">'&lt;p style="color:red"&gt;测试insertBefore方法增加&lt;/p&gt;'</span>, <span class="string">'&lt;p style="color:red"&gt;多参数&lt;/p&gt;'</span>).insertBefore($(<span class="string">".test1"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//在test2元素前后插入集合中每个匹配的元素</span></span><br><span class="line"><span class="comment">//不支持多参数</span></span><br><span class="line">$(<span class="string">'&lt;p style="color:red"&gt;测试insertAfter方法增加&lt;/p&gt;'</span>).insertAfter($(<span class="string">".test2"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h2><p>使用<code>empty()</code>方法会移除指定元素中的所有子节点，但是调用的节点还是存在的<br><code>remove()</code>与empty一样，都是移除元素的方法，但是remove会<strong>将元素自身移除</strong>，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".test1"</span>).remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到所有p元素中，包含了3的元素</span></span><br><span class="line"><span class="comment">//这个也是一个过滤器的处理</span></span><br><span class="line">$(<span class="string">"p"</span>).remove(<span class="string">":contains('3')"</span>)</span><br><span class="line"><span class="comment">//也可以这样：$("p").filter(":contains('3')").remove()</span></span><br></pre></td></tr></table></figure>
<p>如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理，也就是它只会从显示上移除<br>但是：detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过detach方法删除元素</span></span><br><span class="line"><span class="comment">//只是页面不可见，但是这个节点还是保存在内存中</span></span><br><span class="line"><span class="comment">//数据与事件都不会丢失</span></span><br><span class="line">p = $(<span class="string">"p"</span>).detach()</span><br><span class="line"><span class="comment">//还原操作</span></span><br><span class="line">$(<span class="string">"body"</span>).append(p);</span><br></pre></td></tr></table></figure>
<h2 id="复制与替换"><a href="#复制与替换" class="headerlink" title="复制与替换"></a>复制与替换</h2><p>复制也就是克隆，使用<code>.clone()</code>方法深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的<strong>下级元素、文字节点。</strong><br>clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过<code>clone(ture)</code>传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的<strong>事件与数据</strong>给一并克隆了<br>使用时需要注意的一些细节：</p>
<ul>
<li><strong>clone()</strong>方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如可以使用 <code>$(this).clone().css(&#39;color&#39;,&#39;red&#39;)</code>增加了一个颜色</li>
<li>通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上</li>
<li><strong>clone()</strong>方法是jQuery扩展的，<strong>只能处理通过jQuery绑定的事件与数据</strong></li>
<li>元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个</li>
</ul>
<p>至于替换，使用的是replaceWith方法，用<code>$()</code>选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A<br><code>replaceAll()</code>和<code>replaceWith()</code>功能类似，但是<strong>目标和源相反</strong></p>
<ul>
<li>replaceAll()和replaceWith()功能类似，主要是目标和源的位置区别</li>
<li>replaceWith()与replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序</li>
<li>replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用</li>
<li>replaceWith()方法返回的jQuery对象引用的是<strong>替换前的节点</strong>，而不是通过replaceWith/replaceAll方法替换后的节点</li>
</ul>
<p>如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法<br>比如给p元素增加一个div包裹<code>$(&#39;p&#39;).wrap(&#39;&lt;div&gt;&lt;/div&gt;&#39;)</code>也可以这样用，使用一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上面是一个效果</span></span><br><span class="line">$(<span class="string">'p'</span>).wrap(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;div&gt;&lt;/div&gt;'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>jQuery还提供了一个<code>unwarp()</code>方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。<br>上面说的是包裹一个元素的，相应的也就有包裹多个的方法：<code>wrapAll( wrappingElement)</code>给集合中匹配的元素增加一个外面包裹HTML结构，不过这里需要注意的是，如果是通过回调的方式可以<strong>单独处理每一个元素</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'p'</span>).wrapAll(<span class="string">'&lt;div&gt;&lt;/div&gt;'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">'p'</span>).wrapAll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="string">'&lt;div&gt;&lt;div/&gt;'</span>; </span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>p元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果要将合集中的元素内部<strong>所有的子元素</strong>用其他元素包裹起来，并当作指定元素的子元素，针对这样的处理，JQuery提供了一个wrapInner方法，用法和上面的是一样的</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>jQuery是一个合集对象，如果想快速查找合集里面的<strong>第一级子元素</strong>，此时可以用<strong>children()</strong>方法。这里需要注意：<code>.children(selector)</code>方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系）意思就是可以不传入参数返回第一级的子元素，也可以传入表达式进行筛选<br>如果想快速查找DOM树中的这些元素的<strong>后代元素</strong>，此时可以用<strong>find()</strong>方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）使用find方法需要注意的：</p>
<ul>
<li>find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。</li>
<li>与其他的树遍历方法不同，选择器表达式对于<code>.find()</code>是<strong>必需的参数</strong>。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。</li>
<li>find只在后代中遍历，不包括自己。</li>
<li>选择器 context 是由 <code>.find()</code> 方法实现的；因此，<code>$(&#39;.item-ii&#39;).find(&#39;li&#39;)</code> 等价于 <code>$(&#39;li&#39;, &#39;.item-ii&#39;)</code> (找到类名为item-ii的标签下的li标签)。</li>
</ul>
<p>类似的就有找父亲的方法，<code>parent()</code>这个方法只会向上查找一级，相应的<code>parents()</code>方法就可以查找到所有的祖辈元素<br><code>$( &quot;html&quot; ).parent()</code>方法返回一个包含document的集合，而<code>$( &quot;html&quot; ).parents()</code>返回一个空集合。</p>
<p>Jquery还提供了一个<code>closest()</code>方法接受一个匹配元素的选择器字符串从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素，至于和parents的区别</p>
<ol>
<li>起始位置不同：closest开始于当前元素 ；parents开始于父元素</li>
<li>遍历的目标不同：closest要找到指定的目标，parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合</li>
<li>结果不同：closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</li>
</ol>
<p>其他的还有next方法和prev方法，他们应该是一对，一前一后，用法和上面一样，看名字也能知道是干什么的siblings方法是查找兄弟节点，使用add添加节点，它的参数可以几乎接受任何的<strong>$()</strong>，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'li'</span>).add(<span class="string">'p'</span>)</span><br><span class="line">$(<span class="string">'li'</span>).add(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>])</span><br><span class="line">$(<span class="string">'li'</span>).add(<span class="string">'&lt;p&gt;新的p元素&lt;/p&gt;'</span>).appendTo(目标位置)</span><br></pre></td></tr></table></figure>
<p><code>.each()</code>方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>慕课网<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Aaron<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $(<span class="string">"li"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// index 索引 0,1</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// element是对应的li节点</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// this 指向的是li</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><p>jQuery 对象和 JavaScript 的对象是不同的，简单说 jQuery 把 js 原生的对象外面加了一层包装，相当于套了一层数组，然后能使用 jq 中定义的各种事件和方法，他们之间互相独立的，方法不能混用，但是对象之间可以进行转换。<br>js 对象转 jq：<code>$(obj)</code> 直接套一下就 ok；<br>jq 对象转 js：<code>obj[0]</code> 或者 <code>obj.get(0)</code> 毕竟外面套的是数组。<br><strong>为了便于区分，jq 对象一般的命名是以 $ 开头。</strong></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP学习笔记(二)]]></title>
      <url>http://bfchengnuo.com/2017/02/27/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>基本的语法与编写两篇总结应该就差不多了，PHP自带各种强大函数基本都封装好了，学起来也不是很难<br>这篇记录 cookie、session以及IO和异常等<br><a id="more"></a><br>还有点操作数据库的一些库的使用没整理，框架级开发就先不看了</p>
<h2 id="cookie相关"><a href="#cookie相关" class="headerlink" title="cookie相关"></a>cookie相关</h2><p>PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在<code>$_COOKIE</code>的全局变量之中，因此我们可以通过<code>$_COOKIE[&#39;key&#39;]</code>的形式来读取某个Cookie值。</p>
<h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><p>PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个<strong>可选参数</strong>，我们常用到的为前5个：</p>
<ul>
<li>name（ Cookie名）可以通过<code>$_COOKIE[&#39;name&#39;]</code>进行访问</li>
<li>value（Cookie的值）</li>
<li>expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效</li>
<li>path（有效路径）如果路径设置为’/‘，则整个网站都有效</li>
<li>domain（有效域）默认整个域名都有效，如果设置了’www.imooc.com’,则只在www子域中有效</li>
</ul>
<p>因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。<br><code>header(&quot;Set-Cookie:cookie_name=value&quot;);</code>；在values后面可加分号追加有效期<br>删除cookie没有专门的函数，也是为了不让请求过于复杂，可以通过设置有效时间来达到删除目的：<br><code>setcookie(&#39;test&#39;, &#39;&#39;, time()-1);</code></p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>相比cookie，session是将用户的会话数据存储在服务端，<strong>没有大小限制</strong>，不像cookie只能是4kb，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//开始使用session</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="comment">//设置一个session</span></span><br><span class="line">$_SESSION[<span class="string">'test'</span>] = time();</span><br><span class="line"><span class="comment">//显示当前的session_id</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"session_id:"</span>.session_id();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取session值</span></span><br><span class="line"><span class="keyword">echo</span> $_SESSION[<span class="string">'test'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个session</span></span><br><span class="line"><span class="keyword">unset</span>($_SESSION[<span class="string">'test'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有数据，但是session_id仍然存在。</span></span><br><span class="line">session_destroy();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="comment">//此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。</span></span><br><span class="line"><span class="comment">//数组将递归展开值，通过缩进显示其结构。</span></span><br><span class="line">var_dump($_SESSION);</span><br></pre></td></tr></table></figure>
<p>session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。<br>默认情况下，session是<strong>以文件形式</strong>存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题.</p>
<p>关于删除，值得注意的是，<strong>session_destroy</strong>并不会立即的销毁全局变量<code>$_SESSION</code>中的值，只有当下次再访问的时候，<code>$_SESSION</code>才为空，因此如果需要立即销毁<code>$_SESSION</code>，可以使用unset函数。<br>如果需要同时销毁<strong>cookie</strong>中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除cookie中的session_id值。</p>
<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p>PHP具有丰富的文件操作函数，最简单的读取文件的函数为<code>file_get_contents($src)</code>，当然也可以是url，可以将整个文件全部读取到一个字符串中.<br>一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个<code>is_file</code>与<code>file_exists</code>.<br>如果只是判断文件存在，使用<code>file_exists</code>就行，file_exists不仅可以判断文件是否存在，<strong>同时也可以判断目录是否存在</strong><br>而<code>is_file</code>是确切的判断给定的路径是否是一个文件。<br>更加精确的可以使用<code>is_readable</code>与<code>is_writeable</code>在文件是否存在的基础上，判断文件是否可读与可写。<br>通过<code>filesize</code>函数可以取得文件的大小，文件大小是以<strong>字节</strong>数表示的。如果需要转换要自己写函数，并且不支持目录级的计算，要用到递归实现</p>
<blockquote>
<p>  拓展：<br>  fileowner：获得文件的所有者<br>  filectime：获取文件的创建时间<br>  filemtime：获取文件的修改时间<br>  fileatime：获取文件的访问时间</p>
</blockquote>
<p>当然在PHP也可以使用文件指针的方式进行读写文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//die() 函数输出一条消息，并退出当前脚本,该函数是exit()函数的别名。</span></span><br><span class="line">$myfile = fopen(<span class="string">"webdictionary.txt"</span>, <span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line"><span class="comment">// 输出单字符直到 end-of-file</span></span><br><span class="line"><span class="keyword">while</span>(!feof($myfile)) &#123;</span><br><span class="line">  <span class="comment">//从文件中读取单个字符,文件指针也会下移</span></span><br><span class="line">  <span class="keyword">echo</span> fgetc($myfile);</span><br><span class="line">&#125;</span><br><span class="line">fclose($myfile);</span><br></pre></td></tr></table></figure>
<h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><p>PHP提供了内置函数<code>time()</code> 来取得<strong>服务器当前时间</strong>的时间戳。<code>date()</code>函数，来取得当前的日期；<code>date(时间戳的格式, 规定时间戳【默认是当前的日期和时间，可选】)</code>返回值是：函数日期和时间<br>比如：<code>date(&quot;Y-m-d&quot;,&#39;1396193923&#39;);</code>结果就是2014-03-30；默认第二个参数是当前的时间戳，也就是按照格式打印当前时间<br>还可以使用<code>strtotime(&#39;2014-04-29 00:00:01&#39;);</code>类似的获取指定日期的时间戳<br>strtotime函数预期接受一个包含美国英语日期格式的字符串并尝试将其解析为 Unix 时间戳。参数是要解析的时间字符串, 当然也可以不填，默认是当前的时间</p>
<blockquote>
<p>  <code>echo strtotime(&quot;now&quot;);</code>//相当于将英文单词now直接等于现在的日期和时间，并把这个日期时间转化为unix时间戳。这个效果跟<code>echo time();</code>一样。<br>  <code>echo strtotime(&quot;+1 seconds&quot;);</code>//相当于将现在的日期和时间加上了1秒，并把这个日期时间转化为unix时间戳。这个效果跟<code>echo time()+1;</code>一样。<br>  <code>echo strtotime(&quot;+1 day&quot;);</code>//相当于将现在的日期和时间加上了1天。<br>  <code>echo strtotime(&quot;+1 week&quot;);</code>//相当于将现在的日期和时间加上了1周。<br>  <code>echo strtotime(&quot;+1 week 3 days 7 hours 5 seconds&quot;);</code>//相当于将现在的日期和时间加上了1周3天7小时5秒。</p>
</blockquote>
<p><code>gmdate(&#39;Y-m-d H:i:s&#39;, time())</code>函数能格式化一个GMT的日期和时间，返回的是格林威治标准时（GMT），我们是在GMT+8区，所以时间会比现在慢八小时<br>设置时区可以使用<code>date_default_timezone_set(&quot;Asia/Shanghai&quot;);</code>函数完成</p>
<h2 id="图形图像操作"><a href="#图形图像操作" class="headerlink" title="图形图像操作"></a>图形图像操作</h2><p>GD指的是<strong>Graphic Device</strong>，PHP的GD库是用来处理图形的扩展库，通过GD库提供的一系列API，可以对图像进行处理或者直接生成新的图片。<br>PHP除了能进行文本处理以外，通过GD库，可以对JPG、PNG、GIF、SWF等图片进行处理。GD库常用在图片加水印，验证码生成等方面。</p>
<p>PHP默认已经集成了GD库，只需要在安装的时候开启就行。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"content-type: image/png"</span>);</span><br><span class="line">$img=imagecreatetruecolor(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//创建一个真彩色的空白图片：</span></span><br><span class="line">$red=imagecolorallocate($img, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>); <span class="comment">//进行分配画笔颜色</span></span><br><span class="line">imageline($img,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>,$red);  <span class="comment">//进行线条的绘制，通过指定起点跟终点来最终得到线条。</span></span><br><span class="line"><span class="comment">//imagefill($img, 0, 0, $red); 区域填充，相邻点都会被填充，填充背景</span></span><br><span class="line"><span class="comment">//imagesetpixel (resource $image ,int $x ,int $y ,int $color)绘制点</span></span><br><span class="line"></span><br><span class="line">imagepng($img); <span class="comment">//得到一个图片文件，输出到网页</span></span><br><span class="line"><span class="comment">//如果想保存成文件,使用imagejpeg将图片保存成jpeg格式，imagegif将图片保存成gif格式</span></span><br><span class="line"><span class="comment">//需要说明的是，imagejpeg会对图片进行压缩，因此还可以设置一个质量参数。</span></span><br><span class="line"><span class="comment">//imagejpeg($img, $filename, 80);</span></span><br><span class="line"><span class="comment">//imagepng($img, 'img.png');</span></span><br><span class="line">imagedestroy($img); <span class="comment">//销毁图片</span></span><br></pre></td></tr></table></figure>
<p>然后使用imagestring函数来进行文字的绘制，这个函数的参数很多：<code>imagestring ( resource $image , int $font , int $x , int $y , string $s , int $col )</code>，可以通过<strong>$font</strong>来设置字体的大小，x,y设置文字显示的位置，<strong>$s</strong>是要绘制的文字,<strong>$col</strong>是文字的颜色。例子：<code>imagestring($img, 5, 0, 0, &quot;Hello world&quot;, $red);</code></p>
<p>通过<strong>imagecreatefromjpeg</strong>可以直接从图片文件创建图像。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$im = imagecreatefromjpeg($filename);</span><br></pre></td></tr></table></figure>
<p>创建图像对象以后，我们就可以通过前面的GD函数，绘制字符串到图像上。如果要加的水印是一个logo图片，那么就需要再建立一个图像对象，然后通过GD函数imagecopy将logo的图像复制到源图像中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$logo = imagecreatefrompng($filename);</span><br><span class="line"><span class="comment">//将im图像中坐标从0，0开始，宽度为width，高度为height的一部分拷贝到logo图像中坐标为15和15的位置上。</span></span><br><span class="line">imagecopy($im, $logo, <span class="number">15</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, $width, $height);</span><br><span class="line"></span><br><span class="line">$size = getimagesize(<span class="string">'logo.png'</span>);</span><br><span class="line"><span class="comment">//$size[0]是宽度，1是高度，2是格式</span></span><br></pre></td></tr></table></figure>
<p>当将logo图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Exception具有几个基本属性与方法，其中包括：</p>
<blockquote>
<p>  message —- 异常消息内容<br>  code —- 异常代码<br>  file —- 抛出异常的文件名<br>  line —- 抛出异常在该文件的行数</p>
<p>  其中常用的方法有：<br>  getTrace —- 获取异常追踪信息<br>  getTraceAsString —- 获取异常追踪信息的字符串<br>  getMessage —- 获取出错信息</p>
</blockquote>
<p>当然也是可以进行自定义异常</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'自定义错误信息'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">'error'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $e-&gt;getInfo();</span><br><span class="line"><span class="comment">//    echo $e-&gt;getMessage();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般处理方案</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'wrong'</span>); <span class="comment">//可能出现问题的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line">    $msg = <span class="string">'Error:'</span>.$ex-&gt;getMessage().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= $ex-&gt;getTraceAsString().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= <span class="string">'异常行号：'</span>.$ex-&gt;getLine().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= <span class="string">'所在文件：'</span>.$ex-&gt;getFile().<span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">//将异常信息记录到日志中</span></span><br><span class="line">    file_put_contents(<span class="string">'error.log'</span>, $msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP学习笔记(一)]]></title>
      <url>http://bfchengnuo.com/2017/02/21/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>平时还是能时常看到PHP的代码的，然而每次都看不懂，抽几天了解下基本语法，但求看得懂就行….不做深入考虑<br>毕竟是<del>世界上最好的语言</del>，还是要了解一下的2333<br><a id="more"></a><br>看了这几门语言现在感觉有点乱了…..额….<br>也差不多全了，我想了解的，Google的Go语言…..再说</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>打印是用echo和shell类似~~当然使用print_r也是可以的<br>在php中字符串连接符是用点<code>.</code>来表示的，这一点比较特殊，其它多数语言中是用加号<code>+</code>来表示的<br>php声明变量、调用都需要在前面加$<br>在PHP中，支持8种原始类型，其中包括四种标量类型、两种复合类型和两种特殊类型。<br>PHP会自动把变量转换为自动的数据类型<br>boolean类型不区分大小写，true输出为1，否则什么也没有<br>空为null，不区分大小写<br>逻辑运算有and、or、xor(逻辑异或；有且仅有一个为true的情况)、!、&amp;&amp;、||(and与||相同但是有优先级问题)</p>
<hr>
<p>可以用 <code>define()</code> 函数来定义常量，在 PHP 5.3.0 以后，可以使用 const 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。</p>
<blockquote>
<p>  常用系统常量：</p>
<p>  （1）<code>__FILE__</code> :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。<br>  （2）<code>__LINE__</code> :PHP程序文件行数。它可以告诉我们，当前代码在第几行。<br>  （3）PHP_VERSION:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。<br>  （4）PHP_OS：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。</p>
</blockquote>
<p>获取常量还可以使用<code>constant()</code>函数，接受一个str可以是常量名或者一个变量，返回这个常量的值;使用<code>bool defined(string constants_name)</code>判断是否存在常量</p>
<hr>
<p>foreach特点，常用的两种形式：</p>
<ul>
<li>只取值，不要下标<br>数组为例：<code>foreach (数组 as 值){}</code><br>汉字替换成变量即可</li>
<li>取下标和值<br>数组为例：<code>foreach (数组 as 下标 =&gt; 值){}</code></li>
</ul>
<p>可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>PHP有两种数组：索引数组、关联数组。<br>索引和关联两个词都是针对数组的键而言的。通俗将：索引数组就是一般的我们使用的用下标的方式，关联数组就是用key-value的形式，<del>类似java的map</del></p>
<p>可以使用<code>$arr = array();</code>来创建一个空数组，也可用<code>$fruit = array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;);</code> 的方式来创建索引数组。可以使用<code>print_r($fruit);</code>打印查看<br>对于数组的<strong>赋值</strong>，除了常规的方式，PHP还多了一种：用<code>array()</code>创建一个空数组，使用<code>=&gt;</code>符号来分隔键和值，左侧表示键，右侧表示值。当然，索引数组中，键一定是整数。比如:<code>array(&#39;0&#39;=&gt;&#39;苹果&#39;);</code><br><strong>循环取值</strong>除了常规的for循环也可以使用foreach，不过就是有点不习惯….两种数组都适用</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$fruit=<span class="keyword">array</span>(<span class="string">'苹果'</span>,<span class="string">'香蕉'</span>,<span class="string">'菠萝'</span>);</span><br><span class="line"><span class="keyword">foreach</span>($fruit <span class="keyword">as</span> $key=&gt;$value)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;br&gt;第'</span>.$key.<span class="string">'值是：'</span>.$value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>和js类似，使用关键字function来定义函数，PHP中也不允许函数返回多个值，只能是一个<br>这里有个在我看来很神奇的东西–<strong>可变函数</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'jobs'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$func = <span class="string">'name'</span>;</span><br><span class="line">$func(); <span class="comment">//调用可变函数</span></span><br></pre></td></tr></table></figure>
<p>神奇就在于把一个变量赋予一个函数名的字串，竟然就可以通过这个变量调用函数了！至于到底是怎么回事我就不深究了，毕竟只是了解的心态，知道有这样的用法就行了，便于动态调用<br><del>我倒感觉这样写比较容易理解<code>$func = name;</code> 多好</del><br>个人认为最强大的还是内置函数，灰常多，灰常强大，常用的有<br>当我们创建了自定义函数，并且了解了可变函数的用法，为了确保程序调用的函数是存在的，经常会先使用<code>function_exists(&#39;name&#39;)</code>判断一下函数是否存在。同样的<code>method_exists(&#39;name&#39;)</code>可以用来检测类的方法是否存在。类是否定义可以使用class_exists;文件是否存在file_exists等</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>和其他语言类似，也是有类与对象的定义，同样是用class作为关键字，举个栗子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $name = <span class="string">'汽车'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个car对象</span></span><br><span class="line">$car = <span class="keyword">new</span> Car();</span><br><span class="line">$car-&gt;name = <span class="string">'奥迪A6'</span>; <span class="comment">//设置对象的属性值</span></span><br><span class="line"><span class="keyword">echo</span> $car-&gt;getName();  <span class="comment">//调用对象的方法 输出对象的名字</span></span><br></pre></td></tr></table></figure>
<p>比较让我在意的是：相对java来说，因为PHP中的<code>.</code>相当于java中的<code>+</code>；于是用<code>-&gt;</code>表示java中的<code>.</code>：<code>java：this.name</code>在php写的话就是:<code>$this-&gt;name</code>；嗯我乱说的…..23333</p>
<p>在类的定义的时候，属性、方法是支持使用修饰符的，比如方法默认就是public啊，还有protected、private、static；对于静态属性则使用<code>::</code>双冒号进行访问<strong>不要用</strong><code>-&gt;</code>；静态方法中，<code>$this</code>伪变量不允许使用。可以使用self，parent，static在内部<strong>调用静态方法与属性。</strong></p>
<p><strong>类属性</strong>必须定义为公有、受保护、私有之一。为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。</p>
<blockquote>
<p>  方法就是在类中的function，很多时候我们分不清方法与函数有什么差别，在面向过程的程序设计中function叫做函数，在面向对象中function则被称之为方法。</p>
</blockquote>
<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p><strong>PHP5</strong>可以在类中使用<code>__construct()</code>定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。<code>function __construct(){}</code><br>和java比的话这里有点区别，在子类中如果定义了<code>__construct</code>则不会调用父类的<code>__construct</code>，如果需要同时调用父类的构造函数，需要使用<code>parent::__construct()</code>  <strong>显式的调用</strong>。<br>PHP5支持析构函数，使用<code>__destruct()</code>进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。可以使用<code>unset($className);</code>回收对象进行测试，一般不需要手动调用</p>
<p>类似的，如果把构造函数私有化，那就不允许进行初始化了，比如单例模式</p>
<h3 id="继承与重载"><a href="#继承与重载" class="headerlink" title="继承与重载"></a>继承与重载</h3><p>继承使用关键字extends，方法同可以进行覆盖<br>至于重载，就有些不同了</p>
<blockquote>
<p>  PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。<br>  属性的重载通过<code>__set</code>，<code>__get</code>，<code>__isset</code>，<code>__unset</code>来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性<br>  方法的重载通过<code>__call</code>来实现，当调用不存在的方法的时候，将会转为参数调用<code>__call</code>方法，当调用不存在的静态方法时会使用<code>__callStatic</code>重载。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $speed = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//在这里使用重载实现speedDown方法,参数为方法名和调用时传入的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name,$args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($name == <span class="string">'speedDown'</span>)&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;speed -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$car = <span class="keyword">new</span> Car();</span><br><span class="line">$car-&gt;speedDown(); <span class="comment">//调用不存在的speedDown方法</span></span><br><span class="line"><span class="keyword">echo</span> $car-&gt;speed;</span><br></pre></td></tr></table></figure>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>对象复制，在一些特殊情况下，可以通过关键字clone来复制一个对象，这时<code>__clone</code>方法会被调用，通过这个魔术方法来设置属性的值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $obj = <span class="keyword">new</span> Car();</span><br><span class="line">        $obj-&gt;name = <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// -----f g x-------</span></span><br><span class="line">$b = <span class="keyword">clone</span> $a;</span><br><span class="line"><span class="keyword">if</span> ($a == $b) <span class="keyword">echo</span> <span class="string">'=='</span>;   <span class="comment">//true</span></span><br><span class="line"><span class="keyword">if</span> ($a === $b) <span class="keyword">echo</span> <span class="string">'==='</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>对象序列化，可以通过serialize方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过unserialize将字符串反序列化成对象进行使用。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>除了常规的定义方法，PHP中还可以这样定义：heredoc语法结构定义的字符串：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$hello = <span class="string">&lt;&lt;&lt;TAG</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">TAG;</span></span><br></pre></td></tr></table></figure>
<p>为什么感觉似曾相识，想不起是那种语言了，罢了<br>关于定义字符串单引号和双引号的区别：PHP允许我们在双引号串中直接包含字串变量。而单引号串中的内容总被认为是普通字符。</p>
<p>去除字符串的空格：</p>
<blockquote>
<p>  trim去除一个字符串两端空格。<br>  rtrim是去除一个字符串右部空格，其中的r是right的缩写。<br>  ltrim是去除一个字符串左部空格，其中的l是left的缩写。</p>
</blockquote>
<p>计算长度与替换：</p>
<blockquote>
<p>  strlen() 最好用来计算英文字串的长度<br>  mb_strlen() 可以用来计算中文，同时可以传入一个编码格式的参数<br>  替换：str_replace(要查找的字符串, 要替换的字符串, 被搜索的字符串, 替换进行计数[可选])</p>
</blockquote>
<p>字符串截取与查找：</p>
<blockquote>
<p>  英文：substr(字符串变量,开始截取的位置，截取个数）<br>  中文：mb_substr(字符串变量,开始截取的位置，截取个数, 网页编码）<br>  查找：strpos(要处理的字符串, 要定位的字符串, 定位的起始位置[可选])<br>  返回的是索引，从0开始</p>
</blockquote>
<p>格式化字串，没有数据类型就是好：</p>
<blockquote>
<p>  sprintf(格式, 要转化的字符串)<br>  sprintf(‘%01.2f’,$str)<br>  %06.2f—-&gt;整个字串至少需要6个字符占位，如果不足就用0填充，小数点后保留2位</p>
</blockquote>
<p>合并与分割、转义：</p>
<blockquote>
<p>  合并：implode(分隔符[可选], 数组)<br>  分割，返回数组：explode(分隔符[可选], 字符串)<br>  转义：addslashes()  返回一个转义后的字符串，如’i’m’–&gt;’i\’m’</p>
</blockquote>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>PHP中使用PCRE库函数进行正则匹配，<code>preg_match(path,str)</code>用于执行一个正则匹配，常用来判断一类字符模式是否存在。标识一个字串是正则可以用分隔符斜线：<code>&#39;/表达式/&#39;</code>；分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)<br>分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x等，例如使用i修饰符可以忽略大小写匹配：<code>&#39;//i&#39;</code><br>可以传入三个参数：<code>preg_match($pattern, $subject, $matches);</code>，匹配结果会写入到matches中，以数组的方式，第一个一般是完整的匹配，第二个就是第一个子组的所有匹配到的不确定字符 (: 大雾<br><code>\-</code>==&gt;<code>_</code>  嗯…..<br>上面的方法只能匹配一次，想要匹配多次可以使用preg_match_all方法，用法一样</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$string = <span class="string">'April 15, 2014'</span>;</span><br><span class="line">$pattern = <span class="string">'/(\w+) (\d+), (\d+)/i'</span>;</span><br><span class="line">$replacement = <span class="string">'$3, $&#123;1&#125; $2'</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace($pattern, $replacement, $string); <span class="comment">//结果为：2014, April 15</span></span><br></pre></td></tr></table></figure>
<p>其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。分组技术~~~</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-正则与数据库]]></title>
      <url>http://bfchengnuo.com/2017/02/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%AD%A3%E5%88%99%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>学习路线方面应该差不多就先到这吧，毕竟也开学啦，后面的内容感觉挺深的，对web开发目前没啥兴趣，比较在意的就是多线程了…..<br>开始着重看下爬虫和数据挖掘方面吧<br><a id="more"></a><br>Py的语法真的好优雅，一袋能顶两袋撒~~23333</p>
<h2 id="正则-re模块"><a href="#正则-re模块" class="headerlink" title="正则-re模块"></a>正则-re模块</h2><p>Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意<code>\\</code>表示<code>\</code><br>因此强烈建议使用Python的r前缀，就不用考虑转义的问题了,r代表没有转义，还可以跟一个参数如使用<code>re.I</code>表示不区分大小写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pa = re.compile(<span class="string">r'^\d+$'</span>)</span><br><span class="line"><span class="comment"># pa = re.compile(r'^Abcd$',re.I)</span></span><br><span class="line">ma = pa.math(str)</span><br><span class="line"><span class="comment"># 上面的两句可以合为一句</span></span><br><span class="line"><span class="comment"># ma = re.math(r'abc',str)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ma:</span><br><span class="line">    print(ma)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"无匹配"</span>)</span><br></pre></td></tr></table></figure>
<p><code>match()</code>方法判断是否匹配(从头开始匹配)，如果匹配成功，返回一个Match对象，否则返回None<br>如果<strong>正则表达式中定义了组</strong>，通俗说就是使用了小括号，那么就可以在Match对象上用<code>group()</code>方法提取出子串来。需要注意的是<code>group(0)</code>永远是原始字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pa = re.compile(<span class="string">r'^(\d&#123;2&#125;)-(\d&#123;3,4&#125;)$'</span>)</span><br><span class="line">ma = pa.match(<span class="string">'43-1234'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ma:</span><br><span class="line">    print(ma.group(<span class="number">0</span>))</span><br><span class="line">    print(ma.group(<span class="number">1</span>))</span><br><span class="line">    print(ma.groups())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"无匹配"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># 43-1234</span></span><br><span class="line"><span class="comment"># 43</span></span><br><span class="line"><span class="comment"># ('43', '1234')</span></span><br></pre></td></tr></table></figure>
<h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><p>最后需要特别指出的是，正则匹配<strong>默认是贪婪匹配</strong>，也就是匹配<strong>尽可能多的字符</strong>。举例如下，匹配出数字后面的<code>0</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; re.match(r'^(\d+)(0*)$', '102300').groups()</span><br><span class="line">('102300', '')</span><br></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。<br>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; re.match(r'^(\d+?)(0*)$', '102300').groups()</span><br><span class="line">('1023', '00')</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  <strong>非贪婪匹配，尽可能的少匹配</strong><br>  <code>xx*?</code>  匹配零次<br>  因为<em>可以是0次或任意次，<em>*最少</em></em>那就是0咯</p>
<p>  <code>xx+?</code>  匹配一次<br>  +可以是1次或任意次，<strong>最少</strong>就是1次咯</p>
</blockquote>
<h3 id="拓展之split与编译"><a href="#拓展之split与编译" class="headerlink" title="拓展之split与编译"></a>拓展之split与编译</h3><p>如果我们用传统的split切割是没办法切割多个空格的，因为这是不确定事件，但是如果用正则就很简单了<br><code>re.split(r&#39;\s+&#39;, &#39;a b   c&#39;)</code>  ，无论多少个空格都切给你看</p>
<p>编译器处理正则的过程是首先把正则式子进行编译，如果不符合规范会报错，然后再进行比较<br>记得上面说过两种方式，可以直接用math或者拆成2步先compile以下，这里的compile就相当于编译了<br>如果你的正则要复用，还是拆开比较好，效率会高一点</p>
<h2 id="操作MySQL"><a href="#操作MySQL" class="headerlink" title="操作MySQL"></a>操作MySQL</h2><p>python3.5以下的使用MySQLdb，官方下载地址：<a href="https://www.python.org/dev/peps/pep-0249/，安装无难度" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0249/，安装无难度</a><br>python 3.5以上的需要把MySQLdb换成pymysql，使用pip直接安装即可<code>pip install PyMySQL</code></p>
<p>这里主要使用到了2个对象，connect和cursor；conn相当于在客户端和服务器直接修了一条路，cur是运输的货车，当然它也是有可能出现异常的<br>这个模块默认是关闭自动commit，避免一句sql当作一个事务，所以增删改需要commit哦，目前我的环境是3.5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123'</span>, db=<span class="string">'test'</span>, charset=<span class="string">'UTF8'</span>)</span><br><span class="line"><span class="comment"># 关闭自动commit</span></span><br><span class="line"><span class="comment"># conn.autocommit(False)</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(<span class="string">"insert into temp(name) values('测试')"</span>)</span><br><span class="line">    conn.commit()</span><br><span class="line">    print(<span class="string">"执行完毕！"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line">    <span class="comment"># 出现异常回滚操作</span></span><br><span class="line">    conn.rollback()</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>然后是关于一些简单的查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123'</span>, db=<span class="string">'test'</span>, charset=<span class="string">'UTF8'</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line">cur.execute(<span class="string">"select * from temp"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的数据是元组的元组，可以进行遍历</span></span><br><span class="line"><span class="comment"># for i in cur:</span></span><br><span class="line"><span class="comment">#     print("id:%d 姓名：%s" %i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回多少行(增删改中是影响的行数)</span></span><br><span class="line">print(cur.rowcount)</span><br><span class="line"><span class="comment"># 返回一行数据，将指针移动一行</span></span><br><span class="line">rs = cur.fetchone()</span><br><span class="line">print(rs)</span><br><span class="line"><span class="comment"># 返回指定的行数 对于当前指针位置</span></span><br><span class="line">rs = cur.fetchmany(<span class="number">3</span>)</span><br><span class="line">print(rs)</span><br><span class="line"><span class="comment"># 返回全部，当前指针位置到最后</span></span><br><span class="line">rs = cur.fetchall()</span><br><span class="line">print(rs)</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<h2 id="关于sqlite"><a href="#关于sqlite" class="headerlink" title="关于sqlite"></a>关于sqlite</h2><p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。<br>Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 连接到SQLite数据库</span></span><br><span class="line"><span class="comment"># 数据库文件是test.db</span></span><br><span class="line"><span class="comment"># 如果文件不存在，会自动在当前目录创建:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">'test.db'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">'create table user (id varchar(20) primary key, name varchar(20))'</span>)</span><br><span class="line">&lt;sqlite3.Cursor object at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">'insert into user (id, name) values (\'1\', \'Michael\')'</span>)</span><br><span class="line">&lt;sqlite3.Cursor object at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="comment"># 通过rowcount获得插入的行数:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.rowcount</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.commit()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure>
<p>mysql的占位符是<code>%s</code>，sqlite用<code>?</code></p>
<blockquote>
<p>  (‘select <em> from %s’ %(‘temp’,))<br>  (‘select </em> from ?’,(‘temp’,))<br>  好吧，我被坑了</p>
</blockquote>
<h2 id="关于对象的补充"><a href="#关于对象的补充" class="headerlink" title="关于对象的补充"></a>关于对象的补充</h2><p>对象、类这一块不可能上次写的那么一点就能概况，这里提下我比较有疑惑的问题：关于继承中的super</p>
<blockquote>
<p>  super(SubClass, self).method() 的意思是，根据self（站在self的角度）去找SubClass的‘父亲’，然后调用这个‘父亲’的method()</p>
</blockquote>
<p>角度问题很重要，不像Java，Python是支持多继承的，那么就不可避免有这个问题<br>首先要明确的是：<strong>当一个类从多个类继承的时候，按照从左到右的顺序继承。</strong>比如<br><code>class test(A,B)</code>，编译器理解为test的父亲是A，A的父亲是B….这样说可能不太严谨，但是我不知道怎么形容了<br>在test的角度A的父亲就是B，即便A可能还继承了C；当切换到A的角度，A的父亲就是C了<br>理解了这些就能理解super的这种奇怪的用法了</p>
<p>在python3 中做了个简化，如果你在类定义的语句块内写一个不带参数的super()，则相当于写了 super(本类名，self)；因为这样的用法比较多嘛~~</p>
<blockquote>
<p>  推荐2篇文章<br>  <a href="http://zsl-oo7.blog.163.com/blog/static/35329703201591502225288/" target="_blank" rel="noopener">Python和java中的super</a><br>  <a href="http://zsl-oo7.blog.163.com/blog/static/35329703201591502225288/" target="_blank" rel="noopener">python 的 super，一次性整明白</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 正则 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JetBrains系列IDE正确使用姿势]]></title>
      <url>http://bfchengnuo.com/2017/02/15/JetBrains%E7%B3%BB%E5%88%97IDE%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
      <content type="html"><![CDATA[<p>只有有了一个好的环境才能心情愉悦的码代码~~<br>有那些神奇的插件为啥不用？？<br>最终决定还是在这里发下吧，虽然篇幅确实有点短，当时最先用的是 AndroidStudio，现在因为主力 Java，已经转移到 IDEA 中，但是配置都差不多，JetBrains 系列的 IDE 基本都可以通用。<br><a id="more"></a><br>本来是发在了公众号，但是现在我不能在文章中加连接，所以也就做不成目录，搜索功能还搜不到，所以还是在这里再发一下吧</p>
<h2 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h2><p>经常看白色是不是看烦了，换一下感觉也是挺好的，<del>黑色主题是不是会让人感觉很厉害的样子呢？</del><br>选择菜单栏“<code>File</code>–<code>settings</code>–<code>apperance</code>–<code>theme</code>”，主题选择Darcula：<br>当然系统提供的两种主题可能都不太好看，我们可以进入网站<a href="http://color-themes.com/" target="_blank" rel="noopener">http://color-themes.com/</a>来获取第三方主题，比如说Sublime主题感觉还是不错的呢<br>下载下来之后，是一个jar包，回到Android Studio，选择菜单栏“ <code>File</code>–<code>Import Settings</code>”，将下载好的jar包导入即可。</p>
<h2 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h2><p>选一款合适的字体是很有必要的，对于猿来说，能准确的分清各个符号字母是最关键的，选择菜单栏“<code>File</code>–<code>settings</code>–<code>Editor</code>–<code>Colors&amp;Fonts</code>–<code>Font</code>”：<br><img src="/image/dev/AS%E5%AD%97%E4%BD%93.png" alt=""><br>同样也可以修改控制台的字体，就是在<code>console font</code>选项卡中<br>修改完之后发现AS的一些默认字体如侧边栏的工程目录的字体并没有发生变化，如果想改的话<br><img src="/image/dev/AS%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AD%97%E4%BD%93.png" alt=""></p>
<h2 id="代码自动补全"><a href="#代码自动补全" class="headerlink" title="代码自动补全"></a>代码自动补全</h2><p>新版本中AS是默认开启的，在：<br>AS默认的代码提示是<strong>大小写敏感的</strong>，我是喜欢不敏感的，这样设置：</p>
<p><img src="/image/dev/AS%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F.png" alt=""></p>
<h2 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h2><p>虽然手动的话也是有快捷键的，但是还是自动导比较爽呢，这样设置：</p>
<p><img src="/image/dev/AS%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%8C%85.png" alt=""></p>
<h2 id="关闭自动打开工程"><a href="#关闭自动打开工程" class="headerlink" title="关闭自动打开工程"></a>关闭自动打开工程</h2><p>默认AS启动的时候会自动打开上一次的工程，这个我感觉非常不爽，修改下设置就可以进入欢迎页面了：</p>
<p><img src="/image/dev/AS%E7%A6%81%E6%AD%A2%E6%89%93%E5%BC%80%E5%B7%A5%E7%A8%8B.png" alt=""></p>
<h2 id="修改新建文件文件头"><a href="#修改新建文件文件头" class="headerlink" title="修改新建文件文件头"></a>修改新建文件文件头</h2><p>每次建新类的话，对下面这段注释肯定很熟悉吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Created by XXXX on 2015/5/7.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>其实是可以设置的，改成我们的个性样式，哈<br><img src="/image/dev/AS%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B4.png" alt=""></p>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>基于国内的特殊情况，还是挂个代理比较好，你懂得，直接搜索<strong>proxy</strong>或者<strong>http</strong>就行了</p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><p>这里推荐几个，还有更多的神级插件需要自己去学习使用咯~<br>至于安装直接在AS设置中选择<code>plugins</code>搜索即可</p>
<h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><p>可用于快速定位代码，类似于Sublime编辑器右侧定位视图。看着就是舒服</p>
<p><img src="/image/dev/CodeGlance.gif" alt=""></p>
<h3 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h3><p>非常方便的初始化工具，它的功能远远不止这个，很强大 （图片挂了:( </p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>根据json数据快速生成相应的java bean，好用！ （图片挂了:(</p>
<h3 id="ECTranslation"><a href="#ECTranslation" class="headerlink" title="ECTranslation"></a>ECTranslation</h3><p>如果你英语也想我一样很烂，这个翻译工具是必不可少的，记得设置下翻译的快捷键，划词翻译~~</p>
<h3 id="FindViewByMe"><a href="#FindViewByMe" class="headerlink" title="FindViewByMe"></a>FindViewByMe</h3><p>如果你不想用上面的那个初始化工具，写findviewbyid都写吐了吧，可以试试这个小工具，自动根据xml文件生成相应的代码，只需复制，然后到相应位置粘贴即可</p>
<h3 id="ADB-Idea"><a href="#ADB-Idea" class="headerlink" title="ADB Idea"></a>ADB Idea</h3><p>通过该插件可以轻松完成以下操作而不用手动输入ADB命令：</p>
<ul>
<li>卸载应用</li>
<li>杀掉应用进程</li>
<li>启动应用</li>
<li>重启应用</li>
<li>清除应用数据</li>
<li>清楚应用数据并且重启应用</li>
</ul>
<p>使用方法：</p>
<p><code>Ctrl + Alt + Shift + A</code>快速调出菜单，选择相应的操作，回车执行。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可以尝试下阿里的 Java 开发规范插件检查不规范的代码，直接搜 alibaba 就有了。<br>使用 Grep Console 插件可以自定义控制台输出的颜色。<br><strong>iBATIS/MyBatis plugin</strong> ：轻松通过快捷键找到MyBatis中对应的Mapper和XML，CTRL+ALT+B；也可尝试 <strong>MyBatisCodeHelper</strong>。<br><strong>Stack Overflow</strong>：控制台的错误可以直接进行在 <strong>Stack Overflow</strong> 搜索。<br><strong>Background Image Plus</strong>：设置代码区的背景图片，<del>面向对象编程</del><br><strong>Lombok</strong>：忘记 getter/setter 方法吧。<br><strong>emacsIDEAs</strong>：跳转神器。<br><strong>keyPromoter</strong>：记不住快捷键？用它吧。</p>
<p>其他的 MarkdownSupport、Maven Helper 就不多介绍了</p>
<h2 id="修改快捷键"><a href="#修改快捷键" class="headerlink" title="修改快捷键"></a>修改快捷键</h2><p>有一些快捷键我个人感觉还是改一下比较好，比如代码提示默认是<code>Ctrl+空格</code>，这个快捷键在中文的系统上被输入法给占了，换成<code>Ctrl+,</code>感觉比较好，搜索basic即可找到，remove掉重设即可</p>
<p>还有一个就是<code>Ctrl+D</code>，我们常用来复制一行，但如果选中多行（部分，不是完整选择）复制的话不能完整的将多行复制，这个快捷键默认给的是<code>Duplicate Line or Selection</code>，我们设给<code>Duplicate Entire Line</code>就可以了，会有冲突提示，选Leave即可，因为这个快捷键还有其他功能</p>
<h2 id="修改注释紧随文字"><a href="#修改注释紧随文字" class="headerlink" title="修改注释紧随文字"></a>修改注释紧随文字</h2><p>我们按注释的快捷键的时候默认会把两条斜线加在一行的开始位置，我认为这样是非常的别扭的，习惯改为紧贴文字<br>在设置中搜索Java，定位到Code Style里，选择最后的Code Generation：<br><img src="/image/dev/%E6%B3%A8%E9%87%8A.png" alt=""></p>
<p>当然也可以加两个空格在前面，就是上面的Add a …选项</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><strong>显示行数：</strong><br><img src="/image/dev/AS%E6%98%BE%E7%A4%BA%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0.png" alt=""></p>
<p><strong>使用鼠标进行缩放字体：</strong><br>只需要在设置搜索<strong>mouse</strong>，相信你已经看到了！</p>
<p><strong>配置 Git 的忽略文件列表</strong></p>
<p>如果使用 Git，这个一般都要配，避免上传不必要的东西，在项目的目录下创建一个 <code>.gitignore</code> 文件，文件内容模板为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">*.iml.gradle/</span><br><span class="line">local.properties/</span><br><span class="line">.idea</span><br><span class="line">.DS_Store</span><br><span class="line">/build</span><br><span class="line">/captures</span><br><span class="line"></span><br><span class="line">### Android </span><br><span class="line">template</span><br><span class="line"></span><br><span class="line"># Built application files</span><br><span class="line">*.apk</span><br><span class="line">*.ap_</span><br><span class="line"></span><br><span class="line"># Files for the ART/Dalvik VM</span><br><span class="line">*.dex</span><br><span class="line"></span><br><span class="line"># Java class files</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Generated files</span><br><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"># Gradle files</span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># Local configuration file (sdk path, etc)</span><br><span class="line">local.properties</span><br><span class="line"></span><br><span class="line"># Proguard folder generated by Eclipse</span><br><span class="line">proguard/</span><br><span class="line"></span><br><span class="line"># Log Files</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># Android Studio Navigation editor temp files</span><br><span class="line">.navigation/</span><br><span class="line"></span><br><span class="line"># Android Studio captures folder</span><br><span class="line">captures/</span><br><span class="line"></span><br><span class="line"># Intellij</span><br><span class="line">.idea/</span><br><span class="line">workspace.xml</span><br><span class="line"></span><br><span class="line"># Keystore files</span><br><span class="line">*.jks</span><br></pre></td></tr></table></figure>
<p>更多待补充….</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/smyhvae/p/4390905.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4390905.html</a><br><a href="http://www.jianshu.com/p/6f5f818afe4b?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">http://www.jianshu.com/p/6f5f818afe4b?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySql基础知识储备]]></title>
      <url>http://bfchengnuo.com/2017/02/14/MySql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
      <content type="html"><![CDATA[<p>最基本的增删改查SQL命令就略过了，记录下我认为有点难度又容易忘的东西<br>MySQL应该还是挺好用的，对于数据库的知识还是比较匮乏的</p>
<p>数据库引擎的知识没写，需要时再Google吧…. <a id="more"></a>    </p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>稍微一提，啊哈哈</p>
<p>安装服务：<code>mysqld -install</code><br>开启服务：<code>net start mysql</code><br>停止服务：<code>net stop mysql</code><br>登陆mysql：<code>mysql -u用户名 -p密码 -P端口 -h服务器地址</code><br>例如：<code>mysql -uroot -p&lt;br&gt;</code>，然后输入密码即可<br>win下cls清屏<br>如果是对于Linux关于启动不太一样，其他倒是类似<br>启动：<br>1、使用 service 启动：<code>service mysqld start</code><br>2、使用 mysqld 脚本启动：<code>/etc/inint.d/mysqld start</code><br>3、使用 safe_mysqld 启动：<code>safe_mysqld&amp;</code><br>停止：<br>1、使用 service 启动：<code>service mysqld stop</code><br>2、使用 mysqld 脚本启动：<code>/etc/inint.d/mysqld stop</code><br>3、<code>mysqladmin shutdown</code><br>重启：<br>1、使用 service 启动：<code>service mysqld restart</code><br>2、使用 mysqld 脚本启动：<code>/etc/inint.d/mysqld restart</code><br>默认是3306端口，可用<code>netstat -ano</code> 查看</p>
<hr>
<p>显示所有数据库：<br><code>SHOW DATABASES;</code><br>显示某个数据库的细节：<br><code>show create database name;</code><br>打开/进入数据库：<br><code>USE Name;</code><br>查看当前数据库：<br><code>SELECT DATABASE();</code><br>清空数据表：<br><code>truncate table tabName;</code><br>过滤重复的数据（查询结果只显示不同的结果）：<br><code>select distinct cloName from tabName;</code><br>查看当前选择的数据库的所有表：<br><code>SHOW TABLES;</code><br>查看指定数据库中的所有表：<br><code>SHOW TABLES FROM TEST;</code><br>查看数据表结构：<br><code>SHOW COLUMNS FROM tbl_name</code><br>查看表结构的另一种：<br><code>DESC tabName;</code><br>显示创建表的语句：<br><code>SHOW CREATE TABLE table_name;</code><br>查看表是否有索引：<br><code>SHOW INDEXS FROM table_name;</code><br>以网格查看表是否有索引：<br><code>SHOW INDEXS FROM table_name\G</code><br>SQL语句中表名后面加<code>as name</code>，可以给表起别名<br><del>以网格查看的话就是 反斜线G 不要加分号</del><br><strong>为了避免输入和数据库的关键字冲突，可以把值用 [` ] 包起来</strong></p>
<hr>
<p>下面的是一些我经常忘记的语法，是修改表相关的<br>增加一列：<br><code>alter table tabName add newName char(2);</code><br>修改表的列类型：<br><code>alter table tabName modify columnName varchar(20);</code><br>删除某列：<br><code>alter table tabName drop sex;</code><br>改表名：<br><code>alter table tabName to newName;</code><br>改列名：<br><code>alter table tabName change colum newName;</code></p>
<p>使用 <code>\s</code> 可以查看系统信息，可以用于查看当前在那个数据库<br>然后再说下备份数据库，其实就是生成数据的 SQL 语句<br>win: <code>mysqldump -uname -p databaseName &gt; file.sql</code><br>恢复数据库(恢复库中的数据，但是不能恢复库，如果库被删要手动创建)：<br>win：<code>mysql -uroot -p databaseName &lt; file.sql</code><br>mysql：<code>Source file.sql;</code> ；当然最好先 use 进入目标数据库</p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户：<code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code><br>参数解释：</p>
<ul>
<li>username：你将创建的用户名</li>
<li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以<strong>从任意远程主机登陆</strong>，可以使用通配符<code>%</code></li>
<li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li>
</ul>
<p>授权：<code>GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</code><br>显示授权信息可以直接执行 <code>SHOW GRANTS;</code><br>参数解释：</p>
<ul>
<li>privileges：用户的操作权限，如<code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>等，如果要授予所的权限则使用<code>ALL</code><br>比如：<code>GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code></li>
<li>databasename：数据库名</li>
<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*</code>表示，如<code>*.*</code></li>
</ul>
<p>对应的，删除授权就是：<code>REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</code><br>删除用户：<code>DROP USER &#39;username&#39;@&#39;host&#39;;</code><br>然后还有一个就是查看用户，最简单的可以直接查 mysql 这个数据库中的 user 表.<br>引用：<a href="https://www.jianshu.com/p/d7b9c468f20d" target="_blank" rel="noopener">https://www.jianshu.com/p/d7b9c468f20d</a></p>
<blockquote>
<p>MySQL5.7+ 后 mysql.user 表没有 password 字段改为 authentication_string；</p>
</blockquote>
<h2 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h2><p>前：花括号必须选择，中括号可以忽略，ASC升序，DESC降序<br>标准：<code>[GROUP BY {col_name |position [ASC|DESC],...}</code><br>关于使用 GROUP 语句，在 select 指定的字段要么就要包含在 Group By 语句的后面，作为分组的依据；要么就要被包含在聚合函数中，如果 Select 后有字段，GROUP 中没有，那么就会报错。<br>having 语句分组，<strong>用在group by后面追加条件</strong>，判断式中的字段是必须出现在前面select中的 或者是可以包含<strong>没有出现</strong>在前面查询中的字段的一个聚合函数<br>举个例子：<br><code>SELECT sex, age FROM users GROUP BY 1 HAVING age &gt; 35;</code><br><code>SELECT sex FROM users GROUP BY 1 HAVING count(id) &gt;= 2;</code></p>
<p>关于排序，标准：<code>[ORDER BY {col_name | expr | position} [ASC|DESC],...]</code><br>当然是可以按照多个字段排序的，如果第一个就已经达到了要求（不会出现相同的值）那么会忽略后面的，反正则在第一字段的前提下再对相同值按照第二个字段进行排序</p>
<p>可以使用LIMIT进行限制返回的数目，加在 sql 语句的最后，比如返回前两条 <code>LIMIT 2</code>；第2-4条：<code>LIMIT 1,3</code></p>
<h2 id="子查询与连接"><a href="#子查询与连接" class="headerlink" title="子查询与连接"></a>子查询与连接</h2><p>子查询是指出现在 <strong>其他SQL语句内</strong> 的 SELECT 子句<br>子查询指嵌套在 <strong>查询内部</strong>，且必须始终 <strong>出现在圆括号内</strong>。<br>子查询可以包含多个关键字或者条件，如<strong>DISTINCT,GROUP BY,ORDER BY,LIMIT,函数等</strong><br>子查询的外层查询可以是：<strong>SELECT,INSERT,UPDATE,SET或DO</strong><br>子查询可以返回值：标量、一行、一列或者子查询</p>
<p>对于select中的子查询，通过上面的定义基本能猜到大部分的子查询是用在了where判断中，还有一个问题是，如果子查询返回的是多个值怎么办？所以有了下面的3个关键字，含义都在表中了</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符\关键字</th>
<th style="text-align:center">ANY</th>
<th style="text-align:center">SOME</th>
<th style="text-align:center">ALL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">>、&gt;=</td>
<td style="text-align:center">最小值</td>
<td style="text-align:center">最小值</td>
<td style="text-align:center">最大值</td>
</tr>
<tr>
<td style="text-align:center">&lt;、&lt;=</td>
<td style="text-align:center">最大值</td>
<td style="text-align:center">最大值</td>
<td style="text-align:center">最小值</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">任意值</td>
<td style="text-align:center">任意值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;、!=</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">任意值</td>
</tr>
</tbody>
</table>
<p>举个例子就是：<code>SELECT * FROM test where age &gt; ANY (select age from test2 where sex=&#39;女&#39;);</code><br>除了上表所说的，还有两个关键词：IN和NOT IN<br>其实也很简单，可以理解为简写：<code>IN</code>相当于<code>=any</code>；<code>NOT IN</code> 相当于 <code>!=all</code>；<br>可以运用到上面的那个例子上就是：<code>SELECT * FROM test where age IN (select age from test2 where sex=&#39;女&#39;);</code><br>你也完全可以把<code>IN</code>换成<code>=any</code>；一样的</p>
<h3 id="将查询结果写入数据表"><a href="#将查询结果写入数据表" class="headerlink" title="将查询结果写入数据表"></a>将查询结果写入数据表</h3><p>看SQL语句就知道了，比如：<br><code>INSERT test（username） SELECT username FROM users WHERE age &gt;=30;</code><br>以上就是把users表中的年龄大于30的姓名写入了test表；需要注意的是表名后面的列不能省略</p>
<h3 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h3><p>简单说就是A表参照B表的内容进行更新，比如：<br><code>update A inner join B on a_name=b_name set a_cate=b_id;</code></p>
<p>解释：<br>A：想要更改的表名<br>inner join： 内连接<br>B：关联的附表<br>a_name=b_name： 两个表对应列的关系<br>(要修改的列名) = (映射的列名)</p>
<blockquote>
<p>  INNER JOIN,内连接<br>  ​       在MySQL中，JOIN, CROSS JOIN 和 INNER JOIN 是等价的。<br>  LEFT [OUTER] JOIN ,左外连接<br>  RIGHT [OUTER] JOIN,右外连接</p>
</blockquote>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>上面简单提到了3钟连接，这里进一步解释下<br>使用 ON 关键字来设定连接条件，也可以使用 WHERE 来代替。<br>但通常使用 ON 关键字来设定连接条件；使用 WHERE 关键字进行结果集记录的过滤<br><strong>内连接：返回左表及右表符合连接条件的记录（即两表的交集部分）</strong><br>例子：<code>SELECT * FROM tabA JOIN tabB ON tabA.name = tabB.name;</code><br>左外连接(LEFT JOIN)：显示<strong>左表全部</strong>和左右符合连接条件的记录<br>右外连接(RIGHT JOIN)：显示左右符合连接条件的记录和<strong>右表全部</strong>记录<br>若某字段只存在某一表，则另一表的里字段返回null</p>
<p>当然是可以连接多个表的，直接在后面追加连接即可</p>
<p>还有一种比较特殊的情况，就是”自连接”，其实和上面的几种没多少区别，可以想象成有两张完全相同的表来进行连接，当然这就必须要起别名了，要不然分不清啊….</p>
<h3 id="多表删除"><a href="#多表删除" class="headerlink" title="多表删除"></a>多表删除</h3><p>假设一个表中有重复内容，我们利用多表删除去重复，其实是一个表，你可以看做两个表嘛，第二个表就是你用子查询查出来的重复内容的那个表了<br><code>delete t1 from test as t1 left join(select id,name from test group by name having count(name)&gt;=2) as t2 on t1.name=t2.name where t1.id&gt;t2.id;</code><br>将test看做t1与子查询所得到的表进行左连接，然后选出id较大的数据，进行删除<br>最简单的是：从数据表t1中把那些id值在数据表t2里有匹配的记录全删除掉：<code>DELETE t1 FROM t1,t2 WHERE t1.id=t2.id</code><br>我主要是强调t1是不可忽略的…..在多表删除中<br><a href="http://www.cnblogs.com/China-Dragon/archive/2009/03/20/1417256.html" target="_blank" rel="noopener">更多关于多表删除</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当然还有create….select等语句，可以变得更简洁</p>
<h2 id="级联删除和更新"><a href="#级联删除和更新" class="headerlink" title="级联删除和更新"></a>级联删除和更新</h2><p>说的是当两个表用外键连接起来后，如果主表被删或者更新，从表应该如何处理<br><strong>MySQL 支持外键的存储引擎只有 InnoDB</strong><br>比如下面这条定义的外键约束，当主表被删或者更新，从表也跟着删除或者更新，换句话说就是：当外键指向的那个表删除或更新，保存外键的那个表的动作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (`rootid`) REFERENCES roottb(`id`) ON <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>;</span><br><span class="line">FOREIGN KEY (`rootid`) REFERENCES roottb(`id`) ON <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>;</span><br></pre></td></tr></table></figure>
<p>常用的选项是：</p>
<ul>
<li>CASCADE<br>表示父表在更新或者删除时，更新或者删除子表对应记录；</li>
<li>SET NULL<br>表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。</li>
<li>RESTRICT 和 NO ACTION 相同<br>是指在子表有关联记录的情况下父表不能更新；</li>
</ul>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>以例子来解释：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> CREATE FUNCTION hello(num1 VARCHAR(255),num2 VARCHAR(255))</span><br><span class="line">    -&gt; RETURNS VARCHAR(255)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; select count(*) into total from test where num1 like num2;</span><br><span class="line">    -&gt; RETURN 'Hello  world,i am mysql';</span><br><span class="line">    -&gt; END $$</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> SELECT hello('abc','a');</span><br><span class="line">+-------------------------+</span><br><span class="line">| hello()                 |</span><br><span class="line">+-------------------------+</span><br><span class="line">| Hello  world,i am mysql |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> DROP FUNCTION hello;</span><br></pre></td></tr></table></figure>
<p>DELIMITER 是用来修改分隔符的，因为当我们写的函数体有多条语句的时候要用<code>;</code>分割，但是它正好也是语句的结束标志，所以就会导致还没写完就执行了，所以我么先把它修改成别的，写完后再改回来<br>RETURNS 表明了返回值的类型<br>RETURN 是要返回的值<br>SELECT INTO 的用法就是说将查询出的内容插入到另一个表中，就上面而言，是把查询出的 count 技术保存到了 total 表中<br>当函数体内需要执行的是多条语句时，要使用<code>BEGIN...END</code>语句<br>执行函数使用 SELECT 语句，其实前面其实我们已经用到过了<br>删除函数使用<code>DROP FUNCTION</code><br>使用<code>SHOW  CREATE FUNCTION name;</code>可以查看函数的定义<br>上面我故意用了变量，这里补充下：</p>
<blockquote>
<p>  1.用户变量：以”@”开始，形式为”@变量名”用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效<br>  2.全局变量：定义时，以如下两种形式出现，<code>set GLOBAL 变量名</code>  或者<code>set @@global.变量名</code>对所有客户端生效。只有具有super权限才可以设置全局变量</p>
<p>  SELECT @nums; 这样就可以认为是定义了一个变量<br>  也可以这样声明用户自定义变量：set @t1=1;</p>
<p>  set语句可用于向系统变量或用户变量赋值; 也可使用select语句来定义<br>  <strong>对于SET，可以使用=或:=来赋值，对于SELECT只能使用:=来赋值。</strong></p>
</blockquote>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><blockquote>
<p>  我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后交给存储引擎执行，而存储过程（Stored Procedure）<strong>是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中</strong>，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p>
<p>  一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。</p>
<p>  存储过程通常有以下优点：</p>
<ol>
<li>存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li>
<li>存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</li>
<li>存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</li>
<li>存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。</li>
<li>存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</li>
</ol>
</blockquote>
<p>然后我们可以创建一个最简单的存储过程：<br><code>CREATE PROCEDURE sp1() SELECT VERSION();</code><br>这个存储过程就是sp1了，它不带参数，查询版本语句是它的函数体，调用我们用<code>CALL sp_name()</code>，关键字就是CALL啦，带参数的存储过程的调用必须有()，无参数的可以省略<br>下面我们看个比较一般的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">test</span>(<span class="keyword">IN</span> showID <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>,<span class="keyword">OUT</span> showName <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = showID;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">ID</span>) <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">INTO</span> showName;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">//</span><br><span class="line"><span class="keyword">CALL</span> <span class="keyword">test</span>(<span class="number">27</span>, @nums);</span><br><span class="line"><span class="keyword">SELECT</span> @nums;</span><br></pre></td></tr></table></figure>
<p>感觉和定义函数还是差不多的，注意到参数中有IN/OUT这些词，它们的作用也差不多可以猜出来</p>
<blockquote>
<p>  IN表示输入参数；表示<strong>该形参的值必须在调用存储过程时指定并传递给存储过程</strong>，在存储过程中修改该参数的值不能被返回，为原来值。<br>  OUT表示输出参数； <strong>该值可在存储过程内部被改变，并更新调用外面的变量。</strong><br>  INOUT表示既可以是输入，也可以是输出；</p>
<p>  INTO就是把结果写入到后面跟的变量啦</p>
</blockquote>
<h2 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h2><p>MySQL 是支持事务的，并且支持还非常好，简单说下在 MySQL 中使用事务，主要就是三条命令</p>
<ul>
<li>开启事务<br><code>start transaction;</code></li>
<li>回滚事务<br><code>Rollback;</code></li>
<li>提交事务<br><code>Commit;</code></li>
</ul>
<p>还有就是 MySQL 是支持 4 种隔离级别的，顺便说下这四种：</p>
<blockquote>
<p>  Serializable ：可避免上面的全部 （串行化）<br>  Repeatable read ：可避免 脏读、不可重复读  （可重复读） [mysql 默认]<br>  Read committed ：可避免脏读  （读已提交）    [oracle 默认]<br>  Read uncommitted : 最低级别，均无法保证  （读未提交）</p>
</blockquote>
<ul>
<li>设置隔离级别（仅当前窗口有效）<br><code>set transaction isolation level Read uncommitted;</code></li>
<li>查询当前隔离级别<br><code>select @@tx_isolation;</code></li>
</ul>
<p>别管其他窗口（连接）的隔离级别，你设置的最低你就有所有的问题！</p>
<p><a href="http://bfchengnuo.com/2016/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/">数据库中的事务</a></p>
<h2 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h2><p>这里指的一般是手动操作，关于表锁行锁，可以移步 <a href="https://github.com/bfchengnuo/MyRecord/issues/5" target="_blank" rel="noopener">这里</a> 进行查阅。</p>
<blockquote>
<p>lock tables 命令是为当前线程锁定表。<br>这里有 2 种类型的锁定，一种是读锁定，用命令 <code>lock tables tablename read</code>；<br>另外一种是写锁定，用命令 <code>lock tables tablename write</code>；下边分别介绍</p>
</blockquote>
<p>如果一个线程获得在一个表上的 read 锁，那么该线程和所有其他线程只能从表中读数据，不能进行任何写操作（等待）。<br><strong>注意：表必须为 Myisam 表，如果表为 innodb 表，它是事务型的，–single-transaction 是一个更好的选项，因为它不根本需要锁定表。</strong></p>
<p>如果一个线程在一个表上得到一个 WRITE 锁，那么只有拥有这个锁的线程可以从表中读取和写表，其它的线程被阻塞。</p>
<p>mysql 的 表锁 <code>lock tables</code> 感觉就像一个 封闭的空间；<br>mysql 发现 <code>lock tables</code> 命令的时候，会将带有锁标记的表带入封闭空间，直到出现 <code>unlock tables</code> 命令<strong>或线程结束</strong>，才关闭封闭空间。<br>进入封闭空间时 , 仅仅只有锁标记的表可以在里面使用，其他表无法使用。</p>
<p>原文参考：<a href="https://www.cnblogs.com/youxin/p/3584370.html" target="_blank" rel="noopener">https://www.cnblogs.com/youxin/p/3584370.html</a></p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>从5.6+的版本开始吧，MySQL 官方就支持集群功能了，为的是解决读库压力过大，使用读写分离<br>也就是说只有一个主库负责写，其他的从库负责分担读的需求，这样的话就会有两种实现，一类是利用应用层的判断来确定是操作那个数据库（Spring 的 AOP 已经很好的支持），一类就是使用中间件，但是目前并没有太好的中间件。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>原理：<br>master 将数据改变记录到二进制日志(binary log)中,也即是配置文件 log-bin 指定的文件(这些记录叫做二进制日志事件，binary log events)；slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)；最后 slave 重做中继日志中的事件,将改变反映它自己的数据(数据重演)</p>
<blockquote>
<p>需要注意的问题<br>1.、主DB server和从DB server数据库的版本一致<br>2、主DB server和从DB server数据库数据一致[ 这里就会可以把主的备份在从上还原，也可以直接将主的数据目录拷贝到从的相应数据目录]<br><strong>3、主DB server开启二进制日志,主 DB server 和从 DB server 的 server_id 都必须唯一</strong></p>
</blockquote>
<p>下面就具体的操作，首先在主 MySQL 的 ini 配置文件中配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启主从复制，主库的配置</span></span><br><span class="line"><span class="attr">log-bin</span> = mysql3306-bin</span><br><span class="line"><span class="comment">#指定主库serverid</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">101</span></span><br><span class="line"><span class="comment">#指定同步的数据库，如果不指定则同步全部数据库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=mybatis</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>SHOW MASTER STATUS</code> 来查询状态，记录 Position 值，在从库里会用到<br>并且最好是单独创建一个同步的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to &apos;slave01&apos;@&apos;127.0.0.1&apos; identified by &apos;123456&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>从库的 ini 没什么可配置的，如果一台机子有多台 MySQL 除了设置端口不同还要设置 server-id 不同，就是上面设置的那个<br>然后执行下面的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line"> master_host=<span class="string">'127.0.0.1'</span>,</span><br><span class="line"> master_user=<span class="string">'slave01'</span>,</span><br><span class="line"> master_password=<span class="string">'123456'</span>,</span><br><span class="line"> master_port=<span class="number">3306</span>,</span><br><span class="line"> master_log_file=<span class="string">'mysql3306-bin.000006'</span>,</span><br><span class="line"> master_log_pos=<span class="number">1120</span>;</span><br><span class="line"></span><br><span class="line">#启动slave同步</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</span><br><span class="line"></span><br><span class="line">#查看同步状态</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">SLAVE</span> <span class="keyword">STATUS</span>\G;</span><br></pre></td></tr></table></figure>
<p>当看到两个 yes 就证明是配置成功了。<br>如果是在一台机器做测试，记得 UUID 也不能相同，在  <code>data/data/auto.cnf</code> 目录下</p>
<p>PS：这样的架构只能解决读库压力大的情况，如果是写库压力大可以尝试的方案有：</p>
<ul>
<li>使用缓存（不推荐，同步问题不好解决）</li>
<li>多表、多库存储（查询效率会拖慢）</li>
<li>使用队列（推荐）</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>插入数据的时候可以一句插入多条：<code>insert test(id) values(&#39;1&#39;),(&#39;2&#39;);</code>，类似这样，注意没有into了哦</p>
<p>所有的聚合函数都会忽略 Null 值，并且使用 <code>count(1)</code> 比使用 <code>count(*)</code> 效率高很多（HQL 就不支持）</p>
<p>有时会见到 SQL 语句中有 comment 之类的关键字，比如：<code>name varchar(50) DEFAULT NULL COMMENT &#39;资源名称&#39;,</code> ；其中的 comment 后面跟的是注释说明</p>
<p>Key 是索引约束，对表中字段进行约束索引的（<code>KEY cid (&#39;cid&#39;)</code>）</p>
<blockquote>
<p>索引能够提高 SELECT 查询和 WHERE 子句的速度，但是却降低了包含 UPDATE 语句或 INSERT 语句的数据输入过程的速度。索引的创建与删除不会对表中的数据产生影响。<br>对需要排序的字段或者根据其进行搜索的字段创建索引是比较合适的</p>
</blockquote>
<p>更多待补充</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySql修改密码与密码重置]]></title>
      <url>http://bfchengnuo.com/2017/02/13/MySql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E4%B8%8E%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>忘密码这种事，常有的事~~o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br>不过我至少设置的密码复杂性还可以~以至于我每次都不可能猜对…..<br><a id="more"></a></p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>MySQL 的“root”用户默认状态是没有密码的，所以在 PHP 中您可以使用<code>mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;)</code>来连接 MySQL 服务器；</p>
<p>如果您想为 MySQL 中的“root”用户设置密码，请在控制台中使用“mysqladmin”命令。例如：</p>
<p><code>mysqladmin.exe -u root password 123456</code></p>
<p>另外，如果是先前有密码，则修改命令为：</p>
<p><code>mysqladmin.exe -u root -p password 123456</code></p>
<p>回车后提示你输入当前密码，确认后会被修改为新密码</p>
<h2 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h2><p>因为我用的是centOS，所以我使用第一种方法成功重置了，其他的没测试</p>
<h3 id="安全模式重置法"><a href="#安全模式重置法" class="headerlink" title="安全模式重置法"></a>安全模式重置法</h3><p>基本的思路是，以安全模式启动mysql，这样不需要密码可以直接以root身份登录，然后重设密码。<br>首先，我们停掉MySQL服务：<code>service mysql stop</code></p>
<blockquote>
<p>  上面的命令适用于Ubuntu和Debian。CentOS、Fedora和RHEL下使用<strong>mysqld替换mysql</strong>。</p>
</blockquote>
<p>以安全模式启动MySQL：<br><code>mysqld_safe --skip-grant-tables --skip-networking &amp;</code></p>
<p>注意我们加了<code>--skip-networking</code>，避免远程无密码登录 MySQL。<br>这样我们就可以直接用root登录，无需密码：<code>mysql -u root</code><br>接着重设密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> use mysql;</span><br><span class="line"><span class="meta">mysql&gt;</span> update user set password=PASSWORD("mynewpassword") where User='root';</span><br><span class="line"><span class="meta">mysql&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>
<p>注意，命令后需要加分号。<br>重设完毕后，我们退出(quit 或者 exit)，然后启动 MySQL 服务：<br>重启服务：<code>service mysql restart</code></p>
<blockquote>
<p>  同样，以上命令适用于Ubuntu和Debian，Centos、Fedora和RHEL需要用<strong>mysqld替换mysql。</strong></p>
</blockquote>
<p>现在可以尝试用新密码登录了：<code>mysql -u root -pmynewpassword</code></p>
<blockquote>
<p>  注意，<code>-p</code> 和密码间不能有空格。<br>  推荐使用<code>mysql -u root -p</code>然后回车再输密码</p>
</blockquote>
<h3 id="win下安全模式重置"><a href="#win下安全模式重置" class="headerlink" title="win下安全模式重置"></a>win下安全模式重置</h3><p>首先也是先停掉服务：<code>net stop mysql</code><br>然后cd进入mysql的安装目录下的bin目录执行：<code>mysqld.exe --skip-grant-tables</code><br>然后再打开一个命令行，登陆mysql，这时候密码是空了接着重设密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> use mysql;</span><br><span class="line"><span class="meta">mysql&gt;</span> update user set password=PASSWORD("mynewpassword") where User='root';</span><br><span class="line"><span class="meta">#</span> 在mysql5.7以上可能没有password这个字段了新名字叫 authentication_string；所以是下面的语句</span><br><span class="line"><span class="meta">#</span> update user set authentication_string=PASSWORD("mynewpassword") where User='root';</span><br><span class="line"><span class="meta">mysql&gt;</span> flush privileges;</span><br></pre></td></tr></table></figure>
<p>然后进任务管理器结束所有mysql的服务进程，再打开下mysql服务即可</p>
<h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p><strong>在Ubuntu和Debian系统上</strong>，有一个<code>debian-sys-maint</code>用户，Debian类系统下一些系统脚本对mysql的操作是通过这个用户完成的。所以我们可以通过这个用户来修改 root 密码。该用户的密码可以在<code>/etc/mysql/debian.cnf</code>下找到<br>登陆后执行<code>sudo mysql -u debian-sys-maint -p</code>重置即可</p>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-异常与IO]]></title>
      <url>http://bfchengnuo.com/2017/02/12/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E4%B8%8EIO/</url>
      <content type="html"><![CDATA[<p>感觉已经差不多了，必须要实战下了，当时还是为了爬虫学的，现在发现搞数据挖掘也挺好/火<br>然而….还是等熟练了再说吧<br>最近好浮躁啊啊啊！！<br><a id="more"></a></p>
<h2 id="错误-异常处理"><a href="#错误-异常处理" class="headerlink" title="错误/异常处理"></a>错误/异常处理</h2><p>有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。<strong>这类错误也称为异常</strong>，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。<br>Py使用<code>try...except...finally...</code>的错误处理机制，一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>
<p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。<br>错误有时不会只有一个，所以可以使用多个except进行处理；所有的错误类型都继承自BaseException这个类<br>继承关系：<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a><br>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<br>不过报错信息貌似是从下往上看，有点和其他不一样….（调用XX出错，在X行，原因是第X行  :雾）<br>另外一种形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> XXXError,e:</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> XXXError,e:</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>使用<code>try except else</code> 语句，当有异常是会执行except的语句，如果没有异常，则会执行else的语句<br>或者可以进行简写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> xxx <span class="keyword">as</span> f:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>xxx其实就是一个类，返回的值存在f中，可以是多个用元组就可以了，比如：<code>open(xx)</code>,返回的是file对象，会自动进行关闭操作(无论是否发生了异常)，不需要手动关闭<br>又叫做上下文管理器，执行时调用<code>__enter__</code>方法，返回值存在f；退出时执行<code>__exit__</code>方法(发生异常也执行)</p>
<h3 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h3><p>Python内置的logging模块可以非常容易地记录错误信息，主要代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	bar(<span class="string">'0'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	logging.exception(e)</span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>
<p>同样是出错，但程序打印完错误信息后会继续执行，并正常退出。通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>raise 主动抛出异常；格式：<code>raise TypeError,&quot;描述&quot;</code>，或者抛一个异常对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(s)</span>:</span></span><br><span class="line">    n = int(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> FooError(<span class="string">'invalid value: %s'</span> % s) <span class="comment"># 异常描述</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p><code>raise</code>语句如果不带参数，就会把当前异常原样抛出。此外，在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的异常转化成另一种类型</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>assert 断言语句，一个简单的使用例子：<code>assert 0==1 &quot;描述&quot;</code>会抛出一个assert异常，也就是说，如果后面的判断不成立就会抛出异常<br>启动Python解释器时可以用<code>-O</code>参数来关闭assert：<code>$ python3 -O err.py</code>；关闭后，你可以把所有的assert语句当成pass来看。</p>
<h3 id="使用logging"><a href="#使用logging" class="headerlink" title="使用logging"></a>使用logging</h3><p>和assert比，logging不会抛出错误，而且可以输出到文件；<br>它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，debug和info就不起作用了。<br>是不是和某Log比较相似…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure>
<p>logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p>
<h3 id="pdb单步调试"><a href="#pdb单步调试" class="headerlink" title="pdb单步调试"></a>pdb单步调试</h3><p>其实就是单步调试，最好还是使用IDE<br>手动的话就是：<code>$ python3 -m pdb err.py</code><br>输入命令<code>l</code>来查看代码；<br>输入命令<code>n</code>可以单步执行代码；<br>任何时候都可以输入命令<code>p 变量名</code>来查看变量；<br>输入命令<code>q</code>结束调试，退出程序</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，<strong>现代操作系统不允许普通的程序直接操作磁盘</strong>，所以，读写文件就是请求操作系统打开一个<strong>文件对象</strong>（<em>通常称为文件描述符</em>），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>打开一个文件对象就是<code>open(&quot;name&quot;,&quot;role&quot;)</code>，关于权限，常用的有这几种：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>只读，文件必须存在，否则会抛异常</td>
</tr>
<tr>
<td>w</td>
<td>只写，文件不存在时创建文件，存在则清空文件内容</td>
</tr>
<tr>
<td>a</td>
<td>追加，文件不存在时创建文件</td>
</tr>
<tr>
<td>r+</td>
<td>打开文件会保持原文件内容不变，同样可以同时对文件进行读写,覆盖追加</td>
</tr>
<tr>
<td>w+</td>
<td>打开文件会将原文件内容删除，可以同时对文件进行读写</td>
</tr>
<tr>
<td>a+</td>
<td>追加和读写方式</td>
</tr>
<tr>
<td>rb,wb,ab,rb+,wb+,ab+</td>
<td>二进制方式打开(读取图片等)</td>
</tr>
</tbody>
</table>
<p>拿到文件对象后就可以进行读取内容了，可以使用<code>read([size])</code>读取内容，也可以使用<code>readline([size])</code> 读取一行;使用<code>readlines([size])</code> <strong>读取完缓冲区左右（io.DEFAULT_BUFFER_SIZE），返回每一行组成的列表</strong>.<br>最后一步是调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的，但是有可能没有关闭之前出现了异常，所以最好放在<code>try ... finally</code>里<br>可以直接使用<code>for in</code>来读取file对象的每行的数据</p>
<h3 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h3><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>
<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入encoding参数，例如:<code>open(&#39;./gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)</code>；如果遇到非法编码的字符，<code>open()</code>函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略:<code>open(&#39;./gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)</code></p>
<h3 id="写入到文件"><a href="#写入到文件" class="headerlink" title="写入到文件"></a>写入到文件</h3><p>还是用的open这个函数，但是权限不同了，上面的表已经写的很明白了<br>你可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。<strong>当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。</strong>只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用<code>close()</code>的后果是数据可能只写了一部分到磁盘，剩下的丢失了。当然也可以使用flush进行刷新；所以，还是用<code>with</code>语句来得保险：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/test.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'Hello, world!'</span>)</span><br></pre></td></tr></table></figure>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。</p>
<p>使用with语句操作文件IO是个好习惯。</p>
<h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p><code>seek()</code>函数<br>接受2个参数：1.偏移量 2.相对偏移位置</p>
<p><code>file.tell()</code> 返回文件的偏移<br>os.SEEK_SET：相对文件起始位置<br>os.SEEK_CUR：当前位置<br>os.SEEK_END：末尾位置</p>
<p>例子：<br><code>f.seek(0,os.SEEK_SET)</code>：使文件指针回到开始位置；<br><code>f.seek(-5,os.SEEK_CUR)</code>：从后向前移动5个字节<br><code>f.seek(0,os.SEEK_END)</code>：将文件指针移到最后</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><blockquote>
<p>  file.fileno()  文件描述符<br>  .mode  文件打开权限<br>  .closed  是否正确关闭<br>  .enconding  编码方式</p>
<p>  文件标准输入：sys.stdin；<br>  raw_input()该函数是从命令行接受输入，回车终止，可以传一个提示参数str<br>  文件标准输出：sys.stdout；<br>  文件标准错误：sys.stderr;</p>
<p>  sys模块提供sys.argv属性,通过该属性可以得到命令行参数;<br>  sys.argv:字符串组成的列表，第一个参数多为文件名<br>  codecs模块支持open指定编码</p>
</blockquote>
<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>StringIO顾名思义就是在内存中读写str。下面是个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">' '</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'world!'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>
<p><code>getvalue()</code>方法用于获得写入后的str。要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">'Hello!\nHi!\nGoodbye!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>    s = f.readline()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure>
<h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f.getvalue())</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure>
<p>请注意，写入的不是str，而是经过UTF-8编码的bytes。和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取.</p>
<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><p>我们也是可以使用OS模块打开文件的（更贴近底层以及为了跨平台），有更多的方法，先把常用的方法列一下</p>
<blockquote>
<p>  os.open(filename, flag [,mode]):打开文件<br>  flag打开方式：<br>  os.O_CREAT:创建文件<br>  os.O_RDONLY:只读方式打开<br>  os.O_WRONLY:只写方式打开<br>  os.O_RDWR:读写方式打开</p>
<p>  os.read(fd, buffersize):读取文件<br>  os.write(fd, string):写入文件<br>  os.lseek(fd, pos, how): 文件指针操作<br>  os.close(fd):关闭文件</p>
<p>  os.access(path, mode)： F_OK, R_OK ,W_OK, X_OK  判断是否有权限<br>  os.listdir(path)： 返回当path路径下所有文件名组成的列表<br>  os.remove(path)：删除文件<br>  os.rename(old, new)：修改文件或者目录名<br>  os.mkdir(path[, mode])：创建目录<br>  os.makedirs(path[, mode])：创建多级目录<br>  os.removedirs(path)：删除多级目录<br>  os.rmdir(path)：删除目录(目录必须空目录)</p>
<p>  os.path.exists(path)：当前路径是否存在   |  也可以判断是否有该文件<br>  os.path.isdir(s)：是否是一个目录<br>  os.path.isfile(path)：是否是一个文件<br>  os.path.getsize(filename)：返回文件大小  | 返回目录文件大小<br>  os.path.dirname(p)：返回路径的目录<br>  os.path.basename(p)：返回路径的文件名<br>  os.path.split()：拆分出前面的路径和最好一级目录或文件<br>  os.path.splitext()：拆分文件后缀名</p>
<p>  os.name()：系统类型 posix/nt<br>  os.uname()：查看系统信息<br>  os.environ：环境变量（可以指定key比如：os.environ.get(‘PATH’)）</p>
</blockquote>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Python提供了pickle模块来实现序列化。使用前注意Py的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(d)</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object.<br>当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个file-like Object中直接反序列化出对象。</p>
<p>为了方便在不同语言间传递，我们一般序列化为XML或者JSON格式，JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/" target="_blank" rel="noopener">关于with详细解释</a><br><a href="http://www.liaoxuefeng.com" target="_blank" rel="noopener">http://www.liaoxuefeng.com</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图片藏文件的实现及原理]]></title>
      <url>http://bfchengnuo.com/2017/02/07/%E5%9B%BE%E7%89%87%E8%97%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>无意中看到了这个，虽然很早之前就已经用烂了，但是我也只是略懂怎么回事而已，今天就好好深入挖掘下吧<br><del>也许…老司机发车必备吧….</del><br><a id="more"></a></p>
<h2 id="尾部追加法"><a href="#尾部追加法" class="headerlink" title="尾部追加法"></a>尾部追加法</h2><p>这是最简单的一种方法，当然藏个小文本<del>、种子</del>之类的还是挺好的，不要想藏个病毒了，稍微有点电脑基础就能分辨出来；</p>
<p>先来说个例子：现在有两个文件，<code>1.jpg</code>和<code>2.zip</code>，现在要把<code>2.zip</code>文件藏在<code>1.jpg</code>这张图里，并且要可以查看，只需要进入cmd进入到当前目录执行：<code>copy/b 1.jpg+2.zip 3.jpg</code><br>这样就会得到<code>3.jpg</code>这个图片文件，可以正常查看，大小是两个文件的之和，如果用压缩软件打开这个文件(改个后缀也可以，用rar直接打开也可以)就会看到<code>2.zip</code>里的内容。<br>至此，老司机就可以去发车了。最好使用“最大压缩”的选项。</p>
<blockquote>
<p>  部分测试结果：<br>  把ZIP和RAR文件添加到JPG/BMP/GIF/PNG，没有问题，全部可以实现。<br>  把TXT添加到图像格式里，用记事本打开，在乱码的最后能隐约看到原来文件的样子，英文都能看到，中文全是乱码。<br>  把ZIP/RAR添加到PDF里，也能通过。<br>  把 ZIP/RAR添加到MP3/WMA/MID里，添加完后的音频不受影响，但ZIP/RAR打不开了，没有意义。<br>  别的格式没有多试。</p>
</blockquote>
<p>下面说原理</p>
<p><code>copy/b</code>的作用是把两个文件首尾接起来，串个串。一般情况下，这样会破坏2个文件，造成无法读取，其实，<strong>能不能读全看程序怎么处理文件和文件本身的格式。</strong><br>有人说是因为图像格式的文件大小定义在头部，而RAR格式的文件大小定义在尾部，所以2个文件共存才没有冲突。不知道对不对，google一下，查了BMP的文件格式，BMP文件简单来说分4个部分，<strong>文件头+图像头+颜色表+数据区</strong>，具体格式在<a href="http://web.uccs.edu/wbahn/ECE1021/STATIC/REFERENCES/bmpfileformat.htm" target="_blank" rel="noopener">这里</a>可以看到。文件头部分有bfSize是定义整个文件大小，就是从文件头开始到数据区结束的总大小，也就是说，超出这个偏移的数据对文件来说没有意义，读图的程序也不会去理会，程序只读取bfSize里定义的那么多数据，别的一概不管。<br>而RAR格式呢，由于是私有格式，我只能查到一点点信息，<a href="http://www.win-rar.com/index.php?id=24&amp;kb=1&amp;kb_article_id=162" target="_blank" rel="noopener">这里</a>解释了一部分格式的定义，由此我的理解是RAR文件内部以区块为单位，数据以区块存储，区块数量和大小不定，但必须包含几个特定区块，用来保存基本信息，所有数据分段的保存在大量区块中，类似IP数据包，<strong>而每个区块有独立的大小定义以及类似链表的关联定义，每个区块的大小都可知且独立。</strong>这样推测WinRAR读取文件的过程是先查找，再验证，再读取，也就是说找到区块，读取大小和类型信息后把整个区块的数据读出来，而区块外，区块间的数据对WinRAR来说无意义。<br>这样就好解释之前的方法了，图像程序对于头部定义的大小之外的数据不管，WinRAR对于区块外的数据，也就是图像的数据不管，2个互相不管，各读各的，当然可以共存。推而广之，2种格式类似以上情况的都可以共存。</p>
<h2 id="内容覆盖法"><a href="#内容覆盖法" class="headerlink" title="内容覆盖法"></a>内容覆盖法</h2><p>通常来说，图片文件都有包含2部分：文件头和数据区。而“内容覆盖法”，就是把要隐藏的文件，直接<strong>覆盖</strong>到图片文件的<strong>数据区</strong>的<strong>尾部</strong>。比方说，某图片有 100KB，其中文件头占 1KB，那么，数据区就是 99KB。也就是说，最多只能隐藏 99KB 的文件。<br>切记：覆盖的时候，千万不可破坏文件头。文件头一旦破坏，这个图片文件就不再是一个合法的图片文件了。<br>使用这种方法，对图片文件的格式，是有讲究的——最好用<strong>24位色的 BMP 格式</strong>。为啥捏？一来，BMP 格式本身比较简单，数据区随便覆盖，问题不大；二来，24位色的 BMP 相对其它的格式 BMP，文件尺寸更大，可以隐藏更多内容。</p>
<h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><p>这种方法当然是不能和上面那样一句命令就能完成的，需要一些专用工具，或者可以写个Py脚本，很简单，有点编程基础的就可以看懂.<br>如下代码没有严格计算 BMP 的文件头尺寸，俺只是大致预留了 1024 字节，感觉应该够了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">embed</span><span class="params">(container_file, data_file, output_file)</span> :</span></span><br><span class="line">    container = open(container_file, <span class="string">"rb"</span>).read()</span><br><span class="line">    data = open(data_file, <span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(data)+<span class="number">1024</span> &gt;= len(container) :</span><br><span class="line">        print(<span class="string">"Not enough space to save "</span> + data_file)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        f = open(output_file, <span class="string">"wb"</span>)</span><br><span class="line">        f.write(container[ : len(container)-len(data)])</span><br><span class="line">        f.write(data)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__ :</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="keyword">if</span> len(sys.argv) == <span class="number">4</span> :</span><br><span class="line">            embed(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            print(<span class="string">"Usage:\n%s container data output"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err :</span><br><span class="line">        print(err)</span><br></pre></td></tr></table></figure>
<h3 id="提取方法"><a href="#提取方法" class="headerlink" title="提取方法"></a>提取方法</h3><p>如果是藏的压缩文件，直接用rar打开即可，文件大小还不会发生变化哦<br>不过由于隐藏的文件覆盖了数据区，因此，图片在显示的时候，会有一块区域变成灰蒙蒙的（如果遭遇“肉眼审查”，可能会引起怀疑）</p>
<h2 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h2><p>这是一种比较高级的方法了，搞信息安全的可能比较熟<br>此方法会涉及较深奥的技术领域，本人实在能力有限。通俗地说：如果把图片的某个像素的颜色，进行微小的调整，肉眼是看不出来的；因此，专门的软件，利用某些高深的算法，就可以在变化的像素中隐藏信息。<br>有兴趣的同学，可以看“<a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF" target="_blank" rel="noopener">这里</a>”的介绍；</p>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>这种方法一般也只能用专门的软件了；使用这种方法，你需要用专门的工具来进行信息的隐藏和提取。在进行隐藏时，你除了指定图片文件和被隐藏的文件，还需要设置一个密码。隐写工具会把你的隐藏文件先加密，然后再进行隐写；提取的时候，需要用同一款隐写工具进行提取，并输入同样的密码，才能提取出来。<br>假如图片文件落入攻击者手中，他必须同时知道2个信息（你用哪款隐写工具，你隐写时设置的密码），才有可能破解出隐含的信息。因此，安全性相当高。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>界面</th>
</tr>
</thead>
<tbody>
<tr>
<td>Silent Eye</td>
<td>开源</td>
<td>图形界面</td>
</tr>
<tr>
<td>Steg Hide</td>
<td>开源</td>
<td>命令行界面</td>
</tr>
<tr>
<td>Ultima Steganography</td>
<td>商业</td>
<td>图形界面</td>
</tr>
</tbody>
</table>
<p>这种方法虽然隐蔽性和安全性都很高，但是只能隐藏较少的信息（此方法能隐藏的信息量，和图片面积有关，和图片格式无关。比如一张 1600*1200 尺寸的，无论哪种格式，大约只能隐藏 几KB 的数据）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.fulin.org/2006/11/simple_hide_file/" target="_blank" rel="noopener">http://blog.fulin.org/2006/11/simple_hide_file/</a><br><a href="https://program-think.blogspot.com/2011/06/use-image-hide-information.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2011/06/use-image-hide-information.html</a><br><a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-面向对象]]></title>
      <url>http://bfchengnuo.com/2017/01/22/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>wiki上说Py的启发语言有C/C++、java等，果然语言都是想通的，定义形式上差不多~~<br>不过后面的一些特性确实厉害，不过….就是看不太懂 = =,要达到熟练使用的地步…(摊手)<br><a id="more"></a><br>我感觉出了：将Py比作是坦克很形象！</p>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>在Python中，定义类也是通过<code>class</code>关键字，类名通常是大写开头的单词，经典的student例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>括号中的object是表示该类是从哪个类继承下来的，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。<br>然后就是创建实例，Py中不需要new关键字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x10a67a590</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Student</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 绑定属性</span></span><br><span class="line">&gt;&gt;&gt; bart.name = 'Bart Simpson'</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br></pre></td></tr></table></figure>
<p>还可以自定义初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>
<p>注意到<code>__init__</code>方法的第一个参数永远是<strong>self</strong>，<strong>表示创建的实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。<br>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去，总的来说挺想构造函数的<br><strong>注意：相同名称的实例属性将屏蔽掉类属性</strong></p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是<strong>特殊变量</strong>，特殊变量是<strong>可以直接访问的</strong>，不是private变量</p>
<blockquote>
<p>  有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量<strong>外部是可以访问的</strong>，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>  双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>xxx._Student__name</code>来访问<code>__name</code>变量，但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。<br>  如果你确实使用了<code>bart.__name = xxx</code>这样的语句，确实不会报错，它真的会给bart增加一个<code>__name</code> 属性，但它不是内部的name变量，内部的name变量名叫<code>_xxx__name</code></p>
</blockquote>
<h2 id="动态语言和静态语言中的多态"><a href="#动态语言和静态语言中的多态" class="headerlink" title="动态语言和静态语言中的多态"></a>动态语言和静态语言中的多态</h2><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个可以调用的方法就可以了</p>
<blockquote>
<p>  动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
</blockquote>
<h2 id="进阶-slots相关"><a href="#进阶-slots相关" class="headerlink" title="进阶-slots相关"></a>进阶-slots相关</h2><p>给实例绑定属性很简单，直接点就行了，还可以给实例绑定方法，当然这些都是在这一个实例中有效而已</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span> <span class="comment"># 定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age(<span class="number">25</span>) <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age <span class="comment"># 测试结果</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加<code>name</code>和<code>age</code>属性。<br>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p>
<h2 id="进阶-使用-property"><a href="#进阶-使用-property" class="headerlink" title="进阶-使用@property"></a>进阶-使用@property</h2><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，如果使用get/set的方法实现感觉又太麻烦，记得前面学过装饰器，Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性<br><code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>) <span class="comment"># 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶-多继承与定制类"><a href="#进阶-多继承与定制类" class="headerlink" title="进阶-多继承与定制类"></a>进阶-多继承与定制类</h2><p>对，是的，Py是支持多继承的，用逗号分开即可，多继承的这种设计通常称之为MixIn。<br>我们知道以双下划线开头的都是特殊的，比如</p>
<ul>
<li><code>__str__()</code>返回用户看到的字符串，<code>__repr__()</code>返回程序开发者看到的字符串</li>
<li>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</li>
<li>如果要像list那样按照下标取出元素，就需要实现<code>__getitem__()</code>方法</li>
<li>当调用不存在的属性时(也就是找不到的时候)，Python解释器会试图调用<code>__getattr__(self, &#39;XXX&#39;)</code>来尝试获得属性，这个方法也是可以返回函数的，不过调用的时候要加()执行</li>
<li>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。(<code>name()</code>)<br>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</li>
</ul>
<h2 id="进阶-枚举类与元类"><a href="#进阶-枚举类与元类" class="headerlink" title="进阶-枚举类与元类"></a>进阶-枚举类与元类</h2><p>貌似3.5版本以后才支持呢，定义一个枚举类类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>, <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>, <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span>))</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了<strong>Month类型的枚举类</strong>，可以直接使用<code>Month.Jan</code>来引用一个常量，上面的定义等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    Jan = <span class="number">1</span></span><br><span class="line">    Feb = <span class="number">2</span></span><br><span class="line">    Mar = <span class="number">3</span></span><br><span class="line">    Apr = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>当然还有些高级用法，我没怎么看，因为感觉智商有点不够用</p>
<p>Py作为解释性语言，在执行的时候才会编译，所以动态生成类就有了可能，<code>type()</code>函数可以查看一个类型或变量的类型，同时也可以产生新的类，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(self, name=<span class="string">'world'</span>)</span>:</span> <span class="comment"># 先定义函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello = type(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br></pre></td></tr></table></figure>
<p>要创建一个class对象，<code>type()</code>函数依次传入3个参数：</p>
<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>
<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>
<blockquote>
<p>  除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br>  metaclass，直译为元类，简单的解释就是：<br>  当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>  但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。<br>  连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>  所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。<br>  metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</p>
<p>  <a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="noopener">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习笔记(二)]]></title>
      <url>http://bfchengnuo.com/2017/01/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>上一个实在是太多了，然而这篇就有点少….还剩下一丢丢<br>看完马上进入shell编程啦~~<br><a id="more"></a></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理主要就是查看和杀死吧，哈哈….<br>检测系统是否健康很重要</p>
<h3 id="查看进程-ps"><a href="#查看进程-ps" class="headerlink" title="查看进程-ps"></a>查看进程-ps</h3><p>查看进程用的ps命令，一般使用<code>ps aux</code>或者<code>ps -le</code>可以看到所有进程信息，前一种是没有<code>-</code>的，当然就算加上也不影响执行，会有行报错，原因是沿用了以前的BSD系列<br>ps列出来的是当时一瞬间的进程列表，不会时时刷新，然后是说下几个标识：</p>
<ul>
<li>VSZ：使用的虚拟内存</li>
<li>RSS：使用的物理内存</li>
<li>TTY：在那个终端机运作，显示？的一般是系统启动的，不是由终端启动的，ty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的就是远程登陆了</li>
<li>STAT：进程的状态</li>
<li>START：进程启动的日期</li>
<li>TIME：进程使用CPU的时间</li>
</ul>
<p>然后再详细说下状态这一栏，它是用英文字母作为标志，常用的各个的表示意思为：</p>
<ul>
<li>R：正在运行</li>
<li>D：不可中断</li>
<li>S：睡眠状态，可被某些信号唤醒</li>
<li>T：该程序目前正在侦测或者是停止了</li>
<li>Z：僵尸进程，该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</li>
<li>X：死掉的进程（一般不会看到）</li>
<li>+：位于后台的进程组</li>
<li>l：多线程</li>
<li>s：包含子进程</li>
<li>&lt;：高优先级</li>
<li>N：低优先级</li>
<li>L：有些页被锁进内存</li>
</ul>
<p>了解了上面的这些基本就能看懂了。</p>
<p>然后可以使用<code>pstree</code>来查看进程的树结构，加个<code>-p</code>可以展开来看，就是会比较多。</p>
<p>另外补充一个命令：lsof（list open files），这是一个列出当前系统打开文件的工具，在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件；感觉这个会比较有用！<br>例如你可以查看占用指定端口的程序：<code>lsof -i:8080</code></p>
<h3 id="查看进程-top"><a href="#查看进程-top" class="headerlink" title="查看进程-top"></a>查看进程-top</h3><p>top命令是个好东西，默认3秒刷新一次，当然是可以自己设定的，但是这个工具比较吃资源，所以3秒就可以了.<br>top命令前面会列出系统的状态信息，主要就是看这些啦<br>第一行：当前时间，系统已运行时间，登陆用户数，以及1分钟、5分钟、15分钟的负载情况。需要注意的是，系统负载最好不要超过你CPU的核心数，这当然也是个经验值，还要视具体情况<br>第二行：进程的一些信息，都看得懂<br>第三行：CPU的相关状态，us就是用户占用的资源，sy就是系统占用的资源，关键是看id空闲百分比，一般这个不要低于20%<br>第四行：内存的一些信息，总的、使用的、空闲的、缓存的<br>第五行：交换分区的信息，同内存差不多，最后一个是缓冲的</p>
<blockquote>
<p>  第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是<strong>内核还未纳入其管控范围的数量。</strong><br>  纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p>
</blockquote>
<p>关于缓存和缓冲区，其实都是在内存，缓存简单说就是把那些频繁从硬盘读的数据先存在内存中，以<strong>加快读取的速度</strong>；而缓冲相反，把需要往硬盘写的数据先存起来，最后一起写入硬盘，这样避免在硬盘频繁读写的时候加重其的负载<br>所以，如果真的要算可用内存，应该是free的加上缓冲和缓存区的大小</p>
<p>还有，top命令执行后是处于交换状态的，比如按q可以退出，c是显示完整的命令，M根据内存排序，P根据cpu进行排序，T就是根据时间排序</p>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><p>杀进程可用3个命令：kill / killall / pkill<br><code>kill -l</code>可以查看它的信号，比如9是强制结束，1是平滑重启（不会中断用户的连接），15是默认的正常结束<br>举个例子，比如平滑重启某个进程：<code>kill -HUP id</code>或者<code>kill -1 id</code>都可以<br>至于killall是杀死一类进程，按照进程名，kill只能杀死单个进程<br>pkill可以按照终端号进行“踢人”，<code>pkill -9 -t xx</code></p>
<h2 id="关于优先级"><a href="#关于优先级" class="headerlink" title="关于优先级"></a>关于优先级</h2><p>其实一般也用不到，了解下<br>NI一般就是指优先级 范围是：<strong>-20到19</strong>  普通用户只能<strong>0-19</strong><br>配合上面的进程管理命令，有个公式：<br><code>PRI(最终值) = PRI(原始值) + NI</code><br>至于设置优先级，可以使用<code>nice -n [-5] cmd</code>  但是不能修改已经存在的进程<br>如果非要修改存在的进程，那么使用<code>renice [-10] id</code><br>不过优先级无论怎么设，我们一般是感觉不出来的，CPU的速度太快了….</p>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>查看后台列表：<code>jobs [-l]</code><br>把进程放入后台的方式：</p>
<ol>
<li>命令后面加&amp;，这种方式会在后台执行</li>
<li>命令执行后按ctrl + z，这种方式放入后台会暂停</li>
</ol>
<p>需要说下的是，只要是要交互的比如vi、top无论你用那种方式放入后台，都是暂停状态</p>
<p>恢复(工作号在jobs查看)：<br><code>fg (%)工作号</code>  恢复到前台执行，%可省略<br><code>bg (%) 工作号</code>  后台暂停状态恢复到后台执行<br>如果工作号省略那就是执行最后一个加入的，带有<code>+</code>标识的，<code>-</code>是倒数第二个<br>这种方式后台会随终端的关闭而关闭，如果想不让他关闭那就需要加个nohup命令，类似：<br><code>nohup cmd &amp;</code></p>
<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><p>其实用top足够了，不过下面的几个资源占用可能小点<br><code>vmstat 1 3</code> 每隔1秒刷新，共3次<br>硬件状态：dmesg<br>查看内存情况：<code>free -m</code><br>查看CPU信息：<code>cat /proc/cpuinfo</code><br>以及top的精简版？：uptime<br>查看内核：<code>uname -a</code><br>可通过查看系统命令来判断系统是多少位的：<code>file cmd</code><br>文件被谁调用：<code>lsof | more</code>  [<code>-c</code>：进程被谁调用；<code>-u</code>被那个用户调用]</p>
<h2 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h2><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。也就是会遍历系统文件，如果是很大的范围比如<code>/</code>那就非常的消耗系统资源了，是完全匹配，常用的通配符有*、？、[]</p>
<blockquote>
<p>  <code>$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</code></p>
<ul>
<li>&lt;指定目录&gt;： 所要搜索的目录及其所有子目录。<strong>默认为当前目录。</strong></li>
<li>&lt;指定条件&gt;： 所要搜索的文件的特征。</li>
<li>&lt;指定动作&gt;： 对搜索结果进行特定的处理。</li>
</ul>
</blockquote>
<p>举个栗子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。</span><br><span class="line"><span class="meta">$</span> find . -name 'my*' -ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</span><br><span class="line"><span class="meta">#</span> atime 文件访问时间</span><br><span class="line"><span class="meta">#</span> ctime 改变文件属性</span><br><span class="line"><span class="meta">#</span> mtime 修改文件内容</span><br><span class="line"><span class="meta">$</span> find . -type f -mmin -10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查找没有所有者的文件</span><br><span class="line"><span class="meta">$</span> find /root -nouser</span><br><span class="line"><span class="meta">#</span> 按照所有者去搜索</span><br><span class="line"><span class="meta">$</span> find /root -user root</span><br><span class="line"><span class="meta">#</span> 当前目录下,大于25k的文件  M 默认单位是扇区</span><br><span class="line"><span class="meta">$</span> find . -size +25k</span><br><span class="line"><span class="meta">#</span> -a 表示and ；-o 表示or ，搜索大于25k小于10m的文件</span><br><span class="line"><span class="meta">#</span> -exec 和 &#123;&#125;\; 是固定写法，前面的搜出来的交给ls -lh执行，显示详细信息</span><br><span class="line"><span class="meta">$</span> find . -size +25k -a -size -10M -exec ls -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h3><p>locate命令其实是<code>find -name</code>的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库<code>（/var/lib/locatedb）</code>，这个数据库中含有本地所有文件信息。<br>Linux系统自动创建这个数据库，<strong>并且每天自动更新一次</strong>，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用<strong>updatedb</strong>命令，手动更新数据库。<br>比如：<code>$ locate -i ~/m</code> 就是搜索用户主目录下，所有以m开头的文件，并且忽略大小写</p>
<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>whereis命令<strong>只能用于程序名的搜索</strong>，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。如：<code>$ whereis grep</code></p>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>which命令的作用是，<strong>在PATH变量指定的路径中</strong>，搜索某个<strong>系统命令的位置</strong>，并且返回<strong>第一个搜索结果</strong>。也就是说，使用which命令，就可以<strong>看到某个系统命令是否存在</strong>，以及执行的到底是哪一个位置的命令。如：<code>$ which grep</code></p>
<h3 id="grep文本搜索"><a href="#grep文本搜索" class="headerlink" title="grep文本搜索"></a>grep文本搜索</h3><p>Linux 系统中 grep 命令是一种强大的文本搜索工具，它能<strong>使用正则表达式搜索文本</strong>，并把匹 配的行打印出来。grep 全称是 Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>grep 的工作方式是这样的，它在<strong>一个或多个文件中</strong>搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。<br>grep 可用于 shell 脚本，因为 grep 通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<p>前面已经说过它可以用于管道符过滤，类似这样：<code>cat test.txt | grep &quot;lock&quot;</code><br>还有一个很爽的作用是从多个文件中查找关键词：<code>grep -rn &quot;hello,world!&quot; *</code><br>下面就说一下参数的作用：</p>
<blockquote>
<p>  * ： 表示当前目录所有文件，也可以是某个文件名<br>  -r： 是递归查找<br>  -n：是显示行号，在显示符合样式的那一行之前，标示出该行的列数编号<br>  -R：查找所有文件包含子目录<br>  -i：忽略大小写<br>  -s：不显示错误信息<br>  -c ：计算找到 ‘搜寻字符串’ 的次数（列数）<br>  -v：显示不包含匹配文本的所有行<br>  -l：列出文件内容<strong>符合</strong>指定的样式的文件名称<br>  -L：列出文件内容<strong>不符合</strong>指定的样式的文件名称<br>  -F：将样式视为固定字符串的列表<br>  -G：将样式视为普通的表示法来使用</p>
</blockquote>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>一般来说，linux 服务器大多是通过 ssh 客户端来进行远程的登陆和管理的，使用 ssh 登陆 linux 主机以后，如何能够快速的和本地机器<strong>进行文件的交互</strong>呢，也就是上传和下载文件到服务器和本地。<br>使用之前记得安装 lrzsz 包：<code>yum -y install lrzsz</code><br>常用的命令有两个： </p>
<ul>
<li>sz：将选定的文件发送（send）到本地机器</li>
<li>rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到服务器(receive)</li>
</ul>
<p>rz，sz 是便是 Linux/Unix 同 Windows 进行 ZModem 文件传输的命令行工具(不支持文件夹)，当然需要客户端支持，Xshell 和 SecureCRT 都是支持的。<br>注意：<br>单独用 rz 会有两个问题：上传中断、上传文件变化（md5不同），解决办法是上传是用 <code>rz -be</code>，并且去掉弹出的对话框中“Upload files as ASCII”前的勾选。</p>
<p>详情参考：<a href="http://blog.csdn.net/k346k346/article/details/71515740" target="_blank" rel="noopener">http://blog.csdn.net/k346k346/article/details/71515740</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>补充个命令<strong>w</strong>，可以查看当前连接的终端，配合pkill使用很爽</p>
<p><code>/bin/sync</code> 把内存的数据向硬盘转移</p>
<hr>
<p>设置环境变量：编辑 <code>/etc/profile</code> 输入 G 跳转到最后一行，加上环境变量就行了<br>最后使用 <code>source /etc/profile</code> 让其生效</p>
<hr>
<p>通过 <code>id name</code> 可以查看用户的基本信息，组 id 之类的</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习笔记(一)]]></title>
      <url>http://bfchengnuo.com/2017/01/11/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>主要侧重下日常常用的命令，然后是基本的使用，并不涉及完整的功能，用到高级功能还是要去搜索啊….<br>有些命令是redhat系列专有的…写的有点混乱<br><a id="more"></a></p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>增加一个用户：<code>useradd 用户名</code><br>设置当前用户的密码（后面可跟用户名设置指定用户密码）：<code>passwd 密码</code><br>删除用户（加-r参数 删除用户目录）：<code>userdel 用户</code><br>创建用户组：<code>groupadd 组名</code><br>修改用户名：<code>usermod -l 新用户名 旧用户名</code><br>修改用户的组：<code>usermod -g 要加入的组名 用户名</code><br>添加附属组：<code>gpasswd -a userName groupName</code><br>锁定用户（ -u 解锁账户 -d 无密码登陆）：<code>passwd -l 用户名</code><br>切换用户，root可省略用户名：<code>su userName</code></p>
<p>显示当前登陆用户名：whoami<br>显示用户信息：<code>id name</code><br>显示组信息：<code>groups name</code></p>
<p>用户的密码都加密存在<code>/etc/passwd</code>,格式类似：<br><code>root:x:0:0:root:/root:/bin/bash</code><br><code>[用户名]:密码:UID:GID:身份描述:主目录:登录shell</code></p>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p>查看网络状态 ：<code>netstat</code> [-tuln 监听 -an全部]<br>登出：logout<br>查看路由：<code>netstat -rn</code><br>DNS查询：nslookup<br>端口探测（远程登陆不安全）：<code>telnet ip 端口</code><br>路由跟踪：<code>traceroute addrs</code></p>
<p>下载：<code>wget 下载文件URL</code><br>抓包：<code>tcpdump -i eth0 -nnX port 21</code> （[nn：ip端口显示；X：16进制拆分数据包；port：只查看21端口的）</p>
<p>启动ftp服务：<code>service vsftpd start</code></p>
<p>下载文件(远程机用户名@IP:路径 本地路径)<br><code>scp [-r] name@ip:src locaSrc</code><br>上传文件<br><code>scp [-r] file name@ip:src</code></p>
<p>setup命令可以配置一些常见配置，如ip，图形化界面，redhead系列特有<br><a href="http://bfchengnuo.com/2016/03/22/SSH%E8%BF%9E%E6%8E%A5VBOX%E7%9A%84ubuntu/">手动配置IP看这里</a></p>
<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>已安装的软件都在<code>/var/lib/rpm/</code>中的数据库中<br>安装命令：<code>rpm -ivh 包全名</code> (参数：安装、详细信息、显示进度)<br>其他参数：<br>-U 升级跟包全名<br>-e 卸载<br>-q 查询包信息<br>-qa 全部的已安装包<br>-qi 查询详细信息<br>-qip 未安装包<br>-ql 安装的文件<br>-qf 文件属于那个包<br>-V 校验</p>
<p>上面的是手动安装，碰到依赖很多的包是很烦人的，所以就有了yum：<br>yum list<br>yum search 关键字<br>yum -y install name<br>yum -y update [xxname]<br>yum -y remove name<br>yum clean (清缓存)</p>
<p>源码包一般放在 <code>/usr/local/src/name</code><br>安装在 <code>/usr/local/name</code></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>u-用户 g-组 o-其他<br>权限（读写执行）对应：r=4 、w=2(不包括删除) 、x=1<br><strong>权限是对下一层的描述，文件的权限就是对文件中数据的描述，目录权限是对文件的描述</strong><br>常用：最高权限：777，一般文件：644，可执行文件：755<br>目录最高权限：w 文件最高权限：x<br>目录有效权限：0、5、7<br>命令：chmod [-R]<br><code>chmod u+x,g-x,o=rw xxx</code> [a=all]</p>
<p>修改所有者：<code>chown user file</code><br>修改用户组 ：<code>chgrp group file</code> chown命令也可以：<code>chown user:group</code>  除了用<code>:</code>，<code>,</code> 、 <code>.</code>都可以</p>
<p>umask  用来查看默认权限  第一个是特殊权限（写在后面）<br>文件默认权限是 666  目录是 777；在<code>/etc/profile</code>中定义</p>
<p>PS：配合下面的 sudo 权限，使用：<code>chmod u+s xxName</code> 命令可以让某个可执行文件在运行时拥有 root 权限，在运行完毕后撤销 root 权限</p>
<h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><p>用来解决用户身份不够的问题，可以针对单一用户或组来设置特定的权限，递归时会导致权限溢出，尽量少用<br>查看分区ACL权限是否开启(挂载了ACL)：<code>dumpe2fs -h /dev/sda</code><br>显示：<code>Default mount options:    user_xattr acl</code>即为可用</p>
<blockquote>
<p>  dumpe2fs命令是查询指定分区详细文件系统信息的命令<br>  -h：仅显示超级块中信息，而不显示磁盘块组的详细信息</p>
</blockquote>
<p><strong>临时开启分区ACL权限：</strong><br>重新挂载根分区，并挂在加入ACL权限：<code>mount -o remount,acl /</code><br><strong>永久开启ACL权限：</strong><br>修改文件<code>/etc/fstab</code>在默认文件系统后加上acl即可</p>
<blockquote>
<p>  UUID=24f28fc6-717e-4bcd-a5f7-32b959024e26 /   ext4 defaults,<strong>acl</strong>  0   1</p>
</blockquote>
<p>重新挂载：<code>mount -o remount /</code><br>查看(带+的是有ACL权限的)：<code>getfacl fileName</code><br>设定：<code>setfacal -m u:name:rx [-R] file</code>   [m:设定，u:给用户设定，g:给组设定]<br>添加默认ACL权限：<code>setfacal -m d:u:name:rx [-R] file</code><br>mask 最大有效权限，设定的权限和它做逻辑与运算得到的结果是实际权限<br>修改mask：<code>-m m:rx fileName</code><br>-x 删除<br>-b 删除所有</p>
<h3 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h3><p>root把只能超级用户执行的权限赋予普通用户执行<br><strong>sudo的操作对象是系统命令</strong><br>设置sudo，权限：visudo<br>实际修改的是 <code>/etc/sudoers</code></p>
<p>格式：<code>root    ALL=(ALL)       ALL</code><br>root：指定个那个用户赋予sudo，前面加%就是给用户组设置<br>第一个ALL：被管理的电脑IP(可以在那台电脑运行sudo命令)<br>第二个ALL：可切换的身份，ALL就是可切换为任意用户，可省略<br>第三个ALL：可以执行的命令，绝对路径，如：/sbin/；写的越详细越安全，参数也限制，可使用通配符<code>!</code>之类，多个条件以<code>,</code>分隔<br><code>sudo -l</code>  查看可以执行的sudo命令</p>
<h3 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h3><p>不要自己去设置，系统会用到</p>
<ul>
<li><p>SUID/SetUID</p>
<p><strong>必须是可执行文件  拥有X权限</strong><br>SUID权限是第一个，代号s，数字表示4，其他操作和其他权限(基本权限rwx)类似<br><strong>执行此程序会变成文件的所有者</strong></p>
</li>
<li><p>SGID/SetGID</p>
<p>  对于文件，要求和SUID一样<br>  权限显示S是无限的权限，有效权限是小s=S+x<br>  <strong>执行文件时，组身份变成文件的所属组</strong><br>  赋予：g+s或者2755<br>  对于目录，<strong>必须拥有r和x</strong>，在目录中创建文件所属组都是上级目录的组，而不是登陆用户的组</p>
</li>
<li><p>SBIT/sticky BIT</p>
<p>  <strong>只能是目录</strong>，其他人需要有最高权限<br>  赋予：o+t 或者1755，<strong>普通用户只能删自己的文件</strong></p>
</li>
<li><p>chattr(不可改变位权限)<br>  <code>chattr +i</code> (insert) 被锁定，不能任何修改(对于目录就是不能新建和删除)。root也不可以<br>  <code>chattr +a</code> (append) 不能删，只能增加。增加只能用输出重定向 <code>&gt;&gt;</code>  不能用vi<br>  查看权限：lsattr -a 查看所有文件和目录 -d 查看目录权限</p>
</li>
</ul>
<h2 id="计划任务crontab"><a href="#计划任务crontab" class="headerlink" title="计划任务crontab"></a>计划任务crontab</h2><p>服务是否启动 <code>service crond status</code><br>查看当前用户任务列表： <code>crontab -l</code><br>服务大部分后面会加个d，如果没有安装，安装命令：<br><code>yum install vixie-cron</code><br><code>yum install crontabs</code><br>添加任务（当前用户）：<code>crontab -e</code>  [<strong>-e -u</strong>：指定给用户添加]/[<strong>-l -u</strong>：查看某个用户任务]<br>系统级计划任务在<code>/etc/crontab</code>；用户的配置文件在<code>/var/spool/cron/root</code>或者<code>/var/spool/cron/tabs/root</code><br>执行<code>crontab -e</code>实际上是修改<code>/var/spool/cron/root</code>下面对应当前账号的文件。<br>系统服务crond会每分钟从配置文件刷新定时任务、执行<br>它还存在白名单和黑名单(都是对用户来说)：<br>crontab .allow 白名单（优先，默认不存在）<br>crontab .deny  黑名单（默认存在）</p>
<p>格式：<code>* * * * * cmd</code><br>分钟 小时 日期 月份 星期 命令<br><code>0-59  0-23 1-31 1-12 0-7  *</code>就是每分钟、小时、、、<br>多个使用逗号分割 ;范围使用<code>-</code><br><code>*/2</code> 每隔 2 分钟；1-59/2 从 1 开始每隔 2 分钟(奇数)<br><code>*</code> 就是所有时间都匹配</p>
<p>除了使用<code>crontab -e</code>进行添加，还可以将脚本复制到<code>/etc/cron.{daily.weekly...}</code>中的任意一个文件夹下，分别每天、周、月执行【推荐】<br>这种方式其实是使用的anacron，它会检测<code>/etc/cron.{daily.weekly...}</code>和<code>/etc/crontab</code>中的文件是否在系统关机的过程中错过的定时任务,通过命令添加的是不会进行检测的。</p>
<p><code>/var/spool/anacron/con.{daily.weekly…}</code>内存着最后一次crontab的时间，如果当前时间到记录的时间差大于指定的差值，证明有命令漏执行，就会被anacron进行随机延迟执行，配置文件在<code>/etc/anacrontab</code>可以设置延迟的最大时间，所以这种方式有个缺点就是不知道什么时候执行</p>
<p>所有定时任务的日志保存在<code>/var/log/cron</code></p>
<h2 id="定时任务at"><a href="#定时任务at" class="headerlink" title="定时任务at"></a>定时任务at</h2><p>总体和crontab差不多，只不过它是只执行一次的，首先也是看服务有没有运行，服务名是atd<br>同样存在白名单和黑名单：<br>at.allow 白名单（优先，默认不存在）<br>at.deny  黑名单 （默认存在）</p>
<p><code>at now +5 minutes</code>然后输入执行的命令就行了，ctrl + d 退出<br>atq 查询<br><code>at -c id</code> 查看具体内容<br>atrm 删除</p>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>runlevel 是系统运行级别<br>init X 是设置系统级别</p>
<p>查看系统自启服务 RPM包服务 (cent6)：<code>chkconfig --list</code></p>
<blockquote>
<p>  CentOS7之后 ，chkconfig命令已经被systemctl命令取代</p>
</blockquote>
<p>其他命令：<code>ps aux</code>/<code>netstat -tuln -an</code><br>既然能查看就能修改：<code>chkconfig (--level 2345) httpd on/off</code>括号内的可省略<br>添加自启动另一种方法：修改<code>/etc/rc.d/rc.local</code>文件【推荐】<br>以及图形化界面ntsysv，只能修改5等级</p>
<p>启动服务  <code>server xx start/stop/status/restart</code>(<strong>/etc/init.d/xxx  start</strong>)</p>
<p>对于源码包，启动服务的server (redhat系列)、chkconfig都是没效果的，想要支持server命令需要创建一个软连接：<br><code>ln -s xxx /etc/init.d/</code>，也就是说server读取的就是<code>/etc/init.d/</code>目录下的文件(实际目录是<code>/etc/rc.d/init.d/</code>)<br>想要被 chkconfig 识别：修改 <strong>init.d</strong> 文件中的软连接的脚本，增加：</p>
<blockquote>
<p>  第一行定义运行级别、启动顺序、关闭顺序，顺序号只要不冲突即可<br>  第二行是描述信息<br>  # chkconfig:345 86 76<br>  # description:source package apache</p>
</blockquote>
<p>然后执行<code>chkconfig --add xxx</code>即可<br>PS:<code>/etc/rc3.d/</code>下面的文件是运行级别3时 系统开启与关闭分别要执行的服务文件，启动顺序与关闭顺序不能和现有的冲突，k开头的是关闭，s开头是开启</p>
<p>centos系列可以使用图形化界面管理，命令setup；然后再补充下系统运行级别：</p>
<blockquote>
<p>  0 停机，关机<br>  1 单用户，无网络连接，不运行守护进程，不允许非超级用户登录<br>  2 多用户，无网络连接，不运行守护进程<br>  3 多用户，正常启动系统<br>  4 用户自定义<br>  5 多用户，带图形界面<br>  6 重启</p>
</blockquote>
<h2 id="一些常用操作"><a href="#一些常用操作" class="headerlink" title="一些常用操作"></a>一些常用操作</h2><h3 id="修改计算机名"><a href="#修改计算机名" class="headerlink" title="修改计算机名"></a>修改计算机名</h3><p>查看计算机名：hostname<br>至于修改关键是<code>/etc/hosts</code>文件和<code>/etc/sysconfig/network</code>文件<br>然后重启reboot或<code>shutdown -r now</code>(<em>-c</em>取消)</p>
<h3 id="设置默认语言"><a href="#设置默认语言" class="headerlink" title="设置默认语言"></a>设置默认语言</h3><p>临时设置：<code>export LANG=&quot;zh_CN.UTF-8&quot;</code><br>永久生效：修改<code>/etc/sysconfig/i18n</code><br>英文是：<strong>en_US.UTF-8</strong></p>
<h3 id="设置提示忽略大小写"><a href="#设置提示忽略大小写" class="headerlink" title="设置提示忽略大小写"></a>设置提示忽略大小写</h3><p>编辑<code>~/.inputrc</code>（没有的话，就新建一个），在最后加一行:<br><code>set completion-ignore-case on</code></p>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p><code>;</code>连接多个命令，无逻辑 如果报错也还是会继续执行下个命令<br><code>1&amp;&amp;2</code> 1正确执行才会执行2<br><code>1||2</code> 1如果不正确执行2；如果1正确2不会执行<br><code>1|2</code>  1的执行结果是2的参数</p>
<h3 id="目录解释"><a href="#目录解释" class="headerlink" title="目录解释"></a>目录解释</h3><blockquote>
<p>  /  根目录<br>  /bin  命令保存目录（普通用户就可以读取的命令）<br>  /boot  启动目录，启动相关文件<br>  /dev  设备文件保存目录<br>  /etc  配置文件保存目录<br>  /home  普通用户的家目录<br>  /lib  系统库保存目录<br>  /mnt  系统挂载目录<br>  /media  挂载目录<br>  /root  超级用户的家目录<br>  /tmp  临时目录<br>  /sbin  命令保存目录（超级用户才能使用的目录）<br>  /proc  直接写入内存<br>  /sys<br>  /usr  系统软件资源目录<br>  /usr/bin/  系统命令（普通用户<br>  /usr/sbin/ 系统命令（超级用户）<br>  /var  系统相关文档内容</p>
<p>  配置文件一般都在 etc下用户名</p>
</blockquote>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>shell连接：<code>ssh name@ip</code><br>创建文件：touch<br>创建文件夹：mkdir<br>统计字符：wc [-c 字节 ；-w 单词； -l 行]<br>分屏显示：more<br>查询字符串：grep 可配合管道符<code>|</code>筛选使用[-i：忽略大小写；-w：搜索整个词汇]，如<code>$grep -i hAL /etc/passwd</code><br>不断显示文件的最后几行：<code>tail -f fileName</code> ；比如：<code>tail  -3 temp</code>是查看最后三行<br>查看文件内容：cat<br>查看硬盘信息：df<br>创建一个软连接：<code>ln -s [原文件] [目标文件]</code></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-函数式编程]]></title>
      <url>http://bfchengnuo.com/2017/01/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>还没有到IO啊…..什么时候才能写的出爬虫….<br>不过还是希望能够比较系统的进行学习….继续吧，这次是函数式编程<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>函数式编程就是一种抽象程度很高的编程范式，<strong>纯粹的函数式编程语言编写的函数没有变量</strong>，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，<strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</strong><br>Python对函数式编程提供部分支持。<em>由于Python允许使用变量，因此，Python不是纯函数式编程语言。</em><br>函数式编程也可以归结到面向过程的程序设计。</p>
<blockquote>
<p>  函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
</blockquote>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>什么是高阶函数呢，比如举几个栗子：</p>
<ul>
<li><p>变量可以指向函数<br>这点类似js，比如<code>abs()</code>这个函数，abs是函数本身，加括号就是调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数名也是变量<br>  还是用abs这个栗子，abs就是一个变量，你甚至可以给他赋值，他只是保存了计算绝对值这个函数的引用，也就是说他指向具体实现的地方<br>  注：由于<code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的</p>
</li>
<li><p>传入函数<br>  既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
</li>
<li><p>返回函数<br>  有时候我们并不需要立即执行函数，可以传入需要的参数然后让其返回一个函数，需要执行的时候再执行，后面会有详细介绍</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>
<p>  f应该传入一个函数，比如<code>abs()</code></p>
<h2 id="map和reduce"><a href="#map和reduce" class="headerlink" title="map和reduce"></a>map和reduce</h2><p>Python内建了<code>map()</code>和<code>reduce()</code>函数。<br>先来看第一个map函数：它接收两个参数，一个是函数，一个是<code>Iterable(可迭代对象)</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator(迭代器)</code>返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将list转换成字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure>
<hr>
<p>再看reduce的用法。reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，<strong>这个函数必须接收两个参数</strong>，reduce把结果<strong>继续和序列的下一个元素做累积计算</strong>，其效果就是：<code>reduce(f, [x1, x2, x3, x4])</code>等价于<code>f(f(f(x1, x2), x3), x4)</code><br>比方说对一个序列求和，就可以用reduce实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用reduce。</p>
<h2 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h2><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是：<br><code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<strong>True</strong>还是<strong>False</strong>决定保留还是丢弃该元素。<br>比如过滤空字符的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line">list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br></pre></td></tr></table></figure>
<p>注意到<code>filter()</code>函数返回的是一个迭代器，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，<strong>需要用<code>list()</code>函数获得所有结果并返回list。</strong></p>
<h2 id="sorted排序函数"><a href="#sorted排序函数" class="headerlink" title="sorted排序函数"></a>sorted排序函数</h2><p>它接受一个list对其进行排序，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>
<p>key函数作用于每一项，并根据key函数返回的结果进行排序。<br>如果需要反向排序可以传入第三个参数<code>reverse=True</code></p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>这部分刚开始简单的一些还好，后面的高级应用感觉是比较难的(比如..装饰器的时候)，一个简单的例子说明一切：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 == f2</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>可以看出<strong>内部函数sum可以引用外部函数的参数和局部变量</strong>，当lazy_sum返回函数sum时，<strong>相关参数和变量都保存在返回的函数中</strong>，这种称为“闭包（Closure）”的程序结构拥有极大的威力。每次调用都互不影响，比如上面f1和f2是不同的</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>想要返回函数时，内部函数还能引用外部函数的变量实现起来是不容易的<br>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong><br>返回的所有函数会引用变量最后的值<br>如果一定要引用循环变量怎么办？方法是<strong>再创建一个函数，用该函数的参数绑定循环变量当前的值</strong>，无论该循环变量后续如何更改，<strong>已绑定到函数参数的值不变</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span></span><br><span class="line">    <span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>关键字<code>lambda</code>表示匿名函数，比如：<code>lambda x: x * x</code>冒号前面的<code>x</code>表示函数参数，写成一般的函数就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="comment"># 一个例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>匿名函数有个限制，就是只能有一个表达式，当然return也是不可以用的，同时你也可以把匿名函数赋给一个变量，可以通过这个变量来进行调用，或者用于返回函数</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.__name__</span><br><span class="line"><span class="string">'str'</span></span><br></pre></td></tr></table></figure>
<p>至于什么是装饰器，比如我们定义了个函数，后来写某个功能的时候又想在原来的基础上增加一些功能，我们最好还是不要在原来的函数上进行改动，<strong>这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</strong><br>本质上，decorator就是一个返回函数的高阶函数，它接受一个函数，经过装饰后，返回一个新函数<br>比如写一个在执行函数前先打印下函数名的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>装饰器写好了然后就是使用了，我们要借助Python的<code>@</code>语法，把decorator置于函数的定义处</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"><span class="comment"># 调用now函数时，除了执行其本身还打印了其函数名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br></pre></td></tr></table></figure>
<p>其实把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句:<code>now = log(now)</code><br>但是原来的now函数还是存在的，只不过新的now指向了由装饰器构造的函数<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。</p>
<hr>
<p>如果decorator本身需要传入参数，那就需要编写一个<strong>返回decorator的</strong>高阶函数，需要三层嵌套</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">execute now():</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br></pre></td></tr></table></figure>
<p>如果把@语法还原就是这样：<code>now = log(&#39;execute&#39;)(now)</code><br>到这里还有最后一个问题，前面我们说了装饰后的函数它指向了新的函数，也就是wrapper函数，我们并没有修改它的<code>__name__</code> ，它有自己的<strong>name</strong>等属性，如果去看经过decorator装饰之后的函数，它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’<br>想要解决这个问题不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 注意写在函数的上面</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者那个三层嵌套的</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  在面向对象（OOP）的设计模式中，decorator被称为<strong>装饰模式</strong>。OOP的装饰模式需要<strong>通过继承和组合来实现</strong>，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。</p>
<p>  decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
</blockquote>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Python的<code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。<br>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。<br><code>functools.partial</code>就是用来帮助我们创建一个偏函数的，它的作用就是：把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>比如设置一个新函数来用于2进制的转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>) <span class="comment"># == int('1000000',base=2)</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实它只是设置了一个默认值，也可以这样调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>, base=<span class="number">10</span>)</span><br><span class="line"><span class="number">1000000</span></span><br></pre></td></tr></table></figure>
<p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，上面的新函数每次调用的时候都传了一个默认的参数就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kw = &#123; <span class="string">'base'</span>: <span class="number">2</span> &#125;</span><br><span class="line">int(<span class="string">'10010'</span>, **kw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是</span></span><br><span class="line">max2 = functools.partial(max, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 实际上会把10作为*args的一部分自动加到左边</span></span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>
<p>所以：当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块和java中的分类、分包基本一致，不过Py有个很大的特点是：<br>每一个包目录下面都会有一个<code>__init__.py</code>的文件，<strong>这个文件是必须存在的，</strong>否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code><strong>可以是空文件</strong>，也可以有Python代码，因为<code>__init__.py</code>本身就是一个模块，而它的模块名就是顶层目录的名。<br><strong>模块的使用</strong><br>以内建的sys模块为例，编写一个hello的模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">            print(<span class="string">'Hello, world!'</span>)</span><br><span class="line">    <span class="keyword">elif</span> len(args)==<span class="number">2</span>:</span><br><span class="line">        print(<span class="string">'Hello, %s!'</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Too many arguments!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>第4行是一个字符串，表示模块的文档注释，<strong>任何模块代码的第一个字符串都被视为模块的文档注释</strong>；<br>第六行就是声明下作者<br>当我们在命令行运行hello<strong>模块文件</strong>时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在一个模块中，我们可能会定义很多函数和变量，<strong>但有的函数和变量我们希望给别人使用</strong>，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的<br>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；<br>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，注意是不能直接被引用而不是不能被使用，不过我们一般是不会去引用的</p>
<h3 id="第三方模块安装"><a href="#第三方模块安装" class="headerlink" title="第三方模块安装"></a>第三方模块安装</h3><p>在Python中，安装第三方模块，是通过包管理工具pip完成的。<br>比如：<code>pip install Pillow</code></p>
<blockquote>
<p>  当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错，默认情况下Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中</p>
<p>  临时追加：<br>  <code>&gt;&gt;&gt; import sys</code><br>  <code>&gt;&gt;&gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)</code><br>  永久追加：<br>  设置环境变量<strong>PYTHONPATH</strong>，Python自己本身的搜索路径不受影响。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS定位属性Position]]></title>
      <url>http://bfchengnuo.com/2016/12/27/CSS%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7Position/</url>
      <content type="html"><![CDATA[<p>事实证明，有些东西你一段时间不用就会遗忘….<br>于是有了这篇笔记<br><a id="more"></a><br>虽然我认为web前端是个坑，我应该是不会入的，不过这也说不定，这篇文来证明我曾经学过…</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>定位一般指的就是position属性了，一共有五种取值：</p>
<ul>
<li>relative(相对定位)</li>
<li>absolute(绝对定位)</li>
<li>fixed(固定定位)</li>
<li>static(<del>静态定位，</del>无定位)</li>
<li>inherit(继承父元素position属性)</li>
</ul>
<p>元素在页面中的布局遵守一套文档流的方式，<strong>默认的定位属性值为static</strong>。它其实是未被设置定位的。<br>元素如果被定位了，那么它的top,left,bottom,right值就会生效，一般常用的定位属性是relative,absolute和fixed<br>需要注意的另一点是被定位的元素层次(z-index)会得到提高。<br>inherit一般是很少用到的，这里不提了</p>
<h2 id="文档流概念"><a href="#文档流概念" class="headerlink" title="文档流概念"></a>文档流概念</h2><blockquote>
<p>  <strong>将窗体自上而下分成一行行， 并在每行中按从左至右的顺序排放元素，即为文档流。</strong><br>  每个非浮动 块级元素都独占一行， 浮动元素则按规定浮在行的一端。 若当前行容不下， 则另起新行再浮动。<br>  内联元素也不会独占一行。 几乎所有元素(包括块级，内联和列表元素）均可生成子行， 用于摆放子元素。<br>  有三种情况将使得元素脱离文档流而存在，分别是 <strong>浮动，绝对定位， 固定定位</strong>。<br>  但是在IE6中浮动元素也存在于文档流中。</p>
</blockquote>
<h2 id="relative相对定位"><a href="#relative相对定位" class="headerlink" title="relative相对定位"></a>relative相对定位</h2><p>相对于其正常(原来)位置进行定位。它的特点是<strong>不会脱离文档流</strong>，一张图就能说明一切问题：<br><img src="/image/dev/%E5%AE%9A%E4%BD%8D.jpg" alt=""><br>它是唯一并没有对周围的元素有任何影响的定位属性！！它依然存在于文档流中。它的位移是根据它在文档流中的原始位置发生的！！</p>
<h2 id="absolute绝对定位"><a href="#absolute绝对定位" class="headerlink" title="absolute绝对定位"></a>absolute绝对定位</h2><p>绝对定位是一个非常牛逼的属性，牛逼到，你不知道会发生什么。注意，它的解释是什么——“<strong>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</strong>”<br>也就是说，它可以相对于各种各样的东西进行定位。除了 <code>static</code> 其他都可以！！！<strong>注意！注意！注意！</strong> 是 <strong>除了</strong> ！<br>如果所有层次的父元素是static，也就是无效的，它默认会以文档为定位对象，文档对象(document)不等于窗口对象(window)<br>一般我们给坐标对象(必须是父级元素)加一个relative属性就可以了，如果不加left、top等属性相对定位没有任何效果，但是可以起到绝对定位参照的作用</p>
<h2 id="fixed固定定位"><a href="#fixed固定定位" class="headerlink" title="fixed固定定位"></a>fixed固定定位</h2><p>它是相对于浏览器窗口来说的，同时也是脱离文档流的，不会随滚动条的滚动而发生变化<br>同样通过top,left,bottom,right来控制位置</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>position: relative;</code>不会脱离文档流，<code>position: fixed;position: absolute;</code>会脱离文档流</li>
<li><code>position: relative;</code> 相对于自己在文档流中的初始位置偏移定位。</li>
<li><code>position: fixed;</code> 相对于浏览器窗口定位。</li>
<li><code>position: absolute;</code> 是相对于父级非<code>position:static</code> 浏览器定位。<br>如果没有任何一个父级元素是非<code>position:static</code>属性，则会相对于<strong>文档</strong>定位。这里它的<strong>父级元素</strong>是包含<strong>爷爷级元素、祖爷爷级元素、祖宗十八代级元素</strong>的。任意一级都可以。如果它的<strong>父级元素</strong>和<strong>爷爷级元素</strong>都是非<code>position:static</code> 属性，则，它会选择距离最近的父元素。</li>
</ol>
<h2 id="拓展之display属性"><a href="#拓展之display属性" class="headerlink" title="拓展之display属性"></a>拓展之display属性</h2><p>每一个元素都有默认的display属性，<strong>使用最多的是block, inline和inline-block</strong>，不常用的是table-cell。<br>根据display属性，我们可以将元素分为<strong>块级元素(block)</strong>和<strong>内联级元素(inline)</strong>。<br>它们最大区别是:<br><em>block元素可以设置宽度，独占一行。</em><br><em>inline元素宽度由内容决定，与其他元素并列在一行。</em><br>常见的block属性元素有：div, h1-h6, ul, li, ol, dl, dd, dt。<br>常见的inline属性元素有: span, a, em。</p>
<ul>
<li>block<br>宽高可以自行设置，默认宽度由父容器决定，默认高度有内容决定。自己独占一行。</li>
<li>inline<br>宽度和高度都有内容决定，与其他元素共占一行。</li>
<li>inline-block<br>宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中。</li>
<li>table-cell<br>此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/fungleo/article/details/50056111" target="_blank" rel="noopener">http://blog.csdn.net/fungleo/article/details/50056111</a><br><a href="https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/css-position.html" target="_blank" rel="noopener">https://leohxj.gitbooks.io/front-end-database/content/html-and-css-basic/css-position.html</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET笔记]]></title>
      <url>http://bfchengnuo.com/2016/12/23/ASP-NET%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>学校开的课，没怎么深入，跟着学了点常用的，整理下以备用<br>其实都差不多….<br><a id="more"></a></p>
<h2 id="母版页"><a href="#母版页" class="headerlink" title="母版页"></a>母版页</h2><p>母版页也就是模板页 大雾:)，就是一个模板，网站的很多页面有很多地方都是相同的，尤其是后台管理系统，我们不可能每次都copy一份代码，所以就有了母版页，采用母版页的页面保证只有在母版页允许自定义的地方才能写前台代码，母版页中会包含下面这样的一个标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">asp:ContentPlaceHolder</span> <span class="attr">id</span>=<span class="string">"ContentPlaceHolder1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">asp:ContentPlaceHolder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的标签内是可以添加前台代码的地方--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Session全局变量"><a href="#Session全局变量" class="headerlink" title="Session全局变量"></a>Session全局变量</h2><p>网页间的传值是个问题，ASP中不能和winform那样传值了，一般是用Session，我也就会这一种了….<br>创建方法右键–添加新项–全局应用程序类，默认是个名为<code>Global.asax</code>的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Application Language=&quot;C#&quot; %&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">    void Application_Start(object sender, EventArgs e) </span><br><span class="line">    &#123;</span><br><span class="line">        // 在应用程序启动时运行的代码</span><br><span class="line">        //存在于服务器，只有一个</span><br><span class="line">        Application.Lock();</span><br><span class="line">        Application[&quot;online&quot;] = 0;</span><br><span class="line">        Application.UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Application_End(object sender, EventArgs e) </span><br><span class="line">    &#123;</span><br><span class="line">        //  在应用程序关闭时运行的代码</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    void Application_Error(object sender, EventArgs e) </span><br><span class="line">    &#123; </span><br><span class="line">        // 在出现未处理的错误时运行的代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Session_Start(object sender, EventArgs e) </span><br><span class="line">    &#123;</span><br><span class="line">        // 在新会话启动时运行的代码</span><br><span class="line">        //每一个用户拥有自己的一个Session，用户连接的时候分配，用户离开站点(连接断开)即被释放</span><br><span class="line">        //存在于服务端，用户无法直接获取</span><br><span class="line">        Session[&quot;uname&quot;] = &quot;loli&quot;;</span><br><span class="line">        Application.Lock();</span><br><span class="line">        Application[&quot;online&quot;] = (int)Application[&quot;online&quot;] + 1;</span><br><span class="line">        Application.UnLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Session_End(object sender, EventArgs e) </span><br><span class="line">    &#123;</span><br><span class="line">        // 在会话结束时运行的代码。 </span><br><span class="line">        // 注意: 只有在 Web.config 文件中的 sessionstate 模式设置为</span><br><span class="line">        // InProc 时，才会引发 Session_End 事件。如果会话模式设置为 StateServer</span><br><span class="line">        // 或 SQLServer，则不引发该事件。</span><br><span class="line">        Application.Lock();</span><br><span class="line">        Application[&quot;online&quot;] = (int)Application[&quot;online&quot;] - 1;</span><br><span class="line">        Application.UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在代码中可以直接用<code>Session[&quot;uname&quot;]</code>来进行获取值</p>
<h2 id="页面跳转以及IsPostBack"><a href="#页面跳转以及IsPostBack" class="headerlink" title="页面跳转以及IsPostBack"></a>页面跳转以及IsPostBack</h2><p>页面跳转没什么特别可说的，就一行代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.Redirect(<span class="string">"./Admin/Default.aspx"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用相对路径也可以使用绝对路径<br>然后就是ASP中一个比较大的坑，我们可以看到ASP官方的控件中都有个属性叫<code>runat=&quot;server&quot;</code>，可以理解为当触发某个条件时比如按钮的点击事件，就会和服务器进行一次交流，不说性能方面的问题，还有一个很大的问题就是会<strong>刷新整个页面</strong>，也就是说会把后台代码再执行一遍，很多时候就会把用户设置、输入的内容给重置了….<br>所以我们一般都会写这样的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Page_Load</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是不是第一次加载，只有第一次加载才进行数据绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!IsPostBack)</span><br><span class="line">    &#123;</span><br><span class="line">        bindData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>稍微学过点C#的这里应该比较熟悉了，都差不多</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SqlConnection <span class="title">getConn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> connString = ConfigurationManager.ConnectionStrings[<span class="string">"conn"</span>].ConnectionString;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SqlConnection(connString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSet <span class="title">GetDataSet</span>(<span class="params"><span class="keyword">string</span> strSQL</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqlConnection conn = getConn();</span><br><span class="line">    conn.Open();</span><br><span class="line"></span><br><span class="line">    SqlDataAdapter da = <span class="keyword">new</span> SqlDataAdapter(strSQL, conn);</span><br><span class="line">    DataSet ds = <span class="keyword">new</span> DataSet();</span><br><span class="line">    da.Fill(ds);</span><br><span class="line">    conn.Close();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是获取的Web.config中的配置，数据库连接字符串在这里面，部署到服务器后是不允许下载这个文件的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"conn"</span> <span class="attr">connectionString</span>=<span class="string">"Data Source=.;Initial Catalog=test;uid=sa;pwd=12345;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">connectionStrings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">system.web</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">compilation</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">targetFramework</span>=<span class="string">"4.5.2"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--用户最大上传文件为40M，超时时间最大60秒，最大并发100--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">httpRuntime</span> <span class="attr">targetFramework</span>=<span class="string">"4.5.2"</span> <span class="attr">maxRequestLength</span>=<span class="string">"40960"</span> <span class="attr">executionTimeout</span>=<span class="string">"60"</span> <span class="attr">appRequestQueueLimit</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system.web</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="GridView控件"><a href="#GridView控件" class="headerlink" title="GridView控件"></a>GridView控件</h2><p>对于这个控件确实是非常好用的，它可以直接用鼠标设置，也可以用代码，一般是要进行修改列名为中文的，可读性比较好，在编辑列选项中添加BoundField，记得进行和数据表中的字段进行绑定，同时可以添加一些编辑、更新、删除等操作，如果要用这些功能<strong>一定记得加ISPostBack判断</strong><br>如果要自定义加按钮什么的，可以添加个 <strong>TemplateField</strong>里面再套个<strong>ItemTemplate</strong>然后把控件装进去<br>还有一点，如果加了单选框之类的控件默认改变是不会自动上传服务器的，需要手动加个<code>AutoPostBack=&quot;true&quot;</code>属性，但是我们又不希望每点一个就和服务器通讯次，为了减轻压力以及更好的用户体验，可以考虑把GridView外面套一个updatepanel控件，这样应该会进行批量更新….<br>updatepanel标签需要和scriptmanager配套使用，我没仔细研究过，我当时只是为了解决让它不频繁的触发刷新<br>不要忘了在控件的属性中设置对应的事件<br>下面的两个例子把上面的所有功能都用到了，应该….</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">asp:scriptmanager</span> <span class="attr">id</span>=<span class="string">"ScriptManager1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">asp:scriptmanager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">asp:updatepanel</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">id</span>=<span class="string">"UpdatePanel1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ContentTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">asp:GridView</span> <span class="attr">ID</span>=<span class="string">"GridView1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">AutoGenerateColumns</span>=<span class="string">"False"</span> <span class="attr">DataSourceID</span>=<span class="string">"SqlDataSource1"</span> <span class="attr">AllowSorting</span>=<span class="string">"True"</span> <span class="attr">OnRowDataBound</span>=<span class="string">"GridView1_RowDataBound"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Columns</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ReadOnly="True"可设置为不可编辑部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">asp:BoundField</span> <span class="attr">DataField</span>=<span class="string">"name"</span> <span class="attr">HeaderText</span>=<span class="string">"姓名"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义选项部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">asp:TemplateField</span> <span class="attr">HeaderText</span>=<span class="string">"性别"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ItemTemplate</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">asp:RadioButton</span> <span class="attr">ID</span>=<span class="string">"RadioButton1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">Text</span>=<span class="string">"男"</span> <span class="attr">Checked</span>=<span class="string">"true"</span> <span class="attr">GroupName</span>=<span class="string">"g1"</span> <span class="attr">AutoPostBack</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">asp:RadioButton</span> <span class="attr">ID</span>=<span class="string">"RadioButton2"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">Text</span>=<span class="string">"女"</span> <span class="attr">GroupName</span>=<span class="string">"g1"</span> <span class="attr">AutoPostBack</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ItemTemplate</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">asp:TemplateField</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">asp:GridView</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ContentTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">asp:updatepanel</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后是如果使用了编辑、删除、更新之类的，还是要记得加相应的事件</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BindData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置分页显示相关，也可以在属性里设</span></span><br><span class="line">    GridView1.AllowPaging = <span class="literal">true</span>;</span><br><span class="line">    GridView1.PageSize = <span class="number">10</span>;</span><br><span class="line">    GridView1.DataSource = GetDT();</span><br><span class="line">    <span class="comment">//更新数据必须要有条件，就是这个了</span></span><br><span class="line">    GridView1.DataKeyNames = <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"UserID"</span> &#125;;</span><br><span class="line">    GridView1.DataBind();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">GridView1_RowDeleting</span>(<span class="params"><span class="keyword">object</span> sender, GridViewDeleteEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DeleteRows(<span class="string">"TabName"</span>, <span class="string">"UserID"</span>, GridView1.DataKeys[e.RowIndex].Value.ToString()))</span><br><span class="line">        BindData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">GridView1_RowEditing</span>(<span class="params"><span class="keyword">object</span> sender, GridViewEditEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//让其(行)处于编辑状态，要刷新数据才能生效</span></span><br><span class="line">    GridView1.EditIndex = e.NewEditIndex;</span><br><span class="line">    BindData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">GridView1_RowUpdating</span>(<span class="params"><span class="keyword">object</span> sender, GridViewUpdateEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到编辑状态那一行的第1列中的第一个控件，默认编辑状态后是TextBox</span></span><br><span class="line">    <span class="comment">//操作完了不要忘了取消编辑状态，刷新数据源</span></span><br><span class="line">    <span class="keyword">if</span> (UpdateRows(<span class="string">"TabName"</span>, <span class="string">"UserID"</span>, ((TextBox)GridView1.Rows[e.RowIndex].Cells[<span class="number">0</span>].Controls[<span class="number">0</span>]).Text.ToString().Trim()))</span><br><span class="line">    &#123;</span><br><span class="line">        GridView1.EditIndex = <span class="number">-1</span>;</span><br><span class="line">        BindData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">GridView1_RowCancelingEdit</span>(<span class="params"><span class="keyword">object</span> sender, GridViewCancelEditEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GridView1.EditIndex = <span class="number">-1</span>;</span><br><span class="line">    BindData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换页数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">GridView1_PageIndexChanging</span>(<span class="params"><span class="keyword">object</span> sender, GridViewPageEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GridView1.PageIndex = e.NewPageIndex;</span><br><span class="line">    BindData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Repeater控件"><a href="#Repeater控件" class="headerlink" title="Repeater控件"></a>Repeater控件</h2><p>默认有五种模板：</p>
<ul>
<li>ItemTemplate : 对<strong>每一个数据项</strong>进行格式设置</li>
<li>AlternatingItemTemplate : 对交替数据项进行格式设置 ，显示2、4、6条</li>
<li>SeparatorTemplate : 对分隔符进行格式设置 </li>
<li>HeaderTemplate : 对页眉进行格式设置 </li>
<li>FooterTemplate : 对页脚进行格式设置</li>
</ul>
<p>ItemTemplate标签内的内容会重复，和数据表的行数一致</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">asp:Repeater</span> <span class="attr">ID</span>=<span class="string">"Repeater1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">OnItemCommand</span>=<span class="string">"Repeater1_ItemCommand"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">HeaderTemplate</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!-- 显示头部 --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"movies"</span>&gt;</span></span><br><span class="line">	        <span class="comment">&lt;!-- table头部声明--&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">th</span>&gt;</span>详细信息<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">HeaderTemplate</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ItemTemplate</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!-- 数据行 --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">%--自动编号--%</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">asp:Label</span> <span class="attr">ID</span>=<span class="string">"lbNo"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">Text</span>=<span class="string">"&lt;%#Container.ItemIndex+1 %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:Label</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">asp:TextBox</span> <span class="attr">ID</span>=<span class="string">"TBweek"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">Text</span>=<span class="string">'&lt;%#DataBinder.Eval(Container.DataItem,"Week") %&gt;'</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:TextBox</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">asp:TextBox</span> <span class="attr">ID</span>=<span class="string">"TBtime"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">Text</span>=<span class="string">'&lt;%#DataBinder.Eval(Container.DataItem,"Time") %&gt;'</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:TextBox</span>&gt;</span>                          '</span><br><span class="line">	        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ItemTemplate</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">FooterTemplate</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!-- 脚注行 --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">table</span>&gt;</span>   </span><br><span class="line">	    <span class="comment">&lt;!-- table尾 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">FooterTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">asp:Repeater</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="上传文件到服务器"><a href="#上传文件到服务器" class="headerlink" title="上传文件到服务器"></a>上传文件到服务器</h2><p>比如你如果想导入Excel也好还是设置头像也好，文件是必须先要上传到服务器才能操作的，这里使用FileUpload控件来上传</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">Upload</span>(<span class="params">FileUpload fuload</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取选择文件的扩展名</span></span><br><span class="line">    <span class="keyword">string</span> fileExtenSion = Path.GetExtension(fuload.FileName);</span><br><span class="line">    <span class="comment">//检测文件扩展名(格式)</span></span><br><span class="line">    <span class="keyword">if</span> (fileExtenSion.ToLower() != <span class="string">".xls"</span> &amp;&amp; fileExtenSion.ToLower() != <span class="string">".xlsx"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GetFileName返回文件名和扩展名</span></span><br><span class="line">        <span class="keyword">string</span> FileName = <span class="string">"App_Data\\"</span> + Path.GetFileName(fuload.FileName);</span><br><span class="line">        <span class="comment">//判断文件是否存在，如果存在先删除，Server.MapPath返回服务器的物理路径</span></span><br><span class="line">        <span class="keyword">if</span> (File.Exists(Server.MapPath(FileName)))</span><br><span class="line">        &#123;</span><br><span class="line">            File.Delete(Server.MapPath(FileName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传文件到指定目录</span></span><br><span class="line">        fuload.SaveAs(Server.MapPath(FileName));</span><br><span class="line">        <span class="keyword">return</span> Server.MapPath(<span class="string">"./"</span>) + FileName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h2><p>我基本也是从网上找的实例代码，需要安装相应的支持库才行，区分32与64位系统，可以在项目中设置IIS以64位运行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> OleDbConnection <span class="title">getOleConn</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.GC.Collect();</span><br><span class="line">    OleDbConnection oleConn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HDR=Yes，这代表第一行是标题，不做为数据使用 </span></span><br><span class="line">    <span class="comment">//如果用HDR=NO，则表示第一行不是标题，做为数据来使用。系统默认的是YES  </span></span><br><span class="line">    <span class="keyword">string</span> connstr2003 = <span class="string">"Provider=Microsoft.Jet.OLEDB.4.0;Data Source="</span> + fileName + <span class="string">";Extended Properties='Excel 8.0;HDR=Yes;IMEX=1;'"</span>;</span><br><span class="line">    <span class="keyword">string</span> connstr2007 = <span class="string">"Provider=Microsoft.ACE.OLEDB.12.0;Data Source="</span> + fileName + <span class="string">";Extended Properties=\"Excel 12.0;HDR=YES\""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> fileExtenSion = fileName.Substring(fileName.LastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//建立连接，根据不同的扩展名，选择不同的引擎</span></span><br><span class="line">    <span class="keyword">if</span> (fileExtenSion.ToLower() == <span class="string">"xls"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oleConn = <span class="keyword">new</span> OleDbConnection(connstr2003);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        oleConn = <span class="keyword">new</span> OleDbConnection(connstr2007);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oleConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadExcelToDataSet</span>(<span class="params"><span class="keyword">string</span> fileName, <span class="keyword">string</span> strSQL</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OleDbConnection conn = getOleConn(fileName);</span><br><span class="line">    conn.Open();</span><br><span class="line"></span><br><span class="line">    OleDbDataAdapter da = <span class="keyword">new</span> OleDbDataAdapter(strSQL, conn);</span><br><span class="line">    da.SelectCommand.CommandTimeout = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line">    ds = <span class="keyword">new</span> DataSet();</span><br><span class="line">    <span class="comment">//在ds中规定表名为ExcelInfo</span></span><br><span class="line">    da.Fill(ds, <span class="string">"ExcelInfo"</span>);</span><br><span class="line"></span><br><span class="line">    conn.Close();</span><br><span class="line">    conn.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Excel批量快速导入"><a href="#Excel批量快速导入" class="headerlink" title="Excel批量快速导入"></a>Excel批量快速导入</h2><p>主要使用ASP中一个叫SqlBulkCopy的类，想要导入最快要保证内存中的DT和数据库的表<strong>结构相同</strong>，倒是没必要字段也相同</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SQLBulkCopy</span>(<span class="params">DataTable dt,<span class="keyword">string</span> dtName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//using内的对象在代码块结束后会自动销毁，所以conn不用close</span></span><br><span class="line">    <span class="keyword">using</span> (SqlConnection conn = getConn())</span><br><span class="line">    &#123;</span><br><span class="line">        conn.Open();</span><br><span class="line">        <span class="keyword">using</span> (SqlBulkCopy bulkCopy = <span class="keyword">new</span> SqlBulkCopy(conn))</span><br><span class="line">        &#123;</span><br><span class="line">            bulkCopy.DestinationTableName = dtName;</span><br><span class="line">            <span class="comment">//假设数据库和Excel表的列名不同，内存列名映射到数据库的列名</span></span><br><span class="line">            <span class="comment">//bulkCopy.ColumnMappings.Add("loct", "serve");</span></span><br><span class="line">            bulkCopy.WriteToServer(dt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>datatable控件是个很好用的控件，包括类，对于DT的顺序问题，是有个排序方法的，比如可以这样</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataTable dt = getDT();</span><br><span class="line">DataView dv = dt.DefaultView;</span><br><span class="line">dv.Sort = <span class="string">"week ASC,time"</span>;</span><br><span class="line">Repeater1.DataSource = dv.ToTable();</span><br><span class="line">Repeater1.DataBind();</span><br></pre></td></tr></table></figure>
<p>对于判断一个字符串是不是为空，又很多写法都可以实现，据说下面的这种方式比较高效：<br><code>strTest.Length == 0</code></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ASP.NET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-高级特性]]></title>
      <url>http://bfchengnuo.com/2016/12/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>Py笔记大部分来自于：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的BLOG</a><br>非常适合初学者的系列教程！<br>写的太好了！简直无可挑剔，果然大牛~<br><a id="more"></a></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取一个list或tuple的部分元素是非常常见的操作，用一般的方法处理比如循环啦是非常繁琐的，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取前三个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果从0开始可以省略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>
<p><code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>，正好是3个元素。<br>类似的，既然Python支持<code>L[-1]</code>取倒数第一个元素，那么它同样支持倒数切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'Bob'</span>]</span><br></pre></td></tr></table></figure>
<p>还可以支持第三个参数，用于隔数取，如 <code>L[0:3:2]</code>隔两个取一个<br>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple<br>字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串，所以Python没有针对字符串的截取函数，只需要切片一个操作就可以完成。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。<br>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的<br>Python中的for…in可以迭代任何可迭代的对象，无论是否具有下标<br>如何判断是否可以迭代呢？方法是通过collections模块的Iterable类型判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成<strong>索引-元素</strong>对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure>
<p>在for里使用两个变量也是很常见的，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    print(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>举个例子，要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>可以用<code>list(range(1, 11))</code><br>但如果要生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code>怎么做？方法一是循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>写列表生成式时，把要生成的元素<code>x * x</code>放到前面，后面跟<code>for</code>循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以<strong>在循环的过程中不断推算出后续的元素</strong>呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种<strong>一边循环一边计算</strong>的机制，称为生成器：generator。<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>next()</code>函数获得generator的下一个返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>generator保存的是算法</strong>，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。<br>但是这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为<strong>generator也是可迭代对象</strong><br>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。<br>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</p>
<blockquote>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
</blockquote>
<p>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure>
<p><em>注意</em>，赋值语句：<code>a, b = b, a + b</code>相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (b, a + b) <span class="comment"># t是一个tuple</span></span><br><span class="line">a = t[<span class="number">0</span>]</span><br><span class="line">b = t[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>仔细观察，可以看出，<code>fib</code>函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。<br>也就是说，上面的函数和generator仅一步之遥。要把<code>fib</code>函数变成generator，只需要把<code>print(b)</code>改为<code>yield b</code>就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure>
<p>这就是定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator<br>这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。<br>需要注意的是：但是用for循环调用generator时，<strong>拿不到generator的return语句的返回值。</strong>需要捕获错误才行。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。需要注意的是可迭代对象和迭代器是完全不同的两个东西，如果要把Iterable(可迭代对象)变成Iterator(迭代器)可以使用<code>iter()</code>函数，当然也可以用<strong>isinstance</strong>来进行检测</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>你可能会问，为什么list、dict、str等数据类型不是Iterator(迭代器)？<br>这是因为Python的Iterator对象表示的<strong>是一个数据流</strong>，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。<br>凡是可作用于for循环的对象都是Iterable类型；<br>凡是可作用于<code>next()</code>函数的对象都是Iterator类型，它们表示一个惰性计算的序列；<br>Python的for循环本质上就是通过不断调用<code>next()</code>函数实现的；</p>
<h2 id="一些方法的补充"><a href="#一些方法的补充" class="headerlink" title="一些方法的补充"></a>一些方法的补充</h2><h3 id="items相关"><a href="#items相关" class="headerlink" title="items相关"></a>items相关</h3><p>方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value 类似方法 <code>iteritems()</code><br>需要注意的是因为字典是无序的，所以用items方法返回字典的所有项，也是没有顺序的。还有它是占额外的内存的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'x'</span>:<span class="string">'a'</span>,<span class="string">'y'</span>:<span class="string">'b'</span>,<span class="string">'z'</span>:<span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">dict_items([(<span class="string">'z'</span>, <span class="string">'c'</span>), (<span class="string">'x'</span>, <span class="string">'a'</span>), (<span class="string">'y'</span>, <span class="string">'b'</span>)])</span><br></pre></td></tr></table></figure>
<p>至于iteritems方法：与items方法相比作用大致相同，只是它的返回值不是列表，而是一个迭代器。不占额外内存<br>在很多情况下使用iteritems更高效（尤其是想要迭代结果的情况下）。</p>
<blockquote>
<p>重要：</p>
<p>stackoverflow上这样一个问题：<a href="http://stackoverflow.com/questions/10458437/python-what-is-the-difference-between-dict-items-and-dict-iteritems" target="_blank" rel="noopener">dict.items()和dict.iteritems()有什么区别？</a> ，第一个答案大致的意思是这样的：<br>“起初 items() 就是返回一个像上面那样的包含dict所有元素的list，但是由于这样太浪费内存，所以后来就加入了（注：在Python 2.2开始出现的）iteritems(), iterkeys(), itervalues()这一组函数，用于返回一个 iterator 来节省内存，但是在 3.x 里items() 本身就返回这样的 iterator，所以在 3.x 里items() 的行为和 2.x 的 iteritems() 行为一致，iteritems()这一组函数就废除了。”<br>不过更加有意思的是，这个答案虽然被采纳，下面的评论却指出，这种说法并不准确，在 3.x 里 items() 的行为和 2.x 的 iteritems() 不一样，它实际上返回的是一个”full sequence-protocol object”，这个对象能够反映出 dict 的变化，后来在 Python 2.7 里面也加入了另外一个函数 viewitems() 和 3.x 的这种行为保持一致</p>
<p>viewitems和iteritems有什么区别呢，viewitems() 返回的是<strong>view object</strong>，它可以反映出 dictionary 的变化，就是说当字典变化后依然可以进行遍历</p>
<p>总结起来，在 2.x 里面，最初是 items() 这个方法，但是由于太浪费内存，所以加入了 iteritems() 方法，用于返回一个 iterator，在 3.x 里面将 items() 的行为修改成返回一个 view object，让它返回的对象同样也可以反映出原 dictionary 的变化，同时在 2.7 里面又加入了 viewitems() 向下兼容这个特性。<br>所以在 3.x 里面不需要再去纠结于三者的不同之处，因为只保留了一个 items() 方法。</p>
<p>文：<a href="http://blog.csdn.net/revilwang/article/details/38686635" target="_blank" rel="noopener">http://blog.csdn.net/revilwang/article/details/38686635</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-函数]]></title>
      <url>http://bfchengnuo.com/2016/12/10/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>继续学习函数部分，为后面的高级特性打基础，Py中函数的正确打开方式是什么呢？<br>梦想之路还很远呐~~~<br><a id="more"></a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数名其实就是<strong>指向一个函数对象的引用</strong>，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>函数也是放在栈里，递归要避免栈溢出</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>Py中定义函数用<code>def</code>关键字，木有类似花括号的作用域，使用冒号<code>:</code>进行区分，缩进表示层次，Py中缩进非常严格，标准4个空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<br><code>return None</code>可以简写为<code>return</code>。</p>
<p>可以在Py文件的当前目录下启动Python解释器，用<code>from 文件名 import 函数名</code>来导入函数，注意是文件名（不含<code>.py</code>扩展名）</p>
<h3 id="空函数和pass"><a href="#空函数和pass" class="headerlink" title="空函数和pass"></a>空函数和pass</h3><p>定义一个空函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>pass</code>语句什么都不做，那有什么用？实际上<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。<br>在其他地方也适用，比如if和for：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: my_abs() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br></pre></td></tr></table></figure>
<p>但是如果参数类型不对，Python解释器就无法帮我们检查。试试<code>my_abs</code>和内置函数<code>abs</code>的差别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">'A'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> my_abs</span><br><span class="line">TypeError: unorderable types: str() &gt;= int()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="string">'A'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand type <span class="keyword">for</span> abs(): <span class="string">'str'</span></span><br></pre></td></tr></table></figure>
<p>当传入了不恰当的参数时，内置函数<code>abs</code>会检查出参数错误，而我们定义的<code>my_abs</code>没有参数检查，会导致<code>if</code>语句出错，出错信息和<code>abs</code>不一样。所以，这个函数定义不够完善。<br>让我们修改一下<code>my_abs</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance()</code>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>
<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="string">'A'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>Py中函数可以返回“多个值”<br>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure>
<p><code>import math</code>语句表示导入<code>math</code>包，并允许后续代码引用<code>math</code>包里的<code>sin</code>、<code>cos</code>等函数。</p>
<p>然后，我们就可以同时获得返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y)</span><br><span class="line"><span class="number">151.96152422706632</span> <span class="number">70.0</span></span><br></pre></td></tr></table></figure>
<p>但其实这只是一种假象，<strong>Python函数返回的仍然是单一值</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></table></figure>
<p>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，<strong>而多个变量可以同时接收一个tuple</strong>，<strong>按位置赋给对应的值</strong>，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="设置默认参数"><a href="#设置默认参数" class="headerlink" title="设置默认参数"></a>设置默认参数</h3><p>这个感觉是一个很爽的功能，设置了默认参数调用的时候是可以不写的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算x的n次方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>这里注意的是，默认参数只能是存在于最后，要不然就没法区别了…<br>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。<br>当如果又多个默认参数的时候，可以顺序的输入，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用<code>enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)</code>，意思是，<code>city</code>参数用传进去的值，其他默认参数继续使用默认值。</p>
<hr>
<p>这里有一个坑，和java中的参数传递类似：Python函数在定义的时候，假设默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>是个可变对象，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，如果在函数中改变了<code>L</code>所指向对象的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p>
<p>所以，定义默认参数要牢记一点：<strong>默认参数必须指向不变对象！</strong></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。<strong>在函数内部，参数<code>numbers</code>接收到的是一个tuple，</strong>因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数<br>如果已经有一个list或者tuple，要调用一个可变参数怎么办？<br>Python允许你在list或tuple前面加一个<code>*</code>号，<strong>把list或tuple的元素变成可变参数传进去</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>
<p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数<strong>在函数内部自动组装为一个dict</strong>。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
<p>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; person('Michael', 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以传入任意个数的关键字参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; person('Bob', 35, city='Beijing')</span><br><span class="line">name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; person('Adam', 45, gender='M', job='Engineer')</span><br><span class="line">name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125;</span><br></pre></td></tr></table></figure>
<p>关键字参数有什么用？它可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>如果传入的也是个dict怎么办，和上面一样了用<code>**name</code>来区别，反正就是拷贝一份数据，对原数据都是不会影响的，因为不存在什么引用数据类型、基本数据类型，所以都是一样的</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数，函数的调用者可以<strong>传入任意不受限制的关键字参数</strong>。<br>如果要<strong>限制关键字参数的名字</strong>，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>调用方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就<strong>不再需要</strong>一个特殊分隔符<code>*</code>了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错<br>命名关键字参数可以有缺省值，从而简化调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。否则就当作是位置参数</p>
<h3 id="组合参数"><a href="#组合参数" class="headerlink" title="组合参数"></a>组合参数</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，<strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></p>
<p>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>所有的递归函数都可以写成循环的方式，<del>但循环的逻辑不如递归清晰。</del>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。<br>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。<br>尾递归是指，<strong>在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</strong>。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。例如下面一个求阶乘的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的<code>fact(n)</code>函数改成尾递归方式，也会导致栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="生成序列"><a href="#生成序列" class="headerlink" title="生成序列"></a>生成序列</h3><p>Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数(不包括5)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不了解某个函数的使用可以使用<code>help()</code>来查看帮助，如<code>help(abs)</code></p>
</blockquote>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><p><code>isinstance(x, str)</code> 可以判断变量 x 是否是字符串<br><code>upper()</code> 方法可以返回大写的字母</p>
<h2 id="获取信息相关"><a href="#获取信息相关" class="headerlink" title="获取信息相关"></a>获取信息相关</h2><p><code>type()</code>函数可来判断对象的类型<br>对于class的继承关系来说，使用<code>type()</code>就很不方便。我们要判断class的类型，可以使用<code>isinstance()</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'a'</span>, str)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list<br>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y',可以再传入一个默认值</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>
<h3 id="关于math等"><a href="#关于math等" class="headerlink" title="关于math等"></a>关于math等</h3><p>abs() 求绝对值<br>cmp(x, y) 比较函数（如果 x &lt; y，返回 -1；如果 x==y，返回 0；如果 x &gt; y，返回 1）<br>int()/str()  转换函数<br>sum() 可计算list的和<br>sqrt() 平方根</p>
<p>更多待更新…</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python学习笔记-基础]]></title>
      <url>http://bfchengnuo.com/2016/11/20/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>一起愉快的学Py吧，早就听说Py的大名了，感觉还并不是太难，<del>只是一时心血来潮</del>，一直有个<del>梦想</del>，写个爬虫去爬那个啥….o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br><a id="more"></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>py作为解释性语言，能够很好的被读懂(大概)，一向是以简洁 优雅著称<br>因为是解释执行，不会进行预编译成二进制文件，所以….代码是不能被加密的，发就发源代码了…<br>还有一点在py中是<strong>不建议使用分号用来结尾的</strong>，都是以缩进(四个空格)来区分代码的范围</p>
<p>Py文件的头一般有这两句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>
<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；<br>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，<strong>否则，你在源代码中写的中文输出可能会有乱码。</strong></p>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>因为有java语言的基础，主要总结下与java不同的地方</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果字符串中有太多的转义字符可以在前面加<code>r</code>这样里面就不需要进行转义了<code>r&#39;字符串内容&#39;</code><br>如果需要很多的换行符，为了简便可以使用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>，在里面回车会被记录，不用再写转义<code>\n</code>，注意在输入多行内容时，提示符由<code>&gt;&gt;&gt;</code>变为<code>...</code>，提示你可以接着上一行输入。<br>多行字符串<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>还可以在前面加上<code>r</code>使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>一个布尔值只有<code>True</code>、<code>False</code>两种值，注意<strong>第一个字母是大写的</strong>，布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算(类似与或非运算吧…)。<br>Python把<code>0</code>、空字符串<code>&#39;&#39;</code>和<code>None</code>看成 False，其他数值和非空字符串都看成 True</p>
<ul>
<li>在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。</li>
<li>在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。</li>
</ul>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用<code>None</code>表示。和java中的null类似</p>
<h2 id="关于除法"><a href="#关于除法" class="headerlink" title="关于除法"></a>关于除法</h2><p>用<code>/</code>进行运算的除法得到的是一个浮点数，即使两个整数相除<br>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数，会舍弃小数部分</p>
<p><strong>python的整数和浮点数没有大小限制！</strong></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>和JS中类似，Py中的for循环只有for…in的形式，比如经典问题：计算1+2+…+100：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(101)就可以生成0-100的整数序列</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<p>还有另一种循环while，这个就变化不大了，只要条件满足，就不断循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<p>还有break 和  continue也是一样的</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>py中的if确实和java之类不太一样，简化了不少，也不需要加括号，不过要注意<code>:</code>的问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># input()能够获取用户的输入，接受的一个str用于提示用户</span></span><br><span class="line"><span class="comment"># 获取的内容都会转成str类型，需要什么类型的要相对应强转下</span></span><br><span class="line">s = input(<span class="string">'birth: '</span>)</span><br><span class="line">birth = int(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><p>我认为py中的集合类的类型显得更加重要，很多神奇的操作都发生在这里。o(￣▽￣<em>)ゞ))￣▽￣</em>)o</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种<strong>有序的集合</strong>，可以随时添加和删除其中的元素。<br>感觉挺像数组的，因为是动态引用，所以里面的元素没有类型的限制，并且list[-1]可以表示最后一个元素，以此类推</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list的定义，用中括号定义</span></span><br><span class="line">a = [<span class="number">1</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过append方法向list尾部添加元素</span></span><br><span class="line">a.append(<span class="string">'Adam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把元素插入到指定位置，pos为索引</span></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除末尾元素,并且会返回这个元素</span></span><br><span class="line"><span class="comment"># 并且它可以接受一个索引参数，删除指定索引的元素</span></span><br><span class="line">a.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换元素可以直接进行赋值</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list中可以再存list，类似二维数组</span></span><br><span class="line">s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br></pre></td></tr></table></figure>
<p>当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是<code>len(classmates) - 1</code>。</p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>另一种<strong>有序列表</strong>叫元组：tuple。tuple和list非常类似，但是tuple<strong>一旦初始化就不能修改</strong><br>它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的<br>不可变的tuple有什么意义？因为tuple不可变，所以<strong>代码更安全。</strong>如果可能，<strong>能用tuple代替list就尽量用tuple。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义tuple使用小括号(),当只有一个元素时，为了避免产生歧义当作小括号进行运算，我们一般会在后面加个,</span></span><br><span class="line">t = (<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个“可变”的tuple</span></span><br><span class="line"><span class="comment"># 可以看作其中的list是引用数据类型，t[2]指向的是list的地址，而list是可变的</span></span><br><span class="line"><span class="comment"># t指向的list并没有改变所以可以认为tuple确实是不可修改的</span></span><br><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，<strong>具有极快的查找速度。</strong><br>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，<strong>list越大，查找越慢。</strong><br>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。如上<br>它们都是无序的，获取的时候不能使用下标的方式</p>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict就是第二种实现方式，基本的使用(使用{}花括号来定义)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们还可以通过key进行赋值，重复赋值会被覆盖</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>]</span><br><span class="line"><span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取的时候如果key不存在就会报错，为了避免可以判断下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>注意：返回<code>None</code>的时候Python的交互式命令行不显示结果。<br>要删除一个key，用<code>pop(key)</code>方法，<strong>对应的value也会从dict中删除</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure>
<p>请务必注意，<strong>dict内部存放的顺序和key放入的顺序是没有关系的。</strong></p>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
<li>key不能重复，同时存储的键值对是没有顺序的</li>
<li>作为Key的元素必须是不可变的</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p><strong>所以，dict是用空间来换取时间的一种方法。</strong></p>
<p><strong>dict可以用在需要高速查找的很多地方</strong>，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p>
<p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p>
<p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; key = [1, 2, 3]</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; d[key] = 'a list'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: 'list'</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，<strong>但不存储value</strong>。由于key不能重复，所以，在set中，<strong>可以保证没有重复的元素(key)</strong>。<br>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># 没有values</span></span><br></pre></td></tr></table></figure>
<p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，<strong>显示的顺序也不表示set是有序的(它其实是无序的)。。</strong><br><strong>重复元素在set中自动被过滤：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>add(key)</code>方法可以添加元素到set中，<strong>可以重复添加，但不会有效果</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>remove(key)</code>方法可以删除元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>set可以看成数学意义上的无序和无重复元素的集合，因此，<strong>两个set可以做数学意义上的交集、并集等操作</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>set和dict的唯一区别仅在于没有存储对应的value</strong>，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。<br>set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。<br>关于更新，由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：<br>一是把新的元素添加到set中，二是把已有元素从set中删除。<br>set拥有 add remove 方法<br>同样可以使用<code>&#39;name&#39; in set</code>来进行判断是否存在<br>最后，set存储的元素也是没有顺序的。</p>
<h3 id="关于可变与不可变的补充"><a href="#关于可变与不可变的补充" class="headerlink" title="关于可变与不可变的补充"></a>关于可变与不可变的补充</h3><p>tuple虽然是不变对象，上面也解释过，可以把list当作是一个引用，<code>(1, [2, 3])</code>可以看作是<strong>不变</strong>的，但如果把<code>(1, 2, 3)</code>和<code>(1, [2, 3])</code>放入dict或set中，是会报错的，即使引用不会变，但list的内容可变，根据dict和set的规定，同样会导致哈希化的失败</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h3><p><code>,</code>相当于空格、分隔符的作用来连接两个字符串<br><code>print &#39;aaa&#39;,123</code></p>
<h3 id="关于编码"><a href="#关于编码" class="headerlink" title="关于编码"></a>关于编码</h3><p><code>str.decode(&quot;UTF-8&quot;)</code> 解码<br><code>str.encode(&quot;UTF-8&quot;)</code>  编码<br><code>b&#39;aaa&#39;</code>  bytes类型，一个字符占一个字节</p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415926</span></span><br><span class="line"><span class="string">'3.14'</span></span><br></pre></td></tr></table></figure>
<p>%其实可以看作是占位符<code>print(&#39;%s&#39; % &#39;abc&#39;)</code></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python3 中有六个标准的数据类型：</p>
<ol>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionary（字典）</li>
</ol>
<h3 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'abc'</span></span><br><span class="line">a = <span class="string">'def'</span></span><br></pre></td></tr></table></figure>
<p>原来的值如果没有别的变量引用，就会被垃圾回收，但是无法预测回收时间，多久回收一次由V8引擎自己决定</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>待补充…</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android安全开发初步(二)]]></title>
      <url>http://bfchengnuo.com/2016/10/27/Android%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%AD%A5-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>继续更新！Android的安全问题太多太多，这里只是总结了下我所了解(强制 = = )到的安全问题<br>话说，实际开发中还能想到多少呢？？<br><a id="more"></a><br>现在感觉各行各业越来越重视安全，如果有机会接触到感觉还是很爽的！<br><del>其实我想装逼</del></p>
<h2 id="截屏风险"><a href="#截屏风险" class="headerlink" title="截屏风险"></a>截屏风险</h2><p>在登录和注册，或修改密码等敏感数据操作时，如果手机中有后台默认隐藏截屏的应用，<strong>在输入是一直截屏</strong>，就有可能盗取敏感数据信息。<br><strong>解决方案：</strong><br>在Activity onCreate 中加入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写在setContentView上面</span></span><br><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);</span><br></pre></td></tr></table></figure>
<p>官方的意思就是设置了这个flag后, 系统会把当前窗口的内容视为安全隐私内容, 系统会阻止这些内容被截屏或者在不安全可靠的场景显示出来.<br>它起到的主要作用是：</p>
<ul>
<li><p>阻止屏幕截图</p>
</li>
<li><p>在Recent apps(任务切换界面)中只显示应用名字和图标, 不显示内容</p>
</li>
<li>Google App的Now on tap功能不会去分析你的页面的内容</li>
</ul>
<p>最后，对于国内各种ROM对Android的丧心病狂的更改还是要测试下实际效果的。。。</p>
<h2 id="关注debuggable"><a href="#关注debuggable" class="headerlink" title="关注debuggable"></a>关注debuggable</h2><p><code>android:debuggable</code> 属性的设置可能会引起 被动态调试的风险。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">android:debuggable</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>debuggable 属性有两个值“true|false”;<br>只有<code>Android:debuggable=”true”</code>时我们才可以在手机上调试Android程序。<br>但是当我们没在<code>AndroidManifest.xml</code>中设置其debug属性时:<br>使用Eclipse运行这种方式打包时其debug属性为true,使用Eclipse导出这种方式打包时其debug属性为法false.<br>在使用ant打包时，其值就取决于ant的打包参数是release还是debug.<br><strong>因此在AndroidMainifest.xml中最好不设置android:debuggable属性置，而是由打包方式来决定其值。</strong><br>如果设置了 android:debuggable=”true” 那么在正式打包时 把它设置成false吧！！！</p>
<h2 id="关注allowBackup"><a href="#关注allowBackup" class="headerlink" title="关注allowBackup"></a>关注allowBackup</h2><p><code>android:allowBackup</code> 属性的设置可能会引起用数据被任意备份的风险</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:allowBackup</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Android API Level 8 及其以上 Android 系统提供了为应用程序数据的备份和恢复功能，此功能的开关决定于该应用程序中 <code>AndroidManifest.xml</code> 文件中的 allowBackup 属性值，<strong>其属性值默认是 True</strong>。当 allowBackup 标志为 true 时，用户即可通过 adb backup 和 adb restore 来进行对应用数据的备份和恢复。<br>一旦应用程序支持备份和恢复功能，攻击者即可通过 adb backup 和 adb restore 进行恢复新安装的同一个应用来查看聊天记录等信息；对于支付金融类应用，攻击者可通过此来进行恶意支付、盗取存款等；因此为了安全起见，开发者务必将 allowBackup 标志值设置为 false 来关闭应用程序的备份和恢复功能，以免造成信息泄露和财产损失。</p>
<h2 id="安全的打印日志"><a href="#安全的打印日志" class="headerlink" title="安全的打印日志"></a>安全的打印日志</h2><p>如何打印日志？这不是很简单，直接使用<code>android.util.Log</code>这个类不就行了？然而，日志属于非常敏感的信息；逆向工程师在逆向你的程序的时候，本来需要捕捉你程序的各种输出，然后进行推测，顺藤摸瓜然后得到需要的信息；一旦你的日志泄漏，无异于门户洞开，破解你的程序如入无人之境。<br>我们打印日志是用<code>Log.d(TAG, msg);</code>当把APK进行反编译后，TAG这个字符串会原封不动的还原出来，推理推理也就差不多了，不管你是否混淆过….<br>安全的概念本来就是相对的，如果破解你程序的代价远远大于破解得到的价值，那么就可以认为程序是“安全的”；这里就分析一下，为了提高程序的安全性，在打印日志的时候应该注意什么。</p>
<h3 id="让release版本里面不包含日志代码"><a href="#让release版本里面不包含日志代码" class="headerlink" title="让release版本里面不包含日志代码"></a>让release版本里面不包含日志代码</h3><p>我们想要的是在开发的时候，正常打印日志；一旦需要发布版本，把所有打印日志的语句代码，全部删除掉。<br>这里我们可以采用日志开关+<code>proguard</code>的方式来进行优化，关于proguard这个工具，很多认只是觉得他是一个代码混淆的工具，实际上，它还可以帮你剔除无用代码！<br>无用代码就是类似下面的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// statement;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态编译的时候被认为“永远不会执行的代码”，就被认为是无用代码，会被这个工具直接优化掉，生成的class文件里面，这个if语句直接就没有了。这个功能，完美符合我们的需求；我们只需要把输出日志的代码用这样的if语句包围起来，然后release的时候肯定会用这个工具混淆；然后，在release版本里面，所有的输出日志的代码全部都没有了！不会像以前一样，留下一个影子，只是不做事。<br>所以我们这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>; <span class="comment">// 必须是static final 也就是常量，这样才能在编译器优化；删除if块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    android.util.Log.d(TAG, <span class="string">"msg to print"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当<code>DEBUG</code>变量为<code>False</code>的时候proguard可以理所当然地认为，这一部分代码时绝对不会被执行的，这样，打印日志的语句就会被优化（删除）掉.<br>这里还需要注意的是，不要把打印日志进行封装，往里传个TAG和MSG，想省去写if包裹语句，这样的话就会使之前的工作失去作用，反编译后传参的部分会暴露出来….所以不要这么搞！<br>如果你实在懒得打，AS的话有框架提示，打个<code>ifd</code>就会自动生成代码块！<br>AS的话还有另一种方式，详情去参考里翻一翻。</p>
<h2 id="SQLite数据库安全风险"><a href="#SQLite数据库安全风险" class="headerlink" title="SQLite数据库安全风险"></a>SQLite数据库安全风险</h2><p>使用SQLite来存储数据却存在着一个问题。因为大多数的Android手机都是Root过的，而Root过的手机都可以进入到<code>/data/data/&lt;package_name&gt;/databases</code>目录下面，在这里就可以查看到数据库中存储的所有数据。如果是一般的数据还好，但是当涉及到一些账号密码，或者聊天内容的时候，我们的程序就会面临严重的安全漏洞隐患。我们可以借助SQLCipher来解决这个安全性问题。</p>
<blockquote>
<p>SQLCipher是一个在SQLite基础之上进行扩展的开源数据库，它主要是在SQLite的基础之上增加了数据加密功能，如果我们在项目中使用它来存储数据的话，就可以大大提高程序的安全性。SQLCipher支持很多种不同的平台。</p>
</blockquote>
<p>使用SQLCipher替换掉程序中的SQLite的数据。将SQLCipher数据包导入项目相应目录中，将原有的SQlite import文件修改为SQLCipher,在程序启动界面添加<code>SQLiteDatabase.loadLibs(this)</code>，并修改<code>mysqlite.getWritableDatabase()</code>方法<br>首先创建一个MyDatabaseHelper继承自SQLiteOpenHelper,<strong>注意导入的包</strong>，除了导入的包不同，其他基本都和SQLiteOpenHelper相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;  </span><br><span class="line"><span class="keyword">import</span> net.sqlcipher.database.SQLiteDatabase;  </span><br><span class="line"><span class="keyword">import</span> net.sqlcipher.database.SQLiteDatabase.CursorFactory;  </span><br><span class="line"><span class="keyword">import</span> net.sqlcipher.database.SQLiteOpenHelper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_TABLE = <span class="string">"create table Book(name text, pages integer)"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(Context context, String name, CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在使用到的Activity中这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">      <span class="comment">//首先将SQLCipher所依赖的so库加载进来</span></span><br><span class="line">        SQLiteDatabase.loadLibs(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//创建实例</span></span><br><span class="line">        MyDatabaseHelper dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">"demo.db"</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//获取SQLiteDatabase对象，它接受一个字符串参数</span></span><br><span class="line">      <span class="comment">//就是SQLCipher所依赖的key，在对数据库进行加解密的时候SQLCipher都将使用这里指定的key。</span></span><br><span class="line">        db = dbHelper.getWritableDatabase(<span class="string">"secret_key"</span>);</span><br><span class="line">        <span class="comment">//即可对db进行操作</span></span><br><span class="line">		<span class="comment">//db.insert("Book", null, values);  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<strong>加入SQLCipher后会使APP的安装包增加几M，安全与体积要权衡好</strong></p>
<h2 id="Android签名安全"><a href="#Android签名安全" class="headerlink" title="Android签名安全"></a>Android签名安全</h2><p>现在Android逆向越来越火，并且相比PC端的EXE程序感觉Android的逆向还是很简单的，那就会面临着一个问题：会有人将APK进行反编译后修改代码然后进行二次打包发布，造成一些恶劣影响<br>我们知道打包APK必然要进行签名，原始的签名密钥肯定是安全的唯一的，二次打包会改变APP的签名信息，我们在APP启动的时候进行签名对比，如果不一致就强制JVM退出<br>当然了，没有绝对的安全，只要你逆向技术够高，这个是拦不住你的….</p>
<h3 id="获取签名"><a href="#获取签名" class="headerlink" title="获取签名"></a>获取签名</h3><p>获取签名我们可以采用两种方式，一种手动用keytool命令，还可以在代码里写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码方式获取签名，根据包名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Signature[] getRawSignature(Context context, String pkgName) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pkgName == <span class="keyword">null</span>) || (pkgName.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PackageInfo pi = pm.getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);</span><br><span class="line">            <span class="keyword">if</span> (pi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//返回是个数字签名的数组，一般apk都是单签名的</span></span><br><span class="line">          <span class="comment">//因此一般取Signature[0]做MD5，与已知签名的MD5信息做对比即可</span></span><br><span class="line">            <span class="keyword">return</span> pi.signatures;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果是手动用命令查的话，可以直接用RAR之类的打开APK文件，找到Apk文件中META-INF/CERT.RSA文件，解压，然后执行：<code>keytool -printcert -file fileName</code>就可以查到签名了<br>PS:正常的签名文件查询命令是<code>keytool -list -v -keystore filepath</code>(后缀一般为keystore，其实并不需要后缀)</p>
<h3 id="签名进行对比"><a href="#签名进行对比" class="headerlink" title="签名进行对比"></a>签名进行对比</h3><p>这里贴下主要代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">String signature=<span class="string">"e79cf0a46d543ab6092b71f41d835543"</span>; <span class="comment">//正确的已知的签名</span></span><br><span class="line">String pack=<span class="string">"com.bfchengnuo.demo"</span>; <span class="comment">//包名</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取其他应用的签名信息，然后进行对比，错误强制系统退出</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> paramString</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSign</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//getRawSignature方法返回的就是上面获得的签名MD5数组(类似，大概..)</span></span><br><span class="line">	Signature[] arrayOfSignature = getRawSignature(<span class="keyword">this</span>, paramString);</span><br><span class="line">	<span class="keyword">if</span> ((arrayOfSignature == <span class="keyword">null</span>) || (arrayOfSignature.length == <span class="number">0</span>)) &#123;</span><br><span class="line">		errout(<span class="string">"signs is null"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = arrayOfSignature.length;</span><br><span class="line">  	<span class="comment">//与已知的签名进行对比，如果全部匹配不成功则退出JVM</span></span><br><span class="line">	<span class="comment">//签名数组要进行MD5加密处理下，为了保险起见，这里把数组的每一个都进行了对比</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">	stdout(MD5.getMessageDigest(arrayOfSignature[j].toByteArray()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stdout</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(signature.equals(paramString))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// do thing</span></span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"签名正确"</span>, <span class="number">0</span>).show();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	System.exit(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BroadCastReceiver安全风险"><a href="#BroadCastReceiver安全风险" class="headerlink" title="BroadCastReceiver安全风险"></a>BroadCastReceiver安全风险</h2><p>Android 可以在配置文件中声明一个receiver或者动态注册一个receiver来接收广播信息，攻击者假冒APP构造广播发送给被攻击的receiver，是被攻击的APP执行某些敏感行为或者返回敏感信息等，如果receiver接收到有害的数据或者命令时可能泄露数据或者做一些不当的操作，会造成用户的信息泄漏甚至是财产损失<br>那么如何避免应用中注册的广播响应其他应用发送的广播呢，对于显式的广播除非是别人故意攻击，一般很少出现响应别人的广播，<strong>但是对于隐式的广播就很容易出现上述问题，因为action很容易是一样的，一旦是一样的就出问题了</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>如果仅在应用内部通信，可以使用私有receiver，设置<code>exported=&quot;false&quot;</code>，该receiver可以接收相同应用程序组件或带有相同用户ID的应用程序所发出的消息[<a href="http://developer.android.com/guide/topics/manifest/receiver-element.html" target="_blank" rel="noopener">参考</a>]。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".permittedReceiver"</span> <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若只在当前进程内通信，可以使用<code>LocalBroadcastManager</code>，使其他应用程序不能向该receiver发送广播</p>
</li>
<li><p>对于动态注册的广播<code>registerReceiver(BroadcastReceiver, IntentFilter, String permission, android.os.Handler)</code>,指定receiver必须具备的permission。<br>如果只允许自己的产品族使用，可以设置<code>android:protectionLevel=&quot;signature&quot;</code> ，若提供给其他APP使用，则设置<code>android:protectionLevel=&quot;normal&quot;</code>，同时要避免敏感信息的传递。<br>其实就是自定义权限~~</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.android.permission.send_permission"</span> 		<span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".permittedReceiver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:permission</span>=<span class="string">"com.android.permission.send_permission"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.android.permitted_ACTION"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对接收来的广播进行验证，返回结果时需注意接收app是否会泄露信息</p>
</li>
</ul>
<h3 id="关于自定义权限的补充"><a href="#关于自定义权限的补充" class="headerlink" title="关于自定义权限的补充"></a>关于自定义权限的补充</h3><p>首先说一下<code>protectionLevel</code>这个属性：</p>
<ul>
<li>normal：默认的，应用安装前，用户可以看到相应的权限，但无需用户主动授权。</li>
<li>dangerous：normal安全级别控制以外的任何危险操作。需要dangerous级别权限时，Android会明确要求用户进行授权。常见的如：网络使用权限，相机使用权限及联系人信息使用权限等。</li>
<li>signature：它要求权限声明应用和权限使用应用使用相同的keystore进行签名。如果使用同一keystore，则该权限由系统授予，否则系统会拒绝。并且权限授予时，不会通知用户。它常用于应用内部。</li>
</ul>
<p>上面的订阅方例子用到了signature这个值，多说一下，如果别的应用使用的不是同一个签名文件，就没办法使用该权限，从而保护了自己的接收者(可以理解为只接受拥有此权限的应用发送的广播)。<br>发送方和订阅方都是需要加入这个权限的，只不过订阅方需要在注册接收器的时候再写一遍权限，上面的例子是静态注册receiver，如果用动态的方式注册那就是<code>registerReceiver(receiver, filter, permission, null);</code>，直接指定<strong>发送者</strong>应该具有的权限</p>
<blockquote>
<p>android:permission  —如果设置，具有相应权限的广播<strong>发送方</strong>发送的广播才能被此broadcastReceiver所接收</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://wolfeye.baidu.com/blog/recieve-broadcast-security/" target="_blank" rel="noopener">http://wolfeye.baidu.com/blog/recieve-broadcast-security/</a><br><a href="https://github.com/CharonChui/AndroidNote/blob/master/Android%E5%8A%A0%E5%BC%BA/BroadcastReceiver%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">BroadcastReceiver安全问题</a></p>
<h2 id="剪切板安全风险"><a href="#剪切板安全风险" class="headerlink" title="剪切板安全风险"></a>剪切板安全风险</h2><p>同一部手机中安装的其他app，甚至是一些权限不高的app，都可以通过剪贴板功能获取密码管理器中的账户密码信息。原因是Android剪贴板的内容向任何权限的app开放，很容易就被嗅探泄密，如上代码剪切板中存有明文内容，如果是明文内容将会有信息泄露的风险<br>如下代码可以在任意APP中读取剪切板的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClipboardManager cm = (ClipboardManager)getSystemService(CLIPBOARD_SERVICE);</span><br><span class="line">ClipData cd2 = cm.getPrimaryClip();</span><br><span class="line">str2 = cd2.getItemAt(<span class="number">0</span>).getText().toString();</span><br></pre></td></tr></table></figure>
<p>所以，<strong>使用完clipboard及时清空，并避免使用剪贴板明文存储敏感信息</strong></p>
<h2 id="其他风险"><a href="#其他风险" class="headerlink" title="其他风险"></a>其他风险</h2><ul>
<li><p>在配置Database配置模式的时候要注意：避免使用<code>MODE_WORLD_WRITEABLE</code>和<code>MODE_WORLD_READABLE</code>模式创建数据库(Database)，最好还是使用<code>MODE_PRIVATE</code>模式</p>
</li>
<li><p>安卓SecureRandom安全:<br><strong>在Android 4.2以下</strong>，SecureRandom是基于老版的Bouncy Castle实现的。如果生成SecureRandom对象后马上调用setSeed方法。SecureRandom会用用户设置的seed代替默认的随机源。使得每次生成随机数时都是会使用相同的seed作为输入。从而导致生成的随机数是相同的。<br>解决方案推荐：不要使用自定义随机源代替系统默认随机源，就是说不要调用以下函数：</p>
<blockquote>
<p> SecureRandom＃SecureRandom(byte[] seed)<br> SecureRandom＃setSeed(long seed)<br> SecureRandom＃setSeed(byte[] seed)</p>
</blockquote>
<p>其实还可以在调用setSeed方法前先调用任意nextXXX方法(<code>nextBytes(byte[] bytes)</code>)不过不推荐这种方式</p>
<p>现在基本上不用考虑了，毕竟已经到Android7.1+了，但是考虑到国内情况嘛….</p>
</li>
</ul>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006434989" target="_blank" rel="noopener">Android项目安全注意事项</a><br><a href="http://weishu.me/2015/10/19/how-to-log-safely-in-android/" target="_blank" rel="noopener">如何安全打印日志</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android安全开发初步(一)]]></title>
      <url>http://bfchengnuo.com/2016/10/19/Android%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%AD%A5-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>不看不知道，原来经常写的代码存在很多的安全问题，安全这一块着实不简单(我是这么认为的)，很多原理其实是看不太懂，只怪自己水平不够，买的几本Android进阶书还没看….哎~~意识到了时间的宝贵</p>
<a id="more"></a>
<h2 id="Handler内存泄漏"><a href="#Handler内存泄漏" class="headerlink" title="Handler内存泄漏"></a>Handler内存泄漏</h2><p>在使用Handler的时候，我们经常会写下面的一段代码，但是这样会导致严重的内存泄漏问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>当Android应用程序启动时，framework会为该应用程序的<code>主线程</code>创建一个<code>Looper</code>对象。这个Looper对象包含一个简单的<code>消息队列Message Queue</code>，并且能够循环的处理队列中的<a href="http://developer.android.com/reference/android/os/Message.html" target="_blank" rel="noopener">消息</a>。这些消息包括大多数应用程序framework事件，例如Activity生命周期方法调用、button点击等，这些消息都会被添加到消息队列中并被逐个处理。<br>另外，<strong>主线程的Looper对象会伴随该应用程序的整个生命周期。</strong></p>
<p>然后，当主线程里，实例化一个<code>Handler</code>对象后，它就会自动与<code>主线程Looper</code>的消息队列<code>关联</code>起来。所有发送到消息队列的消息Message都会拥有一个<code>对Handler的引用</code>，所以当Looper来处理消息时，会据此回调[Handler#handleMessage(Message)]<br>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象也会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）<br>这里补充一点java知识：</p>
<blockquote>
<p>在java里，<code>非静态内部类</code> 和 <code>匿名类</code> 都会潜在的引用(持有)它们所属的外部类。但是，<code>静态内部类</code>却不会。<br>个人理解：要不然你内部类怎么可以使用外部类的变量？还有.this这种形式</p>
</blockquote>
<p>所以：<br>只要有未处理的消息，那么消息会引用handler(通常在后台线程中)，非静态的handler又会引用外部类，即Activity，导致Activity无法被回收，造成泄漏。<br>同理，如果你用匿名Runnable来实现消息的发送，它属于非静态匿名类，同样会引用外部类。</p>
<p>一般情况下，我们是等耗时操作完成后进行发送消息，进行处理，这时候Activity应该要正常销毁的(也可能在等待过程中用户退出了Activity)，上面的代码会造成其他的对象持有Activity的引用导致Activity无法被GC回收，导致内存泄漏。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="通过程序逻辑来进行保护"><a href="#通过程序逻辑来进行保护" class="headerlink" title="通过程序逻辑来进行保护"></a>通过程序逻辑来进行保护</h4><ol>
<li>在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 </li>
<li>如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">	<span class="comment">//清除消息队列，也防止了内存泄漏</span></span><br><span class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>handler是线程通讯工具类。用于传递消息。它有两个队列：<br>1.消息队列<br>2.线程队列<br>消息队列使用sendMessage和HandleMessage的组合来发送和处理消息。<br>线程队列类似一段代码，或者说一个方法的委托，用户传递方法。使用post,postDelayed 添加委托，使用 removeCallbacks移除委托。<br>这里看到两张图不错：<br><img src="/image/dev/handler%E7%B1%BB%E7%BB%93%E6%9E%84.jpg" alt="handler类结构"><br><img src="/image/dev/handler%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.jpg" alt="handler消息处理"></p>
<p>更多可参考：<br><a href="http://www.jianshu.com/p/e8f3c9e0b873" target="_blank" rel="noopener">http://www.jianshu.com/p/e8f3c9e0b873</a></p>
</blockquote>
<h4 id="将Handler声明为静态类"><a href="#将Handler声明为静态类" class="headerlink" title="将Handler声明为静态类"></a>将Handler声明为静态类</h4><p>如果我们改为静态类，那么它<strong>不会持有外部的引用</strong>，Activity可以被GC回收了，就这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        mImageView.setImageBitmap(mBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是又出现了一个问题，应该注意到了，不会持有 Activity 的引用那么怎么可能操作 Activity 中的对象呢？我们可以加一个Activity 的弱引用 (WeakReference)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    WeakReference&lt;Activity &gt; mActivityReference;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//构造函数</span></span><br><span class="line">    MyHandler(Activity activity) &#123;</span><br><span class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = mActivityReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mImageView.setImageBitmap(mBitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>什么是WeakReference？</p>
<blockquote>
<p>WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>
</blockquote>
<p>关于静态内部类</p>
<blockquote>
<p>静态内部类只能访问外部类的静态成员。<br>静态内部类的对象可以直接生成：Outer.Inner in=new Outer.Inner()；而不需要通过生成外部类对象来生成。</p>
<p><strong>静态内部类和非静态内部类一样，都是在被调用时才会被加载</strong><br>所以可以这么理解：<strong>调用外部类的静态变量，静态方法可以让外部类得到加载，不过这里静态内部类没有被加载</strong></p>
</blockquote>
<p>其他地方ViewHolder内部类 定义为静态的，是一种好习惯。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>很多人认为，静态变量能不用就不用，一旦静态生命周期必然很长，大部分情况下Handler用来更新UI，既然Activity被关闭了，那么Handler也没必要存在了，<del>这种情况下也许采用第一种方法比较更好。</del><br>但是也有说静态内部类和静态变量还是有区别的，这里并不会有什么大问题….<br>静态内部类编译的时候是跟外部类同一级别的，使用static就有了限制，占用资源也就小了</p>
<p>还有就是，貌似 Android 对弱引用的支持并不太好，所以还是尽量少用</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/zhang_yanye/article/details/50344447" target="_blank" rel="noopener">java静态内部类加载</a><br><a href="https://my.oschina.net/rengwuxian/blog/181449" target="_blank" rel="noopener">https://my.oschina.net/rengwuxian/blog/181449</a><br><a href="http://www.jianshu.com/p/cb9b4b71a820" target="_blank" rel="noopener">http://www.jianshu.com/p/cb9b4b71a820</a></p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>一般情况下我们使用ProGuard工具来提供代码混淆<br>PS:因为特殊原因这里是在Eclipse下进行混淆，现在基本都是AS了，那个以后再来补充，其实都差不多，AS下更加简单吧..</p>
<h3 id="ProGuard是什么"><a href="#ProGuard是什么" class="headerlink" title="ProGuard是什么"></a>ProGuard是什么</h3><p>ProGuard是一个工具，用来混淆和优化Java代码。<br>工作方式：移除无效的代码，将代码中的类名、函数名替换为晦涩难懂的名字。<br>注意，它只能混淆Java代码，Android工程中Native代码，资源文件（图片、xml），它是无法混淆的。<br>玩过Android逆向的知道，经过混淆后的类反编译出来名都是单个字母，完全看不懂</p>
<h3 id="如何开启混淆"><a href="#如何开启混淆" class="headerlink" title="如何开启混淆"></a>如何开启混淆</h3><p>修改Android工程根目录下的<code>project.properties</code>文件，把proguard.config=….这一行前面的注释“#”去掉。<br>这一行指定了系统默认的proguard配置文件，位于Android SDK/tools/proguard目录下。<br>当然，你也可以自己编写配置文件，但不建议这样做，因此系统默认的配置已经涵盖了许多通用的细节，如果你还有额外的配置，可以添加在 <code>proguard-project.txt</code> 文件中。<br><strong>注意： 只有在生成release版本的apk时，混淆配置才会起作用，debug版本的apk不会进行混淆。</strong></p>
<h3 id="那些需要手动配置"><a href="#那些需要手动配置" class="headerlink" title="那些需要手动配置"></a>那些需要手动配置</h3><p>系统默认的配置已经涵盖了大部分的内容，但是如果你的工程中有如下内容，则需要手动添加配置到proguard-project.txt文件中。</p>
<ul>
<li>只在 AndroidManifest.xml 引用的类</li>
<li>通过JNI回调方式被调用的函数</li>
<li>运行时动态调用的函数或者成员变量</li>
<li>反射用到的类</li>
<li>WebView中JavaScript调用的方法</li>
<li>Layout文件引用到的自定义View</li>
<li>一些引入的第三方库（一般都会有混淆说明的） 这里推荐两个开源项目，里面收集了一些第三方库的混淆规则<ul>
<li><a href="https://github.com/krschultz/android-proguard-snippets" target="_blank" rel="noopener">android-proguard-snippets</a></li>
<li><a href="https://github.com/msdx/android-proguard-cn" target="_blank" rel="noopener">android-proguard-cn</a></li>
</ul>
</li>
</ul>
<p>当然，如果你不确定哪些需要手动配置，可以以默认的配置生成程序，当运行中发现ClassNotFoundException异常时，即可找到哪个类不该被混淆。</p>
<h3 id="手动配置的规则"><a href="#手动配置的规则" class="headerlink" title="手动配置的规则"></a>手动配置的规则</h3><p>手动添加的配置，一般以“-keep”开头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不混淆Test的构造函数</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">com</span>.<span class="title">example</span>.<span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不混淆package com.example下的所有类/接口</span></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.** </span>&#123; * ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不混淆com.example.Test类:</span></span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">Test</span> </span>&#123; * ; &#125;</span><br><span class="line"><span class="comment">/*如果希望不混淆某个接口，则把上述命令中的class替换为interface即可。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不混淆特定的函数</span></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">com</span>.<span class="title">example</span>.<span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestString</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不混淆com.Test类的子类</span></span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">Test</span></span></span><br><span class="line"><span class="class">//不混淆<span class="title">com</span>.<span class="title">example</span>.<span class="title">TestInterface</span>的实现</span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">class</span> * <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.example.TestInterface$Creator *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排除第三方依赖android-support-v4为例，AS中已自动处理无需手动添加</span></span><br><span class="line">-libraryjars</span><br><span class="line">libs/android-support-v4.jar</span><br><span class="line">-dontwarn</span><br><span class="line">android.support.v4.**&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span>&#123;*;&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">interface</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span>&#123;*;&#125;</span><br><span class="line"><span class="comment">/*注意： 需要添加dontwarn，因为默认情况下proguard会检查每一个引用是否正确，但是第三方库里往往有些不会用到的类，没有正确引用，所以如果不配置的话，系统会报错。*/</span></span><br></pre></td></tr></table></figure>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="http://ticktick.blog.51cto.com/823160/1413066" target="_blank" rel="noopener">http://ticktick.blog.51cto.com/823160/1413066</a><br><a href="https://segmentfault.com/a/1190000004461614" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004461614</a></p>
<h2 id="Activity安全"><a href="#Activity安全" class="headerlink" title="Activity安全"></a>Activity安全</h2><p> 有些说实话还没完全看懂，是太心急了么？逼不得已…</p>
<h3 id="exported"><a href="#exported" class="headerlink" title="exported"></a>exported</h3><p>不准备对外公开的activity一定要设置为非公开，以防止被人非法调用(反编译下很容易就能找到，至于非法调用用于什么坏事我的安全意识还想不出来，反正关掉就是了，也许是用来做钓鱼页面)<br>同时，一定要注意的是， <strong>非公开的Activity不能设置intent-filter</strong><br>因为，如果假设在同一机器上，有另外一个app有同样的intent-filter的话， 调用该Activity的intent会唤醒Android的选择画面， 让你选择使用那个app接受该intent。这样就会事实上绕过了非公开的设置。<br><strong>默认值：如果包含有intent-filter 默认值为<code>true</code>; 没有intent-filter默认值为<code>false</code>。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">".PrivateActivity"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果设置了导出权限，都可能被系统或者第三方的应用程序直接调出并使用。 组件导出可能导致登录界面被绕过、信息泄露、数据库SQL注入、DOS、恶意调用等风险。 </p>
<p>主要作用是：是否支持其它应用调用当前组件。</p>
</blockquote>
<p>更多请参考：<a href="http://blog.csdn.net/watermusicyes/article/details/46460347" target="_blank" rel="noopener">android:exported 属性详解</a></p>
<h4 id="合理的使用exported"><a href="#合理的使用exported" class="headerlink" title="合理的使用exported"></a>合理的使用exported</h4><p>我们接下来谈谈在开发中如何更合理设置exported。<br>Activity被调用的场景分为3种：<strong>封闭式</strong>、<strong>半封闭式</strong>和<strong>开放式</strong></p>
<ul>
<li><p>封闭式<br>被调用的Activity与调用的Context必须在同一个App，其他任何App不能调用<br>这种是我们最常见的Activity，有2种情况：</p>
<ol>
<li><p>没有intent-filter情况<br>可以不设置exported或者设置exported为false</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有intent-filter情况<br>必须设置exported为false</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>半封闭式<br>被调用的Activity只能被部分其他App调用，如同一个公司的2个App之间<br>这种场景下，除了满足封闭式设置外，还必须把调用App和被调用App设置相同的uid，即在2个App的AndroidManifest.xml添加相同的android:sharedUserId，如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:sharedUserId</span>=<span class="string">"com.example.categorytest"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开放式<br>可以被任何App调用 这种场景主要是对外接口，如微信、微博的分享接口。大多数情况下，这样的Activity都会有intent-filter，因此也没必要显式地把exported设为true，不设是可以的，当然不能设为false。<br>但如果你没有intent-filter，那就必须显式地把exported设为true。 当然，对于三方app接口的intent-filter设置还有一些要求，如在隐式intent调用必须添加<code>android.intent.category.DEFAULT</code></p>
</li>
</ul>
<p><strong>补充：</strong><br><strong>关于主Activity</strong>，应用程序需要包含至少一个Activity组件来支持MAIN操作和LAUNCHER种类，即为主Activity<br>暴露的Activity组件不包括主Activity，如果你把主Activity设置exported为false了，那你的应用就甭想运行了，正常的应用来说。</p>
<blockquote>
<p>参考：<br><a href="http://blog.csdn.net/gorgle/article/details/51420586" target="_blank" rel="noopener">http://blog.csdn.net/gorgle/article/details/51420586</a><br><a href="http://www.itdadao.com/articles/c15a12377p0.html" target="_blank" rel="noopener">http://www.itdadao.com/articles/c15a12377p0.html</a></p>
</blockquote>
<h3 id="不要指定taskAffinity"><a href="#不要指定taskAffinity" class="headerlink" title="不要指定taskAffinity"></a>不要指定taskAffinity</h3><p>Android中的activity全都归属于task管理 ， 简单说来task是一种stack(堆栈)的数据结构， 先入后出。<br>一般来说， 如果不指明归属于什么task， 同一个app内部的所有Activity都会存续在一个task中，task的名字就是app的packageName。<br>因为在同一个andorid设备中，不会有两个同packageName的app存在，所以能保证Activity不被攻击。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".Activity1"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:taskAffinity</span>=<span class="string">"com.winuxxan.task"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>恶意软件中的Activity如果也声明为同样的taskAffinity，那他的Activity就会启动到你的task中，就会有机会拿到你的intent(我们一般会在intent中对数据进行加密处理)</p>
<p>那么taskAffinity到底什么用呢？<br>它的作用是描述了不同Activity之间的亲密关系。拥有相同的taskAffinity的Activity是亲密的，它们之间在相互跳转时，会位于同一个task中，而不会新建一个task!<br>简单说就是意味着这activity更喜欢哪个TESK</p>
<blockquote>
<p>一个新的activity，默认地启动到调用startActivity()方法的activity的task中。它和调用者放到同样的back stack中。然而，如果传递给startActivity()的intent包含<code>FLAG_ACTIVITY_NEW_TASK</code>标志，系统将会需找一个不同的task来容纳新的activity。<strong>通常，它是一个新的task</strong>。然而，不是必须都是如此的。如果已经存在一个和新的activity具有相同的affinity的task，新activity会启动到该task中。<strong>如果没有，它会启动一个新的task。</strong></p>
<p>当一个activity它的<code>allowTaskReparenting</code>属性设置为true<br>这种情况，activity可以从它启动的task移到和它有相同affinity的task，当该task来到前台的时候。</p>
</blockquote>
<h3 id="不要指定LaunchMode-默认standard模式"><a href="#不要指定LaunchMode-默认standard模式" class="headerlink" title="不要指定LaunchMode(默认standard模式)"></a>不要指定LaunchMode(默认standard模式)</h3><p>Android中Activity的LaunchMode分成以下四种</p>
<ul>
<li>Standard<br>这种方式打开的Activity不会被当作rootActivity，会生成一个新的Activity的instance(实例)，会和打开者在同一个task内</li>
<li>singleTop<br>和standard基本一样，唯一的区别在于如果当前task第一个Activity就是该Activity的话，就不会生成新的instance</li>
<li>singleTask<br>系统会创建一个新task(如果没有启动应用)和一个activity新实例在新task根部，然后，如果activity实例已经存在单独的task中，系统会调用已经存在activity的 onNewIntent()方法，而不是存在新实例，仅有一个activity实例同时存在。</li>
<li>singleInstance<br>和singleTask相似，除了系统不会让其他的activities运行在所有持有的task实例中，这个activity是独立的，并且task中的成员只有它，任何其他activities运行这个activity都将打开一个独立的task。</li>
</ul>
<p><strong>所有发送给root Activity(根Activiy)的intent都会在android中留下履历(入侵关键，大概)。所以一般来说严禁用singleTask或者singleInstance来启动画面。</strong><br>然而，即使用了standard来打开画面，也可能会出问题，比如如果调用者的Activity是用singleInstance模式打开，即使用standard模式打开被调用Activity，因为调用者的Activity task是不能有其他task的， 所以android会被迫生成一个新的task，并且把被调用者塞进去，最后被调用者就成了rootActivity。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher"</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- root Activity以”singleInstance”模式启动 --&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- 不设置taskAffinity--&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">     	<span class="attr">android:name</span>=<span class="string">".PrivateUserActivity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 非公開Activity --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动模式为”standard” --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不设置taskAffinity--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:name</span>=<span class="string">".PrivateActivity"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p><strong>发给Activity的intent不要设定为FLAG_ACTIVITY_NEW_TASK</strong><br>就算上面的Activity的lauchMode设置完善了， <strong>在打开intent的时候还是能指定打开模式。</strong><br>比如在intent中指明用FLAG_ACTIVITY_NEW_TASK模式的话，发现该activity不存在的话，就会强制新建一个task。如果同时设置了<code>FLAG_ACTIVITY_MULTIPLE_TASK</code>+<code>FLAG_ACTIVITY_NEW_TASK</code>，就无论如何都会生成新的task，该Activity就会变成rootActiviy，并且intent会被留成履历</p>
<h3 id="Intent中数据的加密"><a href="#Intent中数据的加密" class="headerlink" title="Intent中数据的加密"></a>Intent中数据的加密</h3><p>这个前面提到过，Activity中数据的传递都依靠intent， 很容易被攻击， 所以 就算同一个app内部传递数据， 最好还是要加密， 加密算法很多。</p>
<h3 id="明确ActivityName发送Intent"><a href="#明确ActivityName发送Intent" class="headerlink" title="明确ActivityName发送Intent"></a>明确ActivityName发送Intent</h3><p>避免被恶意软件所截取，主要是注意在不同APP直接的数据发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClassName(</span><br><span class="line"><span class="string">"org.jssec.android.activity.publicactivity"</span>,</span><br><span class="line"><span class="string">"org.jssec.android.activity.publicactivity.PublicActivity"</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"><span class="comment">//另一种方式</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();  </span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.example.otherapp"</span>,  </span><br><span class="line">                    <span class="string">"com.example.otherapp.MainActivity2"</span>));  </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>不是指明了packageName和ActivityName就能避免所有的问题,如果有一个恶意软件故意做成和你发送目标同PackageName, 同ActivityName， 此时的intent就会被截取.<br>对于这两种方式经查看源码发现 Intent 的setClass() 方法的实现正是使用ComponentName 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">setClass</span><span class="params">(Context packageContext,Class&lt;?&gt; cls)</span></span>&#123;</span><br><span class="line">    mComponent=<span class="keyword">new</span> ComponentName(packageContext,cls);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收intent时明确对方的身份"><a href="#接收intent时明确对方的身份" class="headerlink" title="接收intent时明确对方的身份"></a>接收intent时明确对方的身份</h3><p>一个好方法是比对对方的app的hashcode。<br>当前，前提是调用者要用startActivityForResult()，因为只有这个方法，被调用者才能得到调用者的packageName</p>
<h3 id="intent数据泄漏到LogCat"><a href="#intent数据泄漏到LogCat" class="headerlink" title="intent数据泄漏到LogCat"></a>intent数据泄漏到LogCat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Intent中发送的数据就会被自动写入LogCat</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"mailto:test@gmail.com"</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri);</span><br><span class="line">startActivity(intent);</span><br><span class="line"><span class="comment">//这样写就能避免</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"mailto:"</span>);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri);</span><br><span class="line">intent.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> String[] &#123;<span class="string">"test@gmail.com"</span>&#125;);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>注意下这个权限<code>&lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;</code><br>有了这个权限就能取出这台手机上所有task上所有根Activity接受到的intent，大概<br>所以：<strong>所有根Activity中的intent都能被所有app共享</strong></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>关于上面介绍的那些每一个其实都大有学问呐，不过都没深入进去追究，目前水平也是有限。<br>这里看到了LaunchMode，再补充下它的应用场景吧：</p>
<blockquote>
<p>singleTop适合接收通知启动的内容显示页面。<br>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。<br>singleTask适合作为程序入口点。<br>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。<br>singleInstance适合需要与程序分离开的页面。<br>例如闹铃提醒，将闹铃提醒与闹铃设置分离。<br>singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p>
<p><strong>TaskAffinity对LaunchMode的影响:</strong><br>不指定TaskAffinity，singleTask会在默认的task 中执行，这个符合预期，一般也都是这么用的，不需要指定。<br>不指定TaskAffinity，singleInstance之后启动的页面不能放倒singleInstance所在那个task中，会放倒默认的task中，不过一般singleInstance也不适合作为程序中间页。</p>
<p><a href="http://blog.csdn.net/xiaodongrush/article/details/28597855" target="_blank" rel="noopener">http://blog.csdn.net/xiaodongrush/article/details/28597855</a></p>
</blockquote>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/thestoryoftony/article/details/9370427" target="_blank" rel="noopener">http://blog.csdn.net/thestoryoftony/article/details/9370427</a><br><a href="http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/index.html" target="_blank" rel="noopener">http://droidyue.com/blog/2015/08/16/dive-into-android-activity-launchmode/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS/jQuery选择器总结]]></title>
      <url>http://bfchengnuo.com/2016/10/04/css-jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>因为一些原因，最近在复习CSS相关的知识，果然，选择器部分直接是一点印象都没了，并且google找了一会也没看到很全的总结，好不容易找到一个，存档以便日后翻阅<br><a id="more"></a><br>虽然我并不喜欢CSS然而还是要了解一些东西的…<br>其中的大部分选择器也是可以直接在JQ中用的，我个人认为…</p>
<h2 id="CSS选择器部分"><a href="#CSS选择器部分" class="headerlink" title="CSS选择器部分"></a>CSS选择器部分</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>*</strong></td>
<td>通用元素选择器，匹配任何元素</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>标签选择器，匹配所有使用E标签的元素</td>
</tr>
<tr>
<td><strong>.info</strong></td>
<td>class选择器，匹配所有class属性中包含info的元素</td>
</tr>
<tr>
<td><strong>#footer</strong></td>
<td>id选择器，匹配所有id属性等于footer的元素</td>
</tr>
</tbody>
</table>
<h3 id="多元素的组合选择器"><a href="#多元素的组合选择器" class="headerlink" title="多元素的组合选择器"></a>多元素的组合选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E,F</td>
<td>多元素选择器，同时<strong>匹配所有</strong>E元素或F元素，E和F之间<strong>用逗号</strong>分隔</td>
</tr>
<tr>
<td>E F</td>
<td>后代元素选择器，匹配所有属于E元素<strong>后代</strong>的F元素，E和F之间用<strong>空格</strong>分隔</td>
</tr>
<tr>
<td>E &gt; F</td>
<td>子元素选择器，匹配所有E元素的子元素F</td>
</tr>
<tr>
<td>E + F</td>
<td>毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</td>
</tr>
<tr>
<td>E.classname</td>
<td>交叉选择器，之间没有空格，选择E标签下的类名为classname的元素，类似的有E#idName</td>
</tr>
</tbody>
</table>
<h3 id="CSS-2-1-属性选择器"><a href="#CSS-2-1-属性选择器" class="headerlink" title="CSS 2.1 属性选择器"></a>CSS 2.1 属性选择器</h3><p>由于MD语法的原因<code>|</code>使用¦代替</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[att]</td>
<td>匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</td>
</tr>
<tr>
<td>E[att=val]</td>
<td>匹配所有att属性等于”val”的E元素</td>
</tr>
<tr>
<td>E[att~=val]</td>
<td>匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</td>
</tr>
<tr>
<td>E[att¦=val]</td>
<td>匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</td>
</tr>
</tbody>
</table>
<h3 id="CSS-2-1中的伪类"><a href="#CSS-2-1中的伪类" class="headerlink" title="CSS 2.1中的伪类"></a>CSS 2.1中的伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:first-child</td>
<td>匹配父元素的第一个子元素</td>
</tr>
<tr>
<td>E:link</td>
<td>匹配所有未被点击的链接</td>
</tr>
<tr>
<td>E:visited</td>
<td>匹配所有已被点击的链接</td>
</tr>
<tr>
<td>E:active</td>
<td>匹配鼠标已经其上按下、还没有释放的E元素</td>
</tr>
<tr>
<td>E:hover</td>
<td>匹配鼠标悬停其上的E元素</td>
</tr>
<tr>
<td>E:focus</td>
<td>匹配获得当前焦点的E元素</td>
</tr>
<tr>
<td>E:lang(c)</td>
<td>匹配lang属性等于c的E元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-2-1中的伪元素"><a href="#CSS-2-1中的伪元素" class="headerlink" title="CSS 2.1中的伪元素"></a>CSS 2.1中的伪元素</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:first-line</td>
<td>匹配E元素的第一行</td>
</tr>
<tr>
<td>E:first-letter</td>
<td>匹配E元素的第一个字母</td>
</tr>
<tr>
<td>E:before</td>
<td>在E元素之前插入生成的内容</td>
</tr>
<tr>
<td>E:after</td>
<td>在E元素之后插入生成的内容</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3的同级元素通用选择器"><a href="#CSS-3的同级元素通用选择器" class="headerlink" title="CSS 3的同级元素通用选择器"></a>CSS 3的同级元素通用选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E ~ F</td>
<td>匹配任何在E元素之后的同级F元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3-属性选择器"><a href="#CSS-3-属性选择器" class="headerlink" title="CSS 3 属性选择器"></a>CSS 3 属性选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[att^=”val”]</td>
<td>属性att的值以”val”开头的元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td>属性att的值以”val”结尾的元素</td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td>属性att的值包含”val”字符串的元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3中与用户界面有关的伪类"><a href="#CSS-3中与用户界面有关的伪类" class="headerlink" title="CSS 3中与用户界面有关的伪类"></a>CSS 3中与用户界面有关的伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:enabled</td>
<td>匹配表单中激活的元素</td>
</tr>
<tr>
<td>E:disabled</td>
<td>匹配表单中禁用的元素</td>
</tr>
<tr>
<td>E:checked</td>
<td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td>
</tr>
<tr>
<td>E::selection</td>
<td>匹配用户当前选中的元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3中的结构性伪类"><a href="#CSS-3中的结构性伪类" class="headerlink" title="CSS 3中的结构性伪类"></a>CSS 3中的结构性伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:root</td>
<td>匹配文档的根元素，对于HTML文档，就是HTML元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>匹配其父元素的第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-last-child(n)</td>
<td>匹配其父元素的倒数第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:nth-last-of-type(n)</td>
<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:last-child</td>
<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:only-child</td>
<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr>
<td>E:only-of-type</td>
<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:empty</td>
<td>匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3的反选伪类"><a href="#CSS-3的反选伪类" class="headerlink" title="CSS 3的反选伪类"></a>CSS 3的反选伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:not(s)</td>
<td>匹配不符合当前选择器的任何元素</td>
</tr>
</tbody>
</table>
<h3 id="CSS-3中的-target-伪类"><a href="#CSS-3中的-target-伪类" class="headerlink" title="CSS 3中的 :target 伪类"></a>CSS 3中的 :target 伪类</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:target</td>
<td>匹配文档中特定”id”点击后的效果</td>
</tr>
</tbody>
</table>
<h2 id="jQ选择器部分"><a href="#jQ选择器部分" class="headerlink" title="jQ选择器部分"></a>jQ选择器部分</h2><p>偷个懒，直接从W3C复制过来的，但貌似也并不全，更详细的可以去下载API</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>实例</th>
<th>选取</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_all.asp" target="_blank" rel="noopener">*</a></td>
<td>$(“*”)</td>
<td>所有元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_id.asp" target="_blank" rel="noopener">#<em>id</em></a></td>
<td>$(“#lastname”)</td>
<td>id=”lastname” 的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_class.asp" target="_blank" rel="noopener">.<em>class</em></a></td>
<td>$(“.intro”)</td>
<td>所有 class=”intro” 的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_element.asp" target="_blank" rel="noopener"><em>element</em></a></td>
<td>$(“p”)</td>
<td>所有 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td>.<em>class</em>.<em>class</em></td>
<td>$(“.intro.demo”)</td>
<td>所有 class=”intro” 且 class=”demo” 的元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_first.asp" target="_blank" rel="noopener">:first</a></td>
<td>$(“p:first”)</td>
<td>第一个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_last.asp" target="_blank" rel="noopener">:last</a></td>
<td>$(“p:last”)</td>
<td>最后一个 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_even.asp" target="_blank" rel="noopener">:even</a></td>
<td>$(“tr:even”)</td>
<td>所有偶数 <code>&lt;tr&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_odd.asp" target="_blank" rel="noopener">:odd</a></td>
<td>$(“tr:odd”)</td>
<td>所有奇数 <code>&lt;tr&gt;</code> 元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_eq.asp" target="_blank" rel="noopener">:eq(<em>index</em>)</a></td>
<td>$(“ul li:eq(3)”)</td>
<td>列表中的第四个元素（index 从 0 开始）</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_gt.asp" target="_blank" rel="noopener">:gt(<em>no</em>)</a></td>
<td>$(“ul li:gt(3)”)</td>
<td>列出 index 大于 3 的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_lt.asp" target="_blank" rel="noopener">:lt(<em>no</em>)</a></td>
<td>$(“ul li:lt(3)”)</td>
<td>列出 index 小于 3 的元素</td>
</tr>
<tr>
<td>:not(<em>selector</em>)</td>
<td>$(“input:not(:empty)”)</td>
<td>所有不为空的 input 元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_header.asp" target="_blank" rel="noopener">:header</a></td>
<td>$(“:header”)</td>
<td>所有标题元素 <code>&lt;h1&gt; - &lt;h6&gt;</code></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_animated.asp" target="_blank" rel="noopener">:animated</a></td>
<td></td>
<td>所有动画元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_contains.asp" target="_blank" rel="noopener">:contains(<em>text</em>)</a></td>
<td>$(“:contains(‘W3School’)”)</td>
<td>包含指定字符串的所有元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_empty.asp" target="_blank" rel="noopener">:empty</a></td>
<td>$(“:empty”)</td>
<td>无子（元素）节点的所有元素</td>
</tr>
<tr>
<td>:hidden</td>
<td>$(“p:hidden”)</td>
<td>所有隐藏的 <code>&lt;p&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_visible.asp" target="_blank" rel="noopener">:visible</a></td>
<td>$(“table:visible”)</td>
<td>所有可见的表格</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s1,s2,s3</td>
<td>$(“th,td,.intro”)</td>
<td>所有带有匹配选择的元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_attribute.asp" target="_blank" rel="noopener">[<em>attribute</em>]</a></td>
<td>$(“[href]”)</td>
<td>所有带有 href 属性的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_attribute_equal_value.asp" target="_blank" rel="noopener">[<em>attribute</em>=<em>value</em>]</a></td>
<td>$(“[href=’#’]”)</td>
<td>所有 href 属性的值等于 “#” 的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_attribute_notequal_value.asp" target="_blank" rel="noopener">[<em>attribute</em>!=<em>value</em>]</a></td>
<td>$(“[href!=’#’]”)</td>
<td>所有 href 属性的值不等于 “#” 的元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_attribute_end_value.asp" target="_blank" rel="noopener">[<em>attribute</em>$=<em>value</em>]</a></td>
<td>$(“[href$=’.jpg’]”)</td>
<td>所有 href 属性的值包含以 “.jpg” 结尾的元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input.asp" target="_blank" rel="noopener">:input</a></td>
<td>$(“:input”)</td>
<td>所有 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_text.asp" target="_blank" rel="noopener">:text</a></td>
<td>$(“:text”)</td>
<td>所有 type=”text” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_password.asp" target="_blank" rel="noopener">:password</a></td>
<td>$(“:password”)</td>
<td>所有 type=”password” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_radio.asp" target="_blank" rel="noopener">:radio</a></td>
<td>$(“:radio”)</td>
<td>所有 type=”radio” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_checkbox.asp" target="_blank" rel="noopener">:checkbox</a></td>
<td>$(“:checkbox”)</td>
<td>所有 type=”checkbox” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_submit.asp" target="_blank" rel="noopener">:submit</a></td>
<td>$(“:submit”)</td>
<td>所有 type=”submit” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_reset.asp" target="_blank" rel="noopener">:reset</a></td>
<td>$(“:reset”)</td>
<td>所有 type=”reset” 的 <code>&lt;input&gt;</code>元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_button.asp" target="_blank" rel="noopener">:button</a></td>
<td>$(“:button”)</td>
<td>所有 type=”button” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_image.asp" target="_blank" rel="noopener">:image</a></td>
<td>$(“:image”)</td>
<td>所有 type=”image” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_file.asp" target="_blank" rel="noopener">:file</a></td>
<td>$(“:file”)</td>
<td>所有 type=”file” 的 <code>&lt;input&gt;</code> 元素</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_enabled.asp" target="_blank" rel="noopener">:enabled</a></td>
<td>$(“:enabled”)</td>
<td>所有激活的 input 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_disabled.asp" target="_blank" rel="noopener">:disabled</a></td>
<td>$(“:disabled”)</td>
<td>所有禁用的 input 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_selected.asp" target="_blank" rel="noopener">:selected</a></td>
<td>$(“:selected”)</td>
<td>所有被选取的 input 元素</td>
</tr>
<tr>
<td><a href="http://www.w3school.com.cn/jquery/selector_input_checked.asp" target="_blank" rel="noopener">:checked</a></td>
<td>$(“:checked”)</td>
<td>所有被选中的 input 元素</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文作者： 阮一峰<br>原文地址：<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2009/03/css_selectors.html</a></p>
<p>jQuery选择器：<a href="http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记]]></title>
      <url>http://bfchengnuo.com/2016/10/02/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>js是一门基于对象的弱类型语言，至于用处可谓是无处不在，GitHub语言排行榜稳稳的第一，JS终究一统世界…不来学习下？起码前半部分还是java呢！虽然和java并无啥关系<br><a id="more"></a><br>还有一个原因是，这几天微信小程序弄的沸沸扬扬，我也漫无目的的去学习了下，也涉及到了js，微信小程序已经内测，你的js知识储备准备好了么？？o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br>写的比较混乱 = =！<del>因为感冒嘛</del>~</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>js一般要和html、css配合起来用，所以还是要有一些html之类的知识的，嘛~不就是一堆标签吗？学习下也用不了多长时间，js的代码我们一般可以写在两个地方：</p>
<ul>
<li>html文件中<br><code>&lt;script type=&quot;text/javascript&quot;&gt;这里写js代码&lt;/script&gt;</code><br>可以放在页面的任何位置，但是我们一般放在网页的head或者body部分。<br>如果在head部分：浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。<br>如果在body部分：网页读取到该语句的时候就会执行，执行完后再读取下面的</li>
<li>外部js文件<br>写在单独的扩展名为.js的文件中然后在html中引用，js文件中不需要再加标签，引用方式：<code>&lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>，注意的是标签中间不能再写js代码，如果需要补充代码的话可以再写一个标签。</li>
</ul>
<p>一般来说，script 要放到 body 的最下面，提高加载速度，如果放到 head 里那就会影响 HTML 结构的渲染，理论上说放那都行，但是规范上 js 属于正文部分，所以最好是放在 body 里面。<br>但是呢，如果页面引用了多个文件，不能保证在用时已经加载完毕，所以很多选择性放在头部还是尾部。<br><a href="http://sfau.lt/b5saPH" target="_blank" rel="noopener">http://sfau.lt/b5saPH</a></p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>很多地方其实还是和其他语言有很大相同点的，这里主要总结一些和其他不同的地方，因为也没学过什么解释型语言。<br>Js中有一种叫严格相等<code>===</code>，<del>也就是比较对象而不是数值</del></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>js是弱类型语言，所以变量的类型不会像java那样细分，定义变量只有一个关键字 var使用就是：var 变量名<br>理论上名称是可以任意取名，同样最好遵守下命名规范：</p>
<blockquote>
<p>1.变量必须使用字母、下划线(_)或者美元符($)开始。</p>
<p>2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。</p>
<p>3.不能使用JavaScript关键词与JavaScript保留字。</p>
<p>更详细的在这：<a href="https://github.com/fex-team/styleguide/blob/master/javascript.md" target="_blank" rel="noopener">https://github.com/fex-team/styleguide/blob/master/javascript.md</a></p>
</blockquote>
<p>注意:<br><strong>变量也可以不声明，直接使用</strong>，但为了规范，需要先声明，后使用，不声明的话就会是(隐式)全局变量[<del>定义全局变量的正统方式</del>]<br><strong>当变量没有初始化就被使用 就会显示undefined</strong><br>js 中 false、null 就是0，非 0 就是true  是可以运算的如： false + 1 = 1 ; true + 1 = 2<br>或者说，null、0、undefined、’’（空字符串） 这些都是 false，可以（可能是部分浏览器）通过 if 判断</p>
<h3 id="函数和属性"><a href="#函数和属性" class="headerlink" title="函数和属性"></a>函数和属性</h3><p>因为js中没有class(类)的概念，所以函数很重要！基本定义如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//函数代码;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数的参数不用特意声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">  x = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态函数,a、b是参数，后面是运算逻辑</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a+b"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//与其java类似的一个需要注意的问题</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">show(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后的结果a还是3，注意它们的范围</span></span><br></pre></td></tr></table></figure>
<p>以及一个简单的调用：<code>&lt;input type=&quot;button&quot;  value=&quot;点击我&quot; onclick=&quot;funName()&quot; /&gt;</code><br><strong>注意：</strong><br>js中的函数<strong>没有重载</strong>（函数其实就是一个对象，对象只有覆盖），所有的参数被函数内的arguments所接收，即使是空参的，所以说空参的函数你也可以向里传参数，同时也<strong>可以传部分参数，你没传的参数默认就是undefined了</strong><br>js中函数就是对象，var x = show  不加括号的话相当于直接指向了那个对象，加括号相当于进行了运算，然后把运算后的值给x(<del>和最近学的Py好像</del>)<br><strong>可以被封装起来用</strong><br>JS中所有<code>.</code>的调用都可以替换成<code>[&#39;&#39;]</code>，他们是等价的，在拼接的时候只能用第二种方式，下面两句是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.prop = <span class="string">"abc"</span>;</span><br><span class="line">obj[<span class="string">"prop"</span>] = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>函数还可以封装起来当作java中的class来使用，涉及到定义属性，JavaScript中有三种不同类型的属性:命名数据属性，命名访问器属性以及内部属性，关于属性其实上面多少已经使用了一些，几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test(<span class="string">"loli"</span>);</span><br><span class="line"><span class="comment">//属性可以直接赋值不用定义</span></span><br><span class="line">a.item = <span class="number">1</span>;</span><br><span class="line">a.t = <span class="string">"aaa"</span>;</span><br><span class="line">alert(a.t + a.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数和方法的区别</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">12</span>;   <span class="comment">// 变量：自由的</span></span><br><span class="line">arr.a= <span class="number">5</span>;     <span class="comment">//属性：属于一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)     //函数：自由的</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  alert(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">arr.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)   //方法：属于一个对象</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  alert(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还可以定义一个空函数用来做构造器，<strong>构造函数首字母一般大写，用来区分</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//设置原型</span></span><br><span class="line">Class.prototype=&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> item=<span class="keyword">new</span> Class();</span><br></pre></td></tr></table></figure>
<p><strong>这里首先声明下，js中的{}一般代表定义一个对象，大部分情况下是要有成对的属性或值，或函数</strong></p>
<h4 id="命名数据属性"><a href="#命名数据属性" class="headerlink" title="命名数据属性"></a>命名数据属性</h4><p>这个是我们通常所用的“普通”属性，感觉挺像json的格式的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//读取(获取)值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.prop); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">"prop"</span>]); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">//写入值</span></span><br><span class="line">obj.prop = <span class="string">"abc"</span>;</span><br><span class="line">obj[<span class="string">"prop"</span>] = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="命名访问器属性"><a href="#命名访问器属性" class="headerlink" title="命名访问器属性"></a>命名访问器属性</h4><p>概括一下就是：借助函数来获取或设置一个属性的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Getter"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Setter: "</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后的效果：</p>
<blockquote>
<p>—&gt;obj.prop<br>‘Getter’</p>
<p>—&gt;obj.prop = 123;<br>Setter: 123</p>
</blockquote>
<h4 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h4><p>有一些属性仅仅是为规范所用的,称之为内部属性,因为它们无法通过JavaScript直接访问到,但是它们的确存在,并且影响着程序的表现.内部属性的名称比较特殊,<strong>它们都被两个中括号包围着</strong>.下面有两个例子:</p>
<ul>
<li>内部属性<code>[[Prototype]]</code>指向了所属对象的原型.该属性的值可以通过<code>Object.getPrototypeOf()</code>函数读取到.该属性的值只能在创建一个新对象的时候通过<code>Object.create()</code>或者<strong>proto</strong>来设置 <a href="http://www.cnblogs.com/ziyunfei/archive/2012/10/30/2745786.html#a1" target="_blank" rel="noopener">[1]</a>.<br>例如：<code>Object.getPrototypeOf(this).methodName1();</code><br>可以看下面的对象原型标题</li>
<li>内部属性<code>[[Extensible]]</code>决定了是否能给所属对象添加新的属性.该属性的值可以通过<code>Object.isExtensible()</code>读取到.还可以通过<code>Object.preventExtensions()</code>将该属性的值设置为false.<strong>一旦设置为false,就无法再设置回true了</strong>.</li>
</ul>
<h4 id="关于匿名函数"><a href="#关于匿名函数" class="headerlink" title="关于匿名函数"></a>关于匿名函数</h4><p>在javascript语言里任何匿名函数都是属于<code>window</code>对象。在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的<code>this</code>指向也是<code>window</code>对象。<br>这里为什么要单独说下匿名函数呢，因为它好玩啊！还可以这样玩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自执行函数</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//或者这样写</span></span><br><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="with语句和for…in"><a href="#with语句和for…in" class="headerlink" title="with语句和for…in"></a>with语句和for…in</h4><ul>
<li><p>with语句主要是为了调用对象的方法可以省略函数名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span>(a)&#123;</span><br><span class="line">  name = <span class="string">"bbb"</span>; <span class="comment">//不用写a.name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…in 可以用来遍历对象。遍历出的是变量名(假设理解为key:values可以理解为key)，如果取值直接用<code>.</code>获取值是不行的，没法进行字符串的连接，所以要用<code>[]</code>的方式来解决<br>遍历数组得到的是角标，同样需要arr[x]取值</p>
</li>
</ul>
<p>关于 for in 及循环来了解一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">in</span> array) &#123;</span><br><span class="line">  fn(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  fn(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 for-in 需要分析出 array 的每个属性，这个操作的性能开销很大，<strong>用在 key 已知的数组上是非常不划算的</strong>。所以尽量不要用 for-in，除非你不清楚要处理哪些属性，例如 JSON 对象这样的情况。<br>在第二种循环中，效率也不高，循环每执行一次，都要检查一次 <strong>array.length</strong> 的值，读属性要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素（像 <code>array = document.getElementByClassName(&quot;class&quot;);</code>），因为每次读 array.length 都要扫描一遍页面上 class=”class” 的元素，速度更是慢得抓狂。<br>下面就介绍几种优化后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length; i--;) &#123;</span><br><span class="line">    fn(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="keyword">var</span> i = array.length;</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    fn(array[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就避免了每次判断 length 的尴尬情况。</p>
<h4 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h4><ul>
<li>关于回调<br>js中的回调相比java就简单太多了，不需要接口啥的，因为变量可以指向函数嘛~所以到时候直接”执行”那个变量就好了嘛…</li>
<li>js中的全局函数<br>escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )等</li>
</ul>
<blockquote>
<p>更多关于函数的解释见：<a href="https://segmentfault.com/a/1190000000660786#articleHeader11" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000660786#articleHeader11</a></p>
</blockquote>
<h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>js中很多内部对象是拥有prototype属性的，对于拥有prototype属性的对象可以在原型的基础上增加功能扩展。下面的例子可以很好的说明这个功能，我们在string对象的基础上增加去空格和转置的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除前后空格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start,end;</span><br><span class="line">  start = <span class="number">0</span>;</span><br><span class="line">  end = <span class="keyword">this</span>.length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(start &lt;= end &amp;&amp; <span class="keyword">this</span>.charAt(start) == <span class="string">" "</span>)&#123;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(start &lt;= end &amp;&amp; <span class="keyword">this</span>.charAt(end) == <span class="string">" "</span>)&#123;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转置函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    str += <span class="keyword">this</span>.charAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象的原型，扩展功能,注意String的S的大写</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = trim;</span><br><span class="line"><span class="built_in">String</span>.prototype.reverse = reverse;</span><br></pre></td></tr></table></figure>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM：<strong>document</strong> object model 文档对象模型，简单说：<strong>将文档和标签以及其他内容变成对象。</strong><br>DOM分为三层模型<br>dom1: 将html文档封装为对象<br>dom2: 在leve 1基础上加入了新功能，比如解析名称空间。<br>dom3: 将XML文档封装成对象</p>
<p>对于dom1的封装，可以视为将html的标签的层级关系封装成了树形结构，称为DOM树，每一个节点(标签)都是一个对象，能更好的进行管理(比如创建、删除、修改)，能够动态的改变html的结构。</p>
<blockquote>
<p>MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">文档对象模型 (DOM)</a> 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。</p>
</blockquote>
<p><strong>说白了DOM就是浏览器为JavaScript提供的一系列接口（通过window.documnet提供的），通过这些接口我们可以操作web页面（JS 无法直接修改页面结构）。</strong> 但DOM并不是编程语言，它是文档对象的模型，该模型是独立于编程语言的。</p>
<p><strong>关于DHTML：</strong><br>是多个技术的综合体，叫做动态的html<br>DHTML=HTML+CSS+JavaScript+DOM</p>
<p><strong>补充：在DHTML基础上加了轻量级的与服务器交互的功能就成了AJAX，DHTML+XMLhttpRequest = AJAX，比如google的搜索词预测</strong></p>
<h3 id="关于解析"><a href="#关于解析" class="headerlink" title="关于解析"></a>关于解析</h3><p>对于DOM解析方式<br>好处：可以对树中的节点进行任意操作，比如：增删改查。<br>弊端：这种解析需要将整个标记型文档加载进内存。意味着如果标记型文档的体积很大，较为浪费内存空间。</p>
<p>另一种解析方式：<br>SAX：是由一些组织定义的一种民间常用的解析方式，并不是w3c标准，而DOM是W3C的标准。<br>SAX解析的方式：基于事件驱动的解析。随加载，随解析(读取到一个标签的结束标记就进行解析)获取数据的速度很快，但是不能对标记进行增删改。</p>
<h3 id="关于节点"><a href="#关于节点" class="headerlink" title="关于节点"></a>关于节点</h3><p>比较常见的又三种DOM节点：</p>
<ol>
<li><p>元素节点：上图中<code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。</p>
</li>
<li><p>文本节点:向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的JavaScript、DOM、CSS等文本。</p>
</li>
<li>属性节点:元素属性，如<code>&lt;a&gt;</code>标签的链接属性href</li>
</ol>
<p><strong>节点名称(nodeName)</strong><br>元素节点的 nodeName 与标签名相同<br>属性节点的 nodeName 是属性的名称<br>文本节点的 nodeName 永远是 #text<br>文档节点的 nodeName 永远是 #document<br><strong>节点的类型(type)：</strong><br>标签型节点：1<br>属性节点：2<br>文本型节点：3<br>注释型节点：8<br>document：9 (它的范围就是浏览器中整个显示网页的区域)<br><strong>获取节点的方式</strong><br>获取的方法有多种，获取子节点、父节点、兄弟节点之类的….<br><strong>注意：标签之间如果存在空行，有的浏览器会认为是一个空白的文本节点</strong></p>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>一般我们常用的就是三种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ID进行获取,window可省略</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"id"</span>);</span><br><span class="line"><span class="comment">//通过标签名获取</span></span><br><span class="line">getElementsByTagName(<span class="string">"tagName"</span>);</span><br><span class="line"><span class="comment">//通过指定的名称</span></span><br><span class="line">getElementsByName(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>
<p>第一种返回的就是一个对象，后面的两个返回的是一个对象的集合，可以理解为数组，因为id只能有一个，其他的就不确定了。<br>获取到对象后可以根据API中的html属性所对应的DHTML样式属性(style)或者标签属性的名来修改内容。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p><strong>微软</strong>提出了名为<strong>事件冒泡</strong>(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会<strong>从最内层的元素开始发生</strong>，一直向上传播，直到document对象。<br>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是<strong>p -&gt; div -&gt; body -&gt; html -&gt; document</strong></p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p><strong>网景</strong>提出另一种事件流名为<strong>事件捕获</strong>(event capturing)。与事件冒泡相反，事件会<strong>从最外层开始</strong>发生，直到最具体的元素。<br>上面的例子在事件捕获的概念下发生click事件的顺序应该是<strong>document -&gt; html -&gt; body -&gt; div -&gt; p</strong></p>
<hr>
<p>后来 w3c 采用折中的方式，平息了战火，制定了统一的标准——<strong>先捕获再冒泡</strong>。<br>以下属于DOM2级处理程序了，0级就是直接设置onclick属性，<strong>DOM0级事件只会在冒泡阶段加载！</strong><br>addEventListener的第三个参数就是为冒泡和捕获准备的.<br>addEventListener有三个参数：</p>
<blockquote>
<p>element.addEventListener(event, function, useCapture)</p>
</blockquote>
<p>第一个参数是需要绑定的事件<br>第二个参数是触发事件后要执行的函数<br>第三个参数默认值是false，表示在<strong>事件冒泡阶段</strong>调用事件处理函数;如果参数为true，则表示在<strong>事件捕获阶段</strong>调用处理函数。<br>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，<strong>从兼容性角度来说还是建议大家使用事件冒泡模型。</strong></p>
<hr>
<p>下面的方法被对象所调用<br>type属性用于获取事件类型<br>target属性用于获取事件目标<br>stopPropagation()方法 用于阻止事件冒泡<br>preventDefault() 方法 阻止事件的默认行为<br>event.KeyCode  可用来屏蔽按键<br>event.returnValue=false 可以将事件取消掉(常用于表单)<br>event.srcElement 获取事件源对象(那一个对象触发的)</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>用于操作浏览器的对象，BOM的核心就是window对象，window对象指当前的浏览器窗口。<br>利用window对象可以操作浏览器的相关设置，比如地址栏、屏幕的大小、操作系统、窗口的位置等等，这个貌似不太经常用，这里不说了，用到了查API或者google之<br>不过一般会用到一些事件，如窗体装载、卸载啦</p>
<ul>
<li><p>加载事件（onload）<br>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p>
</li>
<li><p>卸载事件（onunload）<br>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p>
</li>
</ul>
<ul>
<li><p>关闭窗口<br>window.close ：关闭本窗口<br>[窗口对象].close ：关闭指定窗口</p>
</li>
<li><p>History 对象<br>可以获取用户曾经浏览过那些网页，以实现后退、前进的功能</p>
</li>
<li><p>其他常用对象<br>location用于获取或设置窗体的URL，并且可以用于解析URL。<br>Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。<br>screen对象用于获取用户的屏幕信息。</p>
</li>
</ul>
<h2 id="其他常用函数-事件-属性补充"><a href="#其他常用函数-事件-属性补充" class="headerlink" title="其他常用函数/事件/属性补充"></a>其他常用函数/事件/属性补充</h2><table>
<thead>
<tr>
<th style="text-align:center">函数/事件名/属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alert(字符串或变量)</td>
<td style="text-align:center">警告提示框，调试频繁用</td>
</tr>
<tr>
<td style="text-align:center">confirm(str);</td>
<td style="text-align:center">确认提示框，点击确定返回true，点击取消返回false</td>
</tr>
<tr>
<td style="text-align:center">elementNode.getAttribute(name)</td>
<td style="text-align:center">通过元素节点的属性名称获取属性的值</td>
</tr>
<tr>
<td style="text-align:center">elementNode.setAttribute(name,value)</td>
<td style="text-align:center">增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值</td>
</tr>
<tr>
<td style="text-align:center">Object.innerHTML</td>
<td style="text-align:center">用于获取或替换 HTML 元素的内容。</td>
</tr>
<tr>
<td style="text-align:center">object.className</td>
<td style="text-align:center">获取或者设置元素的类名</td>
</tr>
<tr>
<td style="text-align:center">element.onmouseover</td>
<td style="text-align:center">鼠标经过事件</td>
</tr>
<tr>
<td style="text-align:center">element.onmouseout</td>
<td style="text-align:center">鼠标移开事件</td>
</tr>
<tr>
<td style="text-align:center">element.onfocus</td>
<td style="text-align:center">聚焦事件</td>
</tr>
<tr>
<td style="text-align:center">element.onblur</td>
<td style="text-align:center">失焦事件</td>
</tr>
<tr>
<td style="text-align:center">element.onchange</td>
<td style="text-align:center">文本框内容改变</td>
</tr>
<tr>
<td style="text-align:center">Math.ceil()</td>
<td style="text-align:center">向上取整</td>
</tr>
<tr>
<td style="text-align:center">Math.floor()</td>
<td style="text-align:center">向下取整</td>
</tr>
<tr>
<td style="text-align:center">Math.round()</td>
<td style="text-align:center">四舍五入</td>
</tr>
<tr>
<td style="text-align:center">Math.random()</td>
<td style="text-align:center">生成0-1的随机数</td>
</tr>
<tr>
<td style="text-align:center">setInterval(代码,交互时间)</td>
<td style="text-align:center">从载入页面后每隔指定的时间执行代码</td>
</tr>
<tr>
<td style="text-align:center">clearInterval(id_of_setInterval)</td>
<td style="text-align:center">取消计时器(间隔执行的)</td>
</tr>
<tr>
<td style="text-align:center">setTimeout(代码,延迟时间)</td>
<td style="text-align:center">在载入后延迟指定时间后,去执行一次表达式,仅执行一次，时间单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">clearTimeout(id_of_setTimeout)</td>
<td style="text-align:center">取消计时器(一次性的)</td>
</tr>
<tr>
<td style="text-align:center">console.log()</td>
<td style="text-align:center">打印日志，还有其他等级如debug，各个等级的颜色等会不同</td>
</tr>
<tr>
<td style="text-align:center">console.group()</td>
<td style="text-align:center">日志分组，便于查看，配合console.groupend()使用，一个表示开始一个表示结束</td>
</tr>
<tr>
<td style="text-align:center">console.dir(cmd)</td>
<td style="text-align:center">列出指定命令/对象的所以方法</td>
</tr>
<tr>
<td style="text-align:center">event.srcElement</td>
<td style="text-align:center">获取当前事件源对象(固定写法，一般直接传this来替代)</td>
</tr>
<tr>
<td style="text-align:center">elementNode.parentNode</td>
<td style="text-align:center">获取父节点，父节点只有一个</td>
</tr>
<tr>
<td style="text-align:center">elementNode.childNodes</td>
<td style="text-align:center">得到全部的子节点(firstChild得到第一个，lastChile得到最后一个)</td>
</tr>
<tr>
<td style="text-align:center">isNaN()</td>
<td style="text-align:center">判断是否为数字</td>
</tr>
</tbody>
</table>
<p>判断一个数是不是小数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果输入的不是数字 parse 返回 NaN</span></span><br><span class="line"><span class="keyword">if</span> (num == <span class="built_in">parseInt</span>(num))</span><br></pre></td></tr></table></figure>
<p>parseInt 可以强转开头为数字的字符串，字符会被忽略：<code>parseInt (&#39;123avc1&#39;);</code> 也是可以正常转换的，而使用 Number() 方法转换包含字母的字符串会报错（返回 NAN），但默认是这种转换。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>用到什么比较频繁的东西到时候再回来更新吧…嗯，缓慢更新<br>对DOM不理解的可以去谷狗下DOM事件流</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android逆向基础]]></title>
      <url>http://bfchengnuo.com/2016/08/22/Android%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>听大佬的话，让学下Android逆向相关知识，正好以前也了解过一点PC端的逆向感觉还是不错的，正好最近在学习Android开发，了解下逆向也应该不是很困难吧。<br><del>可惜你不会汇编，硬伤，挖坑待填</del><br><a id="more"></a></p>
<h2 id="APK的组成"><a href="#APK的组成" class="headerlink" title="APK的组成"></a>APK的组成</h2><p>如果你直接打开apk文件，如用RAR</p>
<ul>
<li><p>asset、res<br>这两个属于资源目录，但是他们也是有区别的<br>res目录下的文件编译的时候会自动生成索引文件，在Java代码中用R.XX.XX引用<br>asset目录下的文件不会生成索引，在Java代码中需要用AssetManager来访问<br>一般来说除了视频、音频、游戏相关资源放在raw或asset下其他都会放在res下</p>
</li>
<li><p>META-INF文件夹<br>一般存放工程的属性文件，如Manifest.MF</p>
</li>
<li><p>classes.dex<br>java代码编译得到的，Dalvik VM能直接执行的</p>
</li>
<li><p>resource.arsc<br>对res目录下的资源的一个索引文件，保留了原工程中strings.xml等文件内容</p>
</li>
</ul>
<p>其实除了这些还有其他一些文件，这里不说了，搞开发的应该很清楚了 = =！<br>关于apktool的使用，这里暂时不说，因为我一直在用集成环境</p>
<h2 id="Dalvik-相关介绍"><a href="#Dalvik-相关介绍" class="headerlink" title="Dalvik 相关介绍"></a>Dalvik 相关介绍</h2><p>上面也出现过这个词，到底是什么呢？这个也算是是学习逆向的基础吧，要了解下<br> Dalvik是google专门为Android操作系统设计的一个虚拟机，Dalvik字节码是专门为Dalvik VM设计的一种指令集。和java虚拟机不同的是，java虚拟机是基于堆栈设计的，而Dalvik虚拟机是基于寄存器的(专属文件执行格式dex)，效率要比java虚拟机快很多。<br>每一个进程对应一个Dalvik 虚拟机实例，Dalvik 字节码文件是由Java字节码文件转换而来</p>
<p>需要注意的是通过Dalvik字节码我们也不能看到原来的逻辑代码，这时候就需要用一些工具来进行查看，但是最终我们要修改的文件是<strong>smali</strong>文件而不是Java文件。</p>
<p>PS:从Android 5.0版起，Android Runtime（ART）替换Dalvik成为系统内默认虚拟机。但应该不影响我们逆向，毕竟要向下兼容。</p>
<h2 id="Smali入门"><a href="#Smali入门" class="headerlink" title="Smali入门"></a>Smali入门</h2><h3 id="什么是Smali"><a href="#什么是Smali" class="headerlink" title="什么是Smali"></a>什么是Smali</h3><p>作为我们在逆向接触最多的，有必要认真的进行学习。<br>简单的说，smali就是Dalvik VM内部执行的核心代码。它有自己的一套语法。<br>Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能（注解，调试信息，线路信息等）。</p>
<p>Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个寄存器表示；<br>Dalvik字节码有两种类型：原始类型；引用类型（包括对象和数组）</p>
<h3 id="smali的数据类型"><a href="#smali的数据类型" class="headerlink" title="smali的数据类型"></a>smali的数据类型</h3><p>原始类型：</p>
<ul>
<li><strong>B—byte</strong></li>
<li><strong>C—char</strong></li>
<li><strong>D—double</strong>(64)</li>
<li><strong>F—float</strong></li>
<li><strong>I—int</strong></li>
<li><strong>J—long</strong> (64)</li>
<li><strong>S—short</strong></li>
<li><strong>V—void</strong></li>
<li><strong>Z—boolean</strong></li>
</ul>
<p>对象类型：</p>
<ul>
<li><p><strong>Lxxx/yyy—object</strong><br>Lpackage/name/ObjectName; 相当于Java中的package.name.ObjectName;</p>
<p>​解释如下：<br>​L：表示这是一个对象类型<br>​package/name：该对象所在的包<br>；：表示对象名称的结束</p>
<p>这里提一下，关于内部类的表示是在内部类前加“$”符号<br>就这样：LpackageName/objectName$subObjectName;</p>
</li>
</ul>
<p>数组的表示形式：</p>
<ul>
<li><strong>[XXX—array</strong><br>可以看出数组就是在前面加了个[，例如[i == int[]，二维数组就是加[[咯~<br>以及[Ljava/lang/String 表示一个String的对象数组了</li>
</ul>
<h3 id="smali的方法-函数表示"><a href="#smali的方法-函数表示" class="headerlink" title="smali的方法/函数表示"></a>smali的方法/函数表示</h3><p>举个例子：Lpackage/name/ObjectName;——&gt;methodName(III)Z 详解如下：<br>Lpackage/name/ObjectName 表示类型<br>methodName 表示方法名<br>III 表示参数（这里表示为3个整型参数）<br>说明：方法的参数是一个接一个的，中间没有隔开；<br>方法以<code>.method</code>指令开始，以<code>.end method</code>指令结束。根据方法类型的不同，在方法指令开始前可能会用<code>#</code>加以注释，例如：<code>#virtual methods</code>表示这是一个虚方法，<code># direct methods</code>表示这是一个直接方法。</p>
<p>foo ()V<br>没错，这就是void foo()。</p>
<p>foo (III)Z<br>这个则是boolean foo(int, int, int)。</p>
<p>foo (Z[I[ILjava/lang/String;J)Ljava/lang/String;<br>看出来这是String foo (boolean, int[], int[], String, long) 了吗？</p>
<h3 id="Smail中字段表示"><a href="#Smail中字段表示" class="headerlink" title="Smail中字段表示"></a>Smail中字段表示</h3><p>类似：Lpackage/name/ObjectName;——&gt;FieldName:Ljava/lang/String;  </p>
<p>Lpackage/name/ObjectName;包名<br>FieldName:字段名<br>Ljava/lang/String;字段类型</p>
<p>BakSmali生成的字段代码以<code>.field</code>指令开头，根据字段类型的不同，在字段指令的开始可能会有相应的注释，例如：<code># instance fields</code>表示这是一个实例字段，<code># static fields</code>表示这是一个静态字段。</p>
<h3 id="Smali基本语法"><a href="#Smali基本语法" class="headerlink" title="Smali基本语法"></a>Smali基本语法</h3><blockquote>
<p>.field private isFlag:z ——定义变量<br>.method——方法<br>.parameter——方法参数<br>.prologue——方法开始<br>.line 12——此方法位于第12行<br>invoke-super——调用父函数<br>const/high16  v0, 0x7fo3——把0x7fo3赋值给v0<br>invoke-direct——调用函数<br>return-void——函数返回void<br>.end method——函数结束<br>new-instance——创建实例<br>iput-object——对象赋值<br>iget-object——调用对象<br>invoke-static——调用静态函数</p>
</blockquote>
<p>条件跳转分支：</p>
<blockquote>
<p>“if-eq vA, vB, :cond<em>*”   如果vA等于vB则跳转到:cond</em><em><br>“if-ne vA, vB, :cond_</em>“   如果vA不等于vB则跳转到:cond<em>*<br>“if-lt vA, vB, :cond</em><em>“    如果vA小于vB则跳转到:cond_</em><br>“if-ge vA, vB, :cond<em>*”   如果vA大于等于vB则跳转到:cond</em><em><br>“if-gt vA, vB, :cond_</em>“   如果vA大于vB则跳转到:cond<em>*<br>“if-le vA, vB, :cond</em><em>“    如果vA小于等于vB则跳转到:cond_</em><br>“if-eqz vA, :cond<em>*”   如果vA等于0则跳转到:cond</em><em><br>“if-nez vA, :cond_</em>“   如果vA不等于0则跳转到:cond<em>*<br>“if-ltz vA, :cond</em><em>“    如果vA小于0则跳转到:cond_</em><br>“if-gez vA, :cond<em>*”   如果vA大于等于0则跳转到:cond</em><em><br>“if-gtz vA, :cond_</em>“   如果vA大于0则跳转到:cond<em>*<br>“if-lez vA, :cond</em><em>“    如果vA小于等于0则跳转到:cond_</em></p>
</blockquote>
<p>这里只是贴了下经常见到的，更详细的指令可以看<a href="http://www.jianshu.com/p/730c6e3e21f6" target="_blank" rel="noopener">这里</a>，或者见后面的参考</p>
<h3 id="smali中的继承、接口、包信息"><a href="#smali中的继承、接口、包信息" class="headerlink" title="smali中的继承、接口、包信息"></a>smali中的继承、接口、包信息</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword"> .class</span><span class="keyword"> public</span> <span class="class">Lcom/disney/WMW/WMWActivity;</span> </span><br><span class="line"><span class="keyword"> .super</span> <span class="class">Lcom/disney/common/BaseActivity;</span></span><br><span class="line"><span class="keyword"> .source</span> <span class="string">"WMWActivity.java"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># interfaces</span></span><br><span class="line"><span class="keyword"> .implements</span> <span class="class">Lcom/burstly/lib/ui/IBurstlyAdListener;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># annotations</span></span><br><span class="line"><span class="keyword"> .annotation</span><span class="keyword"> system</span> <span class="class">Ldalvik/annotation/MemberClasses;</span></span><br><span class="line">    value = &#123;</span><br><span class="line">       <span class="class">Lcom/disney/WMW/WMWActivity$MessageHandler;</span>,</span><br><span class="line">       <span class="class">Lcom/disney/WMW/WMWActivity$FinishActivityArgs;</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">.end annotation</span></span><br></pre></td></tr></table></figure>
<p> 1-3行定义的是基本信息：这是一个由WMWActivity.java编译得到的smali文件（第3行），它是com.disney.WMW这个package下的一个类（第1行），继承自com.disney.common.BaseActivity（第2行）。</p>
<p>5-6行定义的是接口信息：这个WMWActivity实现了一个com.burstly.lib.ui这个package下（一个广告SDK）的IBurstyAdListener接口。</p>
<p>8-14行定义的则是内部类：它有两个成员内部类——MessageHandler和FinishActivityArgs</p>
<p>PS:</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.class</span> &lt;访问权限&gt; [修饰关键字] &lt;类名&gt;</span><br><span class="line"><span class="keyword">.super</span> &lt;父类名&gt;</span><br><span class="line"><span class="keyword">.source</span> &lt;源文件名&gt;</span><br><span class="line"></span><br><span class="line">//静态属性</span><br><span class="line"><span class="comment"># static fields</span></span><br><span class="line"><span class="keyword">  .field</span> &lt;访问权限&gt;<span class="keyword"> static</span> [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;</span><br><span class="line">  </span><br><span class="line">//实例属性</span><br><span class="line"> <span class="comment"># instance fields</span></span><br><span class="line"><span class="keyword">  .field</span> &lt;访问权限&gt;<span class="keyword"> static</span> [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;</span><br><span class="line">  </span><br><span class="line">//方法</span><br><span class="line"><span class="comment"># direct methods</span></span><br><span class="line"><span class="keyword">.method</span> &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;</span><br><span class="line">    &lt;.locals&gt;  		局部变量个数</span><br><span class="line">    [.parameter]	方法参数</span><br><span class="line">    [.prologue]		代码开始，混淆后可能去掉</span><br><span class="line">    [.line]			在源码中的位置</span><br><span class="line">    &lt;代码体&gt;</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<h3 id="关于寄存器的补充"><a href="#关于寄存器的补充" class="headerlink" title="关于寄存器的补充"></a>关于寄存器的补充</h3><p>在smali里的所有操作都必须经过寄存器来进行：<strong>本地寄存器</strong>用v开头数字结尾的符号来表示，如v0、v1、v2、…<strong>参数寄存器</strong>则使用p开头数字结尾的符号来表示，如p0、p1、p2、…特别注意的是，<strong>p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”</strong>，p1表示函数的第一个参数，p2代表函数中的第二个参数…而在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法）。本地寄存器没有限制，理论上是可以任意使用的</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v0, 0x0  </span><br><span class="line">iput-boolean v0, p0, <span class="class">Lcom/disney/WMW/WMWActivity;</span>-&gt;isRunning:Z</span><br></pre></td></tr></table></figure>
<p>在上面的两句中，使用了v0本地寄存器，并把值0x0存到v0中，然后第二句用iput-boolean这个指令把v0中的值存放到com.disney.WMW.WMWActivity.isRunning这个成员变量中。即相当于：this.isRunning = false;（上面说过，在非static函数中p0代表的是“this”，在这里就是com.disney.WMW.WMWActivity实例）</p>
<h3 id="Smali中的成员变量"><a href="#Smali中的成员变量" class="headerlink" title="Smali中的成员变量"></a>Smali中的成员变量</h3><p>格式是：.field public/private [static][final] varName:&lt;类型&gt;</p>
<p>对于不同的成员变量有不同的指令<br>获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等，操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。<br>下面是几个例子：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, <span class="class">Lcom/aaa;</span>-&gt;ID:<span class="class">Ljava/lang/String;</span></span><br></pre></td></tr></table></figure>
<p>sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，在这里，把上面出现的ID这个String成员变量获取并放到v0这个寄存器中,因为只指出了该类的所属的类型,可以看出这是个静态的(static fields)<br><strong>注意：前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间是“-&gt;”表示所属关系。</strong></p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iget-object v0, p0, <span class="class">Lcom/aaa;</span>-&gt;view:<span class="class">Lcom/aaa/view;</span></span><br></pre></td></tr></table></figure>
<p>只是由于不是static变量，不能仅仅指出该变量所在类的类型，还需要该变量所在类的实例<br>可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的实例，在这里就是p0即“this”。</p>
<p>获取array的还有aget和aget-object，指令使用和上述类似，略</p>
<p>put指令的使用和get指令是统一的，对比下面两个看效果更佳：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v3, 0x0  </span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br></pre></td></tr></table></figure>
<p>相当于 this.timer=null(null=0x0),因为是obj类型的如果是bool的话….你懂得~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.local v0, args:Landroid/os/Message;  </span><br><span class="line">const/4 v1, 0x12 </span><br><span class="line">iput v1, v0, Landroid/os/Message;-&gt;what:I</span><br></pre></td></tr></table></figure>
<p>相当于 args.what = 18; (args是Message的实例)</p>
<h3 id="Smali中的函数调用"><a href="#Smali中的函数调用" class="headerlink" title="Smali中的函数调用"></a>Smali中的函数调用</h3><p>smali中的函数和成员变量也一样，分为两种，direct和virtual<br>至于它们之间的区别，简单来说就是：<br>direct method 就是private函数，其余的public和protected函数都属于virtual method<br>所以在调用的时候就有了invoke-direct、invoke-virtual,另外类似的还有invoke-static、invoke-super、invoke-interface也就都好理解了。<br>特别的还有invoke-xxx/range的指令，这是参数多于4个的时候调用的指令，应该比较少见。</p>
<p>下面就是具体的调用方式了：</p>
<ul>
<li><p>invoke-static<br>很显然是调用静态函数的</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static&#123;&#125;,<span class="class">Lcom/aaa;</span>-&gt;CheckSignature()z</span><br></pre></td></tr></table></figure>
<p>后面的<strong>一对大括号其实是调用该方法的实例+参数列表</strong>，由于这个方法是静态的，也不需要参数，所以括号内就是空了。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0,<span class="string">"NDKLIB"</span></span><br><span class="line">invoke-static&#123;v0&#125;,<span class="class">Ljava/lang/System;</span>-&gt;loadLibrary(<span class="class">Ljava/lang/string;</span>)V</span><br></pre></td></tr></table></figure>
<p>这个翻译过来就是调用了static void System.loadLibrary(String)来加载NDK的so库引用的方法，同样这里的V0就是参数“NDKLIB”了。</p>
</li>
<li><p>invoke-super</p>
<p>很显然，调用父类方法的指令，一般用于调用onCreate、onDestroy等生命周期函数</p>
</li>
<li><p>invoke-direct</p>
<p>调用private的函数</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct&#123;p0&#125;,<span class="class">Landroid/app/TabActivity;</span>-&gt;&lt;init&gt;()V</span><br></pre></td></tr></table></figure>
<p>这里就是一个定义在TabActivity中的一个private函数init()</p>
</li>
<li><p>invoke-virtual</p>
<p>用于调用protected或public的函数<br>修改smali的时候不要错用哦</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0,<span class="class">Lcom/dddd;</span>-&gt;bbb:Lcom/ccc</span><br><span class="line">invoke-virtual &#123;v0,v1&#125;,<span class="class">Lcom/ccc;</span>-&gt;Messages(<span class="class">Ljava/lang/object;</span>)V</span><br></pre></td></tr></table></figure>
<p>v0就是bbb:Lcom/ccc<br>v1就是传递给Messages方法的Ljava/lang/Object类型的参数</p>
</li>
<li><p>invoke-xxx/range</p>
<p>当方法的参数多于5个时(含5个)就不能直接使用上面的指令了，而是在后面加上”/range”,range表示范围，使用的方法也有所不同。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct/range &#123;v0...v5&#125;,<span class="class">Lcmb/pb/ui/PBContainerActivity;</span>-&gt;h(I<span class="class">Ljava/lang/CharSequence;</span><span class="class">Ljava/lang/String;</span><span class="class">Landroid/content/intent;</span>I)Z</span><br></pre></td></tr></table></figure>
<p>需要传递v0到v5一共6个参数，这时候大括号内的参数会采用省略的形式，并且需要连续。</p>
</li>
</ul>
<p>前面说的都是函数的调用，貌似没有返回之类的指令呢，确实，在Java代码中调用函数和返回函数结果是一条语句完成的，而在smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const/4 v2, 0x0  </span><br><span class="line">invoke-virtual &#123;p0, v2&#125;, <span class="class">Lcom/disney/WMW/WMWActivity;</span>-&gt;getPreferences(I)<span class="class">Landroid/content/SharedPreferences;</span>  </span><br><span class="line">move-result-object v1</span><br></pre></td></tr></table></figure>
<p>  v1保存的就是调用getPreferences(int)方法返回的SharedPreferences实例。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke-virtual &#123;v2&#125;, <span class="class">Ljava/lang/String;</span>-&gt;length()I  </span><br><span class="line">move-result v2</span><br></pre></td></tr></table></figure>
<p>v2保存的则是调用String.length()返回的整型。</p>
<p>下面就是函数实体的例子了：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> private</span> ifReg()V  </span><br><span class="line"><span class="keyword">    .locals</span> 2  //本函数中本地寄存器的个数</span><br><span class="line"><span class="keyword">    .prologue</span>  </span><br><span class="line">   <span class="built_in"> const/4 </span>v0,0x1	//v0赋值为1</span><br><span class="line"><span class="keyword">    .local</span> v0,tempFlag:Z</span><br><span class="line">   <span class="built_in"> if-eqz </span>v0,:cond_0	//如果v0等于0则跳到cond_0标签</span><br><span class="line">   <span class="built_in"> const/4 </span>v1,0x1 		//符合条件的分支 根据上面就是不等于0了</span><br><span class="line">   <span class="keyword"> :goto_0</span>		//标签</span><br><span class="line">   <span class="built_in"> return </span>v1	//返回v1的值</span><br><span class="line">   <span class="keyword"> :cond_0</span>		//标签</span><br><span class="line">   <span class="built_in"> const/4 </span>v1,0x0	//处于cond_0标签分支了</span><br><span class="line">    goto:goto_0		//跳到goto_0标签，就是执行return v1</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwihupDb9NPOAhWEW5QKHUeuCGQQFggcMAA&amp;url=%68%74%74%70%3a%2f%2f%62%6c%6f%67%2e%63%73%64%6e%2e%6e%65%74%2f%73%69%6e%67%77%68%61%74%69%77%61%6e%6e%61%2f%61%72%74%69%63%6c%65%2f%64%65%74%61%69%6c%73%2f%31%39%30%31%39%35%34%37&amp;usg=AFQjCNHD6BKDzhRt3Va4HlmeLhWSh7FdFg&amp;sig2=Z8SlKUMW4pJVkL9E1tevUA" target="_blank" rel="noopener">smali语法介绍</a><br><a href="http://blog.csdn.net/lpohvbe/article/details/7981386" target="_blank" rel="noopener">Android反编译-基础知识</a><br><a href="https://smalinuxer.github.io/2015/12/07/smali-base-1.html" target="_blank" rel="noopener">smali语法-关键是指令集</a><br><a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="noopener">smali指令集-官方</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 逆向工程 </tag>
            
            <tag> smali </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu折腾记录]]></title>
      <url>http://bfchengnuo.com/2016/07/25/ubuntu%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>对于ubuntu其实并不很陌生，前几年就搞过(熟练的安装/卸载 o(￣▽￣<em>)ゞ))￣▽￣</em>)o)，这次准备真正的学下linux，深入一点，刚开始我果然就如此幸运 遇到了各种坑，别人踩过的没踩过的基本都遇到了，真是辣么想让我学习么？？<br>折腾了两天，基本算是能用了吧。。。<br><a id="more"></a></p>
<h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>最开始的时候我想的是 曾经装过辣么多次，自认为在安装上差不多是老司机了，直接去官网下了原版(没用麒麟版)最新的16.04版本的，写进U盘，重启，一切准备就绪！自信满满，然后就有了后面的N次重装，N次重启…</p>
<p>装完发现驱动还不支持，注销、挂起就崩，等等一些小问题，最后还是换回了14.04</p>
<h2 id="分区-挂载点"><a href="#分区-挂载点" class="headerlink" title="分区/挂载点"></a>分区/挂载点</h2><p>因为我扣出来的空间是不连续的，从D盘扣了一点 F盘扣了一点 等等，天真的我想着怎么才能把他们合到一起去，这样才能分给ubuntu，用无损分区助手搞了一会太慢了！！</p>
<p>后来才意识到它们的挂载是不用在一起的！！！一脸懵逼….</p>
<p>下面写下我的分区</p>
<p>/boot      200MB<br>/        20G<br>swap    8G     //貌似不用这么大，毕竟不是服务器<br>/home     50G</p>
<p>以上都是选择的逻辑分区，前两个是从D扣的，后面是E、F扣的，硬盘小伤不起。</p>
<p>引导那选/boot所在的分区，用win引导ubuntu，需要用EasyBCD添加个引导~</p>
<h2 id="与win的时间不同步问题"><a href="#与win的时间不同步问题" class="headerlink" title="与win的时间不同步问题"></a>与win的时间不同步问题</h2><p>因为当时安装的时候是断网情况下，没有联网同步，很明显的就看出来了，这是因为两个系统不同意的问题，我采用的是关闭ubuntu的UTC，还有一种是改win的没测试</p>
<p>这里要说下，16.04的修改方法不太一样了，这让我郁闷了好长时间，网上的大部分做法是：</p>
<blockquote>
<p>sudo vim /etc/default/rcS 修改：UTC=yes为：UTC=no</p>
</blockquote>
<p>然而16.04的这个文件已经没有这些东西了，可以试下下面的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-local-rtc 1 --adjust-system-clock</span><br><span class="line">timedatectl set-ntp 0</span><br></pre></td></tr></table></figure></p>
<h2 id="无线网卡rtl8723be问题"><a href="#无线网卡rtl8723be问题" class="headerlink" title="无线网卡rtl8723be问题"></a>无线网卡rtl8723be问题</h2><p>弄好后连上wifi，频繁掉我也就忍了，网速还每秒几B的速度，去问谷狗发现是rtl8723be这个驱动的问题，官方的驱动和内核不兼容，低端网卡害死人哇…</p>
<p>比较全的解决方案整理在这：<a href="http://forum.ubuntu.org.cn/viewtopic.php?f=116&amp;t=462588&amp;start=15" target="_blank" rel="noopener">坐飞机去论坛</a></p>
<p>我是下载源码重新编译了一下，然而效果还是不是很好，起码比以前是有了较大的改善，但还是不稳定，网页时长打不开，狂按ctrl + F5才能刷出了，不造是什么原因。</p>
<p>附github源码地址：<a href="https://github.com/lwfinger/rtlwifi_new" target="_blank" rel="noopener">驱动源码</a></p>
<p><strong>步骤</strong></p>
<ol>
<li>先安装好需要编译的东西<br><code>sudo apt-get install linux-headers-generic build-essential git</code></li>
<li>先停止网路<br><code>sudo service network-manager stop</code></li>
<li><p>cd 到 rtlwifi_new 目录下<br>如果以前有驱动先卸载：<br><code>sudo modprobe -rfv rtl8723be</code><br>然后再编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line">sudo modprobe -v rtl8723be fwlps=0 ips=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>sudo reboot 重启</p>
</li>
</ol>
<p>最后可以检查下是否设置成功<br><code>systool -v -m rtl8723be</code></p>
<h3 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h3><p><strong>第一种</strong><br>一种比较简单有效的方法：执行<br><code>sudo echo &quot;options rtl8723be fwlps=0 swlps=0&quot; &gt; /etc/modprobe.d/rtl8723be.conf</code></p>
<p><strong>第二种</strong><br>本质上和第一种是一样的，都是往驱动的配置文件写<br>rtl8723be.conf添加以下信息：</p>
<blockquote>
<p>options rtl8723be debug=1<br>options rtl8723be disable_watchdog=N<br>options rtl8723be fwlps=Y<br>options rtl8723be ips=Y<br>options rtl8723be msi=N<br>options rtl8723be swenc=N<br>options rtl8723be swlps=N<br>options rtl8723be ant_sel=2</p>
</blockquote>
<p>保存配置文件后,运行如下命令来应用配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r rtl8723be</span><br><span class="line">sudo modprobe rtl8723be</span><br></pre></td></tr></table></figure></p>
<h2 id="添加打开终端到右键菜单"><a href="#添加打开终端到右键菜单" class="headerlink" title="添加打开终端到右键菜单"></a>添加打开终端到右键菜单</h2><p>这个很简单，装一个软件即可，16.04的版本中已经默认支持了，执行下面命令：<br><code>sudo apt-get install nautilus-open-terminal</code></p>
<h2 id="更换Flatabulous主题"><a href="#更换Flatabulous主题" class="headerlink" title="更换Flatabulous主题"></a>更换Flatabulous主题</h2><p>安装主题的第一步是安装Ubuntu tweak tool，安装命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:tualatrix/ppa</span><br><span class="line">sudo apt-get update  //更新下源数据</span><br><span class="line">sudo apt-get install unity-tweak-tool</span><br><span class="line">//启动Unity Tweak Tool：</span><br><span class="line">unity-tweak-tool</span><br></pre></td></tr></table></figure></p>
<p>下载/安装主题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br></pre></td></tr></table></figure>
<p>下载主题文件：<a href="https://github.com/anmoljagetia/Flatabulous/archive/master.zip" target="_blank" rel="noopener">点我下载</a><br>主题开源地址：<a href="https://github.com/anmoljagetia/Flatabulous" target="_blank" rel="noopener">https://github.com/anmoljagetia/Flatabulous</a></p>
<p>然后直接全部提取出来在一个文件夹里，随便命名，然后丢到/usr/share/themes里就行了，如果tweaktool里找不到的话，就设置以下整个文件夹的权限就ok了，此操作因为需要root权限最好在命令行中完成。</p>
<p>这里也顺便使用了Flat的蓝色图标<br>下载地址是：<a href="http://ppa.launchpad.net/noobslab/icons/ubuntu/pool/main/u/" target="_blank" rel="noopener">点我去下载</a></p>
<p>然后还是同上，只不过是复制到/usr/share/icons下</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实还有一些很常见的小问题，就没写，还有一些问题没有解决，等以后再更新吧…<br>想换一个shell的，暂时先不弄了，因为也许是用的邻居的wifi，等网好了再弄吧。。<br>大体是这个样子了：<br><img src="https://camo.githubusercontent.com/1c2f9a440ed8a7b32fffefb9ffd1b4068da0ff63/687474703a2f2f692e696d6775722e636f6d2f795842365653612e706e673f31" alt=""></p>
<h2 id="继续折腾-标记"><a href="#继续折腾-标记" class="headerlink" title="继续折腾(标记)"></a>继续折腾(标记)</h2><p>今天是休息日，网络也好了，把我的ubuntu搬出来再继续折腾，这次离路由器近了，网络也没出现什么问题，于是就想继续先把环境给弄好～</p>
<h2 id="安装QQ"><a href="#安装QQ" class="headerlink" title="安装QQ"></a>安装QQ</h2><p>虽然我确实不喜欢上qq，但是有些时候你还必须得通过qq来获得一些信息，并且是官方是没有开发linux的QQ的，方法就是靠wine来模拟一个windows环境，可以运行exe程序，然后发现优麒麟官网提供了定制好的wineqq安装包，<a href="http://www.ubuntukylin.com/application/show.php?lang=cn&amp;id=279" target="_blank" rel="noopener">下载地址点我</a></p>
<p>解压后会有三个安装包，先进行安装安装wine-qqintl_0.1.3-2_i386.deb，执行命令<br><code>sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb</code><br>在安装过程中发生错误，这是正常的，这是因为还有一个lib没有配置，所以我们要输入下面的命令：<br><code>sudo apt-get install -f</code><br>然后在重新安装wine-qqintl_0.1.3-2_i386.deb的命令<br><code>sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb</code><br>应该就能安装成功了～～<br>接下来在继续安装剩余的两个deb包<br><code>sudo dpkg -i ttf-wqy-microhei_0.2.0-beta-2_all.deb</code><br><code>sudo dpkg -i fonts-wqy-microhei_0.2.0-beta-2_all.deb</code><br>然后就可以运行wineqqintl啦！<br>为了检查是否安装正确，我们可以输入下面的命令进行检测<br><code>sudo  dpkg -l |grep qq</code><br>到这里在搜索界面也应该可以搜到QQ了～点开运行就行了！</p>
<p>更加详细的汇总可以见官方论坛  <a href="http://wiki.ubuntu.org.cn/QQ#.E4.BC.98.E9.BA.92.E9.BA.9F_wine-qq" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/QQ#.E4.BC.98.E9.BA.92.E9.BA.9F_wine-qq</a></p>
<h2 id="切换到root身份"><a href="#切换到root身份" class="headerlink" title="切换到root身份"></a>切换到root身份</h2><p>期间好几次提示没有权限，尤其是在弄JDK的时候，配置环境变量死活就是提示文件路径不存在，后来也不知道咋好了….好了，接下来正文：<br>这里有种说法：出于安全考虑，默认时Ubuntu的root用户时没有固定密码的，它的密码是随机产生并且动态改变的，貌似是每5分钟改变一次，所以用su（switch user）是不可以的，因为我们不知道root的密码。<br>当然也可以用命令来设置root的密码：<code>sudo passwd root</code>,下面说下几种切换root的方法：</p>
<ul>
<li>su root ，输入root密码切换到root用户，无时间限制。su 用户名切换回其它用户。</li>
<li>sudo su，效果同上，只是不需要root的密码，<strong>而需要当前用户的密码。</strong></li>
<li>sudo -i，输入当前用户密码后以root权限登录shell，无时间限制。使用exit或logout退出。</li>
</ul>
<h2 id="安装SS客户端"><a href="#安装SS客户端" class="headerlink" title="安装SS客户端"></a>安装SS客户端</h2><p>作为google的重度依赖者，这可是一件大事！我采用的是图形界面，命令行的没尝试…<br>用gui方式进行安装：<br>添加PPA源：<code>sudo add-apt-repository ppa:hzwhuang/ss-qt5</code><br>更新软件列表：<code>sudo apt-get update</code><br>安装shadowsocks：<code>sudo apt-get install shadowsocks-qt5</code><br>dash中搜索shadow，然后打开shadowsocks-qt5软件就可以用了，关于账号信息直接就是读取的win下的配置文件，他们是可以进行通用的，还又PAC文件也是可以通用的</p>
<p>SS准备好了剩下的就是配置了，我当然是用了PAC模式，这里可以使用GenPAC，也可以直接使用win下的pac：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>首先安装pip</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line"><span class="meta">#</span>通过pip安装genpac</span><br><span class="line">sudo pip install genpac</span><br></pre></td></tr></table></figure>
<p>使用GenPAC生成pac文件:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genpac -p "SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" --gfwlist-url=https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt --output="autoproxy.pac"</span><br></pre></td></tr></table></figure>
<p>此时会生成一个名为autoproxy.pac的文件,记得要先在系统设置里-网络设置SS代理，先设置为手动即可，下载完成后在系统的网络设置里，选为自动，URL填类似下面的即可~</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>例如 file:///home/用户名/autoproxy.pac</span><br></pre></td></tr></table></figure>
<p>你没有看错，是三个’/‘不要少些，至此，应该可以愉快的google了！</p>
<p>更详细的介绍参考：<a href="http://www.jianshu.com/p/6280ac9fd95d" target="_blank" rel="noopener">http://www.jianshu.com/p/6280ac9fd95d</a></p>
<h2 id="更换shell为zsh"><a href="#更换shell为zsh" class="headerlink" title="更换shell为zsh"></a>更换shell为zsh</h2><p>说起shell的话，我也是知道zsh被称为最强shell，只是配置起来比较复杂，但是有神器oh-my-zsh替你配啊！傻瓜试操作于是我也要提升逼格更换zsh啦！<br>首先看了下系统没有zsh，于是就要去安装啦～(查看shell可以使用cat /etc/shells)<br><code>sudo apt-get install zsh</code><br>我比较懒采用wget自动安装了～～<br><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code><br>安装 oh-my-zsh 时,它自动读取你的环境变量并且自动帮 zsh 进行设置.<br>所以这时的zsh 基本已经配置完成,你需要一行命令就可以切换到 zsh 模式.<br><code>chsh -s /usr/local/bin/zsh</code><br>另外神器有多款皮肤也可以自定义，修改配置文件：<br><code>sudo getdit ~/.zshrc</code><br>我现在在用的是ys的主题，agnoster的貌似也不错，不过字体会存在些兼容问题，可以去安装下面的字体就OK了</p>
<p>字体主页：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a><br>oh-my-zsh主页：<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></p>
<h2 id="点击图标最小化"><a href="#点击图标最小化" class="headerlink" title="点击图标最小化"></a>点击图标最小化</h2><p>感觉这个功能还是比较好用的，实现也很简单，注意的是此方法适用14.04,16的话貌似在Tweak Tool中就可以设置了</p>
<p>启用：<br><code>gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true</code><br>关闭：<br><code>gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window false</code></p>
<h2 id="安装系统监视器System-Monitor-Indicator"><a href="#安装系统监视器System-Monitor-Indicator" class="headerlink" title="安装系统监视器System Monitor Indicator"></a>安装系统监视器System Monitor Indicator</h2><p>通过源安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:alexeftimie/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-sysmonitor</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C#学习笔记]]></title>
      <url>http://bfchengnuo.com/2016/07/16/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>这一学期结束了，虽然一直在搞Android开发，但是C#上课我也是认真听的，是没怎么深学，课下不练习也就很快忘了，<del>为了应付考试(￣^￣)</del>，我整理了下以前的代码，主要的内容提取下做个笔记，反正内容也不是很多，万一以后用到了呢？<br>o(￣▽￣<em>)ゞ))￣▽￣</em>)o<br><a id="more"></a></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>在这之前记得添加引用:using System.IO;</p>
<h3 id="利用打开对话框本地硬盘获取文件"><a href="#利用打开对话框本地硬盘获取文件" class="headerlink" title="利用打开对话框本地硬盘获取文件"></a>利用打开对话框本地硬盘获取文件</h3><p>先写一个最简单的设置背景图片的功能:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          OpenFileDialog openFileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">          <span class="comment">//打开的文件选择对话框上的标题</span></span><br><span class="line">          openFileDialog.Title = <span class="string">"请选择文件"</span>;</span><br><span class="line">          <span class="comment">//设置文件类型</span></span><br><span class="line">          openFileDialog.Filter = <span class="string">"文本文件(*.txt)|*.txt|所有文件(*.*)|*.*"</span>;</span><br><span class="line">          <span class="comment">//设置默认文件类型显示顺序</span></span><br><span class="line">          openFileDialog.FilterIndex = <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//保存对话框是否记忆上次打开的目录</span></span><br><span class="line">          openFileDialog.RestoreDirectory = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//设置是否允许多选</span></span><br><span class="line">          openFileDialog.Multiselect = <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">//设置默认路径</span></span><br><span class="line">          openFileDialog.InitialDirectory = <span class="string">"d:\\"</span>; </span><br><span class="line">          <span class="comment">//按下确定选择的按钮</span></span><br><span class="line">          <span class="keyword">if</span> (openFileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//如果为多选的时候</span></span><br><span class="line">              <span class="comment">//MessageBox.Show(openFileDialog.FileName);    //完整路径</span></span><br><span class="line">              <span class="comment">//MessageBox.Show(openFileDialog.FileNames[0]);     //完整路径 - 多选文件</span></span><br><span class="line">              <span class="comment">//MessageBox.Show(openFileDialog.SafeFileName);  //文件名</span></span><br><span class="line">              <span class="comment">//MessageBox.Show(openFileDialog.SafeFileNames[0]);</span></span><br><span class="line">             </span><br><span class="line">              <span class="comment">//获得文件路径</span></span><br><span class="line">              <span class="keyword">string</span> localFilePath = openFileDialog.FileName.ToString();</span><br><span class="line">              <span class="comment">//获取文件路径，不带文件名</span></span><br><span class="line">              <span class="comment">//FilePath = localFilePath.Substring(0, localFilePath.LastIndexOf("\\"));</span></span><br><span class="line">              <span class="comment">//获取文件名，带后缀名，不带路径</span></span><br><span class="line">              <span class="keyword">string</span> fileNameWithSuffix = localFilePath.Substring(localFilePath.LastIndexOf(<span class="string">"\\"</span>) + <span class="number">1</span>);</span><br><span class="line">              <span class="comment">//去除文件后缀名</span></span><br><span class="line">              <span class="keyword">string</span> fileNameWithoutSuffix = fileNameWithSuffix.Substring(<span class="number">0</span>, fileNameWithSuffix.LastIndexOf(<span class="string">"."</span>));</span><br><span class="line">              <span class="comment">//在文件名前加上时间</span></span><br><span class="line">              <span class="comment">//string fileNameWithTime = DateTime.Now.ToString("yyyy-MM-dd ") + fileNameExt;</span></span><br><span class="line">              <span class="comment">//在文件名里加字符</span></span><br><span class="line">              <span class="keyword">string</span> newFileName = localFilePath.Insert(<span class="number">1</span>, <span class="string">"dameng"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按照指定规则遍历文件"><a href="#按照指定规则遍历文件" class="headerlink" title="按照指定规则遍历文件"></a>按照指定规则遍历文件</h3><p>这里演示下从指定目录过滤出jpg图片文件。<del>规则可以是正则表达式(未证实)</del><br><code>.</code>可以表示可执行程序所在的目录。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">string</span> filepath = <span class="string">"./src/"</span>;</span><br><span class="line"> List&lt;<span class="keyword">string</span>&gt; namelist = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件夹中的信息</span></span><br><span class="line">   DirectoryInfo folder = <span class="keyword">new</span> DirectoryInfo(filepath);</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetAllFiles</span>(<span class="params">DirectoryInfo folder</span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="comment">//遍历文件夹的内容，筛选出符合规则的文件</span></span><br><span class="line">	    <span class="keyword">foreach</span> (FileInfo file <span class="keyword">in</span> folder.GetFiles(<span class="string">"*.jpg"</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="comment">//将文件名添加到集合/容器</span></span><br><span class="line">	        namelist.Add(file.Name);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//遍历文件夹--然后进行递归遍历文件</span></span><br><span class="line">           <span class="keyword">foreach</span> (DirectoryInfo dd <span class="keyword">in</span> d.GetDirectories())</span><br><span class="line">           &#123;</span><br><span class="line">               GetAllFiles(dd);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>补充一个关于读取文件流编码相关的<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamReader sr = <span class="keyword">new</span> StreamReader(filepath + <span class="string">"文本文档.txt"</span>,Encoding.Default);</span><br><span class="line">String line;</span><br><span class="line">   <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="comment">//每次读取一行</span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据库ADO操作"><a href="#数据库ADO操作" class="headerlink" title="数据库ADO操作"></a>数据库ADO操作</h2><p>还是首先要先添加引用:<br>using System.Data;<br>using System.Data.SqlClient;<br>这里其实没什么特别的，就固定的那么几句，其他的就是执行sql语句了，这里写一下标准的几句固定的语句：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DBHelper</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//获得一个链接</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SqlConnection <span class="title">getConn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">string</span> strConn = <span class="string">"data source=.;initial catalog=test;uid=sa;password=.."</span>;</span><br><span class="line">           SqlConnection conn = <span class="keyword">new</span> SqlConnection(strConn);</span><br><span class="line">           conn.Open();</span><br><span class="line">           <span class="keyword">return</span> conn;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//主要是传入一个查询语句，获得一个数据表格</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataTable <span class="title">getDT</span>(<span class="params"><span class="keyword">string</span> strSQL</span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           SqlConnection conn = getConn();</span><br><span class="line"></span><br><span class="line">           DataTable dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">           SqlDataAdapter da = <span class="keyword">new</span> SqlDataAdapter(strSQL, conn);</span><br><span class="line">           da.Fill(dt);</span><br><span class="line">           conn.Close();</span><br><span class="line">           <span class="keyword">return</span> dt;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//主要执行非查询语句(增删改) 返回所影响的行数</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmdSQL</span>(<span class="params"><span class="keyword">string</span> strSQL</span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           SqlConnection conn = getConn();</span><br><span class="line"></span><br><span class="line">           SqlCommand cmd = <span class="keyword">new</span> SqlCommand(strSQL, conn);</span><br><span class="line">           <span class="keyword">int</span> i = cmd.ExecuteNonQuery();</span><br><span class="line">           conn.Close();</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>dt.Rows[0][0];</code>           dataTable的行集合<br><code>dt.Columns[0][0];</code>      dataTable的列集合</p>
<p>再补充一个随机从数据库取得数据的sql语句：<br><code>select top 20 * from  Exam order by newid()</code><br><del>原理大概猜测是是根据ID经过N次排序后抽取前20条记录(未证实)</del></p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><h3 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h3><ul>
<li>按照指定字符分割,返回一个string数组</li>
<li>按照字符数组进行分割，返回一个string数组</li>
<li>按照指定的位置分割，返回一个string<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字符分割</span></span><br><span class="line"><span class="keyword">string</span>[] ss = str.Split(<span class="string">'-'</span>);</span><br><span class="line"><span class="comment">//按照字符数组进行分割</span></span><br><span class="line"><span class="comment">//第二个参数，指定字符串的切割规则，这里是删除空字符</span></span><br><span class="line"><span class="comment">//从字符串头部开始遍历，遇到含有的字符就进行分割 (大概 = = </span></span><br><span class="line"><span class="keyword">string</span>[] ss = richTextBox1.Text.Split(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">' '</span>, <span class="string">'-'</span>,<span class="string">'\n'</span>,<span class="string">','</span> &#125;,StringSplitOptions.RemoveEmptyEntries);</span><br><span class="line"><span class="comment">//按照指定长度/位置分割</span></span><br><span class="line"><span class="comment">//第二个数字是长度，不是下标！ 这里从输入(textBox)获取</span></span><br><span class="line"><span class="keyword">string</span> s1 = str.Substring(<span class="number">0</span>, Convert.ToInt32(textBox2.Text));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于Split的重载还有很多，这里不多介绍，就学了这些 = =</p>
<h3 id="从字符串再选择一段字符串"><a href="#从字符串再选择一段字符串" class="headerlink" title="从字符串再选择一段字符串"></a>从字符串再选择一段字符串</h3><p>这是一个让选中的改变颜色的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选中要改变颜色的字符，第一个是开始位置，第二个是长度</span></span><br><span class="line">   richTextBox1.Select(i, <span class="number">1</span>);</span><br><span class="line">   <span class="comment">//改变选中的字符的颜色</span></span><br><span class="line">   richTextBox1.SelectionColor = Color.Red;</span><br></pre></td></tr></table></figure></p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>还是首先添加引用:<br>using System.Text.RegularExpressions;<br>match会捕获第一个匹配。而matches会捕获所有的匹配。<br>match类型就是一个单独的捕获，matchcollection就是一组捕获。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> strRegex = <span class="string">"正则内容"</span>;</span><br><span class="line"><span class="comment">//IgnoreCase是忽略大小写，这样会降低匹配</span></span><br><span class="line">Regex r = <span class="keyword">new</span> Regex(strRegex, RegexOptions.IgnoreCase);</span><br><span class="line">MatchCollection mc = r.Matches(richTextBox1.Text);</span><br><span class="line"><span class="keyword">foreach</span> (Match m <span class="keyword">in</span> mc)</span><br><span class="line">&#123;</span><br><span class="line">    listBox1.Items.Add(m.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程和委托有着很紧密的联系，使用多线程一般都会使用到委托，和Android一样，多线程不能操作UI，想要更新UI就必须使用委托。<br>为了防止一些其他问题，最佳的做法是一个线程最好只操作UI的一个控件。<br>线程不能被强制终止，只能自己停下来，也就是说不同线程直接是没法进行操作的，<del>我们所做的终止线程只是做了一个终止的标记而已(未测试)。</del><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Thread t1;</span><br><span class="line"><span class="comment">//带参数的开启方式 注意只写方法名即可不需要加()</span></span><br><span class="line">t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(执行的方法));</span><br><span class="line">t1.Start(参数);</span><br><span class="line"><span class="comment">//不带参数的开启方式</span></span><br><span class="line"><span class="comment">//t1 = new Thread(new ThreadStart(执行的方法));</span></span><br><span class="line">   <span class="comment">//t1.Start();</span></span><br><span class="line">   </span><br><span class="line">    t1.Abort();</span><br></pre></td></tr></table></figure></p>
<p>因为不知道传入的参数是什么类型的，所以是个obj类型的，用的时候需要强转，定义的时候也要定义成obj类型的。</p>
<p>下面再来看委托，用在需要更新UI的地方<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">updateListDele</span>(<span class="params"><span class="keyword">string</span> str</span>)</span>;</span><br><span class="line"><span class="comment">//定义符合委托入口参数和返回值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">lock</span> (<span class="keyword">this</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//加了个同步锁，具体的更新UI的逻辑</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//然后就是使用了 可以看出第二个是需要的参数</span></span><br><span class="line"><span class="keyword">this</span>.listBox1.Invoke(<span class="keyword">new</span> updateListDele(updateList), <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; f.FullName &#125;);</span><br></pre></td></tr></table></figure></p>
<p>类似的还有BeginInvoke方法，至于区别：</p>
<ul>
<li>Control.Invoke 方法 (Delegate) :在拥有此控件的基础窗口句柄的线程上执行指定的委托。</li>
<li>Control.BeginInvoke 方法 (Delegate) :在创建控件的基础句柄所在线程上异步执行指定委托。</li>
</ul>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p>老规矩，先添加引用：<br>using System.Net;</p>
<p>先来看看最基本的发送网络请求的写法:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AS相当于就是强制类型转换</span></span><br><span class="line">HttpWebRequest request = WebRequest.Create(<span class="string">"http"</span>) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line"><span class="comment">//模拟一个浏览器</span></span><br><span class="line">   request.UserAgent = <span class="string">"Mozilla/5.0 (Windows NT 5.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.104 Safari/537.36"</span>;</span><br><span class="line">   HttpWebResponse response = request.GetResponse() <span class="keyword">as</span> HttpWebResponse;</span><br><span class="line"></span><br><span class="line">   Stream stream = response.GetResponseStream();</span><br><span class="line">   StreamReader sr = <span class="keyword">new</span> StreamReader(stream, Encoding.Default);</span><br><span class="line">   <span class="keyword">string</span> str = sr.ReadToEnd();</span><br></pre></td></tr></table></figure></p>
<p>然后是socket编程之类<br>下面主要是发送消息的，也就是客户端<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到本机IP，设置UDP端口号</span></span><br><span class="line">   IPAddress localip = getValidIP(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">   <span class="keyword">int</span> localport = getValidPort(<span class="string">"1234"</span>);</span><br><span class="line">   ipLocalPoint = <span class="keyword">new</span> IPEndPoint(localip, localport);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//定义网络类型，数据连接类型和网络协议UDP  </span></span><br><span class="line">   mySocket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//绑定网络地址  </span></span><br><span class="line">   mySocket.Bind(ipLocalPoint);</span><br><span class="line">   <span class="comment">//发送UDP数据包</span></span><br><span class="line">   RemotePoint = (EndPoint)(ipLocalPoint); <span class="comment">//用本地作为接收地址了</span></span><br><span class="line">   <span class="keyword">string</span> msg = <span class="string">"发送的消息"</span></span><br><span class="line">   <span class="keyword">byte</span>[] data = Encoding.Default.GetBytes(msg);</span><br><span class="line">   mySocket.SendTo(data, data.Length, SocketFlags.None, RemotePoint);</span><br></pre></td></tr></table></figure></p>
<p>然后是接收消息的，也就是服务端<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最开始的定义与上面相同，直接引用上面的了</span></span><br><span class="line"><span class="comment">//接收数据处理线程</span></span><br><span class="line">   <span class="keyword">string</span> msg;</span><br><span class="line">   <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="keyword">int</span> rlen = mySocket.ReceiveFrom(data, <span class="keyword">ref</span> RemotePoint);</span><br><span class="line">   msg = Encoding.Default.GetString(data, <span class="number">0</span>, rlen);</span><br></pre></td></tr></table></figure></p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h3><p>举个修改label字体的例子：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//font是一个类  要先声明</span></span><br><span class="line">   Font ff = <span class="keyword">new</span> Font(<span class="string">"微软雅黑"</span>, <span class="number">28</span>);</span><br><span class="line">   label2.Font = ff;</span><br><span class="line">   label2.ForeColor = Color.Red;<span class="comment">//设置前背景，文字颜色</span></span><br></pre></td></tr></table></figure></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Convert.ToInt32(转换的内容);</span><br><span class="line"><span class="comment">//强制类型转换   效率高  上面其实就是调用 int.Parse</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">int</span>.Parse(<span class="keyword">string</span>)；  <span class="comment">//类似的有 double.Parse ....</span></span><br><span class="line"><span class="comment">//强制类型转换函数，如果成功返回true，存在number中，如果失败，返回 false,number为0</span></span><br><span class="line"><span class="keyword">int</span>.TryParse(<span class="string">"string"</span>,<span class="keyword">out</span> number);</span><br></pre></td></tr></table></figure>
<h3 id="timer的使用"><a href="#timer的使用" class="headerlink" title="timer的使用"></a>timer的使用</h3><p>具体执行的代码双击控件，然后再写就可以了。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置timer的开关和刷新时间</span></span><br><span class="line">timer1.Enabled = <span class="literal">true</span>;</span><br><span class="line">   timer1.Interval = <span class="number">888</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="随机数的产生"><a href="#随机数的产生" class="headerlink" title="随机数的产生"></a>随机数的产生</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random()  <span class="comment">//创建能够产生随机数的对象</span></span><br><span class="line"><span class="keyword">int</span> sjs = r.Next(<span class="number">1</span>,<span class="number">10</span>)  <span class="comment">//随机数的范围 [ )区间 //让这个对象用函数来产生随机数</span></span><br></pre></td></tr></table></figure>
<h3 id="关于get和set"><a href="#关于get和set" class="headerlink" title="关于get和set"></a>关于get和set</h3><p>get，set方法在Java中已经非常熟悉了，c#中不太一样<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取部分</span></span><br><span class="line">Demo de = <span class="keyword">new</span> Demo();</span><br><span class="line">   <span class="comment">//设置属性值</span></span><br><span class="line">   de.show = <span class="number">2</span>;</span><br><span class="line">   <span class="comment">//de.show 这样就是获取属性值</span></span><br><span class="line">   MessageBox.Show(de.show+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> a;</span><br><span class="line">       <span class="comment">//定义属性，注意没有（），不需要传入参数</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> show</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//这get 和 set 可以认为是个关键字了吧</span></span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> a;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">set</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//value 就是指传进来的值，固定名称</span></span><br><span class="line">               a = <span class="keyword">value</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="手动添加点击事件"><a href="#手动添加点击事件" class="headerlink" title="手动添加点击事件"></a>手动添加点击事件</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定点击事件</span></span><br><span class="line">bt[b].Click += Form1_Click;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件的定义  通过tag属性来辨别是拿一个按钮对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           Button but = <span class="keyword">new</span> Button();</span><br><span class="line">           but = (Button)sender;</span><br><span class="line">           <span class="keyword">switch</span> (but.Tag.ToString())</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">"0"</span>:</span><br><span class="line">                   BackColor = Color.Red;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">"1"</span>:</span><br><span class="line">                   BackColor = Color.Pink;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就内容来说确实不多，并且和Java也有很多类似的地方，但是很多地方只知道怎么用，具体什么个原理没深究，有些参数都不造啥意思….⊙﹏⊙b汗，<del>这些坑以后有时间慢慢填吧。</del><br>C#写form程序还是很顺手的，以后说不定什么时候就能用的上，做下记录总是不会错的！<br>假期来啦，最佳的学习时段来啦！</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OKhttp初步学习]]></title>
      <url>http://bfchengnuo.com/2016/05/30/OKhttp%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OkHttp是一个专注于性能和易用性的 HTTP 客户端(是一个高效的HTTP库)，用来发送 HTTP 请求并对所得到的响应进行处理。非常高效，支持SPDY、连接池、GZIP和 HTTP 缓存。<br><a id="more"></a></p>
<ul>
<li>支持 SPDY ，共享同一个Socket来处理同一个服务器的所有请求</li>
<li>如果SPDY不可用，则通过连接池来减少请求延时</li>
<li>无缝的支持GZIP来减少数据流量</li>
<li>缓存响应数据来减少重复的网络请求</li>
</ul>
<p>我们一般经常用的功能：</p>
<ul>
<li>一般的get请求</li>
<li>一般的post请求</li>
<li>基于Http的文件上传</li>
<li>文件下载</li>
<li>加载图片</li>
</ul>
<p>对以上功能的封装请见参考。<br>网络操作OKhttp配合Volley、Gson食用味道更佳。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>AS：<code>compile &#39;com.squareup.okhttp3:okhttp:3.3.1&#39;</code><br>以上，可以在github上找到，见参考。</p>
<h3 id="关于GET提交方式"><a href="#关于GET提交方式" class="headerlink" title="关于GET提交方式"></a>关于GET提交方式</h3><h4 id="设置get请求"><a href="#设置get请求" class="headerlink" title="设置get请求"></a>设置get请求</h4><p>1、调用Request.builder  对象的get()方法来设置请求方法为”get”请求。<br>2、调用Request.builder  对象的method(“GET”, null)方法来设置请求方法为“get”请求。</p>
<p>注意：method中的第二个参数表示是请求体，因为get请求的请求参数可以直接跟在url后面，所以中get请求的时候可以传递null。</p>
<h4 id="同步加载-测试一直ANR"><a href="#同步加载-测试一直ANR" class="headerlink" title="同步加载(测试一直ANR)"></a>同步加载(测试一直ANR)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//阻塞式方式 会阻塞UI线程</span></span><br><span class="line">    <span class="comment">//调用call对象的execute方法，发出网络请求,获取Response对象。</span></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(Unexpected code  + response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用response的body方法方法获取相应体。</span></span><br><span class="line">    ResponseBody body = response.body();</span><br><span class="line">    <span class="comment">//调用ResponseBody的相应方法获取具体响应内容。</span></span><br><span class="line">    body.string();  <span class="comment">//如果结果为字符类型，调用这个方法，默认编码utf-8</span></span><br><span class="line">    body.bytes();  <span class="comment">//返回字节数组</span></span><br><span class="line">    body.byteStream();   <span class="comment">//返回字节输入流。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步加载（官方推荐）"><a href="#异步加载（官方推荐）" class="headerlink" title="异步加载（官方推荐）"></a>异步加载（官方推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建okHttpClient对象</span></span><br><span class="line">OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="comment">//创建一个Request</span></span><br><span class="line"><span class="keyword">final</span> Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://github.com/hongyangAndroid"</span>)</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">//new call</span></span><br><span class="line">Call call = mOkHttpClient.newCall(request); </span><br><span class="line"><span class="comment">//请求加入调度</span></span><br><span class="line"><span class="comment">//call.enqueue会开启一个新的线程</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//响应失败回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//响应成功回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="comment">//String htmlStr =  response.body().string();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上就是发送一个get请求的步骤，首先构造一个Request对象，参数最起码有个url，当然你可以通过Request.Builder设置更多的参数比如：header、method等。</p>
<p>然后通过request的对象去构造得到一个Call对象，类似于将你的请求封装成了任务，既然是任务，就会有execute()和cancel()等方法。</p>
<p>最后，我们希望以异步的方式去执行请求，所以我们调用的是call.enqueue，将call加入调度队列，然后等待任务执行完成，我们在Callback中即可得到结果。</p>
<p>看到这，你会发现，整体的写法还是比较长的，所以封装肯定是要做的，不然每个请求这么写，得累死。</p>
<p>需要注意几点：</p>
<ul>
<li>onResponse回调的参数是response，一般情况下，比如我们希望获得返回的字符串，可以通过response.body().string()获取；如果希望获得返回的二进制字节数组，则调用response.body().bytes()；如果你想拿到返回的inputStream，则调用response.body().byteStream()</li>
<li>竟然还能拿到返回的inputStream，看到这个最起码能意识到一点，这里支持大文件下载，有inputStream我们就可以通过IO的方式写文件。不过也说明一个问题，这个onResponse执行的线程<strong><em>并不是UI线程</em></strong>。的确是的，如果你希望操作控件，还是需要使用handler等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作UI</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String res = response.body().string();</span><br><span class="line">  runOnUiThread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      mTv.setText(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关于post提交方式"><a href="#关于post提交方式" class="headerlink" title="关于post提交方式"></a>关于post提交方式</h3><h4 id="设置post方式"><a href="#设置post方式" class="headerlink" title="设置post方式"></a>设置post方式</h4><p>1、调用Request.builder  对象的post(requestBody)方法来设置请求方法。<br>2、调用Request.builder  对象的method(“POST”, requestBody)方法来设置。</p>
<p>注意：<br>1、post的请求参数(请求体requestBody)必须有，不能为null。如果为null会抛异常。<br>2、关于RequestBody：<br>RequestBody是个抽象类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RequestBody提交键值对：</span></span><br><span class="line">RequestBody body = <span class="keyword">new</span> FormEncodingBuilder()</span><br><span class="line">  .add(<span class="string">"name"</span>,<span class="string">"zs"</span>)</span><br><span class="line">  .add(<span class="string">"pwd"</span>,  <span class="string">"aaa"</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p>
<h4 id="进行post提交"><a href="#进行post提交" class="headerlink" title="进行post提交"></a>进行post提交</h4><ul>
<li><p>提交键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  RequestBody formBody = <span class="keyword">new</span> FormEncodingBuilder()</span><br><span class="line">    .add(<span class="string">"platform"</span>, <span class="string">"android"</span>)</span><br><span class="line">    .add(<span class="string">"name"</span>, <span class="string">"bug"</span>)</span><br><span class="line">    .add(<span class="string">"subject"</span>, <span class="string">"XXXXXXXXXXXXXXX"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .post(body)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交json数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为json数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//参数---&gt;类型和数据</span></span><br><span class="line">  RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .post(body)</span><br><span class="line">    .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>post的时候，参数是包含在请求体中的；所以我们通过FormEncodingBuilder。添加多个String键值对，然后去构造RequestBody，最后完成我们Request的构造。<br>后面的就和上面一样了。</p>
<h3 id="文件和表单的的提交"><a href="#文件和表单的的提交" class="headerlink" title="文件和表单的的提交"></a>文件和表单的的提交</h3><p>暂未学习，见参考。<br>挖坑。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。</li>
<li><p>OKhttp与Volley</p>
<p>Volley是针对数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。如果开发中使用HttpUrlConnection则要从头开始封装对应得操作，所以最近转向了一个第三方网络请求框架OkHttp库。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OKhttp的github开源库</a><br><a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="noopener">官方API</a><br><a href="https://github.com/hongyangAndroid/okhttp-utils" target="_blank" rel="noopener">OKhttp完整的封装类</a><br><a href="http://zhenchao125.blog.51cto.com/8241616/1727020" target="_blank" rel="noopener">详解OKhttp</a><br><a href="http://www.sunnyang.com/364.html#" target="_blank" rel="noopener">OkHttp使用详解</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0824/3355.html" target="_blank" rel="noopener">OKhttp完全解析</a></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> OKhttp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的JSON解析]]></title>
      <url>http://bfchengnuo.com/2016/05/28/Java%E4%B8%AD%E7%9A%84json%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Json 是一种是一种轻量级的文本数据交换格式。便于数据传输、存储、交换；目前使用非常广泛。<br>Java 中常见的解析库有：JSON.simple、 GSON、Jackson、JSONP、FastJson 等。<br>本文主要介绍 Gson 和 Jackson 的使用，以及 Json 格式的科普。<a id="more"></a></p>
<h2 id="关于json数据格式"><a href="#关于json数据格式" class="headerlink" title="关于json数据格式"></a>关于json数据格式</h2><p>其主要由三部分组成：</p>
<ul>
<li><p>名称/值<br>无序、一个对象用“｛｝”包括，名称和值间用“：”相隔，对象间用“，”隔开；<br><code>&quot;name&quot;:&quot;html&quot;</code></p>
</li>
<li><p>对象<br>一个JSON对象包括多个名称/值对，在花括号里书写<br><code>{ &quot;name&quot;:&quot;html&quot;,&quot;year&quot;:&quot;5&quot;}</code></p>
</li>
<li><p>数组<br>数组以“［］”包括，数据的对象用逗号隔开</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"> <span class="attr">"name"</span>:<span class="string">"html"</span>,</span><br><span class="line"> <span class="attr">"year"</span>:<span class="string">"5"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"name"</span>:<span class="string">"ht"</span>,</span><br><span class="line"> <span class="attr">"year"</span>:<span class="string">"4"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>数组包含对象，对象包含值/对</strong></p>
</li>
</ul>
<h2 id="使用GSON解析"><a href="#使用GSON解析" class="headerlink" title="使用GSON解析"></a>使用GSON解析</h2><p>GSON 这个Java库能够在Java对象和JSON间进行相互转换。同时它还提供了对Java泛型的完整支持，而且还不需要你在类上面添加注解。无需添加注解使用起来则更为便捷，同时在无法修改源代码的情况下这还是一个必要的先决条件。目前在 Android 开发中是比较流行的一种解析方式。强烈建议看这篇原文<a href="http://www.jianshu.com/p/b87fee2f7a23" target="_blank" rel="noopener">点我起飞</a><br>它基于事件驱动，根据所需要取的数据(不用将全部的数据进行 JavaBean 的编写)通过建立一个对应于 JSON 数据的 JavaBean 类就可以通过简单的操作解析出所需 JSON 数据<br>步骤：<br>创建一个与 JSON 数据对应的 JavaBean 类（用作存储需要解析的数据）<br>GSON 解析的关键是重点是要根据 json 数据里面的结构写出一个对应的 javaBean，规则是：</p>
<ul>
<li>JSON 的大括号对应一个对象，对象里面有 key 和 value (值)。在 JavaBean 里面的类属性要和key同名。</li>
<li>JSON 的方括号对应一个数组，所以在 JavaBean 里面对应的也是数组，数据里面可以有值或者对象。<br>如果是一个对象数组，那就要用<code>list&lt;obj&gt;</code>来装了</li>
<li>如果数组里面只有值没有 key，就说明它只是一个纯数组，如果里面有值有 key，则说明是对象数组。纯数组对应 JavaBean 里面的数组类型，对象数组要在 Bean 里面建立一个内部类，类属性就是对应的对象里面的 key，建立了之后要创建一个这个内部类的对象，名字对应数组名。</li>
<li>对象里面嵌套对象时候，也要建立一个内部类，和对象数组一样，这个内部类对象的名字就是父对象的key</li>
</ul>
<p>注：JavaBean 类里的属性不一定要全部和 JSON 数据里的所有 key 相同，可以按需取数据，也就是你想要哪种数据，就把对应的 key 属性写出来，<strong>注意名字一定要对应</strong><br>关键在于根据 json 数据构建出一个 Javabean 文件，解析非常简单，一句代码</p>
<p><strong>JavaBean对象 = gson.fromJson(json字符串,javaBean类类名.class);</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">//创建实体</span></span><br><span class="line">Student student = <span class="keyword">new</span> EntityStudent();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//用GSON方法将JSON数据转为单个类实体 json变量为json格式的字符串</span></span><br><span class="line">student = gson.fromJson(json,Student.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Java集合转换为json</span></span><br><span class="line"><span class="comment">//list变量可以是JavaBean也可以是Collection集合</span></span><br><span class="line">String json2 = gson.toJson(List);</span><br></pre></td></tr></table></figure></p>
<p>有时候我们解析的可能是一段JSON数组，这个可能麻烦点，我们用List来装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stuList = gson.fromJson(json, <span class="keyword">new</span> TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>
<p>也是一行代码，相比手动实现还是简单的<br>总之：<br>凡是看到 { 就是一个JsonObject<br>凡是看到 [ 就是一个JsonArray</p>
<p><a href="http://www.bejson.com/json2javapojo/" target="_blank" rel="noopener">json字符串转Java类</a></p>
<h2 id="使用Jackson解析"><a href="#使用Jackson解析" class="headerlink" title="使用Jackson解析"></a>使用Jackson解析</h2><p>Jackson 是一个数据处理的工具套件，它的亮点是流式的JSON解析器及生成器。它是专为Java设计的，同时也能处理其它非JSON的编码。从我们在 Github 中的统计来看，它应该是最流行的 JSON 解析器，在 JavaEE 开发中非常常见。<br>Jackson 最常用的 API 就是基于”对象绑定” 的 ObjectMapper，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper(); </span><br><span class="line">Person person = <span class="keyword">new</span> Person(); </span><br><span class="line">person.setName(<span class="string">"Tom"</span>); </span><br><span class="line">person.setAge(<span class="number">40</span>);</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">String res = mapper.writeValueAsString(person);</span><br><span class="line"><span class="comment">// 输出格式化后的字符串(有性能损耗) </span></span><br><span class="line">String jsonString = mapper.writerWithDefaultPrettyPrinter() </span><br><span class="line">    .writeValueAsString(person);</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">Person deserializedPerson = mapper.readValue(jsonString, Person.class);</span><br></pre></td></tr></table></figure>
<p>ObjectMapper 通过 writeValue 系列方法 将 java 对 象序列化 为 json，并 将 json 存 储成不同的格式：String（writeValueAsString），Byte Array（writeValueAsString），Writer， File，OutStream 和 DataOutput。<br>ObjectMapper 通过 readValue 系列方法从不同的数据源像 String ， Byte Array， Reader，File，URL， InputStream 将 json 反序列化为 java 对象。<br>下面是对于泛型、集合的支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line">CollectionType javaType = mapper.getTypeFactory() </span><br><span class="line">    .constructCollectionType(List.class, Person.class); </span><br><span class="line">List&lt;Person&gt; personList = mapper.readValue(jsonInString, javaType);</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">List&lt;Person&gt; personList = mapper.readValue(jsonInString, <span class="keyword">new</span> TypeReference&lt;List&lt;Person&gt;&gt;()&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="comment">//第二参数是 map 的 key 的类型，第三参数是 map 的 value 的类型 </span></span><br><span class="line">MapType javaType = mapper.getTypeFactory()</span><br><span class="line">    .constructMapType(HashMap.class, String.class, Person.class); </span><br><span class="line">Map&lt;String, Person&gt; personMap = mapper.readValue(jsonInString, javaType);</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">Map&lt;String, Person&gt; personMap = mapper.readValue(jsonInString, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, Person&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>开发中上面的这些基本用法一般就满足需求了，更高级的用法参考：<br><a href="https://www.ibm.com/developerworks/cn/java/jackson-advanced-application/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/jackson-advanced-application/index.html</a></p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>在定义的 Bean 中可以使用下面的注解来做相应的调整。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>@JsonProperty</td>
<td>用于属性，把属性的名称序列化时转换为另外一个名称。<br>示例： <code>@JsonProperty(&quot;birth_ d ate&quot;) private Date birthDate;</code></td>
</tr>
<tr>
<td>@JsonFormat</td>
<td>用于属性或者方法，把属性的格式序列化时转换成指定的格式。<br>示例： <code>@JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm&quot;) public Date getBirthDate()</code></td>
</tr>
<tr>
<td>@JsonPropertyOrder</td>
<td>用于类， 指定属性在序列化时 json 中的顺序 <br>示例： <code>@JsonPropertyOrder({ &quot;birth_Date&quot;, &quot;name&quot; }) public class Person</code></td>
</tr>
<tr>
<td>@JsonCreator</td>
<td>用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法。 <br>示例： <code>@JsonCreator public Person(@JsonProperty(&quot;name&quot;)String name) {…}</code></td>
</tr>
<tr>
<td>@JsonAnySetter</td>
<td>用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中 <br>示例：<code>@JsonAnySetter public void set(String key, Object value) { map.put(key, value); }</code></td>
</tr>
<tr>
<td>@JsonAnyGetter</td>
<td>用于方法 ，获取所有未序列化的属性<br>示例：<code>public Map&lt;String, Object&gt; any() { return map; }</code></td>
</tr>
</tbody>
</table>
<h2 id="关于JavaBean"><a href="#关于JavaBean" class="headerlink" title="关于JavaBean"></a>关于JavaBean</h2><p>其实就是一个Java类，只是他加了 getter 和 setter 方法，将属性暴露在外面</p>
<p>一般具备的特点为：</p>
<ol>
<li>所有属性为private</li>
<li>提供默认空构造方法</li>
<li>提供 getter 和 setter</li>
<li>实现 serializable 接口</li>
</ol>
<p>更多可参考：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513115&amp;idx=1&amp;sn=da30cf3d3f163d478748fcdf721b6414&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">Java帝国之JavaBean</a><br><a href="https://zh.wikipedia.org/wiki/JavaBeans" target="_blank" rel="noopener">wiki</a><br><a href="https://github.com/giantray/stackoverflow-java-top-qa/blob/master/contents/what-is-a-javabean-exactly.md" target="_blank" rel="noopener">stackoverflow翻译</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于它们的测试参考 <a href="https://linux.cn/article-7230-1.html" target="_blank" rel="noopener">【1】</a> 、<a href="http://vickyqi.com/2015/10/19/%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8JSON%E5%BA%93%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/" target="_blank" rel="noopener">【2】</a>，数据是2016、2015 的，仅供参考，这里我就直接说结论：</p>
<ul>
<li>如果你的应用经常会处理大的 JSON 文件，那么 Jackson 应该是你的菜。GSON在大文件上表现得相当吃力。</li>
<li>如果你主要是处理小文件请求，比如某个微服务或者分布式架构的初始化，那么GSON当是首选。Jackson 在小文件上的表现则不如人意。</li>
<li>如果这两种文件你都经常会处理到，那么在两轮表现中都位居第二的 JSON.simple 对此类场景则更为适合。在不同的文件大小上 Jackson 和 GSON 的表现都不太好。</li>
</ul>
<hr>
<ul>
<li>字符串解析成 JavaBean：当数据量较少时首选 FastJson，数据量较大使用 Jackson。</li>
<li>字符串解析成JSON：当数据量较少时首选FastJson，数据量较大使用Jackson。</li>
<li>JavaBean 构造JSON：当数据量较少时选择Gson，数据量较大可使用Jackson。</li>
<li>集合构造JSON：首先Jackson，其次Fastjson。</li>
</ul>
<p>如果你对 JSON 库的解析速度比较敏感的话，大文件选 Jackson，小文件选 GSON，两者则 JSON.simple；对解析速度要求非常高时可以考虑阿里的 FastJson，但是如果大文件还是选择 Jackson 吧。</p>
<p>我所见到的基本都是 Android 上 Gson 是主力，JavaEE 上 Jackson 是主力。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Android 中json的解析方法一般有两种：</p>
<ul>
<li><p>基于事件驱动</p>
</li>
<li><p>基于文档驱动解析方式<br>基于文档驱动，类似于 XML 的 DOM 解析方法，先把全部文件读入到内存中，然后遍历所有数据，然后根据需要检索想要的数据。</p>
</li>
</ul>
<p>基于事件驱动的主流方式：Gson 解析和 Jackson 解析<br>基于文档驱动解析方式的主流方式：Android Studio自带 org.son 解析</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[黑暗幽灵（别名 DCM ）的前世今生]]></title>
      <url>http://bfchengnuo.com/2016/05/05/%E9%BB%91%E6%9A%97%E5%B9%BD%E7%81%B5%EF%BC%88%E5%88%AB%E5%90%8D-DCM-%EF%BC%89%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>黑暗幽灵（DCM）木马被腾讯电脑管家曝光之后，引起了业内人士的强烈关注，该木马功能强大，行为诡异，只要插上网线或连上WIFI，无需任何操作，不一会儿电脑就被木马感染了，据分析，黑暗幽灵（DCM）木马具有如下特性：</p>
<ol>
<li><p>木马功能强大，主要以信息情报收集为主，能够监控监听大量的聊天软件，收集网络访问记录、监控Gmail、截取屏幕、监控麦克风和摄像头等。</p>
</li>
<li><p>木马对抗性强，能够绕过几乎全部的安全软件主动防御，重点对抗国内安全软件，能够调用安全软件自身的接口将木马加入白名单，作者投入了大量的精力逆向研究安全软件。</p>
</li>
<li><p>木马感染方式特别，通过网络劫持进行感染，主要劫持主流软件的自动更新程序，当这些软件联网下载更新程序时在网络上用木马替换，导致用户无感中毒。</p>
</li>
<li><p>木马通讯方式特别，木马将数据封装成固定包头的DNS协议包，发送到大型网站来实现数据传输，此方法可以绕过几乎全部的防火墙，但是黑客要截取这些数据，必须在数据包的必经之路上进行嗅探拦截，结合木马的感染方式，可以推测出在受害者网络链路上存在劫持。</p>
</li>
<li><p>木马攻击范围较小，针对性强，且持续时间长达数年，符合APT攻击的特性。</p>
</li>
</ol>
<p>那么，黑暗幽灵木马到底是什么来历呢？匿名作者DcmTeamMember在v2ex发布了一篇文章，揭露了“黑暗幽灵”（别名 DCM）木马的前世今生，以下是文章全文。<br><a id="more"></a></p>
<h2 id="高度机密：“黑暗幽灵”（别名-DCM-）木马的前世今生"><a href="#高度机密：“黑暗幽灵”（别名-DCM-）木马的前世今生" class="headerlink" title="高度机密：“黑暗幽灵”（别名 DCM ）木马的前世今生"></a>高度机密：“黑暗幽灵”（别名 DCM ）木马的前世今生</h2><p>　　首先，我无耻的匿了（多层 VPN 代理，因此那些正在阅读本文而目的却不是本文的正文内容的人，你们可以省省力气了）</p>
<p>　　关于这个叫 DCM 的木马，别名“黑暗幽灵”，我看到这个木马的分析报告的时候瞬间就震惊了。我震惊的原因不是因为这个木马的功能强大，也不是因为它的免杀手段，而是因为我是这个木马的设计和开发者之一！设计和开发团队大概 10 人左右，但是团队成员现在分布在全国各地多家不同行业的公司，因此我觉得把我们全部请去喝茶的可能性不大，况且就算真的被请去喝茶了，我也会装作没有见过这篇文章的。</p>
<p>　　没错，任何一个人都可以站出来，声称他是这木马的作者或设计者。而我却没办法在不泄漏自己真实身份的情况下证明我所写的内容，所以作为本文的读者，如果你不相信我所写的内容，那么就没必要继续读下去了。</p>
<p>　　DCM 木马的前世</p>
<p>　　首先我要证实一下大家的猜测：这个木马确实和 G0V 有关系，属于一款特殊用途的专用木马。我不便透露具体客户的身份。</p>
<p>　　这个木马的项目开始时间大概是 2011 年，目的是作为当时一个在役的木马（以下简称旧马）的继任者。之所以需要一个旧马的继任者，是因为旧马是基于一款开源的远程控制软件（以下简称原型远控）修改而成的，它主要有以下几方面的缺点：</p>
<ul>
<li>免杀</li>
</ul>
<p>　　原型远控在黑客圈子里比较知名，基于它的木马变种非常多。因此杀毒软件对它的查杀力度很大，免杀难度相对较高，保持的时间也较短，经常需要更新。</p>
<ul>
<li>隐蔽</li>
</ul>
<p>　　旧马沿用了原型远控的 TCP 反弹连接协议，因此主控端需要具有 IP 地址，某些应用环境下必须是公网 IP 地址，因此具有泄漏木马使用者身份的风险</p>
<ul>
<li>功能</li>
</ul>
<p>　　原型木马设计更像灰鸽子，被控端上线以后接受控制端发送的命令，然后将结果发送回控制端。旧马虽然努力改变这一设计，但受限于原型木马的框架，大的功能改动显得力不从心。</p>
<p>　　由于原型木马的先天缺陷，导致了旧马各方面难以弥补的不足，因此一个新的继任木马的需求也就被提出来了。</p>
<p>　　DCM 木马的诞生</p>
<p>　　这个继任者的设计理念包括一下几点：</p>
<ul>
<li>无进程无窗口</li>
</ul>
<p>　　该木马的受害者不能明显察觉到任何异样</p>
<ul>
<li>长期免杀</li>
</ul>
<p>　　杀毒软件与防火墙不能发现和拦截，包括木马的安装过程，以及安装成功以后的长期运行</p>
<ul>
<li>不泄漏使用者信息</li>
</ul>
<p>　　必须保障该木马控制者身份的绝对安全，任何情况下都不能泄漏控制者的 IP 地址、域名或者其他任何有价值的身份信息。即使样本被杀毒软件厂商获取并分析，也无法得知控制者的确切身份。</p>
<ul>
<li>完全自动化</li>
</ul>
<p>　　无需人工介入，根据事先的配置设置，全自动窃取信息并回传。没有网络连接的情况下要保存获取的信息，发现可用网络连接后进行回传。</p>
<p>　　经过几个月的设计与开发，这个继任者木马诞生了。</p>
<p>　　该木马的功能与特点已经没有必要在这里赘述了，网上的分析文章写的清清楚楚，总结下来就是自动记录并发送被感染电脑上的一切隐私内容。</p>
<p>　　DCM 木马的感染方式</p>
<p>　　其实该木马本身是不会主动传播的，它的设计就是潜伏并回传数据。它的传播是依赖另外几套系统来实现的（以下统称传播系统），而且这些传播方式也并不局限与传播 DCM 木马。这些传播系统的传染方式当然也不仅局限于分析文章里所提到的替换正常软件自动更新文件的方式。此外，该木马仅用于特定目标人群的”定点打击“，并不会大量传播。</p>
<ul>
<li>正规软件的自动更新</li>
</ul>
<p>　　在网上的分析文章里已经写了，通过替换正常软件的自动更新网络数据，使这些软件下载木马并执行。很多正规软件都直接运行在管理员模式下，还帮木马省去了提权的麻烦。</p>
<ul>
<li>下载可执行文件捆绑</li>
</ul>
<p>　　被列入”定点打击“的电脑如果下载了不超过一个预设大小的 EXE 文件，则传播系统会将木马捆绑在这些正常的 EXE 文件上，而且并不会破坏原有可执行文件。用户一旦运行了下载的 EXE 文件就会被感染。</p>
<ul>
<li>压缩文件感染</li>
</ul>
<p>　　被列入”定点打击“的电脑如果下载了一个符合某些条件的压缩文件，则传播系统会根据配置将木马插入压缩文件中，替换掉压缩文件中的可执行文件，或者替换掉整个压缩文件，从而实现感染目标主机的目的。</p>
<ul>
<li>浏览器劫持感染</li>
</ul>
<p>　　这个感染方式比较极端，只有少量情况下会使用。当该感染方式启动时，用户电脑无法正常浏览部分甚至全部网站，浏览器会被重定向到一个钓鱼页面，要求用户安装”浏览器插件”或者“必要更新”一类的内容，从而诱导甚至强迫用户安装木马。</p>
<p>　　DCM 木马相关的其他木马项目</p>
<p>　　毫无疑问 DCM 是针对 Windows 平台的木马，然而这并不表示其他平台就是安全的。但出于自身安全的原因，我在此不便透露更多细节。</p>
<p>　　DCM Team Member</p>
<p>　　2016 年 4 月 16 日<br>—–BEGIN PGP SIGNATURE—–</p>
<p>iQEcBAEBCAAGBQJXEa7kAAoJECudGUQ3ThEDPtQIAOKPr17Ro17cEd/SzLelCK30<br>l4MM6AiKBMUHSOCDCs3/7B5uBfFkJ/JokdVf9SkxUK9xXruWc5nR81XzM4yr0RwR<br>druFEPsFv0g/O8xkcNczmYqSIoEL7WxW2F+m3NiYCs1CbEnmpkFBMX95ANnpFCMO<br>dqVryOlQtwOYfXhgBwxoKzrAIb/jsilX6QFLHPTGCjnWZbSAg4Bw44FgoYH71jxr<br>ekMmHK/YtMkHAJO2v0dcIdTHFnzDaV7zoxUYUi9aXTSTMMuVezl02dbiyygg9hcK<br>ZjsLNJAJds70CmLqTXYiJAVx9s7FbXnp0gS231ZL8uDBF+xS920C763O28ryyPc=<br>=JJmr<br>—–END PGP SIGNATURE—–</p>
<p>—–BEGIN PGP SIGNED MESSAGE—–<br>Hash: SHA256 </p>
<h2 id="高度机密：“黑暗幽灵”（别名-DCM-）木马的未公开信息"><a href="#高度机密：“黑暗幽灵”（别名-DCM-）木马的未公开信息" class="headerlink" title="高度机密：“黑暗幽灵”（别名 DCM ）木马的未公开信息"></a>高度机密：“黑暗幽灵”（别名 DCM ）木马的未公开信息</h2><p>　　前一篇文章发出来以后，很多人说里面所有的内容都是已经公开的信息，那么我就来披露一些未公开的非敏感信息吧。 </p>
<p>　　从 DCM 木马的通信方式上来说， 2011 年时该木马构造一个 DNS 数据包，包头是 DNS 查询 microsoft.com 的子域名， payload 则是另一个封装的数据包，其中包括文件名、文件大小、分片序号以及 LZMA 压缩后的实际数据内容。木马会将该数据包发往微软的一个 IP 地址，并根据网络上行带宽控制发送速度。由于目标 IP 地址并不是一个有效的 DNS 服务器，所以木马不会收到任何回复数据。之所以发往微软的IP 地址，是因为以下几方面考虑： </p>
<ul>
<li>国外 IP </li>
</ul>
<p>　　选择一个国外的 IP 地址会确保数据包通过城市出口，省出口以及中国的互联网国际出口，因此大幅提高我们截取到这些 DNS 数据包的成功率，而且当用户携带被感染的笔记本电脑等便携式设备到其他没有布防的省市时，我们仍然可以从国际出口的 UDP 53 上行数据中截获所需的数据。 </p>
<ul>
<li>降低可疑度 </li>
</ul>
<p>　　Windows 操作系统自身原本就会发送大量的关于 microsoft.com 域名的 DNS 请求，包括自动更新、错误报告等诸多功能，都会发往微软。因此我们也伪装成相似的 DNS 请求，从而降低数据包的可疑度，即使触发了防火墙的报警，用户仍然有很大概率选择放行。 </p>
<ul>
<li>微软不是中国的“敌对势力” </li>
</ul>
<p>　　起始最初我们曾经设置将数据发往 Google ，但我们的客户认为 Google 是“境外敌对势力”，将这些敏感数据发往 Google 是绝不可接受的。于是经过讨论，我们认为微软本身作为操作系统的开发者，原本就有大量的隐私数据被发往微软，也不在乎再加一点。而且一旦此事真的被大家发现了，安全专家开始关注这个木马（就像现在这样），微软还可以成为一个合理的“怀疑对象”，顺理成章的把我们的责任推到微软的头上。 </p>
<p>　　数据包的重组则依赖于多层网络探针设备，我前面已经说过了，这个木马的背后是一个国家机关，因此我们可以得到这些 DNS 数据包的渠道是非常广泛的。以一个家庭用户为例，有以下节点可供我们获取这些数据： </p>
<ul>
<li>运营商提供的宽带路由器或 Modem </li>
</ul>
<p>　　部分型号是有预留后门的，可以直接远程激活。即使你家中的路由和 Modem 没有后门，在确实必要的情况下我们会干扰你的网络，迫使你主动联系运营商进行维修，然后我们派人伪装成运营商工作人员去“维修”你家中的设备甚至直接建议你更换设备（设备老化之类的借口）除此之外，我们还会在局域网内通过主动的扫描以及被动的监听等方式，来采集局域网内设备的信息，尤其是无线设备的信息。 </p>
<ul>
<li>小区交换机 </li>
</ul>
<p>　　很多小区有自己的电话交换机，我们会直接在电话交换机柜里加装小型低功耗设备，将你的网络数据镜像出来，并储存在设备的硬盘中或转发到其他 IP 地址。如果使用转发模式，可能会复用你的宽带网络，反正用户在你家里抓包是绝对看不到任何异常的。 </p>
<ul>
<li>ISP 机房 </li>
</ul>
<p>　　不用解释了，大家都知道怎么回事。 ISP 机房的好处是设备的功耗和体积没有限制，可以做更多的事。缺点是插拔电话线时会导致用户的网络暂时中断，而且 ISP 机房又只在工作时间向我们开放，所以偶尔可能会被用户察觉到网络和电话突然中断几十秒到几分钟。 </p>
<ul>
<li>当地的公安机房 </li>
</ul>
<p>　　ISP 会将部分数据镜像给公安机关，主要是 TCP 80 上行和 UDP 53 上行，因为这两个端口的上行数据量都不大，而且包含了我们所关心的大部分信息。这也是 DCM 木马选择使用 DNS 数据包的原因之一。 </p>
<ul>
<li>城市出口 </li>
</ul>
<p>　　一线二线的大城市的互联网出口几乎都有我们的设备，但 2011 年时中小城市的覆盖率则相对较低，现在的覆盖率恐怕已经包含了大部分互联网发达的三级城市了。 </p>
<ul>
<li>省出口 </li>
</ul>
<p>　　国内所有的省级互联网出口都有大量的网络探针设备，其中有一部分是我们的，也有一些是其他机关部门的。 </p>
<ul>
<li>国际出口 </li>
</ul>
<p>　　其实国际出口我们是没有办法直接访问的，只是特例有需要的情况下可以拿到镜像数据而已，但这可以作为最后一个机会。 </p>
<p>　　这里面有些层级是会暂时或长期地保留数据的，比如公安机房和国际出口，数据会被选择性的存储下来，供日后查阅。 </p>
<p>　　不过那篇分析文章里找到 IP 地址是百度之类的国内 IP ，估计和最近几年的政策变动有关系。也许微软也成为了境外“敌对势力”之一，从微软的 OneDrive 服务被墙就可以看出，中国对于微软也是不信任或者不完全信任的态度。 </p>
<p>DCM Team Member<br>2016 年 4 月 17 日<br>—–BEGIN PGP SIGNATURE—– </p>
<p>iQEcBAEBCAAGBQJXEtJCAAoJECudGUQ3ThEDhDkIAIjbT9K1qcwf3U0BVzm2Sal7<br>t/iv+2leM0XVrH+KiqKxOPPwS4AxuZXZLLz1GzistZJXozv+EhLJHZ3tcEazd1eE<br>Wfdx67//b5PM7TrFYniZmTnMXrMd6RiVu/Vhn/ynP6hbXMiRU+D9qPSymfKS85ZG<br>AtG7C6TSMshnClK1W/aJ8XtJ+wUmm6FOsp9gN62R63u/Aw/s6qonqoBLmqT7IILd<br>4zsgHG12fMgck8foepd+vRRunIVq5CCWBi01eiqnOpksom5rG0xwauIdCCAyfuDg<br>2NkIIY9nvbM41aLO5ImifE3NoHCy5dLnzriCwHRYtYHxqk4Qbk6socdLHwwjgFc=<br>=KwHw<br>—–END PGP SIGNATURE—–<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text encoding: UTF-8 </span><br><span class="line">PGP Key ID: 0xE75EDBBD207EA30C </span><br><span class="line">dcm_member@mail2tor.com OR dcm_member@mail2tor2zyjdctd.onion</span><br></pre></td></tr></table></figure></p>
<p>另外，有人说我的 PGP 密钥是在我发文的当天生成的。关于这个问题，我的回答其实很简单，你觉得如果我用一个自己用了好几年的密钥来签名这个内容，我还能匿名吗？ </p>
<p>我签名这个文章内容的原因主要是 2 方面考虑，一是我不希望别人篡改这个内容然后转发出去，二是我不敢保证现在这个帐号还能存活多久，一旦因为某些原因导致我无法再继续使用这个帐号，我需要使用新的帐号发帖并能够证实我自己的身份。</p>
<p>原文地址：<a href="http://www.williamlong.info/archives/4577.html" target="_blank" rel="noopener">http://www.williamlong.info/archives/4577.html</a></p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库中的事务]]></title>
      <url>http://bfchengnuo.com/2016/05/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>在和数据库打交道的时候，多少会接触到事务这个词，事务确实解决了很多问题呢！<br>简单说：就是把多件事情当做一件事情来处理。也就是大家同在一条船上，要活一起活，要完蛋都完蛋 ！</p>
<blockquote>
<p>  数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
</blockquote>
<p>更新：2017-5-2  完善相关概念<a id="more"></a></p>
<h2 id="事务特点-ACID"><a href="#事务特点-ACID" class="headerlink" title="事务特点(ACID)"></a>事务特点(ACID)</h2><p>可以这么说，如果数据库支持 ACID ，那么就支持事务；如果说它支持事务，那就一定支持 ACID</p>
<ul>
<li><strong>原子性（Atomicity）</strong><br>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行；就是说不可分割</li>
<li><strong>一致性（Consistency）</strong><br>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。<em>一致状态</em> 的含义是数据库中的数据应满足完整性约束<br>简单说就是：前后数据的完整性保持一致( 这个+10 那个就要 -10，总数不变 )</li>
<li><strong>隔离性（Isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li><strong>持久性（Durability）</strong><br>已被提交的事务对数据库的修改应该永久保存在数据库中<br>即使接下来数据库炸了也要把之前事务的影响保存好，这是数据库该操心的事</li>
</ul>
<p>通俗点的理解就是：<br>原子性：记录之前的版本，允许回滚<br>一致性：事务开始和结束之间的中间状态不会被其他事务看到<br>隔离性：适当的破坏一致性来提升性能与并行度 例如：最终一致~=读未提交。<br>持久性：每一次的事务提交后就会保证不会丢失</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>主要说下这个隔离性，先来明确如果不考虑隔离性的话会造成的后果：</p>
<ul>
<li>脏读<br>读取到别人未提交的事务对表的影响<br>比如 A、B 两个连接<strong>同时</strong>开启了一个事务；A 事务查询表的时候 B 事务更新了数据，但是没有提交，在 A 中却能查到更新后的结果</li>
<li>不可重复读<br>两次查询结果不同，第一次和第二次之间别人(连接)进行了事务提交<br>同上的例子，只不过是 B 更新表、提交事务后，在 A 的事务中(A 事务还未完成)能查到 B 提交后的结果；这就是两次相同查询不一样的结果，不可重复读</li>
<li>虚读（幻读）<br>和不可重复读类似，只不过这次的事务提交是<strong>对表的操作</strong>，比如插入、删除一条记录</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>然后就可以说说隔离级别了，是为了解决上面的问题</p>
<ul>
<li>Serializable<br>可避免上面的全部问题，同时效率也是最低的 （串行化）<br>有点类似单线程操作，如果 A 在处理事务，在未完成之前，其他连接只能等着</li>
<li>Repeatable read<br>可避免 脏读、不可重复读  （可重复读） [mysql 默认]</li>
<li>Read committed<br>可避免脏读  （读已提交）    [oracle 默认]</li>
<li>Read uncommitted<br>最低级别，3 种问题均无法保证  （读未提交）</li>
</ul>
<p>oracle 数据库只支持 1 和 3 ；MySQL 是全支持的</p>
<h2 id="在Android中"><a href="#在Android中" class="headerlink" title="在Android中"></a>在Android中</h2><h3 id="使用事务的优点"><a href="#使用事务的优点" class="headerlink" title="使用事务的优点"></a>使用事务的优点</h3><ul>
<li>在 Android 应用程序开发中，经常会遇到需要进行数据库操作的时候，Android 中数据库操作(尤其是写操作)是非常慢的，打包成事务有利于提高效率。</li>
<li>保证数据的一致性，有关事务的操作全部成功后才提交(生效),否则就进行事务的回滚操作。</li>
</ul>
<h3 id="事务的使用-SQLite示例"><a href="#事务的使用-SQLite示例" class="headerlink" title="事务的使用(SQLite示例)"></a>事务的使用(SQLite示例)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQLiteDatabase db = dbOpenHelper.getWritableDatabase();  </span><br><span class="line">    <span class="comment">//开启事务  </span></span><br><span class="line">    db.beginTransaction();  </span><br><span class="line">    <span class="keyword">try</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        db.execSQL(<span class="string">"update person set amount=amount-10 where personid=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>&#125;);  </span><br><span class="line">        db.execSQL(<span class="string">"update person set amount=amount+10 where personid=?"</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">2</span>&#125;);  </span><br><span class="line">        <span class="comment">//设置事务标志为成功，当结束事务时就会提交事务  </span></span><br><span class="line">        db.setTransactionSuccessful();  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">        <span class="keyword">throw</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//结束事务</span></span><br><span class="line">        db.endTransaction();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然 JDBC 的文章中也有提及，只要涉及数据库操作，基本都有支持</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>事务是可以嵌套的，Android官方源码解释：</p>
<pre><code>* Transactions can be nested.
* When the outer transaction is ended all of
* the work done in that transaction and all of the nested transactions will be committed or
* rolled back. The changes will be rolled back if any transaction is ended without being
* marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed.
</code></pre><p>个人理解：一般数据的操作用到事务，从而保证数据的准确一致，操作全部完成后再提交，只有提交后才会生效。</p>
<h3 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h3><p><a href="http://www.muzileecoding.com/androidsource/Fragment-de-shi-wu-shi-xian-xi-jie-fen-xi.html" target="_blank" rel="noopener">Fragment的事务解析</a></p>
<p>待添加…</p>
]]></content>
      
        <categories>
            
            <category> 自我提升 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 事务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java设计模式-工厂模式]]></title>
      <url>http://bfchengnuo.com/2016/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava/</url>
      <content type="html"><![CDATA[<p>更新：2017-5-3<br>从名字来看，工厂…既然是工厂就一定会生产点什么东西吧，反映在编程上，面向对象语言上，当然就是生产对象最好了！<del>我需要很多对象</del><br>这个是很有必要的，一般我实例化对象就是 new ，简单的还行遇到复杂点就比较不爽了，因为许多类型对象的创造需要一系列的步骤:<br>可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成需要的对象之前必须先生成一些辅助功能的对象。<br>这也说明了弄一个对象不容易啊！如果有一个工厂，只需提供简单的信息<del>（身高、体重、颜值….）</del>，它就能直接给我一个对象，那必然是很爽的！<a id="more"></a><br>想起了一句话，设计模式很好学，都是设定好的套路，关键难在什么时候用！</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</strong><br>有一种定义为：</p>
<blockquote>
<p>  定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂模式在《Java与模式》中分为三类：</p>
<ul>
<li>简单工厂模式（Simple Factory）：不利于产生系列产品；</li>
<li>工厂方法模式（Factory Method）：又称为多形性工厂；</li>
<li>抽象工厂模式（Abstract Factory）：又称为工具箱，产生产品族，但不利于产生新的产品；</li>
</ul>
<p>这三种模式从上到下逐步抽象，并且更具一般性。</p>
<p>GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。</p>
<h2 id="二、简单工厂模式"><a href="#二、简单工厂模式" class="headerlink" title="二、简单工厂模式"></a>二、简单工厂模式</h2><p>简单工厂模式又称静态工厂方法模式。重命名上就可以看出这个模式一定很简单。它存在的目的很简单：<strong>定义一个用于创建对象的接口。</strong><br>在简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定那一个产品类应当被实例化, 如同一个交通警察站在来往的车辆流中,决定放行那一个方向的车辆向那一个方向流动一样。</p>
<p>先来看看它的组成：</p>
<ul>
<li>工厂类角色：<br>这是本模式的核心，含有一定的商业逻辑和判断逻辑。<strong>在 java 中它往往由一个具体类实现。</strong></li>
<li>抽象产品角色：<br>它一般是具体产品继承的父类或者实现的接口。<strong>在 java 中由接口或者抽象类来实现。</strong></li>
<li>具体产品角色：<br>工厂类所创建的对象就是此角色的实例。<strong>在 java 中由一个具体类实现。</strong></li>
</ul>
<p>工厂类角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoliManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回的类型是接口，实际上返回的实现此接口的具体对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Loli <span class="title">factory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"stan"</span>:</span><br><span class="line">                <span class="comment">// TODO  如果对象的实例化需要很多步骤的话</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> StandardLoli();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"leg"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LegitimateLoli();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到相应的匹配"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象产品角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">speak</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的产品角色 (用了两个最简单的例子，贴在一起吧)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No.1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LegitimateLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(￣^￣)"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"(づ｡◕‿‿◕｡)づ"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardLoli</span> <span class="keyword">implements</span> <span class="title">Loli</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">speak</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"大哥哥"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"要抱抱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html" target="_blank" rel="noopener">CSDN的示例</a></p>
<h2 id="三、工厂方法模式"><a href="#三、工厂方法模式" class="headerlink" title="三、工厂方法模式"></a>三、工厂方法模式</h2><p><strong>工厂方法模式是简单工厂模式的进一步抽象化和推广</strong>，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化，这个决定被交给抽象工厂的子类去做。</p>
<p>来看下它的组成：</p>
<ul>
<li>抽象工厂角色：<br>这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。<strong>在 java 中它由抽象类或者接口来实现。</strong></li>
<li>具体工厂角色：<br>它含有和具体业务逻辑有关的代码。<strong>由应用程序调用以创建对应的具体产品的对象。</strong></li>
<li>抽象产品角色：<br>它是具体产品继承的父类或者是实现的接口。<strong>在 java 中一般有抽象类或者接口来实现。</strong></li>
<li>具体产品角色：<br>具体工厂角色所创建的对象就是此角色的实例。<strong>在 java 中由具体的类来实现。</strong></li>
</ul>
<p>工厂方法模式使用<strong>继承自抽象工厂角色</strong>的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。<strong>可以看出工厂角色的结构也是符合开闭原则的！</strong></p>
<p>主要代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品角色，No.1  No.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"plane...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broom</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"broom....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Moveable <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroomFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Broom();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VehicleFactory factory = <span class="keyword">new</span> BroomFactory();</span><br><span class="line">        Moveable m = factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出工厂方法的加入，<strong>使得对象的数量成倍增长</strong>。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们所希望的。<br>至于如何才能避免这种情况，可以考虑使用简单工厂模式与工厂方法模式相结合的方式来减少工厂类：即对于产品树上类似的种类（一般是树的叶子中互为兄弟的）使用简单工厂模式来实现。</p>
<h2 id="四、简单工厂和工厂方法模式的比较"><a href="#四、简单工厂和工厂方法模式的比较" class="headerlink" title="四、简单工厂和工厂方法模式的比较"></a>四、简单工厂和工厂方法模式的比较</h2><p>工厂方法模式和简单工厂模式在定义上的不同是很明显的。工厂方法模式的核心是一个抽象工厂类,而不像简单工厂模式, 把核心放在一个实类上。<br>工厂方法模式可以允许很多实的工厂类从抽象工厂类继承下来, 从而可以在实际上成为多个简单工厂模式的综合,从而推广了简单工厂模式。 </p>
<p>反过来讲,简单工厂模式是由工厂方法模式退化而来。设想如果我们非常确定一个系统只需要一个实的工厂类, 那么就不妨把抽象工厂类合并到实的工厂类中去。而这样一来,我们就退化到简单工厂模式了。</p>
<h2 id="五、抽象工厂模式"><a href="#五、抽象工厂模式" class="headerlink" title="五、抽象工厂模式"></a>五、抽象工厂模式</h2><p>抽象工厂模式( Abstract Factory Pattern )：抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。<br>组成角色：</p>
<ul>
<li><p>AbstractFactory：抽象工厂</p>
</li>
<li><p>ConcreteFactory：具体工厂</p>
</li>
</ul>
<ul>
<li><p>AbstractProduct：抽象产品</p>
</li>
<li><p>Product：具体产品</p>
</li>
</ul>
<p>主要代码（一些和上面重复的就省略了，比如抽象产品和具体产品）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Weapon <span class="title">createWeapon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Food <span class="title">createFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，其中 Food,Vehicle，Weapon 是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">createFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> DefaultFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。<br><strong>在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。</strong></p>
<p>抽象工厂内大多包含着工厂方法，它们经常是在一起的，它们的区别有一定是抽象工厂使用的是组合，工厂方法使用的继承</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul>
<li>简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。 </li>
<li>工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。 </li>
<li>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。<br>而工厂方法模式针对的是一个产品的等级结构。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/forlina/archive/2011/06/21/2086114.html" target="_blank" rel="noopener">原文连接</a><br><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">Wiki抽象工厂</a><br><a href="https://github.com/bfchengnuo/java_learn/tree/master/XC/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">bfchengnuo.Github</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git技巧]]></title>
      <url>http://bfchengnuo.com/2016/03/22/git%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="查看历史提交日志"><a href="#查看历史提交日志" class="headerlink" title="查看历史提交日志"></a><strong>查看历史提交日志</strong></h2><p>默认的日志格式真是无法入目啊，如何才能让其显示出好看的提交日志呢，有大神已经写好了，就是下面的命令：</p>
<p><code>git log --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --</code><br><a id="more"></a><br>这样是可以查看毕竟漂亮的日志，但是太长了。。我们可以写进全局配置里去：</p>
<p><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --&quot;</code></p>
<p>然后，我们就可以使用这样的短命令了：<code>git lg</code></p>
<h2 id="Git-Push-避免用户名和密码方法"><a href="#Git-Push-避免用户名和密码方法" class="headerlink" title="Git Push 避免用户名和密码方法"></a>Git Push 避免用户名和密码方法</h2><p>添加 Git Config 内容</p>
<p>进入 git bash 终端， 输入如下命令：<code>git config --global credential.helper store</code></p>
<p>执行完后查看 %HOME% 目录下的 <code>.gitconfig</code> 文件，会多了一项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure></p>
<p>重新开启<code>git bash</code>会发现 <code>git push</code> 时不用再输入用户名和密码</p>
<h2 id="解决换行符问题"><a href="#解决换行符问题" class="headerlink" title="解决换行符问题"></a>解决换行符问题</h2><p>因为不同系统之间的换行符的差别，造成的不必要的差异是不能忍受的，在 Git 官方也有相关的描述：</p>
<blockquote>
<p>假如你正在 Windows 上写程序，又或者你正在和其他人合作，他们在 Windows 上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。这是因为 Windows 使用回车和换行两个字符来结束一行，而 Mac 和 Linux 只使用换行一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。</p>
</blockquote>
<p>然后他们也给出了解决方案，我选用的就说第一种：</p>
<p>Git 可以在你提交时自动地把行结束符 CRLF 转换成 LF，而在签出代码时把 LF 转换成 CRLF。<br>用 <code>core.autocrlf</code> 来打开此项功能，如果是在 Windows 系统上，把它设置成 <code>true</code> ，这样当签出代码时，LF 会被转换成 CRLF：<code>git config --global core.autocrlf true</code></p>
<p>引用自：<a href="https://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E7%A9%BA%E7%99%BD" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E7%A9%BA%E7%99%BD</a></p>
<p>当然，我顺便会再配置点其他的东西，配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">	autocrlf = true</span><br><span class="line">	# 避免中文乱码，另一篇中有介绍</span><br><span class="line">	quotepath = false</span><br><span class="line">	# 开启大小写敏感</span><br><span class="line">	ignorecase = false</span><br></pre></td></tr></table></figure>
<p>注意 ignorecase 设置为 false 是开启大小写敏感，默认 Git 对大小写不敏感，这就导致一个文件你改了名字，当然只是大小写的改变，Git 并不会感知到，这就很蛋疼了，所以还是开了。</p>
<h2 id="解决乱码问题"><a href="#解决乱码问题" class="headerlink" title="解决乱码问题"></a>解决乱码问题</h2><h3 id="使用-add-命令添加中文文件名时"><a href="#使用-add-命令添加中文文件名时" class="headerlink" title="使用 add 命令添加中文文件名时"></a>使用 add 命令添加中文文件名时</h3><p>乱码类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\316\304\261\276\316\304\265\265.txt</span><br></pre></td></tr></table></figure>
<p>解决方案有两种</p>
<h4 id="修改inputrc文件-不推荐"><a href="#修改inputrc文件-不推荐" class="headerlink" title="修改inputrc文件(不推荐)"></a>修改inputrc文件(不推荐)</h4><p><strong>编辑 <code>C:\Git\etc\inputrc</code> 文件中对应的行，查找以下 2 行，并修改其值</strong></p>
<p>原先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set output-meta off</span><br><span class="line">set convert-meta on</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set output-meta on</span><br><span class="line">set convert-meta off</span><br></pre></td></tr></table></figure>
<h4 id="配置quotepath属性"><a href="#配置quotepath属性" class="headerlink" title="配置quotepath属性"></a>配置quotepath属性</h4><p><strong>在bash提示符下输入：</strong></p>
<p><code>git config --global core.quotepath false</code></p>
<p>core.quotepath 设为 false 的话，就不会对 0x80 以上的字符进行 quote。中文显示正常。</p>
<h2 id="使用log查看含有中文的log信息时"><a href="#使用log查看含有中文的log信息时" class="headerlink" title="使用log查看含有中文的log信息时"></a>使用log查看含有中文的log信息时</h2><p>乱码类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;E4&gt;&lt;BF&gt;&lt;AE&gt;&lt;E6&gt;&lt;94&gt;&lt;B9&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E6&gt;&lt;9C&gt;&lt;AC&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E6&gt;&lt;A1&gt;&lt;A3&gt;</span><br></pre></td></tr></table></figure>
<p><strong>解决方案：</strong></p>
<p>在 Bash 提示符下输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding gbk</span><br><span class="line"></span><br><span class="line"># 顺便把 GUI 的也配了</span><br><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure>
<p>注：设置 commit 提交时使用 utf-8 编码，可避免 Linux 服务器上乱码；同时设置在执行 <code>git log</code> 时将 utf-8 编码转换成 gbk 编码，以解决乱码问题。</p>
<p>编辑 <code>C:\Git\etc\profile</code> 文件，添加如下一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>
<p>注：以使 <code>git log</code> 可以正常显示中文（需要配合：i18n.logoutputencoding gbk）</p>
<p>参考：<a href="https://segmentfault.com/a/1190000000578037" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000578037</a></p>
<h2 id="设置代理服务器"><a href="#设置代理服务器" class="headerlink" title="设置代理服务器"></a>设置代理服务器</h2><p>配置文件中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[https]</span><br><span class="line">	postBuffer = 524288000</span><br><span class="line">	proxy = socks5://127.0.0.1:1080</span><br><span class="line">[http]</span><br><span class="line">	postBuffer = 524288000</span><br><span class="line">	proxy = socks5://127.0.0.1:1080</span><br><span class="line">	sslVerify = false</span><br></pre></td></tr></table></figure></p>
<p><a href="http://blog.useasp.net/archive/2015/08/26/config-git-proxy-settings-on-windows.aspx" target="_blank" rel="noopener">飞机</a></p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[chrome中使用第三方扩展]]></title>
      <url>http://bfchengnuo.com/2016/03/22/chrome%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<p>使用第三方扩展后，chrome老是弹出让禁用的消息，并且关闭后再开启就被禁用了<br>采用windows的本地组策略管理器解决<br><a id="more"></a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用第三方扩展后，chrome老是弹出让禁用的消息，并且关闭后再开启就被禁用了</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li><p><strong>采用开发者模式</strong></p>
<p>将下载的crx重命名为rar，然后解压</p>
<p>进入chrome的插件管理界面，选中开发者模式</p>
<p>选择<code>加载已解压的扩展程序</code>然后找到你解压的crx文件目录，选中，确定</p>
<p>再次开启会提示是否禁用，选择否即可</p>
</li>
<li><p><strong>采用windows的本地组策略管理器</strong></p>
<p>首先下载了一个文件 chrome.adm （temp下）</p>
<p>打开组策略  (直接搜索或者win+r运行输入gpedit.msc)</p>
<p>依次打开计<strong>算机配置—管理模板</strong>右键添加，选择下载的adm文件导入</p>
<p>这时候会多了一个经典管理模版，进去找到<strong>扩展程序</strong>这一文件夹</p>
<p>配置安装白名单—选择已开启—添加你安装的第三方的ID</p>
<p>//需要开启开发者模式才能看到ID</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[eclipse格式化代码无效/常用快捷键]]></title>
      <url>http://bfchengnuo.com/2016/03/22/eclipse%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81%E6%97%A0%E6%95%88%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p><strong>原因</strong></p>
<p>快捷键被占用(被输入法给占用了)</p>
<p><strong>解决</strong></p>
<p>关闭或者更改输入法的快捷键即可<br>也可以修改eclipse的快捷键，搜索key就可以快速定位，然后就自己设吧</p>
<p>解决一类问题。复制行的快捷键可能被显卡给占了<br><a id="more"></a></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>作用</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>格式化代码</td>
<td style="text-align:center">ctrl + shift + F</td>
</tr>
<tr>
<td>快速搜索</td>
<td style="text-align:center">ctrl + shift + R</td>
</tr>
<tr>
<td>移动代码</td>
<td style="text-align:center">alt + ↑/↓</td>
</tr>
<tr>
<td>复制行</td>
<td style="text-align:center">alt + ctrl + ↑/↓</td>
</tr>
<tr>
<td>删除行</td>
<td style="text-align:center">Ctrl + D</td>
</tr>
<tr>
<td>导包</td>
<td style="text-align:center">ctrl + shift + o</td>
</tr>
<tr>
<td>快速修正</td>
<td style="text-align:center">ctrl + 1</td>
</tr>
<tr>
<td>代码注释 行/块,反注释</td>
<td style="text-align:center">ctrl + / [ctrl+shift+/(反斜线为取消)]</td>
</tr>
<tr>
<td>快速提示</td>
<td style="text-align:center">alt + /</td>
</tr>
<tr>
<td>前进后退到上次代码</td>
<td style="text-align:center">alt + ←/→</td>
</tr>
<tr>
<td>查看方法</td>
<td style="text-align:center">F2</td>
</tr>
<tr>
<td>查看类的继承关系</td>
<td style="text-align:center">ctrl+T</td>
</tr>
<tr>
<td>更改为大写</td>
<td style="text-align:center">ctrl+shift+X</td>
</tr>
<tr>
<td>更改为小写</td>
<td style="text-align:center">ctrl+shift+Y</td>
</tr>
<tr>
<td>按单词跳跃</td>
<td style="text-align:center">Ctrl + ←/→</td>
</tr>
<tr>
<td>按单词选择</td>
<td style="text-align:center">Ctrl + Shift + ←/→</td>
</tr>
<tr>
<td>文档注释</td>
<td style="text-align:center">ALT + SHIFT + J</td>
</tr>
<tr>
<td>弹出包围代码块</td>
<td style="text-align:center">Alt+Shift+Z</td>
</tr>
</tbody>
</table>
<p>更多：<a href="http://www.cnblogs.com/Ming8006/p/5980293.html" target="_blank" rel="noopener">http://www.cnblogs.com/Ming8006/p/5980293.html</a></p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>修改作者模板：</p>
<p>window –&gt; preference –&gt; java –&gt; codeStyple –&gt; codetemplate </p>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VBOX启动错误]]></title>
      <url>http://bfchengnuo.com/2016/03/22/VBOX%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>网上查了很久，最多的就是说版本的bug，回退到4.3的版本就可以了，但好像也没有什么效果，依然错误。<br><a id="more"></a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>是因为系统是64位的原因导致某些服务无法启动，也或许是因为是windows10的原因，目前windows10的兼容性还不是很好，git、kdiff3之类的软件默认是英文界面。。。</p>
<p>打开安装目录<code>D:\Program Files\Oracle\VirtualBox\drivers\vboxdrv</code>右键<strong>VBoxDrv.inf</strong>安装，然后重启应该就可以了。(我就是忘了重启又折腾了好久o(￣▽￣<em>)ゞ))￣▽￣</em>)o)</p>
<p>PS：win10下，5.x以上的版本才支持桥连呢</p>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VBOX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL安装和服务无法启动-3534解决]]></title>
      <url>http://bfchengnuo.com/2016/03/22/MySQL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E8%A7%A3%E5%86%B3%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>应该是配置文件没有设置好，多见于绿色版吧，安装版一般没问题<br>有问题卸载重装大法能解决大部分问题啦~<br><a id="more"></a>    </p>
<h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><p>在配置文件写入下列信息<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8 </span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment">#设置3306端口</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span> </span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=D:\mysql\mysql-<span class="number">5.6</span>.<span class="number">17</span>-winx64</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=D:\mysql\mysql-<span class="number">5.6</span>.<span class="number">17</span>-winx64\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></table></figure></p>
<p>CMD管理员运行进入bin目录执行<strong>mysqld install</strong>即可</p>
<h2 id="服务无法启动"><a href="#服务无法启动" class="headerlink" title="服务无法启动"></a>服务无法启动</h2><p>成功安装以后，启动MySQL，输入：</p>
<blockquote>
<p>net start mysql</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>”MySQL 服务无法启动，服务没有报告任何错误，请键入 NET HELPMSG 3534 以获得更多的帮助。”</p>
</blockquote>
<p>查了下，在当前目录下输入：</p>
<p><del><code>mysqld-initialize</code></del></p>
<p><code>mysqld --initialize-insecure</code></p>
<p>还是出错，又查了下，原因是：</p>
<blockquote>
<p>  mysqld –initialize-insecure自动生成无密码的root用户<br>  mysqld –initialize自动生成带随机密码的root用户。<br>  data文件夹不为空是不能执行这个命令的。</p>
</blockquote>
<p>解决办法：<br><strong>先删除data目录下的所有文件或者移走。</strong></p>
<h2 id="服务器安装"><a href="#服务器安装" class="headerlink" title="服务器安装"></a>服务器安装</h2><p>一般服务器安装的都不是官方原版，而是基于原版的衍生版，使用方面和原生的操作完全一样，但是性能方面会有大大的提高，常见的衍生版有 MariaDB 和 PerconaServer，前者是原作者的另一个项目，后者性能有显著提升</p>
<p>安装后常用的操作是：<br>修改/设置 root 的密码：<code>mysqladmin -u root password &quot;root&quot;</code><br>设置为允许远程客户端访问（生产环境为安全不会开启）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- grant all privileges on . to 'root' @'%' identified by 'root';</span></span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="keyword">admin</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'admin'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="comment">-- admin@'%' 其中admin是用户名，“%”是允许任何ip的访问，密码为admin。</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<p>还有就是不要忘了开启防火墙：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">/etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure>
<p>mysql 客户端每次访问 db，mysql 就会试图去解析来访问的机器的 hostname，并缓存到 hostname cache，这样会导致连接速度变慢，我们可以设置关闭这个功能，当然是测试环境时，为了安全还是…..<br>编辑 <code>vim /etc/my.cnf</code> ，在 <strong>[mysqld]</strong> 下面添加 <code>skip-name-resolve</code> 然后重启 MySQL 服务就可以了</p>
<h2 id="设置编码"><a href="#设置编码" class="headerlink" title="设置编码"></a>设置编码</h2><p>首先通过 <code>show variables like &#39;character_set_%&#39;;</code> 查看 mysql 字符集<br>默认编码为 latin1，当然是不支持中文的，所以还是改成 u8 比较好伐，修改 <code>/etc/my.inf</code> 配置文件，主要就是在下面的两个节点下追加一条配置：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span> </span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br></pre></td></tr></table></figure>
<p> 然后重启 MySQL 的服务即可，网上很多资源都是在 [mysqld] 下添加 ：<code>default-character-set=utf8</code> ，如果这样改会导致 5.7 版本 mysql 无法打开，所以要改为 <code>character-set-server=utf8</code> ，所以要考虑版本问题啊….</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据库的编码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> dbtest <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="comment">-- ALTER DATABASE dbtest CHARACTER SET utf8;  -- 简单修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表的编码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbtest <span class="built_in">CHARACTER</span> <span class="keyword">set</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="comment">-- 修改字段编码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbtest <span class="keyword">MODIFY</span> email <span class="built_in">VARCHAR</span>(<span class="number">60</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 我是修电脑的 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用SSH连接VBOX里的ubuntu]]></title>
      <url>http://bfchengnuo.com/2016/03/22/SSH%E8%BF%9E%E6%8E%A5VBOX%E7%9A%84ubuntu/</url>
      <content type="html"><![CDATA[<ol>
<li><p>网络</p>
<p>VBOX设置</p>
<p>设置第一块网卡为<code>网络地址转换NAT</code>用于使用本机网络让虚拟机联网</p>
<p>设置第二块网卡为桥连模式，如果windows10需要VBOX5.X的版本才可以</p>
<p>主机ping虚拟机测试是否ping通，虚拟机ping主机测试是否ping通</p>
<a id="more"></a> 
</li>
<li><p>ssh服务</p>
<ul>
<li><p>查看是否安装ssh服务</p>
<p>  在ubuntu终端命令界面键入：<code>ssh localhost</code></p>
<p>  如果出现下面提示则表示还没有安装ssh服务</p>
<blockquote>
<p>  ssh: connect to hostlocalhost port 22: Connection refused </p>
</blockquote>
</li>
<li><p>如果通过上面步骤查看没有安装sshserver、则键入命令安装</p>
<p><del><code>sudo apt-getinstall –y openssh-server</code></del></p>
<p><del><code>sudo apt-get install openssh-server</code></del></p>
<p><code>sudo apt-get install ssh</code></p>
</li>
<li><p>安装完成后启动ssh <code>service ssh start</code> </p>
</li>
<li><p>启动完成之后可以使用命令：</p>
<p>  <del><code>ps –e | grep ssh</code></del></p>
<p>  <code>netstat -tlp</code>  来查看ssh状态.</p>
<blockquote>
<p>  <del>6455 ?        00:00:00 sshd</del><br>   tcp        0      0 <em>:ssh      </em>:*    LISTEN </p>
</blockquote>
<p>  则表明启动成功。</p>
</li>
</ul>
</li>
<li><p>连接linux</p>
<p> 用SSH工具输入IP连接即可</p>
<p> 查看自己的IP</p>
<p> linux：ifconfig</p>
<p> windows：ipconfig</p>
</li>
</ol>
<h2 id="扩展-配置IP"><a href="#扩展-配置IP" class="headerlink" title="扩展-配置IP"></a>扩展-配置IP</h2><p>可以使用<code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code>进行手动配置ip</p>
<blockquote>
<p>  DEVICE=eth0 #物理设备名<br>  IPADDR=192.168.1.10 #IP地址<br>  NETMASK=255.255.255.0 #掩码值<br>  NETWORK=192.168.1.0 #网络地址(可不要)<br>  BROADCAST=192.168.1.255 #广播地址（可不要）<br>  GATEWAY=192.168.1.1 #网关地址<br>  ONBOOT=yes # [yes|no]（引导时是否激活设备）<br>  USERCTL=no #[yes|no]（非root用户是否可以控制该设备）<br>  BOOTPROTO=static #[none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</p>
</blockquote>
<p>然后就是设置DNS了，使用<code>vi /etc/resolv.conf</code></p>
<blockquote>
<p>  nameserver 202.109.14.5 #主DNS<br>  nameserver 219.141.136.10 #次DNS<br>  search localdomain</p>
</blockquote>
<p>centos系列有图形化界面哦，使用<code>setup</code>命令很爽<br>设置完了还需要重启网络服务network</p>
]]></content>
      
        <categories>
            
            <category> 技能Get </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
